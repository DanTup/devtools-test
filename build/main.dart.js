// Generated by dart2js (full emitter, strong), the Dart to JavaScript compiler version: 2.1.0.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// defaultPackagesBase:
//    Override the location where `package:` uris are resolved from. By default
//    they are resolved under "packages/" from the current window location.
(function() {
  // /* ::norenaming:: */
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function map(x) {
    x = Object.create(null);
    x.x = 0;
    delete x.x;
    return x;
  }
  // The global objects start as so-called "slow objects". For V8, this
  // means that it won't try to make map transitions as we add properties
  // to these objects. Later on, we attempt to turn these objects into
  // fast objects by calling "convertToFastObject" (see
  // [emitConvertToFastObjectFunction]).
  var A = map();
  var B = map();
  var C = map();
  var D = map();
  var E = map();
  var F = map();
  var G = map();
  var H = map();
  var J = map();
  var K = map();
  var L = map();
  var M = map();
  var N = map();
  var O = map();
  var P = map();
  var Q = map();
  var R = map();
  var S = map();
  var T = map();
  var U = map();
  var V = map();
  var W = map();
  var X = map();
  var Y = map();
  var Z = map();
  function Isolate() {
  }
  init();
  // Constructors are generated at runtime.
  function setupProgram(programData, metadataOffset, typesOffset) {
    "use strict";
    function generateAccessor(fieldDescriptor, accessors, cls) {
      var fieldInformation = fieldDescriptor.split("-");
      var field = fieldInformation[0];
      var len = field.length;
      var code = field.charCodeAt(len - 1);
      var reflectable;
      if (fieldInformation.length > 1)
        reflectable = true;
      else
        reflectable = false;
      code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
      if (code) {
        var getterCode = code & 3;
        var setterCode = code >> 2;
        var accessorName = field = field.substring(0, len - 1);
        var divider = field.indexOf(":");
        if (divider > 0) {
          accessorName = field.substring(0, divider);
          field = field.substring(divider + 1);
        }
        if (getterCode) {
          var args = getterCode & 2 ? "receiver" : "";
          var receiver = getterCode & 1 ? "this" : "receiver";
          var body = "return " + receiver + "." + field;
          var property = cls + ".prototype.get$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
        if (setterCode) {
          var args = setterCode & 2 ? "receiver, value" : "value";
          var receiver = setterCode & 1 ? "this" : "receiver";
          var body = receiver + "." + field + " = value";
          var property = cls + ".prototype.set$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
      }
      return field;
    }
    function defineClass(name, fields) {
      var accessors = [];
      var str = "function " + name + "(";
      var comma = "", body = "";
      for (var i = 0; i < fields.length; i++) {
        var fieldDescriptor = fields[i];
        if (fieldDescriptor.charCodeAt(0) == 48) {
          fieldDescriptor = fieldDescriptor.substring(1);
          var field = generateAccessor(fieldDescriptor, accessors, name);
          body += "this." + field + " = null;\n";
        } else {
          var field = generateAccessor(fieldDescriptor, accessors, name);
          var parameter = "p_" + field;
          str += comma;
          comma = ", ";
          str += parameter;
          body += "this." + field + " = " + parameter + ";\n";
        }
      }
      if (supportsDirectProtoAccess)
        body += "this." + "$deferredAction" + "();";
      str += ") {\n" + body + "}\n";
      str += name + ".builtin$cls=\"" + name + "\";\n";
      str += "$desc=$collectedClasses." + name + "[1];\n";
      str += name + ".prototype = $desc;\n";
      if (typeof defineClass.name != "string")
        str += name + ".name=\"" + name + "\";\n";
      str += accessors.join("");
      return str;
    }
    var inheritFrom = supportsDirectProtoAccess ? function(constructor, superConstructor) {
      var prototype = constructor.prototype;
      prototype.__proto__ = superConstructor.prototype;
      prototype.constructor = constructor;
      prototype["$is" + constructor.name] = constructor;
      return convertToFastObject(prototype);
    } : function() {
      function tmp() {
      }
      return function(constructor, superConstructor) {
        tmp.prototype = superConstructor.prototype;
        var object = new tmp();
        convertToSlowObject(object);
        var properties = constructor.prototype;
        var members = Object.keys(properties);
        for (var i = 0; i < members.length; i++) {
          var member = members[i];
          object[member] = properties[member];
        }
        object["$is" + constructor.name] = constructor;
        object.constructor = constructor;
        constructor.prototype = object;
        return object;
      };
    }();
    function finishClasses(processedClasses) {
      var allClasses = init.allClasses;
      processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
      processedClasses.combinedConstructorFunction = null;
      for (var i = 0; i < constructors.length; i++) {
        var constructor = constructors[i];
        var cls = constructor.name;
        var desc = processedClasses.collected[cls];
        var globalObject = desc[0];
        desc = desc[1];
        allClasses[cls] = constructor;
        globalObject[cls] = constructor;
      }
      constructors = null;
      var finishedClasses = init.finishedClasses;
      function finishClass(cls) {
        if (finishedClasses[cls])
          return;
        finishedClasses[cls] = true;
        var superclass = processedClasses.pending[cls];
        if (superclass && superclass.indexOf("+") > 0) {
          var s = superclass.split("+");
          superclass = s[0];
          var mixinClass = s[1];
          finishClass(mixinClass);
          var mixin = allClasses[mixinClass];
          var mixinPrototype = mixin.prototype;
          var clsPrototype = allClasses[cls].prototype;
          var properties = Object.keys(mixinPrototype);
          for (var i = 0; i < properties.length; i++) {
            var d = properties[i];
            if (!hasOwnProperty.call(clsPrototype, d))
              clsPrototype[d] = mixinPrototype[d];
          }
        }
        if (!superclass || typeof superclass != "string") {
          var constructor = allClasses[cls];
          var prototype = constructor.prototype;
          prototype.constructor = constructor;
          prototype.$isObject = constructor;
          prototype.$deferredAction = function() {
          };
          return;
        }
        finishClass(superclass);
        var superConstructor = allClasses[superclass];
        if (!superConstructor)
          superConstructor = existingIsolateProperties[superclass];
        var constructor = allClasses[cls];
        var prototype = inheritFrom(constructor, superConstructor);
        if (mixinPrototype)
          prototype.$deferredAction = mixinDeferredActionHelper(mixinPrototype, prototype);
        if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
          var nativeSpec = prototype["%"].split(";");
          if (nativeSpec[0]) {
            var tags = nativeSpec[0].split("|");
            for (var i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = true;
            }
          }
          if (nativeSpec[1]) {
            tags = nativeSpec[1].split("|");
            if (nativeSpec[2]) {
              var subclasses = nativeSpec[2].split("|");
              for (var i = 0; i < subclasses.length; i++) {
                var subclass = allClasses[subclasses[i]];
                subclass.$nativeSuperclassTag = tags[0];
              }
            }
            for (i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = false;
            }
          }
          prototype.$deferredAction();
        }
        if (prototype.$isInterceptor)
          prototype.$deferredAction();
      }
      var properties = Object.keys(processedClasses.pending);
      for (var i = 0; i < properties.length; i++)
        finishClass(properties[i]);
    }
    function finishAddStubsHelper() {
      var prototype = this;
      while (!prototype.hasOwnProperty("$deferredAction"))
        prototype = prototype.__proto__;
      delete prototype.$deferredAction;
      var properties = Object.keys(prototype);
      for (var index = 0; index < properties.length; index++) {
        var property = properties[index];
        var firstChar = property.charCodeAt(0);
        var elem;
        if (property !== "^" && property !== "$reflectable" && firstChar !== 43 && firstChar !== 42 && (elem = prototype[property]) != null && elem.constructor === Array && property !== "<>")
          addStubs(prototype, elem, property, false, []);
      }
      convertToFastObject(prototype);
      prototype = prototype.__proto__;
      prototype.$deferredAction();
    }
    function mixinDeferredActionHelper(mixinPrototype, targetPrototype) {
      var chain;
      if (targetPrototype.hasOwnProperty("$deferredAction"))
        chain = targetPrototype.$deferredAction;
      return function foo() {
        if (!supportsDirectProtoAccess)
          return;
        var prototype = this;
        while (!prototype.hasOwnProperty("$deferredAction"))
          prototype = prototype.__proto__;
        if (chain)
          prototype.$deferredAction = chain;
        else {
          delete prototype.$deferredAction;
          convertToFastObject(prototype);
        }
        mixinPrototype.$deferredAction();
        prototype.$deferredAction();
      };
    }
    function processClassData(cls, descriptor, processedClasses) {
      descriptor = convertToSlowObject(descriptor);
      var previousProperty;
      var properties = Object.keys(descriptor);
      var hasDeferredWork = false;
      var shouldDeferWork = supportsDirectProtoAccess && cls != "Object";
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        var firstChar = property.charCodeAt(0);
        if (property === "static") {
          processStatics(init.statics[cls] = descriptor.static, processedClasses);
          delete descriptor.static;
        } else if (firstChar === 43) {
          mangledNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
        } else if (firstChar === 42) {
          descriptor[previousProperty].$defaultValues = descriptor[property];
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else {
          var elem = descriptor[property];
          if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
            if (shouldDeferWork)
              hasDeferredWork = true;
            else
              addStubs(descriptor, elem, property, false, []);
          else
            previousProperty = property;
        }
      }
      if (hasDeferredWork)
        descriptor.$deferredAction = finishAddStubsHelper;
      var classData = descriptor["^"],
        split, supr,
        fields = classData;
      var s = fields.split(";");
      fields = s[1] ? s[1].split(",") : [];
      supr = s[0];
      split = supr.split(":");
      if (split.length == 2) {
        supr = split[0];
        var functionSignature = split[1];
        if (functionSignature)
          descriptor.$signature = function(s) {
            return function() {
              return init.types[s];
            };
          }(functionSignature);
      }
      if (supr)
        processedClasses.pending[cls] = supr;
      processedClasses.combinedConstructorFunction += defineClass(cls, fields);
      processedClasses.constructorsList.push(cls);
      processedClasses.collected[cls] = [globalObject, descriptor];
      classes.push(cls);
    }
    function processStatics(descriptor, processedClasses) {
      var properties = Object.keys(descriptor);
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (property === "^")
          continue;
        var element = descriptor[property];
        var firstChar = property.charCodeAt(0);
        var previousProperty;
        if (firstChar === 43) {
          mangledGlobalNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
          if (element && element.length)
            init.typeInformation[previousProperty] = element;
        } else if (firstChar === 42) {
          globalObject[previousProperty].$defaultValues = element;
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else if (typeof element === "function") {
          globalObject[previousProperty = property] = element;
          functions.push(property);
        } else if (element.constructor === Array)
          addStubs(globalObject, element, property, true, functions);
        else {
          previousProperty = property;
          processClassData(property, element, processedClasses);
        }
      }
    }
    function addStubs(prototype, array, name, isStatic, functions) {
      var index = 0,
        applyTrampolineIndex = index,
        alias = array[index],
        f;
      if (typeof alias == "string")
        f = array[++index];
      else {
        f = alias;
        alias = name;
      }
      if (typeof f == "number") {
        applyTrampolineIndex = f;
        f = array[++index];
      }
      prototype[name] = prototype[alias] = f;
      var funcs = [f];
      f.$stubName = name;
      functions.push(name);
      for (index++; index < array.length; index++) {
        f = array[index];
        if (typeof f != "function")
          break;
        if (!isStatic)
          f.$stubName = array[++index];
        funcs.push(f);
        if (f.$stubName) {
          prototype[f.$stubName] = f;
          functions.push(f.$stubName);
        }
      }
      for (var i = 0; i < funcs.length; index++, i++)
        funcs[i].$callName = array[index];
      var getterStubName = array[index];
      array = array.slice(++index);
      var requiredParameterInfo = array[0];
      var isIntercepted = (requiredParameterInfo & 1) === 1;
      requiredParameterInfo = requiredParameterInfo >> 1;
      var requiredParameterCount = requiredParameterInfo >> 1;
      var isAccessor = (requiredParameterInfo & 1) === 1;
      var isSetter = requiredParameterInfo === 3;
      var isGetter = requiredParameterInfo === 1;
      var optionalParameterInfo = array[1];
      var optionalParameterCount = optionalParameterInfo >> 1;
      var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
      var totalParameterCount = requiredParameterCount + optionalParameterCount;
      var functionTypeIndex = array[2];
      if (typeof functionTypeIndex == "number")
        array[2] = functionTypeIndex + typesOffset;
      if (metadataOffset > 0) {
        var position = 3;
        for (var i = 0; i < optionalParameterCount; i++) {
          if (typeof array[position] == "number")
            array[position] = array[position] + metadataOffset;
          position++;
        }
        for (var i = 0; i < totalParameterCount; i++) {
          array[position] = array[position] + metadataOffset;
          position++;
        }
      }
      var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
      if (getterStubName) {
        f = tearOff(funcs, applyTrampolineIndex, array, isStatic, name, isIntercepted);
        prototype[name].$getter = f;
        f.$getterStub = true;
        if (isStatic)
          functions.push(getterStubName);
        prototype[getterStubName] = f;
        funcs.push(f);
        f.$stubName = getterStubName;
        f.$callName = null;
      }
      var isReflectable = array.length > unmangledNameIndex;
      if (isReflectable) {
        funcs[0].$reflectable = 1;
        funcs[0].$reflectionInfo = array;
        for (var i = 1; i < funcs.length; i++) {
          funcs[i].$reflectable = 2;
          funcs[i].$reflectionInfo = array;
        }
        var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
        var unmangledName = array[unmangledNameIndex];
        var reflectionName = unmangledName;
        if (getterStubName)
          mangledNames[getterStubName] = reflectionName;
        if (isSetter)
          reflectionName += "=";
        else if (!isGetter)
          reflectionName += ":" + (requiredParameterCount + optionalParameterCount);
        mangledNames[name] = reflectionName;
        funcs[0].$reflectionName = reflectionName;
        for (var i = unmangledNameIndex + 1; i < array.length; i++)
          array[i] = array[i] + metadataOffset;
        funcs[0].$metadataIndex = unmangledNameIndex + 1;
        if (optionalParameterCount)
          prototype[unmangledName + "*"] = funcs[applyTrampolineIndex];
      }
    }
    Function.prototype.call$1 = function(a) {
      return this(a);
    };
    Function.prototype.call$0 = function() {
      return this();
    };
    Function.prototype.call$2 = function(a, b) {
      return this(a, b);
    };
    Function.prototype.call$1$1 = function(a) {
      return this(a);
    };
    Function.prototype.call$3 = function(a, b, c) {
      return this(a, b, c);
    };
    Function.prototype.call$4 = function(a, b, c, d) {
      return this(a, b, c, d);
    };
    Function.prototype.call$3$3 = function(a, b, c) {
      return this(a, b, c);
    };
    Function.prototype.call$2$2 = function(a, b) {
      return this(a, b);
    };
    Function.prototype.call$2$3 = function(a, b, c) {
      return this(a, b, c);
    };
    Function.prototype.call$1$2 = function(a, b) {
      return this(a, b);
    };
    Function.prototype.call$3$1 = function(a) {
      return this(a);
    };
    Function.prototype.call$2$1 = function(a) {
      return this(a);
    };
    Function.prototype.call$5 = function(a, b, c, d, e) {
      return this(a, b, c, d, e);
    };
    Function.prototype.call$1$0 = function() {
      return this();
    };
    Function.prototype.call$2$0 = function() {
      return this();
    };
    function tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted) {
      return isIntercepted ? new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, true, name);" + "return new c(this, funcs[0], receiver, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null) : new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, false, name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null);
    }
    function tearOff(funcs, applyTrampolineIndex, reflectionInfo, isStatic, name, isIntercepted) {
      var cache = null;
      return isStatic ? function() {
        if (cache === null)
          cache = H.closureFromTearOff(this, funcs, applyTrampolineIndex, reflectionInfo, true, false, name).prototype;
        return cache;
      } : tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted);
    }
    var functionCounter = 0;
    if (!init.libraries)
      init.libraries = [];
    if (!init.mangledNames)
      init.mangledNames = map();
    if (!init.mangledGlobalNames)
      init.mangledGlobalNames = map();
    if (!init.statics)
      init.statics = map();
    if (!init.typeInformation)
      init.typeInformation = map();
    var libraries = init.libraries;
    var mangledNames = init.mangledNames;
    var mangledGlobalNames = init.mangledGlobalNames;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var length = programData.length;
    var processedClasses = map();
    processedClasses.collected = map();
    processedClasses.pending = map();
    processedClasses.constructorsList = [];
    processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
    for (var i = 0; i < length; i++) {
      var data = programData[i];
      var name = data[0];
      var uri = data[1];
      var metadata = data[2];
      var globalObject = data[3];
      var descriptor = data[4];
      var isRoot = !!data[5];
      var fields = descriptor && descriptor["^"];
      if (fields instanceof Array)
        fields = fields[0];
      var classes = [];
      var functions = [];
      processStatics(descriptor, processedClasses);
      libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
    }
    finishClasses(processedClasses);
  }
  Isolate.functionThatReturnsNull = function() {
  };
  var dart = [["_chrome", "dart:_chrome",, H, {
    "^": "",
    ChromeObject: {
      "^": "Object;$ti"
    },
    Rule: {
      "^": "ChromeObject;$ti"
    },
    Event1: {
      "^": "Object;$ti"
    },
    API_ChromeApp: {
      "^": "Object;$ti"
    },
    API_Chrome: {
      "^": "Object;$ti"
    },
    AppWindowBounds: {
      "^": "ChromeObject;$ti"
    },
    AppWindowCreateWindowOptions: {
      "^": "ChromeObject;$ti"
    },
    AppWindowAppWindow: {
      "^": "ChromeObject;$ti"
    },
    Event_app_window_onBoundsChanged: {
      "^": "Event1;$ti"
    },
    Event_app_window_onClosed: {
      "^": "Event1;$ti"
    },
    Event_app_window_onFullscreened: {
      "^": "Event1;$ti"
    },
    Event_app_window_onMaximized: {
      "^": "Event1;$ti"
    },
    Event_app_window_onMinimized: {
      "^": "Event1;$ti"
    },
    Event_app_window_onRestored: {
      "^": "Event1;$ti"
    },
    API_app_window: {
      "^": "Object;$ti"
    },
    AppRuntimeLaunchItem: {
      "^": "ChromeObject;$ti"
    },
    AppRuntimeLaunchData: {
      "^": "ChromeObject;$ti"
    },
    Event_app_runtime_onLaunched: {
      "^": "Event1;$ti"
    },
    Event_app_runtime_onRestarted: {
      "^": "Event1;$ti"
    },
    API_app_runtime: {
      "^": "Object;$ti"
    },
    FilesystemAcceptOption: {
      "^": "ChromeObject;$ti"
    },
    FilesystemChooseEntryOptions: {
      "^": "ChromeObject;$ti"
    },
    API_file_system: {
      "^": "Object;$ti"
    }
  }], ["_foreign_helper", "dart:_foreign_helper",, H, {
    "^": "",
    JS_CONST: {
      "^": "Object;code>,$ti"
    }
  }], ["dart._http", "dart:_http",, H, {
    "^": "",
    _CryptoUtils: {
      "^": "Object;$ti"
    },
    _HashBase: {
      "^": "Object;$ti"
    },
    _MD5: {
      "^": "_HashBase;$ti"
    },
    _SHA1: {
      "^": "_HashBase;$ti"
    },
    HttpStatus: {
      "^": "Object;$ti"
    },
    HttpServer: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [H.HttpRequest0];
      }
    },
    HttpConnectionsInfo: {
      "^": "Object;$ti"
    },
    HttpHeaders: {
      "^": "Object;$ti"
    },
    HeaderValue: {
      "^": "Object;$ti"
    },
    HttpSession: {
      "^": "Object;$ti",
      $isMap: 1,
      $asMap: Isolate.functionThatReturnsNull
    },
    ContentType: {
      "^": "Object;$ti",
      $isHeaderValue: 1
    },
    Cookie: {
      "^": "Object;$ti"
    },
    HttpRequest0: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      }
    },
    HttpResponse: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $isStreamSink: 1,
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1
    },
    HttpClient: {
      "^": "Object;$ti"
    },
    HttpClientRequest: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $isStreamSink: 1,
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1
    },
    HttpClientResponse: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      }
    },
    HttpClientCredentials: {
      "^": "Object;$ti"
    },
    HttpClientBasicCredentials: {
      "^": "HttpClientCredentials;$ti"
    },
    HttpClientDigestCredentials: {
      "^": "HttpClientCredentials;$ti"
    },
    HttpConnectionInfo: {
      "^": "Object;$ti"
    },
    RedirectInfo: {
      "^": "Object;$ti"
    },
    DetachedSocket: {
      "^": "Object;$ti"
    },
    HttpException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    RedirectException: {
      "^": "Object;$ti",
      $isHttpException: 1,
      $isException: 1,
      $isIOException: 1
    },
    HttpDate: {
      "^": "Object;$ti"
    },
    _HttpHeaders: {
      "^": "Object;$ti",
      $isHttpHeaders: 1
    },
    _HeaderValue: {
      "^": "Object;$ti",
      $isHeaderValue: 1
    },
    _ContentType: {
      "^": "_HeaderValue;$ti",
      $isContentType: 1
    },
    _Cookie: {
      "^": "Object;$ti",
      $isCookie: 1
    },
    _ServiceObject: {
      "^": "Object;$ti"
    },
    _CopyingBytesBuilder: {
      "^": "Object;$ti",
      $isBytesBuilder: 1
    },
    _HttpIncoming: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [[P.List, P.int]];
      }
    },
    _HttpInboundMessage: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [[P.List, P.int]];
      }
    },
    _HttpRequest: {
      "^": "_HttpInboundMessage;$ti",
      $isHttpRequest0: 1
    },
    _HttpClientResponse: {
      "^": "_HttpInboundMessage;$ti",
      $isHttpClientResponse: 1
    },
    _StreamSinkImpl: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isSink: 1
    },
    _IOSinkImpl: {
      "^": "_StreamSinkImpl;$ti",
      $as_StreamSinkImpl: function() {
        return [[P.List, P.int]];
      },
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1
    },
    _HttpOutboundMessage: {
      "^": "_IOSinkImpl;$ti"
    },
    _HttpResponse: {
      "^": "_HttpOutboundMessage;$ti",
      $isHttpResponse: 1,
      $as_StreamSinkImpl: function() {
        return [[P.List, P.int]];
      },
      $as_HttpOutboundMessage: function() {
        return [H.HttpResponse];
      },
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $asSink: function() {
        return [[P.List, P.int]];
      }
    },
    _HttpClientRequest: {
      "^": "_HttpOutboundMessage;$ti",
      $isHttpClientRequest: 1,
      $as_StreamSinkImpl: function() {
        return [[P.List, P.int]];
      },
      $as_HttpOutboundMessage: function() {
        return [H.HttpClientResponse];
      },
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $asSink: function() {
        return [[P.List, P.int]];
      }
    },
    _HttpGZipSink: {
      "^": "ByteConversionSink;$ti"
    },
    _HttpOutgoing: {
      "^": "Object;$ti",
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      }
    },
    _HttpClientConnection: {
      "^": "Object;$ti"
    },
    _ConnectionInfo: {
      "^": "Object;$ti"
    },
    _ConnectionTarget: {
      "^": "Object;$ti"
    },
    _HttpClient: {
      "^": "Object;$ti",
      $isHttpClient: 1
    },
    _HttpConnection: {
      "^": "__HttpConnection_LinkedListEntry__ServiceObject;$ti",
      $is_ServiceObject: 1,
      $asLinkedListEntry: function() {
        return [H._HttpConnection];
      }
    },
    _HttpServer: {
      "^": "__HttpServer_Stream__ServiceObject;$ti",
      $isHttpServer: 1,
      $is_ServiceObject: 1,
      $asStream: function() {
        return [H.HttpRequest0];
      }
    },
    _ProxyConfiguration: {
      "^": "Object;$ti"
    },
    _Proxy: {
      "^": "Object;$ti"
    },
    _HttpConnectionInfo: {
      "^": "Object;$ti",
      $isHttpConnectionInfo: 1
    },
    _DetachedSocket: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [[P.List, P.int]];
      },
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $isStreamSink: 1,
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1,
      $isSocket: 1
    },
    _AuthenticationScheme: {
      "^": "Object;$ti"
    },
    _Credentials: {
      "^": "Object;$ti"
    },
    _SiteCredentials: {
      "^": "_Credentials;$ti"
    },
    _ProxyCredentials: {
      "^": "_Credentials;$ti"
    },
    _HttpClientCredentials: {
      "^": "Object;$ti",
      $isHttpClientCredentials: 1
    },
    _HttpClientBasicCredentials: {
      "^": "_HttpClientCredentials;$ti",
      $isHttpClientBasicCredentials: 1
    },
    _HttpClientDigestCredentials: {
      "^": "_HttpClientCredentials;$ti",
      $isHttpClientDigestCredentials: 1
    },
    _RedirectInfo: {
      "^": "Object;$ti",
      $isRedirectInfo: 1
    },
    _Const: {
      "^": "Object;$ti"
    },
    _CharCode: {
      "^": "Object;$ti"
    },
    _State: {
      "^": "Object;$ti"
    },
    _HttpVersion: {
      "^": "Object;$ti"
    },
    _MessageType: {
      "^": "Object;$ti"
    },
    _HttpDetachedStreamSubscription: {
      "^": "Object;$ti",
      $isStreamSubscription: 1,
      $asStreamSubscription: function() {
        return [[P.List, P.int]];
      }
    },
    _HttpDetachedIncoming: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [[P.List, P.int]];
      }
    },
    _HttpParser: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [H._HttpIncoming];
      }
    },
    _HttpSession: {
      "^": "Object;$ti",
      $isHttpSession: 1,
      $isMap: 1,
      $asMap: Isolate.functionThatReturnsNull
    },
    _HttpSessionManager: {
      "^": "Object;$ti"
    },
    HttpOverrides: {
      "^": "Object;$ti"
    },
    _HttpOverridesScope: {
      "^": "HttpOverrides;$ti"
    },
    WebSocketStatus: {
      "^": "Object;$ti"
    },
    CompressionOptions: {
      "^": "Object;$ti"
    },
    WebSocketTransformer: {
      "^": "Object;$ti",
      $isStreamTransformer: 1,
      $asStreamTransformer: function() {
        return [H.HttpRequest0, H.WebSocket];
      }
    },
    WebSocket: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: Isolate.functionThatReturnsNull,
      $isEventSink: 1,
      $asEventSink: Isolate.functionThatReturnsNull,
      $isStreamConsumer: 1,
      $asStreamConsumer: Isolate.functionThatReturnsNull,
      $isStreamSink: 1,
      $asStreamSink: Isolate.functionThatReturnsNull,
      $isSink: 1,
      $asSink: Isolate.functionThatReturnsNull
    },
    WebSocketException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    _WebSocketMessageType: {
      "^": "Object;$ti"
    },
    _WebSocketOpcode: {
      "^": "Object;$ti"
    },
    _EncodedString: {
      "^": "Object;$ti"
    },
    _CompressionMaxWindowBits: {
      "^": "Object;$ti"
    },
    _WebSocketProtocolTransformer: {
      "^": "StreamTransformerBase;$ti",
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $asStreamTransformer: function() {
        return [[P.List, P.int], null];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], null];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      }
    },
    _WebSocketPing: {
      "^": "Object;$ti"
    },
    _WebSocketPong: {
      "^": "Object;$ti"
    },
    _WebSocketTransformerImpl: {
      "^": "StreamTransformerBase;$ti",
      $isWebSocketTransformer: 1,
      $asStreamTransformer: function() {
        return [H.HttpRequest0, H.WebSocket];
      },
      $asStreamTransformerBase: function() {
        return [H.HttpRequest0, H.WebSocket];
      }
    },
    _WebSocketPerMessageDeflate: {
      "^": "Object;$ti"
    },
    _WebSocketOutgoingTransformer: {
      "^": "StreamTransformerBase;$ti",
      $isEventSink: 1,
      $asEventSink: Isolate.functionThatReturnsNull,
      $asStreamTransformer: function() {
        return [null, [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [null, [P.List, P.int]];
      },
      $isSink: 1,
      $asSink: Isolate.functionThatReturnsNull
    },
    _WebSocketConsumer: {
      "^": "Object;$ti",
      $isStreamConsumer: 1,
      $asStreamConsumer: Isolate.functionThatReturnsNull
    },
    _WebSocketImpl: {
      "^": "__WebSocketImpl_Stream__ServiceObject;$ti",
      $is_ServiceObject: 1,
      $isWebSocket: 1,
      $asStream: Isolate.functionThatReturnsNull,
      $isEventSink: 1,
      $asEventSink: Isolate.functionThatReturnsNull,
      $isStreamConsumer: 1,
      $asStreamConsumer: Isolate.functionThatReturnsNull,
      $isStreamSink: 1,
      $asStreamSink: Isolate.functionThatReturnsNull,
      $isSink: 1,
      $asSink: Isolate.functionThatReturnsNull
    },
    __HttpConnection_LinkedListEntry__ServiceObject: {
      "^": "LinkedListEntry;$ti",
      $is_ServiceObject: 1,
      $asLinkedListEntry: function() {
        return [H._HttpConnection];
      }
    },
    __HttpServer_Stream__ServiceObject: {
      "^": "Stream;$ti",
      $is_ServiceObject: 1,
      $asStream: function() {
        return [H.HttpRequest0];
      }
    },
    __WebSocketImpl_Stream__ServiceObject: {
      "^": "Stream;$ti",
      $is_ServiceObject: 1,
      $asStream: Isolate.functionThatReturnsNull
    }
  }], ["_interceptors", "dart:_interceptors",, J, {
    "^": "",
    getDispatchProperty: [function(object) {
      return object[init.dispatchPropertyName];
    }, null, null, 4, 0, null, 9],
    setDispatchProperty: [function(object, value) {
      H.defineProperty(object, init.dispatchPropertyName, value);
    }, null, null, 8, 0, null, 9, 1],
    makeDispatchRecord: [function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    }, null, null, 16, 0, null, 166, 417, 254, 723],
    dispatchRecordInterceptor: [function(record) {
      return record.i;
    }, null, null, 4, 0, null, 150],
    dispatchRecordProto: [function(record) {
      return record.p;
    }, null, null, 4, 0, null, 150],
    dispatchRecordExtension: [function(record) {
      return record.e;
    }, null, null, 4, 0, null, 150],
    dispatchRecordIndexability: [function(record) {
      return record.x;
    }, null, null, 4, 0, null, 150],
    getNativeInterceptor: [function(object) {
      var record, proto, objectProto, $constructor, interceptor;
      record = J.getDispatchProperty(object);
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = J.getDispatchProperty(object);
        }
      if (record != null) {
        proto = J.dispatchRecordProto(record);
        if (false === proto)
          return J.dispatchRecordInterceptor(record);
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return J.dispatchRecordInterceptor(record);
        if (J.dispatchRecordExtension(record) === objectProto)
          throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = J.lookupInterceptorByConstructor($constructor);
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        J.cacheInterceptorOnConstructor($constructor, C.UnknownJavaScriptObject_methods);
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    }, null, null, 4, 0, null, 9],
    lookupInterceptorByConstructor: [function($constructor) {
      return $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
    }, null, null, 4, 0, null, 335],
    cacheInterceptorOnConstructor: [function($constructor, interceptor) {
      H.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), interceptor);
    }, null, null, 8, 0, null, 335, 166],
    Interceptor: {
      "^": "Object;$ti",
      $eq: [function(receiver, other) {
        return receiver === other;
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      }, null, null, 3, 0, null],
      toString$0: ["super$Interceptor$toString", function(receiver) {
        return H.Primitives_objectToHumanReadableString(receiver);
      }, null, "get$toString", 1, 0, null],
      noSuchMethod$1: ["super$Interceptor$noSuchMethod", function(receiver, invocation) {
        H.interceptedTypeCheck(invocation, "$isInvocation");
        throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      }, null, "get$noSuchMethod", 5, 0, null, 306],
      get$runtimeType: [function(receiver) {
        return H.getRuntimeType(receiver);
      }, null, null, 3, 0, null]
    },
    JSBool: {
      "^": "Interceptor;$ti",
      toString$0: [function(receiver) {
        return String(receiver);
      }, null, "get$toString", 1, 0, null],
      $and: [function(receiver, other) {
        return H.checkBool(H.boolTypeCheck(other)) && receiver;
      }, null, "get$&", 5, 0, null, 3],
      get$hashCode: [function(receiver) {
        return receiver ? 519018 : 218159;
      }, null, null, 3, 0, null],
      get$runtimeType: [function(receiver) {
        return C.Type_bool_lhE;
      }, null, null, 3, 0, null],
      $isbool: 1
    },
    JSNull: {
      "^": "Interceptor;$ti",
      $eq: [function(receiver, other) {
        return null == other;
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(receiver) {
        return "null";
      }, null, "get$toString", 1, 0, null],
      get$hashCode: [function(receiver) {
        return 0;
      }, null, null, 3, 0, null],
      get$runtimeType: [function(receiver) {
        return C.Type_Null_Yyn;
      }, null, null, 3, 0, null],
      noSuchMethod$1: [function(receiver, invocation) {
        return this.super$Interceptor$noSuchMethod(receiver, H.interceptedTypeCheck(invocation, "$isInvocation"));
      }, null, "get$noSuchMethod", 5, 0, null, 306],
      $isNull: 1
    },
    JSIndexable: {
      "^": "Object;$ti"
    },
    JSMutableIndexable: {
      "^": "JSIndexable;$ti"
    },
    JSObject: {
      "^": "Object;$ti"
    },
    JavaScriptObject: {
      "^": "Interceptor;$ti",
      get$hashCode: [function(receiver) {
        return 0;
      }, null, null, 3, 0, null],
      get$runtimeType: [function(receiver) {
        return C.Type_JSObject_8k0;
      }, null, null, 3, 0, null],
      toString$0: ["super$JavaScriptObject$toString", function(receiver) {
        return String(receiver);
      }, null, "get$toString", 1, 0, null],
      destroy$2: function(receiver, p0, p1) {
        return receiver.destroy(p0, p1);
      },
      $isJSObject: 1,
      $is_SplitOptions: 1,
      $isSplitter: 1
    },
    PlainJavaScriptObject: {
      "^": "JavaScriptObject;$ti"
    },
    UnknownJavaScriptObject: {
      "^": "JavaScriptObject;$ti"
    },
    JavaScriptFunction: {
      "^": "JavaScriptObject;$ti",
      toString$0: [function(receiver) {
        var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
        if (dartClosure == null)
          return this.super$JavaScriptObject$toString(receiver);
        return "JavaScript function for " + H.S(J.toString$0$(dartClosure));
      }, null, "get$toString", 1, 0, null],
      $signature: function() {
        return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
      },
      $isFunction: 1
    },
    _Growable: {
      "^": "Object;$ti"
    },
    JSArray: {
      "^": "Interceptor;$ti",
      checkMutable$1: [function(receiver, reason) {
        if (!!receiver.immutable$list)
          throw H.wrapException(P.UnsupportedError$(H.stringTypeCheck(reason)));
      }, null, "get$checkMutable", 5, 0, null, 390],
      checkGrowable$1: [function(receiver, reason) {
        if (!!receiver.fixed$length)
          throw H.wrapException(P.UnsupportedError$(H.stringTypeCheck(reason)));
      }, null, "get$checkGrowable", 5, 0, null, 390],
      cast$1$0: [1, function(receiver, $R) {
        return P.List_castFrom(receiver, H.getTypeArgumentByIndex(receiver, 0), $R);
      }, function($receiver) {
        return this.cast$1$0($receiver, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      add$1: [function(receiver, value) {
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
        this.checkGrowable$1(receiver, "add");
        receiver.push(value);
      }, "call$1", "get$add", 5, 0, 2, 1],
      removeAt$1: [function(receiver, index) {
        H.intTypeCheck(index);
        this.checkGrowable$1(receiver, "removeAt");
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.argumentErrorValue(index));
        if (index < 0 || index >= receiver.length)
          throw H.wrapException(P.RangeError$value(index, null, null));
        return receiver.splice(index, 1)[0];
      }, null, "get$removeAt", 5, 0, null, 6],
      insert$2: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
        this.checkGrowable$1(receiver, "insert");
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.argumentErrorValue(index));
        if (index < 0 || index > receiver.length)
          throw H.wrapException(P.RangeError$value(index, null, null));
        receiver.splice(index, 0, value);
      }, null, "get$insert", 9, 0, null, 6, 1],
      insertAll$2: [function(receiver, index, iterable) {
        var t1, insertionLength, end;
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
        this.checkGrowable$1(receiver, "insertAll");
        P.RangeError_checkValueInInterval(index, 0, receiver.length, "index", null);
        t1 = J.getInterceptor$(iterable);
        if (!t1.$isEfficientLengthIterable)
          iterable = t1.toList$0(iterable);
        insertionLength = J.get$length$asx(iterable);
        t1 = receiver.length;
        if (typeof insertionLength !== "number")
          return H.iae(insertionLength);
        this.set$length(receiver, t1 + insertionLength);
        if (typeof index !== "number")
          return index.$add();
        end = index + insertionLength;
        this.setRange$4(receiver, end, receiver.length, receiver, index);
        this.setRange$3(receiver, index, end, iterable);
      }, null, "get$insertAll", 9, 0, null, 6, 13],
      setAll$2: [function(receiver, index, iterable) {
        var t1, element, index0;
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
        this.checkMutable$1(receiver, "setAll");
        P.RangeError_checkValueInInterval(index, 0, receiver.length, "index", null);
        for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0(); index = index0) {
          element = t1.get$current();
          if (typeof index !== "number")
            return index.$add();
          index0 = index + 1;
          this.$indexSet(receiver, index, element);
        }
      }, null, "get$setAll", 9, 0, null, 6, 13],
      removeLast$0: [function(receiver) {
        this.checkGrowable$1(receiver, "removeLast");
        if (receiver.length === 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, -1));
        return receiver.pop();
      }, null, "get$removeLast", 1, 0, null],
      remove$1: [function(receiver, element) {
        var i;
        this.checkGrowable$1(receiver, "remove");
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], element)) {
            receiver.splice(i, 1);
            return true;
          }
        return false;
      }, null, "get$remove", 5, 0, null, 10],
      where$1: [function(receiver, f) {
        var t1 = H.getTypeArgumentByIndex(receiver, 0);
        return H.WhereIterable$(receiver, H.functionTypeCheck(f, {func: 1, ret: P.bool, args: [t1]}), t1);
      }, null, "get$where", 5, 0, null, 15],
      addAll$1: [function(receiver, collection) {
        var t1;
        H.assertSubtype(collection, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
        this.checkGrowable$1(receiver, "addAll");
        for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
          receiver.push(t1.get$current());
      }, null, "get$addAll", 5, 0, null, 383],
      clear$0: [function(receiver) {
        this.set$length(receiver, 0);
      }, null, "get$clear", 1, 0, null],
      forEach$1: [function(receiver, f) {
        var end, i;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(receiver, 0)]});
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          f.call$1(receiver[i]);
          if (receiver.length !== end)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
      }, null, "get$forEach", 5, 0, null, 15],
      map$1$1: [1, function(receiver, f, $T) {
        var t1 = H.getTypeArgumentByIndex(receiver, 0);
        return H.MappedListIterable$(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      join$1: [function(receiver, separator) {
        var list, i;
        H.stringTypeCheck(separator);
        list = new Array(receiver.length);
        list.fixed$length = Array;
        for (i = 0; i < receiver.length; ++i)
          this.$indexSet(list, i, H.S(receiver[i]));
        return list.join(separator);
      }, null, "get$join", 1, 2, null, 39, 90],
      take$1: [function(receiver, n) {
        return H.SubListIterable$(receiver, 0, H.intTypeCheck(n), H.getTypeArgumentByIndex(receiver, 0));
      }, null, "get$take", 5, 0, null, 72],
      skip$1: [function(receiver, n) {
        return H.SubListIterable$(receiver, H.intTypeCheck(n), null, H.getTypeArgumentByIndex(receiver, 0));
      }, null, "get$skip", 5, 0, null, 72],
      fold$1$2: [1, function(receiver, initialValue, combine, $T) {
        var $length, value, i;
        H.assertSubtypeOfRuntimeType(initialValue, $T);
        H.functionTypeCheck(combine, {func: 1, ret: $T, args: [$T, H.getTypeArgumentByIndex(receiver, 0)]});
        $length = receiver.length;
        for (value = initialValue, i = 0; i < $length; ++i) {
          value = combine.call$2(value, receiver[i]);
          if (receiver.length !== $length)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return value;
      }, function($receiver, initialValue, combine) {
        return this.fold$1$2($receiver, initialValue, combine, null);
      }, "fold$2", null, "call$2", "get$fold", 9, 0, null, 888, 655],
      firstWhere$2$orElse: [function(receiver, test, orElse) {
        var t1, end, i, element;
        t1 = H.getTypeArgumentByIndex(receiver, 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          element = receiver[i];
          if (test.call$1(element))
            return element;
          if (receiver.length !== end)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$firstWhere", 5, 3, null, 0, 41, 98],
      lastWhere$2$orElse: [function(receiver, test, orElse) {
        var t1, $length, i, element;
        t1 = H.getTypeArgumentByIndex(receiver, 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        $length = receiver.length;
        for (i = $length - 1; i >= 0; --i) {
          element = receiver[i];
          if (test.call$1(element))
            return element;
          if ($length !== receiver.length)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      elementAt$1: [function(receiver, index) {
        return this.$index(receiver, H.intTypeCheck(index));
      }, null, "get$elementAt", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.checkNull(start);
        if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
        if (end == null)
          end = receiver.length;
        else if (end < start || end > receiver.length)
          throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
        if (start === end)
          return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
        return J.JSArray_JSArray$markGrowable(receiver.slice(start, end), H.getTypeArgumentByIndex(receiver, 0));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      get$first: [function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 3, 0, null],
      get$last: [function(receiver) {
        var t1 = receiver.length;
        if (t1 > 0)
          return receiver[t1 - 1];
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 3, 0, null],
      get$single: [function(receiver) {
        var t1 = receiver.length;
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(receiver, 0);
          return receiver[0];
        }
        if (t1 === 0)
          throw H.wrapException(H.IterableElementError_noElement());
        throw H.wrapException(H.IterableElementError_tooMany());
      }, null, null, 3, 0, null],
      setRange$4: [function(receiver, start, end, iterable, skipCount) {
        var t1, $length, t2, otherStart, otherList, i;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = H.getTypeArgumentByIndex(receiver, 0);
        H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
        H.intTypeCheck(skipCount);
        this.checkMutable$1(receiver, "setRange");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length === 0)
          return;
        P.RangeError_checkNotNegative(skipCount, "skipCount", null);
        t2 = J.getInterceptor$(iterable);
        if (!!t2.$isList) {
          H.assertSubtype(iterable, "$isList", [t1], "$asList");
          otherStart = skipCount;
          otherList = iterable;
        } else {
          otherList = J.toList$1$growable$ax(t2.skip$1(iterable, skipCount), false);
          otherStart = 0;
        }
        if (typeof otherStart !== "number")
          return otherStart.$add();
        t1 = J.getInterceptor$asx(otherList);
        t2 = t1.get$length(otherList);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (otherStart + $length > t2)
          throw H.wrapException(H.IterableElementError_tooFew());
        if (otherStart < start)
          for (i = $length - 1; i >= 0; --i)
            receiver[start + i] = t1.$index(otherList, otherStart + i);
        else
          for (i = 0; i < $length; ++i)
            receiver[start + i] = t1.$index(otherList, otherStart + i);
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      replaceRange$3: [function(receiver, start, end, replacement) {
        var t1, removeLength, insertLength, insertEnd, delta, newLength;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(replacement, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
        this.checkGrowable$1(receiver, "replaceRange");
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        t1 = J.getInterceptor$(replacement);
        if (!t1.$isEfficientLengthIterable)
          replacement = t1.toList$0(replacement);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        removeLength = end - start;
        insertLength = J.get$length$asx(replacement);
        if (typeof insertLength !== "number")
          return H.iae(insertLength);
        t1 = receiver.length;
        insertEnd = start + insertLength;
        if (removeLength >= insertLength) {
          delta = removeLength - insertLength;
          newLength = t1 - delta;
          this.setRange$3(receiver, start, insertEnd, replacement);
          if (delta !== 0) {
            this.setRange$4(receiver, insertEnd, newLength, receiver, end);
            this.set$length(receiver, newLength);
          }
        } else {
          newLength = t1 + (insertLength - removeLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, replacement);
        }
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 115],
      any$1: [function(receiver, test) {
        var end, i;
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(receiver, 0)]});
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          if (test.call$1(receiver[i]))
            return true;
          if (receiver.length !== end)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return false;
      }, null, "get$any", 5, 0, null, 41],
      get$reversed: [function(receiver) {
        return H.ReversedListIterable$(receiver, H.getTypeArgumentByIndex(receiver, 0));
      }, null, null, 3, 0, null],
      sort$1: [function(receiver, compare) {
        var t1 = H.getTypeArgumentByIndex(receiver, 0);
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
        this.checkMutable$1(receiver, "sort");
        H.Sort_sort(receiver, compare == null ? J._interceptors_JSArray__compareAny$closure() : compare, t1);
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      indexOf$2: [function(receiver, element, start) {
        var t1, i;
        H.intTypeCheck(start);
        t1 = receiver.length;
        if (typeof start !== "number")
          return start.$ge();
        if (start >= t1)
          return -1;
        if (start < 0)
          start = 0;
        for (i = start; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], element))
            return i;
        return -1;
      }, function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      }, "indexOf$1", null, null, "get$indexOf", 5, 2, null, 16, 10, 5],
      contains$1: [function(receiver, other) {
        var i;
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], other))
            return true;
        return false;
      }, null, "get$contains", 5, 0, null, 3],
      get$isEmpty: [function(receiver) {
        return receiver.length === 0;
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(receiver) {
        return !this.get$isEmpty(receiver);
      }, null, null, 3, 0, null],
      toString$0: [function(receiver) {
        return P.ListBase_listToString(receiver);
      }, null, "get$toString", 1, 0, null],
      toList$1$growable: [function(receiver, growable) {
        return H.boolTypeCheck(growable) ? this._toListGrowable$0(receiver) : this._toListFixed$0(receiver);
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95],
      _toListGrowable$0: [function(receiver) {
        return J.JSArray_JSArray$markGrowable(receiver.slice(0), H.getTypeArgumentByIndex(receiver, 0));
      }, null, "get$_toListGrowable", 1, 0, null],
      _toListFixed$0: [function(receiver) {
        return J.JSArray_JSArray$markFixed(receiver.slice(0), H.getTypeArgumentByIndex(receiver, 0));
      }, null, "get$_toListFixed", 1, 0, null],
      get$iterator: [function(receiver) {
        return J.ArrayIterator$(receiver, H.getTypeArgumentByIndex(receiver, 0));
      }, null, null, 3, 0, null],
      get$hashCode: [function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      }, null, null, 3, 0, null],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      set$length: [function(receiver, newLength) {
        H.intTypeCheck(newLength);
        this.checkGrowable$1(receiver, "set length");
        if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
          throw H.wrapException(P.ArgumentError$value(newLength, "newLength", null));
        if (newLength < 0)
          throw H.wrapException(P.RangeError$range(newLength, 0, null, "newLength", null));
        receiver.length = newLength;
      }, null, null, 7, 0, null, 162],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
        this.checkMutable$1(receiver, "indexed set");
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      }, null, "get$[]=", 9, 0, null, 6, 1],
      $add: [function(receiver, other) {
        var t1, t2, t3, totalLength;
        t1 = [H.getTypeArgumentByIndex(receiver, 0)];
        H.assertSubtype(other, "$isList", t1, "$asList");
        t2 = receiver.length;
        t3 = J.get$length$asx(other);
        if (typeof t3 !== "number")
          return H.iae(t3);
        totalLength = t2 + t3;
        t1 = H.setRuntimeTypeInfo([], t1);
        this.set$length(t1, totalLength);
        this.setRange$3(t1, 0, receiver.length, receiver);
        this.setRange$3(t1, receiver.length, totalLength, other);
        return t1;
      }, null, "get$+", 5, 0, null, 3],
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1,
      static: {
        JSArray_JSArray$fixed: [function($length, $E) {
          H.intTypeCheck($length);
          if (typeof $length !== "number" || Math.floor($length) !== $length)
            throw H.wrapException(P.ArgumentError$value($length, "length", "is not an integer"));
          if ($length < 0 || $length > 4294967295)
            throw H.wrapException(P.RangeError$range($length, 0, 4294967295, "length", null));
          return J.JSArray_JSArray$markFixed(new Array($length), $E);
        }, null, null, 4, 0, null, 35],
        JSArray_JSArray$growable: [function($length, $E) {
          H.intTypeCheck($length);
          if (typeof $length !== "number" || Math.floor($length) !== $length || $length < 0)
            throw H.wrapException(P.ArgumentError$("Length must be a non-negative integer: " + H.S($length)));
          return J.JSArray_JSArray$markGrowable(new Array($length), $E);
        }, null, null, 4, 0, null, 35],
        JSArray_JSArray$typed: [function(allocation, $E) {
          return allocation;
        }, null, null, 4, 0, null, 303],
        JSArray_JSArray$markFixed: [function(allocation, $E) {
          return J.JSArray_markFixedList(H.setRuntimeTypeInfo(J.JSArray_JSArray$typed(allocation, $E), [$E]));
        }, null, null, 4, 0, null, 303],
        JSArray_JSArray$markGrowable: [function(allocation, $E) {
          return H.setRuntimeTypeInfo(J.JSArray_JSArray$typed(allocation, $E), [$E]);
        }, null, null, 4, 0, null, 303],
        JSArray_markFixedList: [function(list) {
          H.listTypeCheck(list);
          list.fixed$length = Array;
          return list;
        }, null, null, 4, 0, null, 68],
        JSArray_markUnmodifiableList: [function(list) {
          H.listTypeCheck(list);
          list.fixed$length = Array;
          list.immutable$list = Array;
          return list;
        }, null, null, 4, 0, null, 68],
        JSArray__compareAny: [function(a, b) {
          return P.Comparable_compare(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
        }, "call$2", "_interceptors_JSArray__compareAny$closure", 8, 0, 71, 33, 54]
      }
    },
    JSUnmodifiableArray: {
      "^": "JSArray;$ti"
    },
    ArrayIterator: {
      "^": "Object;_iterable,_length,_index,0_current,$ti",
      set$_current: function(_current) {
        this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
      },
      get$current: [function() {
        return this._current;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        var t1, t2, $length;
        t1 = this._iterable;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (!J.$eq$(this._length, $length))
          throw H.wrapException(H.throwConcurrentModificationError(t1));
        if (J.$ge$n(this._index, $length)) {
          this.set$_current(null);
          return false;
        }
        this.set$_current(t2.$index(t1, this._index));
        this._index = H.intTypeCheck(J.$add$ansx(this._index, 1));
        return true;
      }, null, "get$moveNext", 0, 0, null],
      $isIterator: 1,
      static: {
        ArrayIterator$: [function(iterable, $E) {
          return new J.ArrayIterator(iterable, iterable.length, 0, [$E]);
        }, null, null, 4, 0, null, 13]
      }
    },
    JSNumber: {
      "^": "Interceptor;$ti",
      compareTo$1: [function(receiver, b) {
        var bIsNegative;
        H.numTypeCheck(b);
        if (typeof b !== "number")
          throw H.wrapException(H.argumentErrorValue(b));
        if (receiver < b)
          return -1;
        else if (receiver > b)
          return 1;
        else if (receiver === b) {
          if (receiver === 0) {
            bIsNegative = this.get$isNegative(b);
            if (J.$eq$(this.get$isNegative(receiver), bIsNegative))
              return 0;
            if (this.get$isNegative(receiver))
              return -1;
            return 1;
          }
          return 0;
        } else if (this.get$isNaN(receiver)) {
          if (this.get$isNaN(b))
            return 0;
          return 1;
        } else
          return -1;
      }, null, "get$compareTo", 5, 0, null, 54],
      get$isNegative: [function(receiver) {
        return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
      }, null, null, 3, 0, null],
      get$isNaN: [function(receiver) {
        return isNaN(receiver);
      }, null, null, 3, 0, null],
      get$isInfinite: [function(receiver) {
        return receiver == 1 / 0 || receiver == -1 / 0;
      }, null, null, 3, 0, null],
      get$isFinite: [function(receiver) {
        return isFinite(receiver);
      }, null, null, 3, 0, null],
      remainder$1: [function(receiver, b) {
        H.numTypeCheck(b);
        if (typeof b !== "number")
          throw H.wrapException(H.argumentErrorValue(b));
        return receiver % b;
      }, null, "get$remainder", 5, 0, null, 54],
      abs$0: [function(receiver) {
        return Math.abs(receiver);
      }, null, "get$abs", 1, 0, null],
      toInt$0: [function(receiver) {
        if (receiver >= -2147483648 && receiver <= 2147483647)
          return receiver | 0;
        if (isFinite(receiver))
          return this.truncateToDouble$0(receiver) + 0;
        throw H.wrapException(P.UnsupportedError$("" + receiver + ".toInt()"));
      }, null, "get$toInt", 1, 0, null],
      truncate$0: [function(receiver) {
        return this.toInt$0(receiver);
      }, null, "get$truncate", 1, 0, null],
      ceil$0: [function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647) {
            truncated = receiver | 0;
            return receiver === truncated ? truncated : truncated + 1;
          }
        } else if (receiver >= -2147483648)
          return receiver | 0;
        d = Math.ceil(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(P.UnsupportedError$("" + receiver + ".ceil()"));
      }, null, "get$ceil", 1, 0, null],
      floor$0: [function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647)
            return receiver | 0;
        } else if (receiver >= -2147483648) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated - 1;
        }
        d = Math.floor(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(P.UnsupportedError$("" + receiver + ".floor()"));
      }, null, "get$floor", 1, 0, null],
      round$0: [function(receiver) {
        if (receiver > 0) {
          if (receiver !== 1 / 0)
            return Math.round(receiver);
        } else if (receiver > -1 / 0)
          return 0 - Math.round(0 - receiver);
        throw H.wrapException(P.UnsupportedError$("" + receiver + ".round()"));
      }, null, "get$round", 1, 0, null],
      ceilToDouble$0: [function(receiver) {
        return Math.ceil(receiver);
      }, null, "get$ceilToDouble", 1, 0, null],
      floorToDouble$0: [function(receiver) {
        return Math.floor(receiver);
      }, null, "get$floorToDouble", 1, 0, null],
      truncateToDouble$0: [function(receiver) {
        return receiver < 0 ? this.ceilToDouble$0(receiver) : this.floorToDouble$0(receiver);
      }, null, "get$truncateToDouble", 1, 0, null],
      clamp$2: [function(receiver, lowerLimit, upperLimit) {
        H.numTypeCheck(lowerLimit);
        H.numTypeCheck(upperLimit);
        if (typeof lowerLimit !== "number")
          throw H.wrapException(H.argumentErrorValue(lowerLimit));
        if (typeof upperLimit !== "number")
          throw H.wrapException(H.argumentErrorValue(upperLimit));
        if (J.$gt$n(this.compareTo$1(lowerLimit, upperLimit), 0))
          throw H.wrapException(H.argumentErrorValue(lowerLimit));
        if (J.$lt$n(this.compareTo$1(receiver, lowerLimit), 0))
          return lowerLimit;
        if (J.$gt$n(this.compareTo$1(receiver, upperLimit), 0))
          return upperLimit;
        return receiver;
      }, null, "get$clamp", 9, 0, null, 1007, 610],
      toDouble$0: [function(receiver) {
        return receiver;
      }, null, "get$toDouble", 1, 0, null],
      toStringAsFixed$1: [function(receiver, fractionDigits) {
        var result;
        H.intTypeCheck(fractionDigits);
        H.checkInt(fractionDigits);
        if (typeof fractionDigits !== "number")
          return fractionDigits.$lt();
        if (fractionDigits < 0 || fractionDigits > 20)
          throw H.wrapException(P.RangeError$range(fractionDigits, 0, 20, "fractionDigits", null));
        result = receiver.toFixed(fractionDigits);
        if (receiver === 0 && this.get$isNegative(receiver))
          return "-" + result;
        return result;
      }, null, "get$toStringAsFixed", 5, 0, null, 370],
      toRadixString$1: [function(receiver, radix) {
        var result;
        H.intTypeCheck(radix);
        H.checkInt(radix);
        if (typeof radix !== "number")
          return radix.$lt();
        if (radix < 2 || radix > 36)
          throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
        result = receiver.toString(radix);
        if (!J.$eq$(C.JSString_methods.codeUnitAt$1(result, result.length - 1), 41))
          return result;
        return J.JSNumber__handleIEtoString(result);
      }, null, "get$toRadixString", 5, 0, null, 264],
      toString$0: [function(receiver) {
        if (receiver === 0 && 1 / receiver < 0)
          return "-0.0";
        else
          return "" + receiver;
      }, null, "get$toString", 1, 0, null],
      get$hashCode: [function(receiver) {
        return receiver & 0x1FFFFFFF;
      }, null, null, 3, 0, null],
      $negate: [function(receiver) {
        return -receiver;
      }, null, "get$unary-", 1, 0, null],
      $add: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver + other;
      }, null, "get$+", 5, 0, null, 3],
      $sub: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver - other;
      }, null, "get$-", 5, 0, null, 3],
      $div: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver / other;
      }, null, "get$/", 5, 0, null, 3],
      $mul: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver * other;
      }, null, "get$*", 5, 0, null, 3],
      $mod: [function(receiver, other) {
        var result;
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        result = receiver % other;
        if (result === 0)
          return 0;
        if (result > 0)
          return result;
        if (other < 0)
          return result - other;
        else
          return result + other;
      }, null, "get$%", 5, 0, null, 3],
      _isInt32$1: [function(receiver, value) {
        return (value | 0) === value;
      }, null, "get$_isInt32", 5, 0, null, 1],
      $tdiv: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        if (this._isInt32$1(receiver, receiver))
          if (other >= 1 || other < -1)
            return receiver / other | 0;
        return this._tdivSlow$1(receiver, other);
      }, null, "get$~/", 5, 0, null, 3],
      _tdivFast$1: [function(receiver, other) {
        H.numTypeCheck(other);
        return this._isInt32$1(receiver, receiver) ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
      }, null, "get$_tdivFast", 5, 0, null, 3],
      _tdivSlow$1: [function(receiver, other) {
        var quotient;
        H.numTypeCheck(other);
        quotient = receiver / other;
        if (quotient >= -2147483648 && quotient <= 2147483647)
          return quotient | 0;
        if (quotient > 0) {
          if (quotient !== 1 / 0)
            return Math.floor(quotient);
        } else if (quotient > -1 / 0)
          return Math.ceil(quotient);
        throw H.wrapException(P.UnsupportedError$("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + H.S(other)));
      }, null, "get$_tdivSlow", 5, 0, null, 3],
      $shl: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        return this._shlPositive$1(receiver, other);
      }, null, "get$<<", 5, 0, null, 3],
      _shlPositive$1: [function(receiver, other) {
        H.numTypeCheck(other);
        return other > 31 ? 0 : receiver << other >>> 0;
      }, null, "get$_shlPositive", 5, 0, null, 3],
      $shr: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        return this._shrOtherPositive$1(receiver, other);
      }, null, "get$>>", 5, 0, null, 3],
      _shrOtherPositive$1: [function(receiver, other) {
        var t1;
        H.numTypeCheck(other);
        if (receiver > 0)
          t1 = this._shrBothPositive$1(receiver, other);
        else {
          if (typeof other !== "number")
            return other.$gt();
          if (other > 31)
            t1 = 31;
          else
            t1 = other;
          t1 = receiver >> t1 >>> 0;
        }
        return t1;
      }, null, "get$_shrOtherPositive", 5, 0, null, 3],
      _shrBothPositive$1: [function(receiver, other) {
        H.numTypeCheck(other);
        return other > 31 ? 0 : receiver >>> other;
      }, null, "get$_shrBothPositive", 5, 0, null, 3],
      $and: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver & other) >>> 0;
      }, null, "get$&", 5, 0, null, 3],
      $or: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver | other) >>> 0;
      }, null, "get$|", 5, 0, null, 3],
      $xor: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver ^ other) >>> 0;
      }, null, "get$^", 5, 0, null, 3],
      $lt: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver < other;
      }, null, "get$<", 5, 0, null, 3],
      $gt: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver > other;
      }, null, "get$>", 5, 0, null, 3],
      $le: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver <= other;
      }, null, "get$<=", 5, 0, null, 3],
      $ge: [function(receiver, other) {
        H.numTypeCheck(other);
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver >= other;
      }, null, "get$>=", 5, 0, null, 3],
      get$runtimeType: [function(receiver) {
        return C.Type_num_cv7;
      }, null, null, 3, 0, null],
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      },
      $isdouble: 1,
      $isnum: 1,
      static: {
        JSNumber__handleIEtoString: [function(result) {
          var match, t1, exponent;
          H.stringTypeCheck(result);
          match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
          if (match == null)
            throw H.wrapException(P.UnsupportedError$("Unexpected toString result: " + H.S(result)));
          t1 = match.length;
          if (1 >= t1)
            return H.ioore(match, 1);
          result = match[1];
          if (3 >= t1)
            return H.ioore(match, 3);
          exponent = +match[3];
          t1 = match[2];
          if (t1 != null) {
            result += t1;
            exponent -= t1.length;
          }
          return C.JSString_methods.$add(result, C.JSString_methods.$mul("0", exponent));
        }, null, null, 4, 0, null, 59]
      }
    },
    JSInt: {
      "^": "JSNumber;$ti",
      abs$0: [function(receiver) {
        return Math.abs(receiver);
      }, null, "get$abs", 1, 0, null],
      $negate: [function(receiver) {
        return -receiver;
      }, null, "get$unary-", 1, 0, null],
      get$isOdd: [function(receiver) {
        return (receiver & 1) === 1;
      }, null, null, 3, 0, null],
      toUnsigned$1: [function(receiver, width) {
        H.intTypeCheck(width);
        if (typeof width !== "number")
          return H.iae(width);
        return (receiver & this.$shl(1, width) - 1) >>> 0;
      }, null, "get$toUnsigned", 5, 0, null, 56],
      get$runtimeType: [function(receiver) {
        return C.Type_int_tHn;
      }, null, null, 3, 0, null],
      $not: [function(receiver) {
        return ~receiver >>> 0;
      }, null, "get$~", 1, 0, null],
      $isint: 1
    },
    JSDouble: {
      "^": "JSNumber;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_double_K1J;
      }, null, null, 3, 0, null]
    },
    JSString: {
      "^": "Interceptor;$ti",
      codeUnitAt$1: [function(receiver, index) {
        H.intTypeCheck(index);
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return this._codeUnitAt$1(receiver, index);
      }, null, "get$codeUnitAt", 5, 0, null, 6],
      _codeUnitAt$1: [function(receiver, index) {
        H.intTypeCheck(index);
        if (typeof index !== "number")
          return index.$ge();
        if (index >= receiver.length)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver.charCodeAt(index);
      }, null, "get$_codeUnitAt", 5, 0, null, 6],
      allMatches$2: [function(receiver, string, start) {
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        H.checkString(string);
        H.checkInt(start);
        if (typeof start !== "number")
          return H.iae(start);
        if (0 > start || start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return H.allMatchesInStringUnchecked(receiver, string, start);
      }, function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      }, "allMatches$1", null, null, "get$allMatches", 5, 2, null, 16, 30, 5],
      matchAsPrefix$2: [function(receiver, string, start) {
        var t1, t2, i;
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        if (typeof start !== "number")
          return start.$lt();
        if (start < 0 || start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        t1 = receiver.length;
        if (start + t1 > string.length)
          return;
        for (t2 = J.getInterceptor$s(string), i = 0; i < t1; ++i)
          if (!J.$eq$(t2.codeUnitAt$1(string, start + i), this._codeUnitAt$1(receiver, i)))
            return;
        return H.StringMatch$(start, string, receiver);
      }, function($receiver, string) {
        return this.matchAsPrefix$2($receiver, string, 0);
      }, "matchAsPrefix$1", null, null, "get$matchAsPrefix", 5, 2, null, 16, 30, 5],
      $add: [function(receiver, other) {
        H.stringTypeCheck(other);
        if (typeof other !== "string")
          throw H.wrapException(P.ArgumentError$value(other, null, null));
        return receiver + other;
      }, null, "get$+", 5, 0, null, 3],
      endsWith$1: [function(receiver, other) {
        var otherLength, t1;
        H.stringTypeCheck(other);
        H.checkString(other);
        otherLength = other.length;
        t1 = receiver.length;
        if (otherLength > t1)
          return false;
        t1 = this.substring$1(receiver, t1 - otherLength);
        return other == null ? t1 == null : other === t1;
      }, null, "get$endsWith", 5, 0, null, 3],
      replaceAll$2: [function(receiver, from, to) {
        H.stringSuperNativeTypeCheck(from, "$isPattern");
        H.stringTypeCheck(to);
        H.checkString(to);
        return H.stringTypeCheck(H.stringReplaceAllUnchecked(receiver, from, to));
      }, null, "get$replaceAll", 9, 0, null, 121, 222],
      replaceAllMapped$2: [function(receiver, from, convert) {
        return this.splitMapJoin$2$onMatch(receiver, H.stringSuperNativeTypeCheck(from, "$isPattern"), H.functionTypeCheck(convert, {func: 1, ret: P.String, args: [P.Match]}));
      }, null, "get$replaceAllMapped", 9, 0, null, 121, 188],
      splitMapJoin$3$onMatch$onNonMatch: [function(receiver, from, onMatch, onNonMatch) {
        return H.stringTypeCheck(H.stringReplaceAllFuncUnchecked(receiver, H.stringSuperNativeTypeCheck(from, "$isPattern"), H.functionTypeCheck(onMatch, {func: 1, ret: P.String, args: [P.Match]}), H.functionTypeCheck(onNonMatch, {func: 1, ret: P.String, args: [P.String]})));
      }, function($receiver, from, onMatch) {
        return this.splitMapJoin$3$onMatch$onNonMatch($receiver, from, onMatch, null);
      }, "splitMapJoin$2$onMatch", null, null, "get$splitMapJoin", 5, 5, null, 0, 0, 121, 270, 269],
      replaceFirst$3: [function(receiver, from, to, startIndex) {
        H.stringSuperNativeTypeCheck(from, "$isPattern");
        H.stringTypeCheck(to);
        H.intTypeCheck(startIndex);
        H.checkString(to);
        H.checkInt(startIndex);
        P.RangeError_checkValueInInterval(startIndex, 0, receiver.length, "startIndex", null);
        return H.stringTypeCheck(H.stringReplaceFirstUnchecked(receiver, from, to, startIndex));
      }, function($receiver, from, to) {
        return this.replaceFirst$3($receiver, from, to, 0);
      }, "replaceFirst$2", null, null, "get$replaceFirst", 9, 2, null, 16, 121, 222, 76],
      split$1: [function(receiver, pattern) {
        H.stringSuperNativeTypeCheck(pattern, "$isPattern");
        H.checkNull(pattern);
        if (typeof pattern === "string")
          return H.stringSplitUnchecked(receiver, pattern);
        else if (pattern instanceof H.JSSyntaxRegExp && J.$eq$(H.regExpCaptureCount(pattern), 0))
          return H.stringSplitUnchecked(receiver, H.regExpGetNative(pattern));
        else
          return this._defaultSplit$1(receiver, pattern);
      }, null, "get$split", 5, 0, null, 36],
      replaceRange$3: [function(receiver, start, end, replacement) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.stringTypeCheck(replacement);
        H.checkString(replacement);
        H.checkInt(start);
        end = P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        H.checkInt(end);
        return H.stringReplaceRangeUnchecked(receiver, start, end, replacement);
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 115],
      _defaultSplit$1: [function(receiver, pattern) {
        var result, t1, start, $length, t2, matchStart, matchEnd;
        H.stringSuperNativeTypeCheck(pattern, "$isPattern");
        result = H.setRuntimeTypeInfo([], [P.String]);
        for (t1 = J.get$iterator$ax(J.allMatches$1$s(pattern, receiver)), start = 0, $length = 1; t1.moveNext$0();) {
          t2 = t1.get$current();
          matchStart = t2.get$start(t2);
          matchEnd = t2.get$end();
          if (typeof matchEnd !== "number")
            return matchEnd.$sub();
          if (typeof matchStart !== "number")
            return H.iae(matchStart);
          $length = matchEnd - matchStart;
          if ($length === 0 && start === matchStart)
            continue;
          C.JSArray_methods.add$1(result, this.substring$2(receiver, start, matchStart));
          start = matchEnd;
        }
        if (start < receiver.length || $length > 0)
          C.JSArray_methods.add$1(result, this.substring$1(receiver, start));
        return result;
      }, null, "get$_defaultSplit", 5, 0, null, 36],
      startsWith$2: [function(receiver, pattern, index) {
        var endIndex;
        H.stringSuperNativeTypeCheck(pattern, "$isPattern");
        H.intTypeCheck(index);
        H.checkInt(index);
        if (typeof index !== "number")
          return index.$lt();
        if (index < 0 || index > receiver.length)
          throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
        if (typeof pattern === "string") {
          endIndex = index + pattern.length;
          if (endIndex > receiver.length)
            return false;
          return pattern === receiver.substring(index, endIndex);
        }
        return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
      }, function($receiver, pattern) {
        return this.startsWith$2($receiver, pattern, 0);
      }, "startsWith$1", null, null, "get$startsWith", 5, 2, null, 16, 36, 6],
      substring$2: [function(receiver, startIndex, endIndex) {
        H.intTypeCheck(startIndex);
        H.intTypeCheck(endIndex);
        H.checkInt(startIndex);
        if (endIndex == null)
          endIndex = receiver.length;
        if (typeof startIndex !== "number")
          return startIndex.$lt();
        if (startIndex < 0)
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (startIndex > endIndex)
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (endIndex > receiver.length)
          throw H.wrapException(P.RangeError$value(endIndex, null, null));
        return receiver.substring(startIndex, endIndex);
      }, function($receiver, startIndex) {
        return this.substring$2($receiver, startIndex, null);
      }, "substring$1", null, null, "get$substring", 5, 2, null, 0, 76, 249],
      toLowerCase$0: [function(receiver) {
        return receiver.toLowerCase();
      }, null, "get$toLowerCase", 1, 0, null],
      toUpperCase$0: [function(receiver) {
        return receiver.toUpperCase();
      }, null, "get$toUpperCase", 1, 0, null],
      trim$0: [function(receiver) {
        var result, endIndex, startIndex, t1, endIndex0;
        result = receiver.trim();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        if (this._codeUnitAt$1(result, 0) === 133) {
          startIndex = J.JSString__skipLeadingWhitespace(result, 1);
          if (startIndex === endIndex)
            return "";
        } else
          startIndex = 0;
        t1 = endIndex - 1;
        endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
        if (startIndex === 0 && endIndex0 === endIndex)
          return result;
        return result.substring(startIndex, endIndex0);
      }, null, "get$trim", 1, 0, null],
      trimLeft$0: [function(receiver) {
        var result, startIndex;
        if (typeof receiver.trimLeft != "undefined") {
          result = receiver.trimLeft();
          if (result.length === 0)
            return result;
          startIndex = this._codeUnitAt$1(result, 0) === 133 ? J.JSString__skipLeadingWhitespace(result, 1) : 0;
        } else {
          startIndex = J.JSString__skipLeadingWhitespace(receiver, 0);
          result = receiver;
        }
        if (startIndex === 0)
          return result;
        if (startIndex === result.length)
          return "";
        return result.substring(startIndex);
      }, null, "get$trimLeft", 1, 0, null],
      trimRight$0: [function(receiver) {
        var result, endIndex, t1;
        if (typeof receiver.trimRight != "undefined") {
          result = receiver.trimRight();
          endIndex = result.length;
          if (endIndex === 0)
            return result;
          t1 = endIndex - 1;
          if (this.codeUnitAt$1(result, t1) === 133)
            endIndex = J.JSString__skipTrailingWhitespace(result, t1);
        } else {
          endIndex = J.JSString__skipTrailingWhitespace(receiver, receiver.length);
          result = receiver;
        }
        if (endIndex === result.length)
          return result;
        if (endIndex === 0)
          return "";
        return result.substring(0, endIndex);
      }, null, "get$trimRight", 1, 0, null],
      $mul: [function(receiver, times) {
        var s, result;
        H.intTypeCheck(times);
        if (typeof times !== "number")
          return H.iae(times);
        if (0 >= times)
          return "";
        if (times === 1 || receiver.length === 0)
          return receiver;
        if (times !== times >>> 0)
          throw H.wrapException(C.C_OutOfMemoryError);
        for (s = receiver, result = ""; true;) {
          if ((times & 1) === 1)
            result = J.$add$ansx(s, result);
          times = times >>> 1;
          if (times === 0)
            break;
          s = H.stringTypeCheck(J.$add$ansx(s, s));
        }
        return result;
      }, null, "get$*", 5, 0, null, 871],
      padLeft$2: [function(receiver, width, padding) {
        var delta;
        H.intTypeCheck(width);
        H.stringTypeCheck(padding);
        if (typeof width !== "number")
          return width.$sub();
        delta = width - receiver.length;
        if (delta <= 0)
          return receiver;
        return J.$add$ansx(J.$mul$ns(padding, delta), receiver);
      }, function($receiver, width) {
        return this.padLeft$2($receiver, width, " ");
      }, "padLeft$1", null, null, "get$padLeft", 5, 2, null, 247, 56, 416],
      padRight$2: [function(receiver, width, padding) {
        var delta;
        H.intTypeCheck(width);
        H.stringTypeCheck(padding);
        if (typeof width !== "number")
          return width.$sub();
        delta = width - receiver.length;
        if (delta <= 0)
          return receiver;
        return this.$add(receiver, J.$mul$ns(padding, delta));
      }, function($receiver, width) {
        return this.padRight$2($receiver, width, " ");
      }, "padRight$1", null, null, "get$padRight", 5, 2, null, 247, 56, 416],
      get$codeUnits: [function(receiver) {
        return H.CodeUnits$(receiver);
      }, null, null, 3, 0, null],
      indexOf$2: [function(receiver, pattern, start) {
        var t1, match, t2, i;
        H.stringSuperNativeTypeCheck(pattern, "$isPattern");
        H.intTypeCheck(start);
        H.checkNull(pattern);
        if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
        if (typeof pattern === "string")
          return H.intTypeCheck(H.stringIndexOfStringUnchecked(receiver, pattern, start));
        t1 = J.getInterceptor$(pattern);
        if (!!t1.$isJSSyntaxRegExp) {
          match = H.firstMatchAfter(pattern, receiver, start);
          return match == null ? -1 : match.get$start(match);
        }
        for (t2 = receiver.length, i = start; i <= t2; ++i)
          if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
            return i;
        return -1;
      }, function($receiver, pattern) {
        return this.indexOf$2($receiver, pattern, 0);
      }, "indexOf$1", null, null, "get$indexOf", 5, 2, null, 16, 36, 5],
      lastIndexOf$2: [function(receiver, pattern, start) {
        var t1, t2, i;
        H.stringSuperNativeTypeCheck(pattern, "$isPattern");
        H.intTypeCheck(start);
        H.checkNull(pattern);
        if (start == null)
          start = receiver.length;
        else if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
        if (typeof pattern === "string") {
          t1 = pattern.length;
          t2 = receiver.length;
          return H.intTypeCheck(H.stringLastIndexOfUnchecked(receiver, pattern, start + t1 > t2 ? t2 - t1 : start));
        }
        for (t1 = J.getInterceptor$s(pattern), i = start; i >= 0; --i)
          if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
            return i;
        return -1;
      }, function($receiver, pattern) {
        return this.lastIndexOf$2($receiver, pattern, null);
      }, "lastIndexOf$1", null, null, "get$lastIndexOf", 5, 2, null, 0, 36, 5],
      contains$2: [function(receiver, other, startIndex) {
        H.stringSuperNativeTypeCheck(other, "$isPattern");
        H.intTypeCheck(startIndex);
        H.checkNull(other);
        if (typeof startIndex !== "number")
          return startIndex.$lt();
        if (startIndex < 0 || startIndex > receiver.length)
          throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
        return H.boolTypeCheck(H.stringContainsUnchecked(receiver, other, startIndex));
      }, function($receiver, other) {
        return this.contains$2($receiver, other, 0);
      }, "contains$1", null, null, "get$contains", 5, 2, null, 16, 3, 76],
      get$isEmpty: [function(receiver) {
        return receiver.length === 0;
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(receiver) {
        return !this.get$isEmpty(receiver);
      }, null, null, 3, 0, null],
      compareTo$1: [function(receiver, other) {
        var t1;
        H.stringTypeCheck(other);
        if (typeof other !== "string")
          throw H.wrapException(H.argumentErrorValue(other));
        if (receiver === other)
          t1 = 0;
        else
          t1 = receiver < other ? -1 : 1;
        return t1;
      }, null, "get$compareTo", 5, 0, null, 3],
      toString$0: [function(receiver) {
        return receiver;
      }, null, "get$toString", 1, 0, null],
      get$hashCode: [function(receiver) {
        var t1, hash, i;
        for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
          hash = 536870911 & hash + receiver.charCodeAt(i);
          hash = 536870911 & hash + ((524287 & hash) << 10);
          hash ^= hash >> 6;
        }
        hash = 536870911 & hash + ((67108863 & hash) << 3);
        hash ^= hash >> 11;
        return 536870911 & hash + ((16383 & hash) << 15);
      }, null, null, 3, 0, null],
      get$runtimeType: [function(receiver) {
        return C.Type_String_k8F;
      }, null, null, 3, 0, null],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $isComparable: 1,
      $asComparable: function() {
        return [P.String];
      },
      $isPattern: 1,
      $isString: 1,
      static: {
        JSString__isWhitespace: [function(codeUnit) {
          H.intTypeCheck(codeUnit);
          if (typeof codeUnit !== "number")
            return codeUnit.$lt();
          if (codeUnit < 256)
            switch (codeUnit) {
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 32:
              case 133:
              case 160:
                return true;
              default:
                return false;
            }
          switch (codeUnit) {
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8232:
            case 8233:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }, null, null, 4, 0, null, 125],
        JSString__skipLeadingWhitespace: [function(string, index) {
          var t1, codeUnit;
          H.stringTypeCheck(string);
          H.intTypeCheck(index);
          t1 = string.length;
          while (true) {
            if (typeof index !== "number")
              return index.$lt();
            if (!(index < t1))
              break;
            codeUnit = C.JSString_methods.codeUnitAt$1(string, index);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
            ++index;
          }
          return index;
        }, null, null, 8, 0, null, 30, 6],
        JSString__skipTrailingWhitespace: [function(string, index) {
          var t1, index0, codeUnit;
          H.stringTypeCheck(string);
          H.intTypeCheck(index);
          t1 = J.getInterceptor$s(string);
          while (true) {
            if (typeof index !== "number")
              return index.$gt();
            if (!(index > 0))
              break;
            index0 = index - 1;
            codeUnit = t1.codeUnitAt$1(string, index0);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
            index = index0;
          }
          return index;
        }, null, null, 8, 0, null, 30, 6]
      }
    }
  }], ["dart._internal", "dart:_internal",, H, {
    "^": "",
    printToConsole: [function(line) {
      H.printString(H.S(H.stringTypeCheck(line)));
    }, null, null, 4, 0, null, 49],
    makeListFixedLength: [1, function(growableList, $T) {
      var t1 = [$T];
      return H.assertSubtype(J.JSArray_markFixedList(H.assertSubtype(growableList, "$isList", t1, "$asList")), "$isList", t1, "$asList");
    }, function(growableList) {
      return H.makeListFixedLength(growableList, null);
    }, null, "call$1", null, 4, 0, null, 600],
    makeFixedListUnmodifiable: [1, function(fixedLengthList, $T) {
      var t1 = [$T];
      return H.assertSubtype(J.JSArray_markUnmodifiableList(H.assertSubtype(fixedLengthList, "$isList", t1, "$asList")), "$isList", t1, "$asList");
    }, function(fixedLengthList) {
      return H.makeFixedListUnmodifiable(fixedLengthList, null);
    }, null, "call$1", null, 4, 0, null, 624],
    hexDigitValue: [function(char) {
      var digit, letter;
      H.intTypeCheck(char);
      if (typeof char !== "number")
        return char.$xor();
      digit = (char ^ 48) >>> 0;
      if (digit <= 9)
        return digit;
      letter = (char | 32) >>> 0;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    }, null, null, 4, 0, null, 164],
    parseHexByte: [function(source, index) {
      var digit1, digit2;
      H.stringTypeCheck(source);
      H.intTypeCheck(index);
      digit1 = H.hexDigitValue(J.getInterceptor$s(source).codeUnitAt$1(source, index));
      if (typeof index !== "number")
        return index.$add();
      digit2 = H.hexDigitValue(C.JSString_methods.codeUnitAt$1(source, index + 1));
      if (typeof digit1 !== "number")
        return digit1.$mul();
      if (typeof digit2 !== "number")
        return H.iae(digit2);
      return digit1 * 16 + digit2 - (digit2 & 256);
    }, null, null, 8, 0, null, 11, 6],
    _checkCount: [function(count) {
      H.intTypeCheck(count);
      if (typeof count !== "number" || Math.floor(count) !== count)
        throw H.wrapException(P.ArgumentError$value(count, "count", "is not an integer"));
      P.RangeError_checkNotNegative(count, "count", null);
      return count;
    }, null, null, 4, 0, null, 42],
    IterableElementError_noElement: [function() {
      return P.StateError$("No element");
    }, null, null, 0, 0, null],
    IterableElementError_tooMany: [function() {
      return P.StateError$("Too many elements");
    }, null, null, 0, 0, null],
    IterableElementError_tooFew: [function() {
      return P.StateError$("Too few elements");
    }, null, null, 0, 0, null],
    Sort_sort: [1, function(a, compare, $E) {
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      H.Sort__doSort(a, 0, J.$sub$n(J.get$length$asx(a), 1), compare, $E);
    }, function(a, compare) {
      return H.Sort_sort(a, compare, null);
    }, null, "call$2", null, 8, 0, null, 33, 79],
    Sort__doSort: [1, function(a, left, right, compare, $E) {
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.intTypeCheck(left);
      H.intTypeCheck(right);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      if (typeof right !== "number")
        return right.$sub();
      if (typeof left !== "number")
        return H.iae(left);
      if (right - left <= 32)
        H.Sort__insertionSort(a, left, right, compare, $E);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare, $E);
    }, function(a, left, right, compare) {
      return H.Sort__doSort(a, left, right, compare, null);
    }, null, "call$4", null, 16, 0, null, 33, 119, 214, 79],
    Sort__insertionSort: [1, function(a, left, right, compare, $E) {
      var i, t1, el, j, j0;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.intTypeCheck(left);
      H.intTypeCheck(right);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      if (typeof left !== "number")
        return left.$add();
      i = left + 1;
      if (typeof right !== "number")
        return H.iae(right);
      t1 = J.getInterceptor$asx(a);
      for (; i <= right; ++i) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
            break;
          j0 = j - 1;
          t1.$indexSet(a, j, t1.$index(a, j0));
          j = j0;
        }
        t1.$indexSet(a, j, el);
      }
    }, function(a, left, right, compare) {
      return H.Sort__insertionSort(a, left, right, compare, null);
    }, null, "call$4", null, 16, 0, null, 33, 119, 214, 79],
    Sort__dualPivotQuicksort: [1, function(a, left, right, compare, $E) {
      var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, great0, less0, pivots_are_equal, comp_pivot1, comp_pivot2, t2;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.intTypeCheck(left);
      H.intTypeCheck(right);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      if (typeof right !== "number")
        return right.$sub();
      if (typeof left !== "number")
        return H.iae(left);
      sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
      index1 = left + sixth;
      index5 = right - sixth;
      index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
      index2 = index3 - sixth;
      index4 = index3 + sixth;
      t1 = J.getInterceptor$asx(a);
      el1 = t1.$index(a, index1);
      el2 = t1.$index(a, index2);
      el3 = t1.$index(a, index3);
      el4 = t1.$index(a, index4);
      el5 = t1.$index(a, index5);
      if (J.$gt$n(compare.call$2(el1, el2), 0)) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el3), 0)) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el4), 0)) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el3, el4), 0)) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el5), 0)) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t1.$indexSet(a, index1, el1);
      t1.$indexSet(a, index3, el3);
      t1.$indexSet(a, index5, el5);
      t1.$indexSet(a, index2, t1.$index(a, left));
      t1.$indexSet(a, index4, t1.$index(a, right));
      less = left + 1;
      great = right - 1;
      if (J.$eq$(compare.call$2(el2, el4), 0)) {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp = compare.call$2(ak, el2);
          if (comp === 0)
            continue;
          if (typeof comp !== "number")
            return comp.$lt();
          if (comp < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else
            for (; true;) {
              comp = compare.call$2(t1.$index(a, great), el2);
              if (typeof comp !== "number")
                return comp.$gt();
              if (comp > 0) {
                --great;
                continue;
              } else {
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
        pivots_are_equal = true;
      } else {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp_pivot1 = compare.call$2(ak, el2);
          if (typeof comp_pivot1 !== "number")
            return comp_pivot1.$lt();
          if (comp_pivot1 < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else {
            comp_pivot2 = compare.call$2(ak, el4);
            if (typeof comp_pivot2 !== "number")
              return comp_pivot2.$gt();
            if (comp_pivot2 > 0)
              for (; true;) {
                comp = compare.call$2(t1.$index(a, great), el4);
                if (typeof comp !== "number")
                  return comp.$gt();
                if (comp > 0) {
                  --great;
                  if (great < k)
                    break;
                  continue;
                } else {
                  comp = compare.call$2(t1.$index(a, great), el2);
                  if (typeof comp !== "number")
                    return comp.$lt();
                  great0 = great - 1;
                  if (comp < 0) {
                    t1.$indexSet(a, k, t1.$index(a, less));
                    less0 = less + 1;
                    t1.$indexSet(a, less, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                    less = less0;
                  } else {
                    t1.$indexSet(a, k, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                  }
                  great = great0;
                  break;
                }
              }
          }
        }
        pivots_are_equal = false;
      }
      t2 = less - 1;
      t1.$indexSet(a, left, t1.$index(a, t2));
      t1.$indexSet(a, t2, el2);
      t2 = great + 1;
      t1.$indexSet(a, right, t1.$index(a, t2));
      t1.$indexSet(a, t2, el4);
      H.Sort__doSort(a, left, less - 2, compare, $E);
      H.Sort__doSort(a, great + 2, right, compare, $E);
      if (pivots_are_equal)
        return;
      if (less < index1 && great > index5) {
        for (; J.$eq$(compare.call$2(t1.$index(a, less), el2), 0);)
          ++less;
        for (; J.$eq$(compare.call$2(t1.$index(a, great), el4), 0);)
          --great;
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) === 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) === 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) === 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                comp = compare.call$2(t1.$index(a, great), el2);
                if (typeof comp !== "number")
                  return comp.$lt();
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare, $E);
      } else
        H.Sort__doSort(a, less, great, compare, $E);
    }, function(a, left, right, compare) {
      return H.Sort__dualPivotQuicksort(a, left, right, compare, null);
    }, null, "call$4", null, 16, 0, null, 33, 119, 214, 79],
    CastStream: {
      "^": "Stream;$ti",
      $asStream: function($S, $T) {
        return [$T];
      }
    },
    CastStreamSubscription: {
      "^": "Object;$ti",
      $isStreamSubscription: 1,
      $asStreamSubscription: function($S, $T) {
        return [$T];
      }
    },
    CastStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function(SS, ST, TS, TT) {
        return [TS, TT];
      },
      $asStreamTransformerBase: function(SS, ST, TS, TT) {
        return [TS, TT];
      }
    },
    CastConverter: {
      "^": "Converter;$ti",
      $asStreamTransformer: function(SS, ST, TS, TT) {
        return [TS, TT];
      },
      $asStreamTransformerBase: function(SS, ST, TS, TT) {
        return [TS, TT];
      },
      $asConverter: function(SS, ST, TS, TT) {
        return [TS, TT];
      }
    },
    _CastIterableBase: {
      "^": "Iterable;$ti",
      get$iterator: [function(_) {
        return H.CastIterator$(J.get$iterator$ax(this.get$__internal$_source()), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this.get$__internal$_source());
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this.get$__internal$_source());
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this.get$__internal$_source());
      }, null, null, 3, 0, null],
      skip$1: [function(_, count) {
        H.intTypeCheck(count);
        return H.CastIterable_CastIterable(J.skip$1$ax(this.get$__internal$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, "get$skip", 5, 0, null, 42],
      take$1: [function(_, count) {
        H.intTypeCheck(count);
        return H.CastIterable_CastIterable(J.take$1$ax(this.get$__internal$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, "get$take", 5, 0, null, 42],
      elementAt$1: [function(_, index) {
        H.intTypeCheck(index);
        return H.subtypeOfRuntimeTypeCast(J.elementAt$1$ax(this.get$__internal$_source(), index), H.getTypeArgumentByIndex(this, 1));
      }, null, "get$elementAt", 5, 0, null, 6],
      get$first: [function(_) {
        return H.subtypeOfRuntimeTypeCast(J.get$first$ax(this.get$__internal$_source()), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        return H.subtypeOfRuntimeTypeCast(J.get$last$ax(this.get$__internal$_source()), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        return H.subtypeOfRuntimeTypeCast(J.get$single$ax(this.get$__internal$_source()), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      contains$1: [function(_, other) {
        return J.contains$1$asx(this.get$__internal$_source(), other);
      }, null, "get$contains", 5, 0, null, 3],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1, t2, t3;
        t1 = H.getTypeArgumentByIndex(this, 1);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        t2 = this.get$__internal$_source();
        t3 = orElse == null ? null : new H._CastIterableBase_lastWhere_closure(this, orElse);
        return H.subtypeOfRuntimeTypeCast(J.lastWhere$2$orElse$ax(t2, new H._CastIterableBase_lastWhere_closure0(this, test), t3), t1);
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      toString$0: [function(_) {
        return J.toString$0$(this.get$__internal$_source());
      }, null, "get$toString", 1, 0, null],
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    _CastIterableBase_lastWhere_closure0: {
      "^": "Closure;$this,test,$ti",
      call$1: [function(element) {
        var t1 = this.$this;
        return this.test.call$1(H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(t1, 0)), H.getTypeArgumentByIndex(t1, 1)));
      }, null, null, 4, 0, null, 10, "call"],
      $signature: function() {
        return {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
      }
    },
    _CastIterableBase_lastWhere_closure: {
      "^": "Closure;$this,orElse,$ti",
      call$0: [function() {
        return H.subtypeOfRuntimeTypeCast(this.orElse.call$0(), H.getTypeArgumentByIndex(this.$this, 0));
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        return {func: 1, ret: H.getTypeArgumentByIndex(this.$this, 0)};
      }
    },
    CastIterator: {
      "^": "Object;__internal$_source,$ti",
      moveNext$0: [function() {
        return this.__internal$_source.moveNext$0();
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return H.subtypeOfRuntimeTypeCast(this.__internal$_source.get$current(), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 2, 0, null],
      $isIterator: 1,
      $asIterator: function($S, $T) {
        return [$T];
      },
      static: {
        CastIterator$: [function(_source, $S, $T) {
          return new H.CastIterator(_source, [$S, $T]);
        }, null, null, 4, 0, null, 146]
      }
    },
    CastIterable: {
      "^": "_CastIterableBase;__internal$_source<,$ti",
      static: {
        CastIterable$_: [function(_source, $S, $T) {
          return new H.CastIterable(_source, [$S, $T]);
        }, null, null, 4, 0, null, 146],
        CastIterable_CastIterable: [function(source, $S, $T) {
          H.assertSubtype(source, "$isIterable", [$S], "$asIterable");
          if (H.checkSubtype(source, "$isEfficientLengthIterable", [$S], "$asEfficientLengthIterable"))
            return H._EfficientLengthCastIterable$(source, $S, $T);
          return H.CastIterable$_(source, $S, $T);
        }, null, null, 4, 0, null, 11]
      }
    },
    _EfficientLengthCastIterable: {
      "^": "CastIterable;__internal$_source,$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      static: {
        _EfficientLengthCastIterable$: [function(source, $S, $T) {
          return new H._EfficientLengthCastIterable(source, [$S, $T]);
        }, null, null, 4, 0, null, 11]
      }
    },
    _CastListBase: {
      "^": "__CastListBase__CastIterableBase_ListMixin;$ti",
      $index: [function(_, index) {
        return H.subtypeOfRuntimeTypeCast(J.$index$asx(this.__internal$_source, H.intTypeCheck(index)), H.getTypeArgumentByIndex(this, 1));
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(_, index, value) {
        J.$indexSet$ax(this.__internal$_source, H.intTypeCheck(index), H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)), H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(_, $length) {
        J.set$length$asx(this.__internal$_source, H.intTypeCheck($length));
      }, null, null, 7, 0, null, 35],
      add$1: [function(_, value) {
        J.add$1$ax(this.__internal$_source, H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)), H.getTypeArgumentByIndex(this, 0)));
      }, "call$1", "get$add", 5, 0, 2, 1],
      addAll$1: [function(_, values) {
        var t1 = H.getTypeArgumentByIndex(this, 1);
        J.addAll$1$ax(this.__internal$_source, H.CastIterable_CastIterable(H.assertSubtype(values, "$isIterable", [t1], "$asIterable"), t1, H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$addAll", 5, 0, null, 347],
      sort$1: [function(_, compare) {
        var t1 = H.getTypeArgumentByIndex(this, 1);
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
        t1 = compare == null ? null : new H._CastListBase_sort_closure(this, compare);
        J.sort$1$ax(this.__internal$_source, t1);
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      insert$2: [function(_, index, element) {
        J.insert$2$ax(this.__internal$_source, H.intTypeCheck(index), H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 1)), H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$insert", 9, 0, null, 6, 10],
      insertAll$2: [function(_, index, elements) {
        var t1 = H.getTypeArgumentByIndex(this, 1);
        J.insertAll$2$ax(this.__internal$_source, H.intTypeCheck(index), H.CastIterable_CastIterable(H.assertSubtype(elements, "$isIterable", [t1], "$asIterable"), t1, H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$insertAll", 9, 0, null, 6, 80],
      setAll$2: [function(_, index, elements) {
        var t1 = H.getTypeArgumentByIndex(this, 1);
        J.setAll$2$ax(this.__internal$_source, H.intTypeCheck(index), H.CastIterable_CastIterable(H.assertSubtype(elements, "$isIterable", [t1], "$asIterable"), t1, H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$setAll", 9, 0, null, 6, 80],
      remove$1: [function(_, value) {
        return J.remove$1$ax(this.__internal$_source, value);
      }, null, "get$remove", 5, 0, null, 1],
      removeAt$1: [function(_, index) {
        return H.subtypeOfRuntimeTypeCast(J.removeAt$1$ax(this.__internal$_source, H.intTypeCheck(index)), H.getTypeArgumentByIndex(this, 1));
      }, null, "get$removeAt", 5, 0, null, 6],
      removeLast$0: [function(_) {
        return H.subtypeOfRuntimeTypeCast(J.removeLast$0$ax(this.__internal$_source), H.getTypeArgumentByIndex(this, 1));
      }, null, "get$removeLast", 1, 0, null],
      setRange$4: [function(_, start, end, iterable, skipCount) {
        var t1;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = H.getTypeArgumentByIndex(this, 1);
        H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
        H.intTypeCheck(skipCount);
        J.setRange$4$ax(this.__internal$_source, start, end, H.CastIterable_CastIterable(iterable, t1, H.getTypeArgumentByIndex(this, 0)), skipCount);
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      replaceRange$3: [function(_, start, end, replacement) {
        var t1 = H.getTypeArgumentByIndex(this, 1);
        J.replaceRange$3$asx(this.__internal$_source, H.intTypeCheck(start), H.intTypeCheck(end), H.CastIterable_CastIterable(H.assertSubtype(replacement, "$isIterable", [t1], "$asIterable"), t1, H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 115],
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $isListMixin: 1,
      $asListMixin: function($S, $T) {
        return [$T];
      },
      $isList: 1,
      $asList: function($S, $T) {
        return [$T];
      }
    },
    _CastListBase_sort_closure: {
      "^": "Closure;$this,compare,$ti",
      call$2: [function(v1, v2) {
        var t1, t2;
        t1 = this.$this;
        t2 = H.getTypeArgumentByIndex(t1, 0);
        H.assertSubtypeOfRuntimeType(v1, t2);
        H.assertSubtypeOfRuntimeType(v2, t2);
        t1 = H.getTypeArgumentByIndex(t1, 1);
        return this.compare.call$2(H.subtypeOfRuntimeTypeCast(v1, t1), H.subtypeOfRuntimeTypeCast(v2, t1));
      }, null, null, 8, 0, null, 749, 924, "call"],
      $signature: function() {
        var t1 = H.getTypeArgumentByIndex(this.$this, 0);
        return {func: 1, ret: P.int, args: [t1, t1]};
      }
    },
    _CastListBase_retainWhere_closure: {
      "^": "Closure;$ti"
    },
    CastList: {
      "^": "_CastListBase;__internal$_source<,$ti",
      cast$1$0: [1, function(_, $R) {
        return H.CastList$(this.__internal$_source, H.getTypeArgumentByIndex(this, 0), $R);
      }, function($receiver) {
        return this.cast$1$0($receiver, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      static: {
        CastList$: [function(_source, $S, $T) {
          return new H.CastList(_source, [$S, $T]);
        }, null, null, 4, 0, null, 146]
      }
    },
    CastSet: {
      "^": "_CastIterableBase;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $isSet: 1,
      $asSet: function($S, $T) {
        return [$T];
      }
    },
    CastMap: {
      "^": "MapBase;__internal$_source,$ti",
      cast$2$0: [1, function(_, RK, RV) {
        return H.CastMap$(this.__internal$_source, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1), RK, RV);
      }, function($receiver) {
        return this.cast$2$0($receiver, null, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      containsKey$1: [function(key) {
        return this.__internal$_source.containsKey$1(key);
      }, null, "get$containsKey", 4, 0, null, 4],
      $index: [function(_, key) {
        return H.subtypeOfRuntimeTypeCast(J.$index$asx(this.__internal$_source, key), H.getTypeArgumentByIndex(this, 3));
      }, null, "get$[]", 5, 0, null, 4],
      $indexSet: [function(_, key, value) {
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 2));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 3));
        J.$indexSet$ax(this.__internal$_source, H.subtypeOfRuntimeTypeCast(key, H.getTypeArgumentByIndex(this, 0)), H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(this, 1)));
      }, null, "get$[]=", 9, 0, null, 4, 1],
      putIfAbsent$2: [function(key, ifAbsent) {
        var t1, t2;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 2));
        t1 = H.getTypeArgumentByIndex(this, 3);
        H.functionTypeCheck(ifAbsent, {func: 1, ret: t1});
        H.subtypeOfRuntimeTypeCast(key, H.getTypeArgumentByIndex(this, 0));
        t2 = ifAbsent == null ? null : new H.CastMap_putIfAbsent_closure(this, ifAbsent);
        return H.subtypeOfRuntimeTypeCast(this.__internal$_source.putIfAbsent$2(key, t2), t1);
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      addAll$1: [function(_, other) {
        var t1, t2;
        t1 = H.getTypeArgumentByIndex(this, 2);
        t2 = H.getTypeArgumentByIndex(this, 3);
        J.addAll$1$ax(this.__internal$_source, H.CastMap$(H.assertSubtype(other, "$isMap", [t1, t2], "$asMap"), t1, t2, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)));
      }, null, "get$addAll", 5, 0, null, 3],
      remove$1: [function(_, key) {
        return H.subtypeOfRuntimeTypeCast(J.remove$1$ax(this.__internal$_source, key), H.getTypeArgumentByIndex(this, 3));
      }, null, "get$remove", 5, 0, null, 4],
      clear$0: [function(_) {
        J.clear$0$ax(this.__internal$_source);
      }, null, "get$clear", 1, 0, null],
      forEach$1: [function(_, f) {
        J.forEach$1$ax(this.__internal$_source, new H.CastMap_forEach_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 2), H.getTypeArgumentByIndex(this, 3)]})));
      }, null, "get$forEach", 5, 0, null, 15],
      get$keys: [function() {
        return H.CastIterable_CastIterable(this.__internal$_source.get$keys(), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 2));
      }, null, null, 2, 0, null],
      get$values: [function(_) {
        return H.CastIterable_CastIterable(J.get$values$z(this.__internal$_source), H.getTypeArgumentByIndex(this, 1), H.getTypeArgumentByIndex(this, 3));
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this.__internal$_source);
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this.__internal$_source);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this.__internal$_source);
      }, null, null, 3, 0, null],
      get$entries: [function(_) {
        return J.map$1$1$ax(J.get$entries$z(this.__internal$_source), new H.CastMap_entries_closure(this), [P.MapEntry, H.getTypeArgumentByIndex(this, 2), H.getTypeArgumentByIndex(this, 3)]);
      }, null, null, 3, 0, null],
      $asMapBase: function(SK, SV, $K, $V) {
        return [$K, $V];
      },
      $asMapMixin: function(SK, SV, $K, $V) {
        return [$K, $V];
      },
      $asMap: function(SK, SV, $K, $V) {
        return [$K, $V];
      },
      static: {
        CastMap$: [function(_source, SK, SV, $K, $V) {
          return new H.CastMap(_source, [SK, SV, $K, $V]);
        }, null, null, 4, 0, null, 146]
      }
    },
    CastMap_putIfAbsent_closure: {
      "^": "Closure;$this,ifAbsent,$ti",
      call$0: [function() {
        return H.subtypeOfRuntimeTypeCast(this.ifAbsent.call$0(), H.getTypeArgumentByIndex(this.$this, 1));
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        return {func: 1, ret: H.getTypeArgumentByIndex(this.$this, 1)};
      }
    },
    CastMap_forEach_closure: {
      "^": "Closure;$this,f,$ti",
      call$2: [function(key, value) {
        var t1 = this.$this;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1));
        this.f.call$2(H.subtypeOfRuntimeTypeCast(key, H.getTypeArgumentByIndex(t1, 2)), H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(t1, 3)));
      }, null, null, 8, 0, null, 4, 1, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
      }
    },
    CastMap_entries_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(e) {
        var t1, t2;
        t1 = this.$this;
        H.assertSubtype(e, "$isMapEntry", [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)], "$asMapEntry");
        t2 = H.getTypeArgumentByIndex(t1, 2);
        t1 = H.getTypeArgumentByIndex(t1, 3);
        return P.MapEntry$_(H.subtypeOfRuntimeTypeCast(e.key, t2), H.subtypeOfRuntimeTypeCast(e.value, t1), t2, t1);
      }, null, null, 4, 0, null, 19, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: [P.MapEntry, H.getTypeArgumentByIndex(t1, 2), H.getTypeArgumentByIndex(t1, 3)], args: [[P.MapEntry, H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]]};
      }
    },
    CastQueue: {
      "^": "_CastIterableBase;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $isQueue: 1,
      $asQueue: function($S, $T) {
        return [$T];
      }
    },
    CodeUnits: {
      "^": "UnmodifiableListBase;__internal$_string,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this.__internal$_string);
      }, null, null, 3, 0, null],
      $index: [function(_, i) {
        return J.codeUnitAt$1$s(this.__internal$_string, H.intTypeCheck(i));
      }, null, "get$[]", 5, 0, null, 198],
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      },
      static: {
        CodeUnits$: [function(_string) {
          return new H.CodeUnits(_string, []);
        }, null, null, 4, 0, null, 304]
      }
    },
    ExternalName: {
      "^": "Object;$ti"
    },
    EfficientLengthIterable: {
      "^": "Iterable;$ti"
    },
    ListIterable: {
      "^": "EfficientLengthIterable;$ti",
      get$iterator: [function(_) {
        return H.ListIterator$(this, H.getRuntimeTypeArgument(this, "ListIterable", 0));
      }, null, null, 3, 0, null],
      forEach$1: [function(_, action) {
        var $length, i;
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "ListIterable", 0)]});
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          action.call$1(this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
      }, null, "get$forEach", 5, 0, null, 63],
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$first: [function(_) {
        if (J.$eq$(this.get$length(this), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.elementAt$1(0, 0);
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        if (J.$eq$(this.get$length(this), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.elementAt$1(0, J.$sub$n(this.get$length(this), 1));
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        if (J.$eq$(this.get$length(this), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this.get$length(this), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return this.elementAt$1(0, 0);
      }, null, null, 3, 0, null],
      contains$1: [function(_, element) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (J.$eq$(this.elementAt$1(0, i), element))
            return true;
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return false;
      }, null, "get$contains", 5, 0, null, 10],
      any$1: [function(_, test) {
        var $length, i;
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "ListIterable", 0)]});
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.elementAt$1(0, i)))
            return true;
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return false;
      }, null, "get$any", 5, 0, null, 41],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1, $length, i, element;
        t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return $length.$sub();
        i = $length - 1;
        for (; i >= 0; --i) {
          element = this.elementAt$1(0, i);
          if (test.call$1(element))
            return element;
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      join$1: [function(_, separator) {
        var $length, first, t1, buffer, i;
        H.stringTypeCheck(separator);
        $length = this.get$length(this);
        if (!J.get$isEmpty$asx(separator)) {
          if ($length === 0)
            return "";
          first = H.S(this.elementAt$1(0, 0));
          t1 = this.get$length(this);
          if ($length == null ? t1 != null : $length !== t1)
            throw H.wrapException(P.ConcurrentModificationError$(this));
          buffer = P.StringBuffer$(first);
          if (typeof $length !== "number")
            return H.iae($length);
          i = 1;
          for (; i < $length; ++i) {
            buffer.write$1(separator);
            buffer.write$1(this.elementAt$1(0, i));
            if ($length !== this.get$length(this))
              throw H.wrapException(P.ConcurrentModificationError$(this));
          }
          return buffer.toString$0(0);
        } else {
          buffer = P.StringBuffer$("");
          if (typeof $length !== "number")
            return H.iae($length);
          i = 0;
          for (; i < $length; ++i) {
            buffer.write$1(this.elementAt$1(0, i));
            if ($length !== this.get$length(this))
              throw H.wrapException(P.ConcurrentModificationError$(this));
          }
          return buffer.toString$0(0);
        }
      }, null, "get$join", 1, 2, null, 39, 90],
      where$1: [function(_, test) {
        return this.super$Iterable$where(0, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "ListIterable", 0)]}));
      }, null, "get$where", 5, 0, null, 41],
      map$1$1: [1, function(_, f, $T) {
        var t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
        return H.MappedListIterable$(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      skip$1: [function(_, count) {
        return H.SubListIterable$(this, H.intTypeCheck(count), null, H.getRuntimeTypeArgument(this, "ListIterable", 0));
      }, null, "get$skip", 5, 0, null, 42],
      take$1: [function(_, count) {
        return H.SubListIterable$(this, 0, H.intTypeCheck(count), H.getRuntimeTypeArgument(this, "ListIterable", 0));
      }, null, "get$take", 5, 0, null, 42],
      toList$1$growable: [function(_, growable) {
        var t1, result, t2, i;
        t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
        if (H.boolTypeCheck(growable)) {
          result = H.setRuntimeTypeInfo([], [t1]);
          C.JSArray_methods.set$length(result, this.get$length(this));
        } else {
          t2 = this.get$length(this);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = new Array(t2);
          t2.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t2, [t1]);
        }
        i = 0;
        while (true) {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          C.JSArray_methods.$indexSet(result, i, this.elementAt$1(0, i));
          ++i;
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95]
    },
    SubListIterable: {
      "^": "ListIterable;__internal$_iterable,_start,_endOrLength,$ti",
      SubListIterable$3: [function(_iterable, _start, _endOrLength, $E) {
        var t1, t2;
        t1 = this._start;
        P.RangeError_checkNotNegative(t1, "start", null);
        t2 = this._endOrLength;
        if (t2 != null) {
          P.RangeError_checkNotNegative(t2, "end", null);
          if (J.$gt$n(t1, t2))
            throw H.wrapException(P.RangeError$range(t1, 0, t2, "start", null));
        }
      }, null, null, 12, 0, null, 167, 185, 382],
      get$_endIndex: [function() {
        var $length, t1;
        $length = J.get$length$asx(this.__internal$_iterable);
        t1 = this._endOrLength;
        if (t1 == null || J.$gt$n(t1, $length))
          return $length;
        return t1;
      }, null, null, 2, 0, null],
      get$_startIndex: [function() {
        var $length, t1;
        $length = J.get$length$asx(this.__internal$_iterable);
        t1 = this._start;
        if (J.$gt$n(t1, $length))
          return $length;
        return t1;
      }, null, null, 2, 0, null],
      get$length: [function(_) {
        var $length, t1, t2;
        $length = J.get$length$asx(this.__internal$_iterable);
        t1 = this._start;
        if (J.$ge$n(t1, $length))
          return 0;
        t2 = this._endOrLength;
        if (t2 == null || J.$ge$n(t2, $length)) {
          if (typeof $length !== "number")
            return $length.$sub();
          if (typeof t1 !== "number")
            return H.iae(t1);
          return $length - t1;
        }
        return J.$sub$n(t2, t1);
      }, null, null, 3, 0, null],
      elementAt$1: [function(_, index) {
        var realIndex, t1;
        H.intTypeCheck(index);
        realIndex = J.$add$ansx(this.get$_startIndex(), index);
        if (typeof index !== "number")
          return index.$lt();
        if (index >= 0) {
          t1 = this.get$_endIndex();
          if (typeof realIndex !== "number")
            return realIndex.$ge();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = realIndex >= t1;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.IndexError$(index, this, "index", null, null));
        return J.elementAt$1$ax(this.__internal$_iterable, realIndex);
      }, null, "get$elementAt", 5, 0, null, 6],
      skip$1: [function(_, count) {
        var newStart, t1, t2;
        H.intTypeCheck(count);
        P.RangeError_checkNotNegative(count, "count", null);
        newStart = J.$add$ansx(this._start, count);
        t1 = this._endOrLength;
        if (t1 != null) {
          if (typeof newStart !== "number")
            return newStart.$ge();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t2 = newStart >= t1;
        } else
          t2 = false;
        if (t2)
          return H.EmptyIterable$(H.getTypeArgumentByIndex(this, 0));
        return H.SubListIterable$(this.__internal$_iterable, newStart, t1, H.getTypeArgumentByIndex(this, 0));
      }, null, "get$skip", 5, 0, null, 42],
      take$1: [function(_, count) {
        var t1, t2, newEnd;
        H.intTypeCheck(count);
        P.RangeError_checkNotNegative(count, "count", null);
        t1 = this._endOrLength;
        t2 = this._start;
        if (t1 == null)
          return H.SubListIterable$(this.__internal$_iterable, t2, J.$add$ansx(t2, count), H.getTypeArgumentByIndex(this, 0));
        else {
          newEnd = J.$add$ansx(t2, count);
          if (J.$lt$n(t1, newEnd))
            return this;
          return H.SubListIterable$(this.__internal$_iterable, t2, newEnd, H.getTypeArgumentByIndex(this, 0));
        }
      }, null, "get$take", 5, 0, null, 42],
      toList$1$growable: [function(_, growable) {
        var start, t1, t2, end, end0, $length, t3, result, t4, i;
        H.boolTypeCheck(growable);
        start = this._start;
        t1 = this.__internal$_iterable;
        t2 = J.getInterceptor$asx(t1);
        end = t2.get$length(t1);
        end0 = this._endOrLength;
        if (end0 != null && J.$lt$n(end0, end))
          end = end0;
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length < 0)
          $length = 0;
        t3 = this.$ti;
        if (growable) {
          result = H.setRuntimeTypeInfo([], t3);
          C.JSArray_methods.set$length(result, $length);
        } else {
          t4 = new Array($length);
          t4.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t4, t3);
        }
        for (i = 0; i < $length; ++i) {
          C.JSArray_methods.$indexSet(result, i, t2.elementAt$1(t1, start + i));
          if (J.$lt$n(t2.get$length(t1), end))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95],
      static: {
        SubListIterable$: [function(_iterable, _start, _endOrLength, $E) {
          var t1 = new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
          t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
          return t1;
        }, null, null, 12, 0, null, 167, 185, 382]
      }
    },
    ListIterator: {
      "^": "Object;__internal$_iterable,__internal$_length,__internal$_index,0__internal$_current,$ti",
      set$__internal$_current: function(_current) {
        this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
      },
      get$current: [function() {
        return this.__internal$_current;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        var t1, t2, $length;
        t1 = this.__internal$_iterable;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (!J.$eq$(this.__internal$_length, $length))
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        if (J.$ge$n(this.__internal$_index, $length)) {
          this.set$__internal$_current(null);
          return false;
        }
        this.set$__internal$_current(t2.elementAt$1(t1, this.__internal$_index));
        this.__internal$_index = H.intTypeCheck(J.$add$ansx(this.__internal$_index, 1));
        return true;
      }, null, "get$moveNext", 0, 0, null],
      $isIterator: 1,
      static: {
        ListIterator$: [function(iterable, $E) {
          return new H.ListIterator(iterable, J.get$length$asx(iterable), 0, [$E]);
        }, null, null, 4, 0, null, 13]
      }
    },
    MappedIterable: {
      "^": "Iterable;__internal$_iterable,_f,$ti",
      get$iterator: [function(_) {
        return H.MappedIterator$(J.get$iterator$ax(this.__internal$_iterable), this._f, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this.__internal$_iterable);
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this.__internal$_iterable);
      }, null, null, 3, 0, null],
      get$first: [function(_) {
        return this._f.call$1(J.get$first$ax(this.__internal$_iterable));
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        return this._f.call$1(J.get$last$ax(this.__internal$_iterable));
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        return this._f.call$1(J.get$single$ax(this.__internal$_iterable));
      }, null, null, 3, 0, null],
      elementAt$1: [function(_, index) {
        return this._f.call$1(J.elementAt$1$ax(this.__internal$_iterable, H.intTypeCheck(index)));
      }, null, "get$elementAt", 5, 0, null, 6],
      $asIterable: function($S, $T) {
        return [$T];
      },
      static: {
        MappedIterable_MappedIterable: [function(iterable, $function, $S, $T) {
          H.assertSubtype(iterable, "$isIterable", [$S], "$asIterable");
          H.functionTypeCheck($function, {func: 1, ret: $T, args: [$S]});
          if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
            return H.EfficientLengthMappedIterable$(iterable, $function, $S, $T);
          return H.MappedIterable$_(iterable, $function, $S, $T);
        }, null, null, 8, 0, null, 13, 64],
        MappedIterable$_: [function(_iterable, _f, $S, $T) {
          return new H.MappedIterable(_iterable, _f, [$S, $T]);
        }, null, null, 8, 0, null, 167, 196]
      }
    },
    EfficientLengthMappedIterable: {
      "^": "MappedIterable;__internal$_iterable,_f,$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      static: {
        EfficientLengthMappedIterable$: [function(iterable, $function, $S, $T) {
          return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
        }, null, null, 8, 0, null, 13, 64]
      }
    },
    MappedIterator: {
      "^": "Iterator;0__internal$_current,_iterator,_f,$ti",
      set$__internal$_current: function(_current) {
        this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
      },
      moveNext$0: [function() {
        var t1 = this._iterator;
        if (t1.moveNext$0()) {
          this.set$__internal$_current(this._f.call$1(t1.get$current()));
          return true;
        }
        this.set$__internal$_current(null);
        return false;
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return this.__internal$_current;
      }, null, null, 2, 0, null],
      $asIterator: function($S, $T) {
        return [$T];
      },
      static: {
        MappedIterator$: [function(_iterator, _f, $S, $T) {
          return new H.MappedIterator(_iterator, _f, [$S, $T]);
        }, null, null, 8, 0, null, 158, 196]
      }
    },
    MappedListIterable: {
      "^": "ListIterable;__internal$_source,_f,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this.__internal$_source);
      }, null, null, 3, 0, null],
      elementAt$1: [function(_, index) {
        return this._f.call$1(J.elementAt$1$ax(this.__internal$_source, H.intTypeCheck(index)));
      }, null, "get$elementAt", 5, 0, null, 6],
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asListIterable: function($S, $T) {
        return [$T];
      },
      $asIterable: function($S, $T) {
        return [$T];
      },
      static: {
        MappedListIterable$: [function(_source, _f, $S, $T) {
          return new H.MappedListIterable(_source, _f, [$S, $T]);
        }, null, null, 8, 0, null, 146, 196]
      }
    },
    WhereIterable: {
      "^": "Iterable;__internal$_iterable,_f,$ti",
      get$iterator: [function(_) {
        return H.WhereIterator$(J.get$iterator$ax(this.__internal$_iterable), this._f, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      map$1$1: [1, function(_, f, $T) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return H.MappedIterable$_(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      static: {
        WhereIterable$: [function(_iterable, _f, $E) {
          return new H.WhereIterable(_iterable, _f, [$E]);
        }, null, null, 8, 0, null, 167, 196]
      }
    },
    WhereIterator: {
      "^": "Iterator;_iterator,_f,$ti",
      moveNext$0: [function() {
        var t1, t2;
        for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
          if (t2.call$1(t1.get$current()))
            return true;
        return false;
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return this._iterator.get$current();
      }, null, null, 2, 0, null],
      static: {
        WhereIterator$: [function(_iterator, _f, $E) {
          return new H.WhereIterator(_iterator, _f, [$E]);
        }, null, null, 8, 0, null, 158, 196]
      }
    },
    ExpandIterable: {
      "^": "Iterable;$ti",
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    ExpandIterator: {
      "^": "Object;$ti",
      $isIterator: 1,
      $asIterator: function($S, $T) {
        return [$T];
      }
    },
    TakeIterable: {
      "^": "Iterable;__internal$_iterable,_takeCount,$ti",
      get$iterator: [function(_) {
        return H.TakeIterator$(J.get$iterator$ax(this.__internal$_iterable), this._takeCount, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      static: {
        TakeIterable_TakeIterable: [function(iterable, takeCount, $E) {
          H.assertSubtype(iterable, "$isIterable", [$E], "$asIterable");
          H.intTypeCheck(takeCount);
          if (typeof takeCount !== "number" || Math.floor(takeCount) !== takeCount || takeCount < 0)
            throw H.wrapException(P.ArgumentError$(takeCount));
          if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
            return H.EfficientLengthTakeIterable$(iterable, takeCount, $E);
          return H.TakeIterable$_(iterable, takeCount, $E);
        }, null, null, 8, 0, null, 13, 399],
        TakeIterable$_: [function(_iterable, _takeCount, $E) {
          return new H.TakeIterable(_iterable, _takeCount, [$E]);
        }, null, null, 8, 0, null, 167, 576]
      }
    },
    EfficientLengthTakeIterable: {
      "^": "TakeIterable;__internal$_iterable,_takeCount,$ti",
      get$length: [function(_) {
        var iterableLength, t1;
        iterableLength = J.get$length$asx(this.__internal$_iterable);
        t1 = this._takeCount;
        if (typeof iterableLength !== "number")
          return iterableLength.$gt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (iterableLength > t1)
          return t1;
        return iterableLength;
      }, null, null, 3, 0, null],
      $isEfficientLengthIterable: 1,
      static: {
        EfficientLengthTakeIterable$: [function(iterable, takeCount, $E) {
          return new H.EfficientLengthTakeIterable(iterable, takeCount, [$E]);
        }, null, null, 8, 0, null, 13, 399]
      }
    },
    TakeIterator: {
      "^": "Iterator;_iterator,_remaining,$ti",
      TakeIterator$2: [function(_iterator, _remaining, $E) {
      }, null, null, 8, 0, null, 158, 412],
      moveNext$0: [function() {
        var t1 = H.intTypeCheck(J.$sub$n(this._remaining, 1));
        this._remaining = t1;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 >= 0)
          return this._iterator.moveNext$0();
        this._remaining = -1;
        return false;
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        if (J.$lt$n(this._remaining, 0))
          return;
        return this._iterator.get$current();
      }, null, null, 2, 0, null],
      static: {
        TakeIterator$: [function(_iterator, _remaining, $E) {
          var t1 = new H.TakeIterator(_iterator, _remaining, [$E]);
          t1.TakeIterator$2(_iterator, _remaining, $E);
          return t1;
        }, null, null, 8, 0, null, 158, 412]
      }
    },
    TakeWhileIterable: {
      "^": "Iterable;$ti"
    },
    TakeWhileIterator: {
      "^": "Iterator;$ti"
    },
    SkipIterable: {
      "^": "Iterable;__internal$_iterable,_skipCount,$ti",
      skip$1: [function(_, count) {
        return H.SkipIterable$_(this.__internal$_iterable, J.$add$ansx(this._skipCount, H._checkCount(H.intTypeCheck(count))), H.getTypeArgumentByIndex(this, 0));
      }, null, "get$skip", 5, 0, null, 42],
      get$iterator: [function(_) {
        return H.SkipIterator$(J.get$iterator$ax(this.__internal$_iterable), this._skipCount, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      static: {
        SkipIterable_SkipIterable: [function(iterable, count, $E) {
          H.assertSubtype(iterable, "$isIterable", [$E], "$asIterable");
          H.intTypeCheck(count);
          if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
            return H.EfficientLengthSkipIterable_EfficientLengthSkipIterable(iterable, count, $E);
          return H.SkipIterable$_(iterable, H._checkCount(count), $E);
        }, null, null, 8, 0, null, 13, 42],
        SkipIterable$_: [function(_iterable, _skipCount, $E) {
          return new H.SkipIterable(_iterable, _skipCount, [$E]);
        }, null, null, 8, 0, null, 167, 343]
      }
    },
    EfficientLengthSkipIterable: {
      "^": "SkipIterable;__internal$_iterable,_skipCount,$ti",
      get$length: [function(_) {
        var $length = J.$sub$n(J.get$length$asx(this.__internal$_iterable), this._skipCount);
        if (typeof $length !== "number")
          return $length.$ge();
        if ($length >= 0)
          return $length;
        return 0;
      }, null, null, 3, 0, null],
      skip$1: [function(_, count) {
        return H.EfficientLengthSkipIterable$_(this.__internal$_iterable, J.$add$ansx(this._skipCount, H._checkCount(H.intTypeCheck(count))), H.getTypeArgumentByIndex(this, 0));
      }, null, "get$skip", 5, 0, null, 42],
      $isEfficientLengthIterable: 1,
      static: {
        EfficientLengthSkipIterable_EfficientLengthSkipIterable: [function(iterable, count, $E) {
          return H.EfficientLengthSkipIterable$_(H.assertSubtype(iterable, "$isIterable", [$E], "$asIterable"), H._checkCount(H.intTypeCheck(count)), $E);
        }, null, null, 8, 0, null, 13, 42],
        EfficientLengthSkipIterable$_: [function(iterable, count, $E) {
          return new H.EfficientLengthSkipIterable(iterable, count, [$E]);
        }, null, null, 8, 0, null, 13, 42]
      }
    },
    SkipIterator: {
      "^": "Iterator;_iterator,_skipCount,$ti",
      SkipIterator$2: [function(_iterator, _skipCount, $E) {
      }, null, null, 8, 0, null, 158, 343],
      moveNext$0: [function() {
        var t1, i, t2;
        t1 = this._iterator;
        i = 0;
        while (true) {
          t2 = this._skipCount;
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.moveNext$0();
          ++i;
        }
        this._skipCount = 0;
        return t1.moveNext$0();
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return this._iterator.get$current();
      }, null, null, 2, 0, null],
      static: {
        SkipIterator$: [function(_iterator, _skipCount, $E) {
          var t1 = new H.SkipIterator(_iterator, _skipCount, [$E]);
          t1.SkipIterator$2(_iterator, _skipCount, $E);
          return t1;
        }, null, null, 8, 0, null, 158, 343]
      }
    },
    SkipWhileIterable: {
      "^": "Iterable;$ti"
    },
    SkipWhileIterator: {
      "^": "Iterator;$ti"
    },
    EmptyIterable: {
      "^": "EfficientLengthIterable;$ti",
      get$iterator: [function(_) {
        return C.C_EmptyIterator;
      }, null, null, 3, 0, null],
      forEach$1: [function(_, action) {
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      }, null, "get$forEach", 5, 0, null, 63],
      get$isEmpty: [function(_) {
        return true;
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return 0;
      }, null, null, 3, 0, null],
      get$first: [function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 3, 0, null],
      elementAt$1: [function(_, index) {
        throw H.wrapException(P.RangeError$range(H.intTypeCheck(index), 0, 0, "index", null));
      }, null, "get$elementAt", 5, 0, null, 6],
      contains$1: [function(_, element) {
        return false;
      }, null, "get$contains", 5, 0, null, 10],
      any$1: [function(_, test) {
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this, 0)]});
        return false;
      }, null, "get$any", 5, 0, null, 41],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      join$1: [function(_, separator) {
        H.stringTypeCheck(separator);
        return "";
      }, null, "get$join", 1, 2, null, 39, 90],
      where$1: [function(_, test) {
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this, 0)]});
        return this;
      }, null, "get$where", 5, 0, null, 41],
      map$1$1: [1, function(_, f, $T) {
        H.functionTypeCheck(f, {func: 1, ret: $T, args: [H.getTypeArgumentByIndex(this, 0)]});
        return H.EmptyIterable$($T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      skip$1: [function(_, count) {
        P.RangeError_checkNotNegative(H.intTypeCheck(count), "count", null);
        return this;
      }, null, "get$skip", 5, 0, null, 42],
      take$1: [function(_, count) {
        P.RangeError_checkNotNegative(H.intTypeCheck(count), "count", null);
        return this;
      }, null, "get$take", 5, 0, null, 42],
      toList$1$growable: [function(_, growable) {
        var t1, t2;
        t1 = this.$ti;
        if (H.boolTypeCheck(growable))
          t1 = H.setRuntimeTypeInfo([], t1);
        else {
          t2 = new Array(0);
          t2.fixed$length = Array;
          t1 = H.setRuntimeTypeInfo(t2, t1);
        }
        return t1;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95],
      static: {
        EmptyIterable$: [function($E) {
          return new H.EmptyIterable([$E]);
        }, null, null, 0, 0, null]
      }
    },
    EmptyIterator: {
      "^": "Object;$ti",
      moveNext$0: [function() {
        return false;
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return;
      }, null, null, 2, 0, null],
      $isIterator: 1
    },
    FollowedByIterable: {
      "^": "Iterable;$ti"
    },
    EfficientLengthFollowedByIterable: {
      "^": "FollowedByIterable;$ti",
      $isEfficientLengthIterable: 1
    },
    FollowedByIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    WhereTypeIterable: {
      "^": "Iterable;$ti"
    },
    WhereTypeIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    IterableElementError: {
      "^": "Object;$ti"
    },
    LinkedList: {
      "^": "IterableBase;$ti"
    },
    LinkedListEntry0: {
      "^": "Object;$ti"
    },
    _LinkedListIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    FixedLengthListMixin: {
      "^": "Object;$ti",
      set$length: [function(receiver, newLength) {
        H.intTypeCheck(newLength);
        throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
      }, null, null, 7, 0, null, 162],
      add$1: [function(receiver, value) {
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0));
        throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
      }, "call$1", "get$add", 5, 0, 2, 1],
      insert$2: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0));
        throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
      }, null, "get$insert", 9, 0, null, 6, 1],
      insertAll$2: [function(receiver, at, iterable) {
        H.intTypeCheck(at);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
      }, null, "get$insertAll", 9, 0, null, 281, 13],
      addAll$1: [function(receiver, iterable) {
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
      }, null, "get$addAll", 5, 0, null, 13],
      remove$1: [function(receiver, element) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
      }, null, "get$remove", 5, 0, null, 10],
      clear$0: [function(receiver) {
        throw H.wrapException(P.UnsupportedError$("Cannot clear a fixed-length list"));
      }, null, "get$clear", 1, 0, null],
      removeAt$1: [function(receiver, index) {
        H.intTypeCheck(index);
        throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
      }, null, "get$removeAt", 5, 0, null, 6],
      removeLast$0: [function(receiver) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
      }, null, "get$removeLast", 1, 0, null],
      replaceRange$3: [function(receiver, start, end, iterable) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 13]
    },
    UnmodifiableListMixin: {
      "^": "Object;$ti",
      $indexSet: [function(_, index, value) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0));
        throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(_, newLength) {
        H.intTypeCheck(newLength);
        throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
      }, null, null, 7, 0, null, 162],
      setAll$2: [function(_, at, iterable) {
        H.intTypeCheck(at);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
      }, null, "get$setAll", 9, 0, null, 281, 13],
      add$1: [function(_, value) {
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0));
        throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
      }, "call$1", "get$add", 5, 0, 2, 1],
      insert$2: [function(_, index, element) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0));
        throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
      }, null, "get$insert", 9, 0, null, 6, 10],
      insertAll$2: [function(_, at, iterable) {
        H.intTypeCheck(at);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
      }, null, "get$insertAll", 9, 0, null, 281, 13],
      addAll$1: [function(_, iterable) {
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
      }, null, "get$addAll", 5, 0, null, 13],
      remove$1: [function(_, element) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
      }, null, "get$remove", 5, 0, null, 10],
      sort$1: [function(_, compare) {
        var t1 = H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0);
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
        throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      clear$0: [function(_) {
        throw H.wrapException(P.UnsupportedError$("Cannot clear an unmodifiable list"));
      }, null, "get$clear", 1, 0, null],
      removeAt$1: [function(_, index) {
        H.intTypeCheck(index);
        throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
      }, null, "get$removeAt", 5, 0, null, 6],
      removeLast$0: [function(_) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
      }, null, "get$removeLast", 1, 0, null],
      setRange$4: [function(_, start, end, iterable, skipCount) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0)], "$asIterable");
        H.intTypeCheck(skipCount);
        throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      replaceRange$3: [function(_, start, end, iterable) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 13],
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1
    },
    FixedLengthListBase: {
      "^": "ListBase;$ti",
      $isFixedLengthListMixin: 1
    },
    UnmodifiableListBase: {
      "^": "ListBase+UnmodifiableListMixin;$ti",
      $isUnmodifiableListMixin: 1
    },
    _ListIndicesIterable: {
      "^": "ListIterable;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asListIterable: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      }
    },
    ListMapView: {
      "^": "UnmodifiableMapBase;$ti",
      $asMapBase: function($E) {
        return [P.int, $E];
      },
      $asMapMixin: function($E) {
        return [P.int, $E];
      },
      $asUnmodifiableMapBase: function($E) {
        return [P.int, $E];
      },
      $as_UnmodifiableMapMixin: function($E) {
        return [P.int, $E];
      },
      $asMap: function($E) {
        return [P.int, $E];
      }
    },
    ReversedListIterable: {
      "^": "ListIterable;__internal$_source,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this.__internal$_source);
      }, null, null, 3, 0, null],
      elementAt$1: [function(_, index) {
        var t1, t2;
        H.intTypeCheck(index);
        t1 = this.__internal$_source;
        t2 = J.getInterceptor$asx(t1);
        return t2.elementAt$1(t1, J.$sub$n(J.$sub$n(t2.get$length(t1), 1), index));
      }, null, "get$elementAt", 5, 0, null, 6],
      static: {
        ReversedListIterable$: [function(_source, $E) {
          return new H.ReversedListIterable(_source, [$E]);
        }, null, null, 4, 0, null, 146]
      }
    },
    UnmodifiableListError: {
      "^": "Object;$ti"
    },
    NonGrowableListError: {
      "^": "Object;$ti"
    },
    Sort: {
      "^": "Object;$ti"
    },
    Symbol: {
      "^": "Object;__internal$_name,$ti",
      get$hashCode: [function(_) {
        var hash, t1;
        hash = this._hashCode;
        if (hash != null)
          return hash;
        t1 = J.get$hashCode$(this.__internal$_name);
        if (typeof t1 !== "number")
          return H.iae(t1);
        hash = 536870911 & 664597 * t1;
        this._hashCode = hash;
        return hash;
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return 'Symbol("' + H.S(this.__internal$_name) + '")';
      }, null, "get$toString", 1, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.Symbol && J.$eq$(this.__internal$_name, other.__internal$_name);
      }, null, "get$==", 5, 0, null, 3],
      $isSymbol0: 1,
      static: {
        Symbol$unvalidated: [function(_name) {
          return new H.Symbol(_name, []);
        }, null, null, 4, 0, null, 293],
        Symbol_getName: [function(symbol) {
          return H.interceptedTypeCheck(symbol, "$isSymbol").__internal$_name;
        }, null, null, 4, 0, null, 289]
      }
    },
    __CastListBase__CastIterableBase_ListMixin: {
      "^": "_CastIterableBase+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $isListMixin: 1,
      $asListMixin: function($S, $T) {
        return [$T];
      },
      $isList: 1,
      $asList: function($S, $T) {
        return [$T];
      }
    }
  }], ["dart._js", "dart:_js",, H, {
    "^": "",
    isBrowserObject: [function(o) {
      var t1 = J.getInterceptor$(o);
      return !!t1.$isBlob || !!t1.$isEvent || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode || !!t1.$isWindow || !!t1.$isWorkerGlobalScope;
    }, null, null, 4, 0, null, 25],
    convertFromBrowserObject: [function(o) {
      return o;
    }, null, null, 4, 0, null, 25]
  }], ["dart2js._embedded_names", "dart:_js_embedded_names",, H, {
    "^": "",
    JsGetName: {
      "^": "Object;$ti"
    },
    JsBuiltin: {
      "^": "Object;$ti"
    }
  }], ["_js_helper", "dart:_js_helper",, H, {
    "^": "",
    ConstantMap__throwUnmodifiable: [function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    }, null, null, 0, 0, null],
    isCheckPropertyToJsConstructorName: [function(isCheckProperty) {
      return H.stringTypeCheck(isCheckProperty).substring(3);
    }, null, null, 4, 0, null, 563],
    isDartFunctionType: [function(type) {
      return 'func' in type;
    }, null, null, 4, 0, null, 29],
    isDartFutureOrType: [function(type) {
      return 'futureOr' in type;
    }, null, null, 4, 0, null, 29],
    isDartVoidTypeRti: [function(type) {
      return type === -1;
    }, null, null, 4, 0, null, 29],
    rawRtiToJsConstructorName: [function(rti) {
      return rti.builtin$cls;
    }, null, null, 4, 0, null, 83],
    unminifyOrTag: [function(rawClassName) {
      var preserved;
      H.stringTypeCheck(rawClassName);
      preserved = H.unmangleGlobalNameIfPreservedAnyways(rawClassName);
      if (typeof preserved === "string")
        return preserved;
      return rawClassName;
    }, null, null, 4, 0, null, 585],
    getRawRuntimeType: [function(o) {
      return o.constructor;
    }, null, null, 4, 0, null, 25],
    builtinIsSubtype: [function(type, other) {
      return '$is' + H.stringTypeCheck(other) in type.prototype;
    }, null, null, 8, 0, null, 29, 3],
    isDartFunctionTypeRti: [function(type) {
      return type.builtin$cls === "Function";
    }, null, null, 4, 0, null, 29],
    isNullType: [function(type) {
      return type.builtin$cls === "Null";
    }, null, null, 4, 0, null, 29],
    isDartDynamicTypeRti: [function(type) {
      return type == null;
    }, null, null, 4, 0, null, 29],
    isDartJsInteropTypeArgumentRti: [function(type) {
      return type === -2;
    }, null, null, 4, 0, null, 29],
    isDartObjectTypeRti: [function(type) {
      return type.builtin$cls === "Object";
    }, null, null, 4, 0, null, 29],
    isNullTypeRti: [function(type) {
      return type.builtin$cls === "Null";
    }, null, null, 4, 0, null, 29],
    getMetadata: [function(index) {
      return init.metadata[H.intTypeCheck(index)];
    }, null, null, 4, 0, null, 6],
    getType: [function(index) {
      return init.types[H.intTypeCheck(index)];
    }, null, null, 4, 0, null, 6],
    requiresPreamble: [function() {
    }, null, null, 0, 0, null],
    isJsIndexable: [function(object, record) {
      var result;
      if (record != null) {
        result = J.dispatchRecordIndexability(record);
        if (result != null)
          return H.boolTypeCheck(result);
      }
      return !!J.getInterceptor$(object).$isJavaScriptIndexingBehavior;
    }, null, null, 8, 0, null, 9, 150],
    S: [function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    }, null, null, 4, 0, null, 1],
    createUnmangledInvocationMirror: [function(symbol, internalName, kind, $arguments, argumentNames, types) {
      return H.JSInvocationMirror$(H.interceptedTypeCheck(symbol, "$isSymbol0"), H.stringTypeCheck(internalName), H.intTypeCheck(kind), H.listTypeCheck($arguments), H.listTypeCheck(argumentNames), H.intTypeCheck(types));
    }, null, null, 24, 0, null, 289, 595, 267, 94, 605, 298],
    Primitives_objectHashCode: [function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    }, null, null, 4, 0, null, 9],
    Primitives_parseInt: [function(source, radix) {
      var match, decimalMatch, maxCharCode, digitsPart, t1, i, characterCode;
      H.stringTypeCheck(source);
      H.intTypeCheck(radix);
      H.checkString(source);
      match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return;
      if (3 >= match.length)
        return H.ioore(match, 3);
      decimalMatch = H.stringTypeCheck(match[3]);
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return;
      }
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i) {
          characterCode = J.$or$n(C.JSString_methods._codeUnitAt$1(digitsPart, i), 32);
          if (typeof characterCode !== "number")
            return characterCode.$gt();
          if (characterCode > maxCharCode)
            return;
        }
      }
      return parseInt(source, radix);
    }, null, null, 8, 0, null, 11, 264],
    Primitives_parseDouble: [function(source) {
      var result, trimmed;
      H.stringTypeCheck(source);
      H.checkString(source);
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return;
      result = parseFloat(source);
      if (H.boolTypeCheck(C.JSNumber_methods.get$isNaN(result))) {
        trimmed = J.trim$0$s(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return;
      }
      return result;
    }, null, null, 4, 0, null, 11],
    Primitives_formatType: [function(className, typeArguments) {
      H.stringTypeCheck(className);
      H.listTypeCheck(typeArguments);
      return H.unmangleAllIdentifiersIfPreservedAnyways(H.S(className) + H.S(H.joinArguments(typeArguments, 0)));
    }, null, null, 8, 0, null, 964, 967],
    Primitives_objectTypeName: [function(object) {
      var className, $arguments;
      className = H.Primitives__objectClassName(object);
      $arguments = H.joinArguments(H.getRuntimeTypeInfo(object), 0);
      return H.S(className) + H.S($arguments);
    }, null, null, 4, 0, null, 9],
    Primitives__objectClassName: [function(object) {
      var interceptor, interceptorConstructor, interceptorConstructorName, $name, t1, dispatchName, objectConstructor, match, decompiledName;
      interceptor = J.getInterceptor$(object);
      interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      t1 = $name == null;
      if (t1 || interceptor === C.Interceptor_methods || !!interceptor.$isUnknownJavaScriptObject) {
        dispatchName = H.constructorNameFallback(object);
        if (t1)
          $name = dispatchName;
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
        }
        return $name;
      }
      $name = $name;
      return H.unminifyOrTag($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36 ? C.JSString_methods.substring$1($name, 1) : $name);
    }, null, null, 4, 0, null, 9],
    Primitives_objectToHumanReadableString: [function(object) {
      return "Instance of '" + H.S(H.Primitives_objectTypeName(object)) + "'";
    }, null, null, 4, 0, null, 9],
    Primitives_dateNow: [function() {
      return Date.now();
    }, "call$0", "_js_helper_Primitives_dateNow$closure", 0, 0, 208],
    Primitives_initTicker: [function() {
      var $window, performance;
      if ($.Primitives_timerFrequency != null)
        return;
      $.Primitives_timerFrequency = 1000;
      $.Primitives_timerTicks = H._js_helper_Primitives_dateNow$closure();
      if (typeof window == "undefined")
        return;
      $window = window;
      if ($window == null)
        return;
      performance = $window.performance;
      if (performance == null)
        return;
      if (typeof performance.now != "function")
        return;
      $.Primitives_timerFrequency = 1000000;
      $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
    }, null, null, 0, 0, null],
    Primitives_currentUri: [function() {
      H.requiresPreamble();
      if (!!self.location)
        return self.location.href;
      return;
    }, null, null, 0, 0, null],
    Primitives__fromCharCodeApply: [function(array) {
      var end, result, i, i0, chunkEnd;
      H.listTypeCheck(array);
      end = J.get$length$asx(array);
      if (typeof end !== "number")
        return end.$le();
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    }, null, null, 4, 0, null, 252],
    Primitives_stringFromCodePoints: [function(codePoints) {
      var a, t1, i;
      a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = J.get$iterator$ax(H.listSuperNativeTypeCheck(codePoints, "$isIterable")); t1.moveNext$0();) {
        i = t1.get$current();
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          C.JSArray_methods.add$1(a, i);
        else if (i <= 1114111) {
          C.JSArray_methods.add$1(a, 55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          C.JSArray_methods.add$1(a, 56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    }, null, null, 4, 0, null, 889],
    Primitives_stringFromCharCodes: [function(charCodes) {
      var t1, i;
      for (H.listSuperNativeTypeCheck(charCodes, "$isIterable"), t1 = J.get$iterator$ax(charCodes); t1.moveNext$0();) {
        i = t1.get$current();
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(H.listTypeCheck(charCodes));
    }, null, null, 4, 0, null, 187],
    Primitives_stringFromNativeUint8List: [function(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      H.interceptedTypeCheck(charCodes, "$isNativeUint8List");
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      if (typeof end !== "number")
        return end.$le();
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      i = start;
      result = "";
      while (true) {
        if (typeof i !== "number")
          return i.$lt();
        if (!(i < end))
          break;
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
        i = i0;
      }
      return result;
    }, null, null, 12, 0, null, 187, 5, 7],
    Primitives_stringFromCharCode: [function(charCode) {
      var bits;
      H.numTypeCheck(charCode);
      if (typeof charCode !== "number")
        return H.iae(charCode);
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    }, null, null, 4, 0, null, 93],
    Primitives_stringConcatUnchecked: [function(string1, string2) {
      return H.stringTypeCheck(string1) + H.stringTypeCheck(string2);
    }, null, null, 8, 0, null, 659, 684],
    Primitives_flattenString: [function(str) {
      H.stringTypeCheck(str);
      return str.charCodeAt(0) == 0 ? str : str;
    }, null, null, 4, 0, null, 82],
    Primitives_valueFromDecomposedDate: [function(years, month, day, hours, minutes, seconds, milliseconds, isUtc) {
      var jsMonth, value;
      H.checkInt(years);
      H.checkInt(month);
      H.checkInt(day);
      H.checkInt(hours);
      H.checkInt(minutes);
      H.checkInt(seconds);
      H.checkInt(milliseconds);
      H.checkBool(isUtc);
      jsMonth = J.$sub$n(month, 1);
      H.numTypeCheck(years);
      if (typeof years !== "number")
        return H.iae(years);
      if (0 <= years && years < 100) {
        years += 400;
        jsMonth = J.$sub$n(jsMonth, 4800);
      }
      value = H.boolTypeCheck(isUtc) ? Date.UTC(years, jsMonth, day, hours, minutes, seconds, milliseconds) : new Date(years, jsMonth, day, hours, minutes, seconds, milliseconds).valueOf();
      if (H.boolTypeCheck(C.JSNumber_methods.get$isNaN(value)) || value < -864e13 || value > 864e13)
        return;
      return value;
    }, null, null, 32, 0, null, 864, 238, 237, 358, 359, 361, 236, 317],
    Primitives_lazyAsJsDate: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      if (receiver.date === void 0)
        receiver.date = new Date(receiver.get$millisecondsSinceEpoch());
      return receiver.date;
    }, null, null, 4, 0, null, 38],
    Primitives_getYear: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
    }, null, null, 4, 0, null, 38],
    Primitives_getMonth: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
    }, null, null, 4, 0, null, 38],
    Primitives_getDay: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
    }, null, null, 4, 0, null, 38],
    Primitives_getHours: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
    }, null, null, 4, 0, null, 38],
    Primitives_getMinutes: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
    }, null, null, 4, 0, null, 38],
    Primitives_getSeconds: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
    }, null, null, 4, 0, null, 38],
    Primitives_getMilliseconds: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
    }, null, null, 4, 0, null, 38],
    Primitives_getWeekday: [function(receiver) {
      H.interceptedTypeCheck(receiver, "$isDateTime");
      return C.JSInt_methods.$mod((receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCDay() + 0 : H.Primitives_lazyAsJsDate(receiver).getDay() + 0) + 6, 7) + 1;
    }, null, null, 4, 0, null, 38],
    Primitives_getProperty: [function(object, key) {
      if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
        throw H.wrapException(H.argumentErrorValue(object));
      return object[key];
    }, null, null, 8, 0, null, 9, 4],
    Primitives_setProperty: [function(object, key, value) {
      if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
        throw H.wrapException(H.argumentErrorValue(object));
      object[key] = value;
    }, null, null, 12, 0, null, 9, 4, 1],
    Primitives_functionNoSuchMethod: [function($function, positionalArguments, namedArguments) {
      var t1, $arguments, namedArgumentList, t2;
      t1 = {};
      H.listTypeCheck(positionalArguments);
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      if (positionalArguments != null) {
        t2 = J.get$length$asx(positionalArguments);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.argumentCount = 0 + t2;
        C.JSArray_methods.addAll$1($arguments, positionalArguments);
      }
      t1.names = "";
      if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
        namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, namedArgumentList, $arguments));
      return J.noSuchMethod$1$($function, H.interceptedTypeCheck(H.createUnmangledInvocationMirror(C.Symbol_call, "call" + "$" + H.S(t1.argumentCount) + H.S(t1.names), 0, $arguments, namedArgumentList, 0), "$isInvocation"));
    }, null, null, 12, 0, null, 64, 153, 157],
    Primitives_applyFunction: [function($function, positionalArguments, namedArguments) {
      H.interceptedTypeCheck($function, "$isFunction");
      H.listTypeCheck(positionalArguments);
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      return namedArguments == null ? H.Primitives_applyFunctionWithPositionalArguments($function, positionalArguments) : H.Primitives_applyFunctionWithNamedArguments($function, positionalArguments, namedArguments);
    }, null, null, 12, 0, null, 64, 153, 157],
    Primitives_applyFunctionWithPositionalArguments: [function($function, positionalArguments) {
      var $arguments, t1;
      H.interceptedTypeCheck($function, "$isFunction");
      H.listTypeCheck(positionalArguments);
      if (positionalArguments != null)
        $arguments = positionalArguments instanceof Array ? positionalArguments : P.List_List$from(positionalArguments, true, null);
      else
        $arguments = [];
      t1 = J.getInterceptor$asx($arguments);
      if (J.$eq$(t1.get$length($arguments), 0)) {
        if (!!$function.call$0)
          return $function.call$0();
      } else if (J.$eq$(t1.get$length($arguments), 1)) {
        if (!!$function.call$1)
          return $function.call$1($arguments[0]);
      } else if (J.$eq$(t1.get$length($arguments), 2)) {
        if (!!$function.call$2)
          return $function.call$2($arguments[0], $arguments[1]);
      } else if (J.$eq$(t1.get$length($arguments), 3)) {
        if (!!$function.call$3)
          return $function.call$3($arguments[0], $arguments[1], $arguments[2]);
      } else if (J.$eq$(t1.get$length($arguments), 4)) {
        if (!!$function.call$4)
          return $function.call$4($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
      } else if (J.$eq$(t1.get$length($arguments), 5))
        if (!!$function.call$5)
          return $function.call$5($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]);
      return H.Primitives__genericApplyFunctionWithPositionalArguments($function, $arguments);
    }, null, null, 8, 0, null, 64, 153],
    Primitives__genericApplyFunctionWithPositionalArguments: [function($function, $arguments) {
      var argumentCount, jsFunction, info, requiredArgumentCount, t1, maxArgumentCount, pos;
      H.interceptedTypeCheck($function, "$isFunction");
      H.listTypeCheck($arguments);
      argumentCount = J.get$length$asx($arguments);
      jsFunction = $function["call" + "$" + H.S(argumentCount)];
      if (jsFunction == null) {
        jsFunction = J.getInterceptor$($function)["call*"];
        if (jsFunction == null)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        info = H.ReflectionInfo_ReflectionInfo(jsFunction);
        requiredArgumentCount = info.requiredParameterCount;
        t1 = info.optionalParameterCount;
        if (typeof requiredArgumentCount !== "number")
          return requiredArgumentCount.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        maxArgumentCount = requiredArgumentCount + t1;
        if (!info.areOptionalParametersNamed) {
          if (typeof argumentCount !== "number")
            return H.iae(argumentCount);
          t1 = requiredArgumentCount > argumentCount || maxArgumentCount < argumentCount;
        } else
          t1 = true;
        if (t1)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        $arguments = P.List_List$from($arguments, true, null);
        t1 = J.getInterceptor$ax($arguments);
        pos = argumentCount;
        while (true) {
          if (typeof pos !== "number")
            return pos.$lt();
          if (!(pos < maxArgumentCount))
            break;
          t1.add$1($arguments, H.getMetadata(info.defaultValue$1(0, pos)));
          ++pos;
        }
      }
      return jsFunction.apply($function, $arguments);
    }, null, null, 8, 0, null, 64, 94],
    Primitives_applyFunctionWithNamedArguments: [function($function, positionalArguments, namedArguments) {
      var _box_0, jsFunction, info, t1, t2, defaultArguments, t3, i, index;
      _box_0 = {};
      H.interceptedTypeCheck($function, "$isFunction");
      H.listTypeCheck(positionalArguments);
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      if (namedArguments.get$isEmpty(namedArguments))
        return H.Primitives_applyFunctionWithPositionalArguments($function, positionalArguments);
      jsFunction = J.getInterceptor$($function)["call*"];
      if (jsFunction == null)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      info = H.ReflectionInfo_ReflectionInfo(jsFunction);
      if (info == null || !info.areOptionalParametersNamed)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      positionalArguments = positionalArguments != null ? P.List_List$from(positionalArguments, true, null) : [];
      t1 = info.requiredParameterCount;
      t2 = J.getInterceptor$asx(positionalArguments);
      if (!J.$eq$(t1, t2.get$length(positionalArguments)))
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      defaultArguments = H.JsLinkedHashMap_JsLinkedHashMap$es6(null, null);
      t3 = info.optionalParameterCount;
      if (typeof t3 !== "number")
        return H.iae(t3);
      i = 0;
      for (; i < t3; ++i) {
        if (typeof t1 !== "number")
          return H.iae(t1);
        index = i + t1;
        defaultArguments.$indexSet(0, info.parameterNameInOrder$1(index), H.getMetadata(info.defaultValueInOrder$1(index)));
      }
      _box_0.bad = false;
      namedArguments.forEach$1(0, new H.Primitives_applyFunctionWithNamedArguments_closure(_box_0, defaultArguments));
      if (_box_0.bad)
        return H.Primitives_functionNoSuchMethod($function, positionalArguments, namedArguments);
      t2.addAll$1(positionalArguments, defaultArguments.get$values(defaultArguments));
      return jsFunction.apply($function, positionalArguments);
    }, null, null, 12, 0, null, 64, 153, 157],
    JsCache_fetch: [function(cache, key) {
      return cache[H.stringTypeCheck(key)];
    }, null, null, 8, 0, null, 879, 4],
    iae: [function(argument) {
      throw H.wrapException(H.argumentErrorValue(argument));
    }, null, null, 4, 0, null, 388],
    ioore: [function(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    }, null, null, 8, 0, null, 38, 6],
    diagnoseIndexError: [function(indexable, index) {
      var $length, t1;
      if (typeof index !== "number" || Math.floor(index) !== index)
        return P.ArgumentError$value(index, "index", null);
      $length = H.intTypeCheck(J.get$length$asx(indexable));
      if (!(index < 0)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = index >= $length;
      } else
        t1 = true;
      if (t1)
        return P.IndexError$(index, indexable, "index", null, $length);
      return P.RangeError$value(index, "index", null);
    }, null, null, 8, 0, null, 389, 6],
    diagnoseRangeError: [function(start, end, $length) {
      var t1;
      if (typeof start !== "number" || Math.floor(start) !== start)
        return P.ArgumentError$value(start, "start", null);
      if (!(start < 0)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = start > $length;
      } else
        t1 = true;
      if (t1)
        return P.RangeError$range(start, 0, H.intTypeCheck($length), "start", null);
      if (end != null) {
        if (typeof end !== "number" || Math.floor(end) !== end)
          return P.ArgumentError$value(end, "end", null);
        if (!(end < start)) {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = end > $length;
        } else
          t1 = true;
        if (t1)
          return P.RangeError$range(end, start, H.intTypeCheck($length), "end", null);
      }
      return P.ArgumentError$value(end, "end", null);
    }, null, null, 12, 0, null, 5, 7, 35],
    stringLastIndexOfUnchecked: [function(receiver, element, start) {
      return receiver.lastIndexOf(element, start);
    }, null, null, 12, 0, null, 38, 10, 5],
    argumentErrorValue: [function(object) {
      return P.ArgumentError$value(object, null, null);
    }, null, null, 4, 0, null, 9],
    checkNull: [function(object) {
      if (object == null)
        throw H.wrapException(H.argumentErrorValue(object));
      return object;
    }, null, null, 4, 0, null, 9],
    checkNum: [function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    }, null, null, 4, 0, null, 1],
    checkInt: [function(value) {
      if (typeof value !== "number" || Math.floor(value) !== value)
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    }, null, null, 4, 0, null, 1],
    checkBool: [function(value) {
      if (typeof value !== "boolean")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    }, null, null, 4, 0, null, 1],
    checkString: [function(value) {
      if (typeof value !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    }, null, null, 4, 0, null, 1],
    wrapException: [function(ex) {
      var wrapper;
      if (ex == null)
        ex = P.NullThrownError$();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    }, null, null, 4, 0, null, 225],
    toStringWrapper: [function() {
      return J.toString$0$(this.dartException);
    }, null, null, 0, 0, null],
    throwExpression: [function(ex) {
      throw H.wrapException(ex);
    }, null, null, 4, 0, null, 225],
    throwConcurrentModificationError: [function(collection) {
      throw H.wrapException(P.ConcurrentModificationError$(collection));
    }, null, null, 4, 0, null, 383],
    unwrapException: [function(ex) {
      var t1, message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match, t2;
      t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
            case 445:
            case 5007:
              return t1.call$1(H.NullError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(H.NullError$(H.stringTypeCheck(message), match));
          }
        }
        return t1.call$1(H.UnknownJsTypeError$(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && H.contains(message, "call stack"))
          return P.StackOverflowError$();
        message = H.tryStringifyException(ex);
        return t1.call$1(P.ArgumentError$(typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return P.StackOverflowError$();
      return ex;
    }, null, null, 4, 0, null, 225],
    tryStringifyException: [function(ex) {
      return function(ex) {
        try {
          return String(ex);
        } catch (e) {
        }
        return null;
      }(ex);
    }, null, null, 4, 0, null, 225],
    getTraceFromException: [function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return H._StackTrace$(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = H._StackTrace$(exception);
    }, null, null, 4, 0, null, 593],
    objectHashCode: [function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    }, null, null, 4, 0, null, 9],
    fillLiteralMap: [function(keyValuePairs, result) {
      var $length, index, index0, index1;
      H.interceptedTypeCheck(result, "$isMap");
      $length = H.getLength(keyValuePairs);
      if (typeof $length !== "number")
        return H.iae($length);
      index = 0;
      for (; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, H.getIndex(keyValuePairs, index), H.getIndex(keyValuePairs, index0));
      }
      return result;
    }, null, null, 8, 0, null, 311, 59],
    invokeClosure: [function(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      H.interceptedTypeCheck(closure, "$isFunction");
      switch (H.intTypeCheck(numberOfArguments)) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    }, null, null, 24, 0, null, 193, 597, 91, 126, 291, 628],
    convertDartClosureToJS: [function(closure, arity) {
      var $function;
      H.intTypeCheck(arity);
      if (closure == null)
        return;
      $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    }, null, null, 8, 0, null, 193, 282],
    Closure_fromTearOff: [function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, propertyName) {
      var $function, callName, functionType, $prototype, $constructor, t1, trampoline, signatureFunction, getReceiver, applyTrampoline, i, t2, stub, stubCallName;
      H.listTypeCheck(functions);
      H.intTypeCheck(applyTrampolineIndex);
      H.boolTypeCheck(isStatic);
      H.boolTypeCheck(isIntercepted);
      H.stringTypeCheck(propertyName);
      $function = functions[0];
      callName = $function.$callName;
      if (!!J.getInterceptor$(reflectionInfo).$isList) {
        $function.$reflectionInfo = reflectionInfo;
        functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
      } else
        functionType = reflectionInfo;
      $prototype = isStatic ? Object.create(H.StaticClosure$().constructor.prototype) : Object.create(H.BoundClosure$(null, null, null, null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function static_tear_off() {
          this.$initialize();
        };
      else if (H.Closure_isCsp()) {
        t1 = function tear_off(a, b, c, d) {
          this.$initialize(a, b, c, d);
        };
        $constructor = t1;
      } else {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ansx(t1, 1);
        t1 = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
        $constructor = t1;
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
      }
      if (typeof functionType == "number")
        signatureFunction = function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getType, functionType);
      else if (typeof functionType == "function")
        if (isStatic)
          signatureFunction = functionType;
        else {
          getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
          signatureFunction = function(f, r) {
            return function() {
              return f.apply({$receiver: r(this)}, arguments);
            };
          }(functionType, getReceiver);
        }
      else
        throw H.wrapException("Error in reflectionInfo.");
      $prototype.$signature = signatureFunction;
      $prototype[callName] = trampoline;
      t1 = J.getInterceptor$asx(functions);
      applyTrampoline = trampoline;
      i = 1;
      while (true) {
        t2 = t1.get$length(functions);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        stub = t1.$index(functions, i);
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          stub = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex) {
          stub.$reflectionInfo = reflectionInfo;
          applyTrampoline = stub;
        }
        ++i;
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    }, null, null, 28, 0, null, 38, 427, 428, 429, 434, 278, 105],
    Closure_cspForwardCall: [function(arity, isSuperCall, stubName, $function) {
      var getSelf;
      H.intTypeCheck(arity);
      H.boolTypeCheck(isSuperCall);
      H.stringTypeCheck(stubName);
      getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    }, null, null, 16, 0, null, 282, 435, 652, 64],
    Closure_isCsp: [function() {
      return false;
    }, null, null, 2, 0, null],
    Closure_forwardCallTo: [function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, selfName, $arguments;
      if (H.boolTypeCheck(isIntercepted))
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      if (H.Closure_isCsp() || !t1 || arity >= 27)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ansx(t1, 1);
        selfName = "self" + H.S(t1);
        return new Function("return function(){var " + selfName + " = this." + H.S(H.BoundClosure_selfFieldName()) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ansx(t1, 1);
      $arguments += H.S(t1);
      return new Function("return function(" + H.S($arguments) + "){return this." + H.S(H.BoundClosure_selfFieldName()) + "." + H.S(stubName) + "(" + H.S($arguments) + ");}")();
    }, null, null, 12, 0, null, 38, 64, 278],
    Closure_cspForwardInterceptedCall: [function(arity, isSuperCall, $name, $function) {
      var getSelf, getReceiver;
      H.intTypeCheck(arity);
      H.boolTypeCheck(isSuperCall);
      H.stringTypeCheck($name);
      getSelf = H.BoundClosure_selfOf;
      getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    }, null, null, 16, 0, null, 282, 435, 8, 64],
    Closure_forwardInterceptedCallTo: [function(receiver, $function) {
      var selfField, receiverField, stubName, arity, lookedUpFunction, t1, t2, $arguments;
      selfField = H.BoundClosure_selfFieldName();
      receiverField = H.BoundClosure_receiverFieldName();
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t2 = !t1 || arity >= 28;
      if (t2)
        return H.Closure_cspForwardInterceptedCall(arity, !t1, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(receiverField) + ");";
        t2 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ansx(t2, 1);
        return new Function(t1 + H.S(t2) + "}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(receiverField) + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ansx(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }, null, null, 8, 0, null, 38, 64],
    closureFromTearOff: [function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, $name) {
      return H.Closure_fromTearOff(receiver, functions, H.intTypeCheck(applyTrampolineIndex), reflectionInfo, !!isStatic, !!isIntercepted, $name);
    }, null, null, 28, 0, null, 38, 427, 428, 429, 434, 278, 8],
    instantiate1: [1, function(f, T1) {
      return H.Instantiation1$(H.interceptedTypeCheck(f, "$isClosure"), T1);
    }, function(f) {
      return H.instantiate1(f, null);
    }, null, "call$1", null, 4, 0, null, 15],
    jsHasOwnProperty: [function(jsObject, property) {
      return jsObject.hasOwnProperty(H.stringTypeCheck(property));
    }, null, null, 8, 0, null, 241, 67],
    jsPropertyAccess: [function(jsObject, property) {
      return jsObject[H.stringTypeCheck(property)];
    }, null, null, 8, 0, null, 241, 67],
    stringTypeCheck: [function(value) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "String"));
    }, null, null, 4, 0, null, 1],
    stringTypeCast: [function(value) {
      if (typeof value === "string" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "String"));
    }, null, null, 4, 0, null, 1],
    doubleTypeCheck: [function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "double"));
    }, null, null, 4, 0, null, 1],
    numTypeCheck: [function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "num"));
    }, null, null, 4, 0, null, 1],
    boolTypeCheck: [function(value) {
      if (value == null)
        return value;
      if (typeof value === "boolean")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "bool"));
    }, null, null, 4, 0, null, 1],
    intTypeCheck: [function(value) {
      if (value == null)
        return value;
      if (typeof value === "number" && Math.floor(value) === value)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "int"));
    }, null, null, 4, 0, null, 1],
    propertyTypeError: [function(value, property) {
      throw H.wrapException(H.TypeErrorImplementation$(value, H.unminifyOrTag(H.isCheckPropertyToJsConstructorName(H.stringTypeCheck(property)))));
    }, null, null, 8, 0, null, 1, 67],
    propertyTypeCastError: [function(value, property) {
      throw H.wrapException(H.CastErrorImplementation$(value, H.unminifyOrTag(H.isCheckPropertyToJsConstructorName(H.stringTypeCheck(property)))));
    }, null, null, 8, 0, null, 1, 67],
    interceptedTypeCheck: [function(value, property) {
      if (value == null)
        return value;
      if ((typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    }, null, null, 8, 0, null, 1, 67],
    interceptedTypeCast: [function(value, property) {
      var t1;
      if (value != null)
        t1 = (typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property];
      else
        t1 = true;
      if (t1)
        return value;
      H.propertyTypeCastError(value, property);
    }, null, null, 8, 0, null, 1, 67],
    numberOrStringSuperNativeTypeCheck: [function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    }, null, null, 8, 0, null, 1, 67],
    stringSuperNativeTypeCheck: [function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    }, null, null, 8, 0, null, 1, 67],
    listTypeCheck: [function(value) {
      if (value == null)
        return value;
      if (!!J.getInterceptor$(value).$isList)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "List<dynamic>"));
    }, null, null, 4, 0, null, 1],
    listSuperNativeTypeCheck: [function(value, property) {
      var t1;
      if (value == null)
        return value;
      t1 = J.getInterceptor$(value);
      if (!!t1.$isList)
        return value;
      if (t1[property])
        return value;
      H.propertyTypeError(value, property);
    }, null, null, 8, 0, null, 1, 67],
    extractFunctionTypeObjectFrom: [function(o) {
      return H.extractFunctionTypeObjectFromInternal(J.getInterceptor$(o));
    }, null, null, 4, 0, null, 25],
    extractFunctionTypeObjectFromInternal: [function(o) {
      var signature;
      if ("$signature" in o) {
        signature = o.$signature;
        if (typeof signature == "number")
          return H.getType(H.intTypeCheck(signature));
        else
          return o.$signature();
      }
      return;
    }, null, null, 4, 0, null, 25],
    functionTypeTest: [function(value, functionTypeRti) {
      var functionTypeObject;
      if (value == null)
        return false;
      if (typeof value == "function")
        return true;
      functionTypeObject = H.extractFunctionTypeObjectFrom(value);
      if (functionTypeObject == null)
        return false;
      return H.isFunctionSubtype(functionTypeObject, functionTypeRti);
    }, null, null, 8, 0, null, 1, 459],
    functionTypeCheck: [function(value, functionTypeRti) {
      var $self, t1;
      if (value == null)
        return value;
      if (true === $._inTypeAssertion)
        return value;
      $._inTypeAssertion = true;
      try {
        if (H.boolTypeCheck(H.functionTypeTest(value, functionTypeRti)))
          return value;
        $self = H.runtimeTypeToString(functionTypeRti);
        t1 = H.TypeErrorImplementation$(value, $self);
        throw H.wrapException(t1);
      } finally {
        $._inTypeAssertion = false;
      }
    }, null, null, 8, 0, null, 1, 459],
    futureOrCheck: [function(o, futureOrRti) {
      return H.assertSubtypeOfRuntimeType(o, futureOrRti);
    }, null, null, 8, 0, null, 25, 914],
    _typeDescription: [function(value) {
      var functionTypeObject;
      if (value instanceof H.Closure) {
        functionTypeObject = H.extractFunctionTypeObjectFrom(value);
        if (functionTypeObject != null)
          return H.runtimeTypeToString(functionTypeObject);
        return "Closure";
      }
      return H.Primitives_objectTypeName(value);
    }, null, null, 4, 0, null, 1],
    throwCyclicInit: [function(staticName) {
      throw H.wrapException(P.CyclicInitializationError$(H.stringTypeCheck(staticName)));
    }, null, null, 4, 0, null, 736],
    jsonEncodeNative: [function(string) {
      return JSON.stringify(H.stringTypeCheck(string));
    }, null, null, 4, 0, null, 30],
    getIsolateAffinityTag: [function($name) {
      return init.getIsolateTag(H.stringTypeCheck($name));
    }, null, null, 4, 0, null, 8],
    registerGlobalObject: [function(object) {
    }, null, null, 4, 0, null, 9],
    createRuntimeType: [function(rti) {
      return H.TypeImpl$(rti);
    }, null, null, 4, 0, null, 83],
    setRuntimeTypeInfo: [function(target, rti) {
      target.$ti = rti;
      return target;
    }, null, null, 8, 0, null, 89, 83],
    getRuntimeTypeInfo: [function(target) {
      if (target == null)
        return;
      return target.$ti;
    }, null, null, 4, 0, null, 89],
    getRuntimeTypeArguments: [function(interceptor, object, substitutionName) {
      return H.substitute(H.getField(interceptor, "$as" + H.S(substitutionName)), H.getRuntimeTypeInfo(object));
    }, null, null, 12, 0, null, 166, 9, 327],
    getRuntimeTypeArgumentIntercepted: [function(interceptor, target, substitutionName, index) {
      var $arguments;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.getRuntimeTypeArguments(interceptor, target, substitutionName);
      return $arguments == null ? null : H.getIndex($arguments, index);
    }, null, null, 16, 0, null, 166, 89, 327, 6],
    getRuntimeTypeArgument: [function(target, substitutionName, index) {
      var $arguments;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.getRuntimeTypeArguments(target, target, substitutionName);
      return $arguments == null ? null : H.getIndex($arguments, index);
    }, null, null, 12, 0, null, 89, 327, 6],
    getTypeArgumentByIndex: [function(target, index) {
      var rti;
      H.intTypeCheck(index);
      rti = H.getRuntimeTypeInfo(target);
      return rti == null ? null : H.getIndex(rti, index);
    }, null, null, 8, 0, null, 89, 6],
    _getRuntimeTypeAsString: [function(rti, genericContext) {
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      return H.S(H.unminifyOrTag(H.rawRtiToJsConstructorName(H.getIndex(rti, 0)))) + H.S(H._joinArguments(rti, 1, genericContext));
    }, null, null, 8, 0, null, 83, 230],
    runtimeTypeToString: [function(rti) {
      return H._runtimeTypeToString(rti, null);
    }, null, null, 4, 0, null, 83],
    _runtimeTypeToString: [function(rti, genericContext) {
      var t1;
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (H.isDartDynamicTypeRti(rti))
        return "dynamic";
      if (H.isDartVoidTypeRti(rti))
        return "void";
      if (H.isJsArray(rti))
        return H._getRuntimeTypeAsString(rti, genericContext);
      if (H.isJsFunction(rti))
        return H.unminifyOrTag(H.rawRtiToJsConstructorName(rti));
      if (H.isDartJsInteropTypeArgumentRti(rti))
        return "dynamic";
      if (H.isGenericFunctionTypeParameter(rti)) {
        H.intTypeCheck(rti);
        if (genericContext != null) {
          if (typeof rti !== "number")
            return rti.$lt();
          if (rti >= 0) {
            t1 = J.get$length$asx(genericContext);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = rti >= t1;
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1)
          return "unexpected-generic-index:" + H.S(rti);
        t1 = J.getInterceptor$asx(genericContext);
        return H.S(t1.$index(genericContext, J.$sub$n(J.$sub$n(t1.get$length(genericContext), rti), 1)));
      }
      if (H.isDartFunctionType(rti))
        return H._functionRtiToString(rti, genericContext);
      if (H.isDartFutureOrType(rti))
        return "FutureOr<" + H.S(H._runtimeTypeToString(H.getFutureOrArgument(rti), genericContext)) + ">";
      return "unknown-reified-type";
    }, null, null, 8, 0, null, 83, 230],
    _functionRtiToString: [function(rti, genericContext) {
      var t1, boundsRti, outerContextLength, offset, i, i0, typeParameters, typeSep, boundRti, returnTypeText, argumentsText, sep, argument, optionalArguments, namedArguments, t2;
      t1 = [P.String];
      H.assertSubtype(genericContext, "$isList", t1, "$asList");
      if (H.boolTypeCheck(H.hasField(rti, "bounds"))) {
        boundsRti = rti.bounds;
        if (genericContext == null) {
          genericContext = H.setRuntimeTypeInfo([], t1);
          outerContextLength = null;
        } else
          outerContextLength = J.get$length$asx(genericContext);
        t1 = J.getInterceptor$asx(genericContext);
        offset = t1.get$length(genericContext);
        for (i = boundsRti.length, i0 = i; i0 > 0; --i0) {
          if (typeof offset !== "number")
            return offset.$add();
          t1.add$1(genericContext, "T" + (offset + i0));
        }
        for (typeParameters = "<", typeSep = "", i0 = 0; i0 < i; ++i0, typeSep = ", ") {
          typeParameters = J.$add$ansx(J.$add$ansx(typeParameters, typeSep), t1.$index(genericContext, J.$sub$n(J.$sub$n(t1.get$length(genericContext), i0), 1)));
          boundRti = boundsRti[i0];
          if (H.isInterestingBound(boundRti))
            typeParameters = J.$add$ansx(typeParameters, C.JSString_methods.$add(" extends ", H._runtimeTypeToString(boundRti, genericContext)));
        }
        typeParameters = J.$add$ansx(typeParameters, ">");
      } else {
        typeParameters = "";
        outerContextLength = null;
      }
      returnTypeText = !!rti.v ? "void" : H._runtimeTypeToString(rti.ret, genericContext);
      if (H.boolTypeCheck(H.hasField(rti, "args")))
        for (t1 = C.JSArray_methods.get$iterator(rti.args), argumentsText = "", sep = ""; t1.moveNext$0(); sep = ", ") {
          argument = t1.get$current();
          argumentsText = J.$add$ansx(J.$add$ansx(argumentsText, sep), H._runtimeTypeToString(argument, genericContext));
        }
      else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText = J.$add$ansx(argumentsText, sep + "[");
        for (t1 = C.JSArray_methods.get$iterator(optionalArguments), sep = ""; t1.moveNext$0(); sep = ", ") {
          argument = t1.get$current();
          argumentsText = J.$add$ansx(J.$add$ansx(argumentsText, sep), H._runtimeTypeToString(argument, genericContext));
        }
        argumentsText = J.$add$ansx(argumentsText, "]");
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText = J.$add$ansx(argumentsText, sep + "{");
        for (t1 = J.get$iterator$ax(H.extractKeys(namedArguments)), sep = ""; t1.moveNext$0(); sep = ", ") {
          t2 = H.stringTypeCheck(t1.get$current());
          argumentsText = J.$add$ansx(J.$add$ansx(J.$add$ansx(argumentsText, sep), H._runtimeTypeToString(namedArguments[t2], genericContext)), " " + H.S(t2));
        }
        argumentsText = J.$add$ansx(argumentsText, "}");
      }
      if (outerContextLength != null)
        genericContext.length = outerContextLength;
      return H.S(typeParameters) + "(" + H.S(argumentsText) + ") => " + H.S(returnTypeText);
    }, null, null, 8, 0, null, 83, 230],
    joinArguments: [function(types, startIndex) {
      return H._joinArguments(types, H.intTypeCheck(startIndex), null);
    }, null, null, 8, 0, null, 298, 76],
    _joinArguments: [function(types, startIndex, genericContext) {
      var buffer, index, separator, allDynamic, t1, argument;
      H.intTypeCheck(startIndex);
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (types == null)
        return "";
      buffer = P.StringBuffer$("");
      index = startIndex;
      separator = "";
      allDynamic = true;
      while (true) {
        t1 = H.getLength(types);
        if (typeof index !== "number")
          return index.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(index < t1))
          break;
        buffer.write$1(separator);
        argument = H.getIndex(types, index);
        if (argument != null)
          allDynamic = false;
        buffer.write$1(H._runtimeTypeToString(argument, genericContext));
        ++index;
        separator = ", ";
      }
      return "<" + H.S(buffer) + ">";
    }, null, null, 12, 0, null, 298, 76, 230],
    getRti: [function(o) {
      var t1, functionRti, type, rti;
      t1 = J.getInterceptor$(o);
      if (!!t1.$isClosure) {
        functionRti = H.extractFunctionTypeObjectFrom(o);
        if (functionRti != null)
          return functionRti;
      }
      type = H.getRawRuntimeType(t1);
      if (o == null)
        return type;
      if (typeof o != "object")
        return type;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return type;
    }, null, null, 4, 0, null, 25],
    getRuntimeType: [function(object) {
      return H.TypeImpl$(H.getRti(object));
    }, null, null, 4, 0, null, 9],
    substitute: [function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      substitution = H.invoke(substitution, $arguments);
      if (substitution == null)
        return;
      if (H.isJsArray(substitution))
        return substitution;
      if (H.isJsFunction(substitution))
        return H.invoke(substitution, $arguments);
      return $arguments;
    }, null, null, 8, 0, null, 523, 94],
    checkSubtype: [function(object, isField, checks, asField) {
      var $arguments, interceptor;
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor$(object);
      if (H.getField(interceptor, isField) == null)
        return false;
      return H.checkArguments(H.getField(interceptor, asField), $arguments, null, checks, null);
    }, null, null, 16, 0, null, 9, 232, 234, 286],
    computeTypeName: [function(isField, $arguments) {
      H.stringTypeCheck(isField);
      H.listTypeCheck($arguments);
      return H.Primitives_formatType(H.unminifyOrTag(H.isCheckPropertyToJsConstructorName(isField)), $arguments);
    }, null, null, 8, 0, null, 232, 94],
    subtypeCast: [function(object, isField, checks, asField) {
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.CastErrorImplementation$(object, H.computeTypeName(isField, checks)));
    }, null, null, 16, 0, null, 9, 232, 234, 286],
    assertSubtype: [function(object, isField, checks, asField) {
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.TypeErrorImplementation$(object, H.computeTypeName(isField, checks)));
    }, null, null, 16, 0, null, 9, 232, 234, 286],
    assertIsSubtype: [function(subtype, supertype, prefix, infix, suffix) {
      H.stringTypeCheck(prefix);
      H.stringTypeCheck(infix);
      H.stringTypeCheck(suffix);
      if (!H.isSubtype(subtype, supertype))
        H.throwTypeError("TypeError: " + H.S(prefix) + H.S(H.runtimeTypeToString(subtype)) + H.S(infix) + H.S(H.runtimeTypeToString(supertype)) + H.S(suffix));
    }, null, null, 20, 0, null, 315, 1021, 1024, 779, 843],
    throwTypeError: [function(message) {
      throw H.wrapException(H.TypeErrorImplementation$fromMessage(H.stringTypeCheck(message)));
    }, null, null, 4, 0, null, 21],
    checkArguments: [function(substitution, $arguments, sEnv, checks, tEnv) {
      return H.areSubtypes(H.substitute(substitution, $arguments), sEnv, checks, tEnv);
    }, null, null, 20, 0, null, 523, 94, 199, 234, 212],
    areSubtypes: [function(s, sEnv, t, tEnv) {
      var len, i;
      if (t == null)
        return true;
      if (s == null) {
        len = H.getLength(t);
        if (typeof len !== "number")
          return H.iae(len);
        i = 0;
        for (; i < len; ++i)
          if (!H._isSubtype(null, null, H.getIndex(t, i), tEnv))
            return false;
        return true;
      }
      len = H.getLength(s);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        if (!H._isSubtype(H.getIndex(s, i), sEnv, H.getIndex(t, i), tEnv))
          return false;
      return true;
    }, null, null, 16, 0, null, 50, 199, 102, 212],
    computeSignature: [function(signature, context, contextName) {
      return H.invokeOn(signature, context, H.getRuntimeTypeArguments(J.getInterceptor$(context), context, contextName));
    }, null, null, 12, 0, null, 657, 202, 675],
    isTopType: [function(type) {
      return H.isDartDynamicTypeRti(type) || H.isDartVoidTypeRti(type) || H.isDartObjectTypeRti(type) || H.isDartJsInteropTypeArgumentRti(type);
    }, null, null, 4, 0, null, 29],
    isSupertypeOfNull: [function(type) {
      return H.isSupertypeOfNullBase(type) || H.isSupertypeOfNullRecursive(type);
    }, null, null, 4, 0, null, 29],
    isSupertypeOfNullBase: [function(type) {
      return H.isDartDynamicTypeRti(type) || H.isDartObjectTypeRti(type) || H.isNullTypeRti(type) || H.isDartVoidTypeRti(type) || H.isDartJsInteropTypeArgumentRti(type);
    }, null, null, 4, 0, null, 29],
    isSupertypeOfNullRecursive: [function(type) {
      var typeArgument;
      if (H.isGenericFunctionTypeParameter(type))
        return false;
      if (H.isDartFutureOrType(type)) {
        typeArgument = H.getFutureOrArgument(type);
        return H.isSupertypeOfNullBase(type) || H.isSupertypeOfNullRecursive(typeArgument);
      }
      return false;
    }, null, null, 4, 0, null, 29],
    getFutureOrArgument: [function(type) {
      return H.boolTypeCheck(H.hasField(type, "type")) ? H.getField(type, "type") : null;
    }, null, null, 4, 0, null, 29],
    checkSubtypeOfRuntimeType: [function(o, t) {
      var type, rti;
      if (o == null)
        return H.isSupertypeOfNull(t);
      if (H.isTopType(t))
        return true;
      if (typeof t == "object") {
        if (H.isDartFutureOrType(t))
          if (H.checkSubtypeOfRuntimeType(o, H.getFutureOrArgument(t)))
            return true;
        if (H.isDartFunctionType(t))
          return H.boolTypeCheck(H.functionTypeTest(o, t));
      }
      type = H.getRawRuntimeType(J.getInterceptor$(o));
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return H.isSubtype(type, t);
    }, null, null, 8, 0, null, 25, 102],
    subtypeOfRuntimeTypeCast: [function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.CastErrorImplementation$(object, H.runtimeTypeToString(type)));
      return object;
    }, null, null, 8, 0, null, 9, 29],
    assertSubtypeOfRuntimeType: [function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.TypeErrorImplementation$(object, H.runtimeTypeToString(type)));
      return object;
    }, null, null, 8, 0, null, 9, 29],
    getArguments: [function(type) {
      return H.isJsArray(type) ? type.slice(1) : null;
    }, null, null, 4, 0, null, 29],
    isSubtype: [function(s, t) {
      return H._isSubtype(s, null, t, null);
    }, null, null, 8, 0, null, 50, 102],
    _isSubtype: [function(s, sEnv, t, tEnv) {
      var typeOfS, tTypeArgument, futureArguments, typeOfT, typeOfTString, substitution;
      if (H.isIdentical(s, t))
        return true;
      if (H.isTopType(t))
        return true;
      if (H.isDartJsInteropTypeArgumentRti(s))
        return true;
      if (H.isTopType(s)) {
        if (H.isGenericFunctionTypeParameter(t))
          return false;
        if (H.isDartFutureOrType(t))
          return H._isSubtype(s, sEnv, H.getFutureOrArgument(t), tEnv);
        return false;
      }
      if (H.isGenericFunctionTypeParameter(s))
        return false;
      if (H.isGenericFunctionTypeParameter(t))
        return false;
      if (H.isNullType(s))
        return true;
      if (H.isDartFunctionType(t))
        return H._isFunctionSubtype(s, sEnv, t, tEnv);
      if (H.isDartFunctionType(s))
        return H.isDartFunctionTypeRti(t);
      typeOfS = H.isJsArray(s) ? H.getIndex(s, 0) : s;
      if (H.isDartFutureOrType(t)) {
        tTypeArgument = H.getFutureOrArgument(t);
        if (H.isDartFutureOrType(s))
          return H._isSubtype(H.getFutureOrArgument(s), sEnv, tTypeArgument, tEnv);
        else if (H._isSubtype(s, sEnv, tTypeArgument, tEnv))
          return true;
        else {
          if (!H.builtinIsSubtype(typeOfS, "Future"))
            return false;
          futureArguments = H.substitute(H.getField(typeOfS.prototype, "$as" + "Future"), H.getArguments(s));
          return H._isSubtype(H.isJsArray(futureArguments) ? H.getIndex(futureArguments, 0) : null, sEnv, tTypeArgument, tEnv);
        }
      }
      typeOfT = H.isJsArray(t) ? H.getIndex(t, 0) : t;
      if (H.isNotIdentical(typeOfT, typeOfS)) {
        typeOfTString = H.rawRtiToJsConstructorName(typeOfT);
        if (!H.builtinIsSubtype(typeOfS, typeOfTString))
          return false;
        substitution = H.getField(typeOfS.prototype, "$as" + H.S(typeOfTString));
      } else
        substitution = null;
      if (!H.isJsArray(t))
        return true;
      return H.checkArguments(substitution, H.getArguments(s), sEnv, H.getArguments(t), tEnv);
    }, null, null, 16, 0, null, 50, 199, 102, 212],
    isFunctionSubtype: [function(s, t) {
      return H._isFunctionSubtype(s, null, t, null);
    }, null, null, 8, 0, null, 50, 102],
    _isFunctionSubtype: [function(s, sEnv, t, tEnv) {
      var sBounds, tBounds, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, tPos, sPos, sNamedParameters, tNamedParameters;
      if (!H.isDartFunctionType(s))
        return false;
      if (H.boolTypeCheck(H.hasField(s, "bounds"))) {
        if (H.boolTypeCheck(H.hasNoField(t, "bounds")))
          return false;
        sBounds = H.getField(s, "bounds");
        tBounds = H.getField(t, "bounds");
        if (H.getLength(sBounds) != H.getLength(tBounds))
          return false;
      } else if (H.boolTypeCheck(H.hasField(t, "bounds")))
        return false;
      if (!H._isSubtype(H.getField(s, "ret"), sEnv, H.getField(t, "ret"), tEnv))
        return false;
      sParameterTypes = H.getField(s, "args");
      tParameterTypes = H.getField(t, "args");
      sOptionalParameterTypes = H.getField(s, "opt");
      tOptionalParameterTypes = H.getField(t, "opt");
      sParametersLen = sParameterTypes != null ? H.getLength(sParameterTypes) : 0;
      tParametersLen = tParameterTypes != null ? H.getLength(tParameterTypes) : 0;
      sOptionalParametersLen = sOptionalParameterTypes != null ? H.getLength(sOptionalParameterTypes) : 0;
      tOptionalParametersLen = tOptionalParameterTypes != null ? H.getLength(tOptionalParameterTypes) : 0;
      if (typeof sParametersLen !== "number")
        return sParametersLen.$gt();
      if (typeof tParametersLen !== "number")
        return H.iae(tParametersLen);
      if (sParametersLen > tParametersLen)
        return false;
      if (typeof sOptionalParametersLen !== "number")
        return H.iae(sOptionalParametersLen);
      if (typeof tOptionalParametersLen !== "number")
        return H.iae(tOptionalParametersLen);
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      for (pos = 0; pos < sParametersLen; ++pos)
        if (!H._isSubtype(H.getIndex(tParameterTypes, pos), tEnv, H.getIndex(sParameterTypes, pos), sEnv))
          return false;
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(H.getIndex(tParameterTypes, tPos), tEnv, H.getIndex(sOptionalParameterTypes, sPos), sEnv))
          return false;
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(H.getIndex(tOptionalParameterTypes, tPos), tEnv, H.getIndex(sOptionalParameterTypes, sPos), sEnv))
          return false;
      sNamedParameters = H.getField(s, "named");
      tNamedParameters = H.getField(t, "named");
      if (tNamedParameters == null)
        return true;
      if (sNamedParameters == null)
        return false;
      return H.namedParametersSubtypeCheck(sNamedParameters, sEnv, tNamedParameters, tEnv);
    }, null, null, 16, 0, null, 50, 199, 102, 212],
    namedParametersSubtypeCheck: [function(s, sEnv, t, tEnv) {
      var names, t1, i, $name;
      names = Object.getOwnPropertyNames(t);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        if (!H._isSubtype(t[$name], tEnv, s[$name], sEnv))
          return false;
      }
      return true;
    }, null, null, 16, 0, null, 50, 199, 102, 212],
    isGenericFunctionTypeParameter: [function(type) {
      return typeof type === "number";
    }, null, null, 4, 0, null, 29],
    instantiatedGenericFunctionType: [function(genericFunctionRti, parameters) {
      if (genericFunctionRti == null)
        return;
      H.getLength(H.getField(genericFunctionRti, "bounds"));
      H.getLength(parameters);
      return H.finishBindInstantiatedFunctionType(genericFunctionRti, {func: 1}, parameters, 0);
    }, null, null, 8, 0, null, 683, 137],
    bindInstantiatedFunctionType: [function(rti, parameters, depth) {
      var result, bounds, t1;
      H.intTypeCheck(depth);
      result = {func: 1};
      if (H.boolTypeCheck(H.hasField(rti, "bounds"))) {
        bounds = H.getField(rti, "bounds");
        t1 = H.getLength(bounds);
        if (typeof depth !== "number")
          return depth.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        depth += t1;
        H.setField(result, "bounds", H.bindInstantiatedTypes(bounds, parameters, depth));
      }
      return H.finishBindInstantiatedFunctionType(rti, result, parameters, depth);
    }, null, null, 12, 0, null, 83, 137, 161],
    finishBindInstantiatedFunctionType: [function(rti, result, parameters, depth) {
      var namedParameters, boundNamed, t1, $name;
      H.intTypeCheck(depth);
      if (H.boolTypeCheck(H.hasField(rti, "v")))
        H.setField(result, "v", H.getField(rti, "v"));
      else if (H.boolTypeCheck(H.hasField(rti, "ret")))
        H.setField(result, "ret", H.bindInstantiatedType(H.getField(rti, "ret"), parameters, depth));
      if (H.boolTypeCheck(H.hasField(rti, "args")))
        H.setField(result, "args", H.bindInstantiatedTypes(H.getField(rti, "args"), parameters, depth));
      if (H.boolTypeCheck(H.hasField(rti, "opt")))
        H.setField(result, "opt", H.bindInstantiatedTypes(H.getField(rti, "opt"), parameters, depth));
      if (H.boolTypeCheck(H.hasField(rti, "named"))) {
        namedParameters = H.getField(rti, "named");
        boundNamed = {};
        for (t1 = C.JSArray_methods.get$iterator(Object.keys(namedParameters)); t1.moveNext$0();) {
          $name = H.stringTypeCheck(t1.get$current());
          H.setField(boundNamed, $name, H.bindInstantiatedType(H.getField(namedParameters, $name), parameters, depth));
        }
        H.setField(result, "named", boundNamed);
      }
      return result;
    }, null, null, 16, 0, null, 83, 59, 137, 161],
    bindInstantiatedType: [function(rti, parameters, depth) {
      var t1;
      H.intTypeCheck(depth);
      if (H.isDartDynamicTypeRti(rti))
        return rti;
      if (H.isDartVoidTypeRti(rti))
        return rti;
      if (H.isJsFunction(rti))
        return rti;
      if (H.isGenericFunctionTypeParameter(rti)) {
        t1 = J.getInterceptor$n(rti);
        if (H.boolTypeCheck(t1.$lt(rti, depth)))
          return rti;
        return parameters[t1.$sub(rti, depth)];
      }
      if (typeof rti === "number")
        return rti;
      if (H.isJsArray(rti))
        return H.bindInstantiatedTypes(rti, parameters, depth);
      if (H.isDartFunctionType(rti))
        return H.bindInstantiatedFunctionType(rti, parameters, depth);
      throw H.wrapException(P.ArgumentError$("Unknown RTI format in bindInstantiatedType."));
    }, null, null, 12, 0, null, 83, 137, 161],
    bindInstantiatedTypes: [function(rti, parameters, depth) {
      var array, t1, i;
      H.intTypeCheck(depth);
      array = rti.slice();
      for (t1 = array.length, i = 0; i < t1; ++i)
        C.JSArray_methods.$indexSet(array, i, H.bindInstantiatedType(array[i], parameters, depth));
      return array;
    }, null, null, 12, 0, null, 83, 137, 161],
    invoke: [function($function, $arguments) {
      return H.invokeOn($function, null, $arguments);
    }, null, null, 8, 0, null, 64, 94],
    invokeOn: [function($function, receiver, $arguments) {
      return $function.apply(receiver, $arguments);
    }, null, null, 12, 0, null, 64, 38, 94],
    getField: [function(object, $name) {
      return object[H.stringTypeCheck($name)];
    }, null, null, 8, 0, null, 9, 8],
    getIndex: [function(array, index) {
      return array[H.intTypeCheck(index)];
    }, null, null, 8, 0, null, 252, 6],
    setField: [function(object, $name, value) {
      object[H.stringTypeCheck($name)] = value;
    }, null, null, 12, 0, null, 9, 8, 1],
    getLength: [function(array) {
      return array.length;
    }, null, null, 4, 0, null, 252],
    isJsArray: [function(value) {
      return typeof value === "object" && value !== null && value.constructor === Array;
    }, null, null, 4, 0, null, 1],
    hasField: [function(object, $name) {
      return $name in object;
    }, null, null, 8, 0, null, 9, 8],
    hasNoField: [function(object, $name) {
      return !H.boolTypeCheck(H.hasField(object, $name));
    }, null, null, 8, 0, null, 9, 8],
    isJsFunction: [function(o) {
      return typeof o == "function";
    }, null, null, 4, 0, null, 25],
    isIdentical: [function(s, t) {
      return s === t;
    }, null, null, 8, 0, null, 50, 102],
    isNotIdentical: [function(s, t) {
      return s !== t;
    }, null, null, 8, 0, null, 50, 102],
    isInterestingBound: [function(rti) {
      return rti != null && H.isNotIdentical(rti, P.Object);
    }, null, null, 4, 0, null, 83],
    contains: [function(userAgent, $name) {
      return H.stringTypeCheck(userAgent).indexOf(H.stringTypeCheck($name)) !== -1;
    }, null, null, 8, 0, null, 883, 8],
    propertyGet: [function(object, property) {
      return object[H.stringTypeCheck(property)];
    }, null, null, 8, 0, null, 9, 67],
    propertySet: [function(object, property, value) {
      object[H.stringTypeCheck(property)] = value;
    }, null, null, 12, 0, null, 9, 67, 1],
    defineProperty: [function(obj, property, value) {
      Object.defineProperty(obj, H.stringTypeCheck(property), {value: value, enumerable: false, writable: true, configurable: true});
    }, null, null, 12, 0, null, 85, 67, 1],
    interceptorsByTag: [function() {
      return init.interceptorsByTag;
    }, null, null, 2, 0, null],
    leafTags: [function() {
      return init.leafTags;
    }, null, null, 2, 0, null],
    lookupInterceptor: [function(tag) {
      H.stringTypeCheck(tag);
      return H.propertyGet(H.interceptorsByTag(), tag);
    }, null, null, 4, 0, null, 109],
    lookupAndCacheInterceptor: [function(obj) {
      var tag, record, interceptor, interceptorClass, mark;
      tag = H.stringTypeCheck($.getTagFunction.call$1(obj));
      record = H.propertyGet($.dispatchRecordsForInstanceTags, tag);
      if (record != null)
        return H.patchInstance(obj, record);
      interceptor = H.propertyGet($.interceptorsForUncacheableTags, tag);
      if (interceptor != null)
        return interceptor;
      interceptorClass = H.lookupInterceptor(tag);
      if (interceptorClass == null) {
        tag = H.stringTypeCheck($.alternateTagFunction.call$2(obj, tag));
        if (tag != null) {
          record = H.propertyGet($.dispatchRecordsForInstanceTags, tag);
          if (record != null)
            return H.patchInstance(obj, record);
          interceptor = H.propertyGet($.interceptorsForUncacheableTags, tag);
          if (interceptor != null)
            return interceptor;
          interceptorClass = H.lookupInterceptor(tag);
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        H.propertySet($.dispatchRecordsForInstanceTags, tag, record);
        return H.patchInstance(obj, record);
      }
      if (mark === "~") {
        H.propertySet($.interceptorsForUncacheableTags, tag, interceptor);
        return interceptor;
      }
      if (mark === "-")
        return H.patchProto(obj, H.makeLeafDispatchRecord(interceptor));
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(P.UnimplementedError$(tag));
      if (H.leafTags()[tag] === true)
        return H.patchProto(obj, H.makeLeafDispatchRecord(interceptor));
      else
        return H.patchInteriorProto(obj, interceptor);
    }, null, null, 4, 0, null, 85],
    patchInstance: [function(obj, record) {
      J.setDispatchProperty(obj, record);
      return J.dispatchRecordInterceptor(record);
    }, null, null, 8, 0, null, 85, 150],
    patchProto: [function(obj, record) {
      J.setDispatchProperty(Object.getPrototypeOf(obj), record);
      return J.dispatchRecordInterceptor(record);
    }, null, null, 8, 0, null, 85, 150],
    patchInteriorProto: [function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      J.setDispatchProperty(proto, J.makeDispatchRecord(interceptor, proto, null, null));
      return interceptor;
    }, null, null, 8, 0, null, 85, 166],
    makeLeafDispatchRecord: [function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    }, null, null, 4, 0, null, 166],
    makeDefaultDispatchRecord: [function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (H.leafTags()[tag] === true)
        return H.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    }, null, null, 12, 0, null, 109, 554, 417],
    constructorNameFallback: [function(object) {
      return C.JS_CONST_u2C(object);
    }, null, null, 4, 0, null, 9],
    initNativeDispatch: [function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    }, null, null, 0, 0, null],
    initNativeDispatchContinue: [function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = H.interceptorsByTag();
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              J.setDispatchProperty(proto, record);
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = H.propertyGet(map, tag);
          H.propertySet(map, "!" + tag, interceptorClass);
          H.propertySet(map, "~" + tag, interceptorClass);
          H.propertySet(map, "-" + tag, interceptorClass);
          H.propertySet(map, "+" + tag, interceptorClass);
          H.propertySet(map, "*" + tag, interceptorClass);
        }
      }
    }, null, null, 0, 0, null],
    initHooks: [function() {
      var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
      hooks = C.JS_CONST_bDt();
      hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_u2C), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = H.applyHooksTransformer(transformer, hooks);
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    }, null, null, 0, 0, null],
    applyHooksTransformer: [function(transformer, hooks) {
      return transformer(hooks) || hooks;
    }, null, null, 8, 0, null, 592, 596],
    regExpGetNative: [function(regexp) {
      return H.interceptedTypeCheck(regexp, "$isJSSyntaxRegExp")._nativeRegExp;
    }, null, null, 4, 0, null, 251],
    regExpGetGlobalNative: [function(regexp) {
      var nativeRegexp = H.interceptedTypeCheck(regexp, "$isJSSyntaxRegExp").get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      return nativeRegexp;
    }, null, null, 4, 0, null, 251],
    regExpCaptureCount: [function(regexp) {
      return H.interceptedTypeCheck(regexp, "$isJSSyntaxRegExp").get$_nativeAnchoredVersion().exec("").length - 2;
    }, null, null, 4, 0, null, 251],
    firstMatchAfter: [function(regExp, string, start) {
      return H.interceptedTypeCheck(regExp, "$isJSSyntaxRegExp")._execGlobal$2(H.stringTypeCheck(string), H.intTypeCheck(start));
    }, null, null, 12, 0, null, 685, 30, 5],
    stringIndexOfStringUnchecked: [function(receiver, other, startIndex) {
      return receiver.indexOf(other, startIndex);
    }, null, null, 12, 0, null, 38, 3, 76],
    stringContainsStringUnchecked: [function(receiver, other, startIndex) {
      return J.$ge$n(H.stringIndexOfStringUnchecked(receiver, other, startIndex), 0);
    }, null, null, 12, 0, null, 38, 3, 76],
    stringSplitUnchecked: [function(receiver, pattern) {
      return J.JSArray_JSArray$markGrowable(H.stringTypeCheck(receiver).split(pattern), P.String);
    }, null, null, 8, 0, null, 38, 36],
    allMatchesInStringUnchecked: [function(pattern, string, startIndex) {
      H.stringTypeCheck(pattern);
      return H._StringAllMatchesIterable$(H.stringTypeCheck(string), pattern, H.intTypeCheck(startIndex));
    }, null, null, 12, 0, null, 36, 30, 76],
    stringContainsUnchecked: [function(receiver, other, startIndex) {
      var t1, t2;
      if (typeof other === "string")
        return H.stringContainsStringUnchecked(receiver, other, startIndex);
      else {
        t1 = J.getInterceptor$(other);
        t2 = J.getInterceptor$s(receiver);
        if (!!t1.$isJSSyntaxRegExp)
          return other.hasMatch$1(H.stringTypeCheck(t2.substring$1(receiver, startIndex)));
        else
          return J.get$isNotEmpty$asx(t1.allMatches$1(other, t2.substring$1(receiver, startIndex)));
      }
    }, null, null, 12, 0, null, 38, 3, 76],
    stringReplaceJS: [function(receiver, replacer, replacement) {
      return receiver.replace(replacer, replacement.replace(/\$/g, "$$$$"));
    }, null, null, 12, 0, null, 38, 787, 115],
    stringReplaceFirstRE: [function(receiver, regexp, replacement, startIndex) {
      var match, start, end;
      match = regexp._execGlobal$2(receiver, startIndex);
      if (match == null)
        return receiver;
      start = J.get$start$x(match);
      end = match.get$end();
      return H.stringReplaceRangeUnchecked(H.stringTypeCheck(receiver), H.intTypeCheck(start), H.intTypeCheck(end), H.stringTypeCheck(replacement));
    }, null, null, 16, 0, null, 38, 251, 115, 76],
    quoteStringForRegExp: [function(string) {
      return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
    }, null, null, 4, 0, null, 30],
    stringReplaceAllUnchecked: [function(receiver, pattern, replacement) {
      var t1, result, $length, i;
      H.checkString(replacement);
      if (typeof pattern === "string")
        if (pattern === "") {
          t1 = J.getInterceptor$(receiver);
          if (t1.$eq(receiver, ""))
            return replacement;
          else {
            result = P.StringBuffer$("");
            $length = H.intTypeCheck(t1.get$length(receiver));
            result.write$1(replacement);
            if (typeof $length !== "number")
              return H.iae($length);
            i = 0;
            for (; i < $length; ++i) {
              result.write$1(t1.$index(receiver, i));
              result.write$1(replacement);
            }
            return result.toString$0(0);
          }
        } else
          return H.stringReplaceJS(receiver, new RegExp(H.quoteStringForRegExp(pattern), 'g'), replacement);
      else if (pattern instanceof H.JSSyntaxRegExp)
        return H.stringReplaceJS(receiver, H.regExpGetGlobalNative(pattern), replacement);
      else {
        H.checkNull(pattern);
        throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
      }
    }, null, null, 12, 0, null, 38, 36, 115],
    _matchString: [function(match) {
      return H.interceptedTypeCheck(match, "$isMatch").$index(0, 0);
    }, "call$1", "_js_helper___matchString$closure", 4, 0, 38, 148],
    _stringIdentity: [function(string) {
      return H.stringTypeCheck(string);
    }, "call$1", "_js_helper___stringIdentity$closure", 4, 0, 7, 30],
    stringReplaceAllFuncUnchecked: [function(receiver, pattern, onMatch, onNonMatch) {
      var t1, buffer, t2, startIndex, t3;
      if (onMatch == null)
        onMatch = H._js_helper___matchString$closure();
      if (onNonMatch == null)
        onNonMatch = H._js_helper___stringIdentity$closure();
      if (typeof pattern === "string")
        return H.stringReplaceAllStringFuncUnchecked(receiver, pattern, onMatch, onNonMatch);
      t1 = J.getInterceptor$(pattern);
      if (!t1.$isPattern)
        throw H.wrapException(P.ArgumentError$value(pattern, "pattern", "is not a Pattern"));
      buffer = P.StringBuffer$("");
      for (t1 = J.get$iterator$ax(H.listSuperNativeTypeCheck(t1.allMatches$1(pattern, receiver), "$isIterable")), t2 = J.getInterceptor$s(receiver), startIndex = 0; t1.moveNext$0();) {
        t3 = H.interceptedTypeCheck(t1.get$current(), "$isMatch");
        buffer.write$1(onNonMatch.call$1(t2.substring$2(receiver, startIndex, t3.get$start(t3))));
        buffer.write$1(onMatch.call$1(t3));
        startIndex = t3.get$end();
      }
      buffer.write$1(onNonMatch.call$1(t2.substring$1(receiver, startIndex)));
      return buffer.toString$0(0);
    }, null, null, 16, 0, null, 38, 36, 270, 269],
    stringReplaceAllEmptyFuncUnchecked: [function(receiver, onMatch, onNonMatch) {
      var buffer, t1, $length, i, code, i0;
      buffer = P.StringBuffer$("");
      t1 = J.getInterceptor$asx(receiver);
      $length = H.intTypeCheck(t1.get$length(receiver));
      buffer.write$1(onNonMatch.call$1(""));
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length;) {
        H.stringTypeCheck(receiver);
        buffer.write$1(onMatch.call$1(H.StringMatch$(i, receiver, "")));
        code = H.intTypeCheck(t1._codeUnitAt$1(receiver, i));
        if (typeof code !== "number")
          return code.$and();
        if ((code & 4294966272) >>> 0 === 55296 && $length > i + 1) {
          code = H.intTypeCheck(C.JSString_methods._codeUnitAt$1(receiver, i + 1));
          if (typeof code !== "number")
            return code.$and();
          if ((code & 4294966272) >>> 0 === 56320) {
            i0 = i + 2;
            buffer.write$1(onNonMatch.call$1(C.JSString_methods.substring$2(receiver, i, i0)));
            i = i0;
            continue;
          }
        }
        if (i >= receiver.length)
          return H.ioore(receiver, i);
        buffer.write$1(onNonMatch.call$1(receiver[i]));
        ++i;
      }
      buffer.write$1(onMatch.call$1(H.StringMatch$(i, H.stringTypeCheck(receiver), "")));
      buffer.write$1(onNonMatch.call$1(""));
      return buffer.toString$0(0);
    }, null, null, 12, 0, null, 38, 270, 269],
    stringReplaceAllStringFuncUnchecked: [function(receiver, pattern, onMatch, onNonMatch) {
      var patternLength, t1, $length, buffer, startIndex, position;
      patternLength = H.intTypeCheck(J.get$length$asx(pattern));
      if (patternLength === 0)
        return H.stringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch);
      t1 = J.getInterceptor$asx(receiver);
      $length = H.intTypeCheck(t1.get$length(receiver));
      buffer = P.StringBuffer$("");
      if (typeof $length !== "number")
        return H.iae($length);
      startIndex = 0;
      for (; startIndex < $length;) {
        position = H.intTypeCheck(H.stringIndexOfStringUnchecked(receiver, pattern, startIndex));
        if (position === -1)
          break;
        buffer.write$1(onNonMatch.call$1(t1.substring$2(receiver, startIndex, position)));
        buffer.write$1(onMatch.call$1(H.StringMatch$(position, H.stringTypeCheck(receiver), H.stringTypeCheck(pattern))));
        if (typeof position !== "number")
          return position.$add();
        if (typeof patternLength !== "number")
          return H.iae(patternLength);
        startIndex = position + patternLength;
      }
      buffer.write$1(onNonMatch.call$1(t1.substring$1(receiver, startIndex)));
      return buffer.toString$0(0);
    }, null, null, 16, 0, null, 38, 36, 270, 269],
    stringReplaceFirstUnchecked: [function(receiver, pattern, replacement, startIndex) {
      var index, t1, matches, match;
      H.intTypeCheck(startIndex);
      if (typeof pattern === "string") {
        index = H.intTypeCheck(H.stringIndexOfStringUnchecked(receiver, pattern, startIndex));
        if (typeof index !== "number")
          return index.$lt();
        if (index < 0)
          return receiver;
        t1 = pattern.length;
        return H.stringReplaceRangeUnchecked(H.stringTypeCheck(receiver), index, index + t1, H.stringTypeCheck(replacement));
      }
      t1 = J.getInterceptor$(pattern);
      if (!!t1.$isJSSyntaxRegExp)
        return startIndex === 0 ? H.stringReplaceJS(receiver, H.regExpGetNative(pattern), replacement) : H.stringReplaceFirstRE(receiver, pattern, replacement, startIndex);
      H.checkNull(pattern);
      matches = H.assertSubtype(J.get$iterator$ax(t1.allMatches$2(pattern, receiver, startIndex)), "$isIterator", [P.Match], "$asIterator");
      if (!matches.moveNext$0())
        return receiver;
      match = matches.get$current();
      return J.replaceRange$3$asx(receiver, match.get$start(match), match.get$end(), replacement);
    }, null, null, 16, 0, null, 38, 36, 115, 76],
    stringReplaceRangeUnchecked: [function(receiver, start, end, replacement) {
      var prefix, suffix;
      H.stringTypeCheck(receiver);
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      H.stringTypeCheck(replacement);
      prefix = receiver.substring(0, start);
      suffix = receiver.substring(end);
      return prefix + H.S(replacement) + suffix;
    }, null, null, 16, 0, null, 38, 5, 7, 115],
    NoSideEffects: {
      "^": "Object;$ti"
    },
    NoThrows: {
      "^": "Object;$ti"
    },
    NoInline: {
      "^": "Object;$ti"
    },
    ForceInline: {
      "^": "Object;$ti"
    },
    Native: {
      "^": "Object;$ti"
    },
    _Patch: {
      "^": "Object;$ti"
    },
    ConstantMapView: {
      "^": "UnmodifiableMapView;_collection$_map,$ti",
      $isConstantMap: 1,
      static: {
        ConstantMapView$: [function(base, $K, $V) {
          return new H.ConstantMapView(base, [$K, $V]);
        }, null, null, 4, 0, null, 280]
      }
    },
    ConstantMap: {
      "^": "Object;$ti",
      cast$2$0: [1, function(_, RK, RV) {
        return P.Map_castFrom(this, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1), RK, RV);
      }, function($receiver) {
        return this.cast$2$0($receiver, null, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return P.MapBase_mapToString(this);
      }, null, "get$toString", 1, 0, null],
      $indexSet: [function(_, key, val) {
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtypeOfRuntimeType(val, H.getTypeArgumentByIndex(this, 1));
        return H.ConstantMap__throwUnmodifiable();
      }, null, "get$[]=", 9, 0, null, 4, 859],
      putIfAbsent$2: [function(key, ifAbsent) {
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(this, 1)});
        return H.ConstantMap__throwUnmodifiable();
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      remove$1: [function(_, key) {
        return H.ConstantMap__throwUnmodifiable();
      }, null, "get$remove", 5, 0, null, 4],
      clear$0: [function(_) {
        return H.ConstantMap__throwUnmodifiable();
      }, null, "get$clear", 1, 0, null],
      addAll$1: [function(_, other) {
        H.assertSubtype(other, "$isMap", this.$ti, "$asMap");
        return H.ConstantMap__throwUnmodifiable();
      }, null, "get$addAll", 5, 0, null, 3],
      get$entries: [function(_) {
        return this.entries$body$ConstantMap(_, [P.MapEntry, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]);
      }, null, null, 3, 0, null],
      entries$body$ConstantMap: [function($async$_, $async$type) {
        var $async$self = this;
        return P._makeSyncStarIterable(function() {
          var _ = $async$_;
          var $async$goto = 0, $async$handler = 1, $async$currentError, t1, t2, t3, key;
          return function $async$get$entries($async$errorCode, $async$result) {
            if ($async$errorCode === 1) {
              $async$currentError = $async$result;
              $async$goto = $async$handler;
            }
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  t1 = J.get$iterator$ax($async$self.get$keys()), t2 = H.getTypeArgumentByIndex($async$self, 0), t3 = H.getTypeArgumentByIndex($async$self, 1);
                case 2:
                  // for condition
                  if (!t1.moveNext$0()) {
                    // goto after for
                    $async$goto = 3;
                    break;
                  }
                  key = t1.get$current();
                  $async$goto = 4;
                  return P.MapEntry$_(key, $async$self.$index(0, key), t2, t3);
                case 4:
                  // after yield
                  // goto for condition
                  $async$goto = 2;
                  break;
                case 3:
                  // after for
                  // implicit return
                  return P._IterationMarker_endOfIteration();
                case 1:
                  // rethrow
                  return P._IterationMarker_uncaughtError($async$currentError);
              }
          };
        }, $async$type);
      }, null, null, 1, 0, null],
      map$2$1: [1, function(_, transform, K2, V2) {
        var result;
        H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]});
        result = P.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
        this.forEach$1(0, new H.ConstantMap_map_closure(this, transform, result));
        return result;
      }, function($receiver, transform) {
        return this.map$2$1($receiver, transform, null, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 204],
      $isMap: 1
    },
    ConstantMap_map_closure: {
      "^": "Closure;$this,transform,result,$ti",
      call$2: [function(key, value) {
        var t1, entry;
        t1 = this.$this;
        entry = this.transform.call$2(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
        J.$indexSet$ax(this.result, entry.key, entry.value);
      }, null, null, 8, 0, null, 4, 1, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
      }
    },
    ConstantStringMap: {
      "^": "ConstantMap;__js_helper$_length<,_jsObject,__js_helper$_keys,$ti",
      get$length: [function(_) {
        return this.__js_helper$_length;
      }, null, null, 3, 0, null],
      get$_keysArray: [function() {
        return this.__js_helper$_keys;
      }, null, null, 2, 0, null],
      containsKey$1: [function(key) {
        if (typeof key !== "string")
          return false;
        if ("__proto__" === key)
          return false;
        return H.jsHasOwnProperty(this._jsObject, key);
      }, null, "get$containsKey", 4, 0, null, 4],
      $index: [function(_, key) {
        if (!this.containsKey$1(key))
          return;
        return this._fetch$1(key);
      }, null, "get$[]", 5, 0, null, 4],
      _fetch$1: [function(key) {
        return H.jsPropertyAccess(this._jsObject, H.stringTypeCheck(key));
      }, null, "get$_fetch", 4, 0, null, 4],
      forEach$1: [function(_, f) {
        var t1, keys, t2, i, t3, key;
        t1 = H.getTypeArgumentByIndex(this, 1);
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), t1]});
        keys = this.get$_keysArray();
        t2 = J.getInterceptor$asx(keys);
        i = 0;
        while (true) {
          t3 = t2.get$length(keys);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          key = t2.$index(keys, i);
          f.call$2(key, H.assertSubtypeOfRuntimeType(this._fetch$1(key), t1));
          ++i;
        }
      }, null, "get$forEach", 5, 0, null, 15],
      get$keys: [function() {
        return H._ConstantMapKeyIterable$(this, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 2, 0, null],
      get$values: [function(_) {
        return H.MappedIterable_MappedIterable(this.get$_keysArray(), new H.ConstantStringMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null]
    },
    ConstantStringMap_values_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(key) {
        var t1 = this.$this;
        return H.assertSubtypeOfRuntimeType(t1._fetch$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0))), H.getTypeArgumentByIndex(t1, 1));
      }, null, null, 4, 0, null, 4, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
      }
    },
    ConstantProtoMap: {
      "^": "ConstantStringMap;$ti"
    },
    _ConstantMapKeyIterable: {
      "^": "Iterable;_map,$ti",
      get$iterator: [function(_) {
        return J.get$iterator$ax(this._map.get$_keysArray());
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this._map.get$_keysArray());
      }, null, null, 3, 0, null],
      static: {
        _ConstantMapKeyIterable$: [function(_map, $K) {
          return new H._ConstantMapKeyIterable(_map, [$K]);
        }, null, null, 4, 0, null, 141]
      }
    },
    GeneralConstantMap: {
      "^": "ConstantMap;_jsData,$ti",
      _getMap$0: [function() {
        var backingMap = this.$map;
        if (backingMap == null) {
          backingMap = H.JsLinkedHashMap$(H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
          H.fillLiteralMap(this._jsData, backingMap);
          this.$map = backingMap;
        }
        return backingMap;
      }, null, "get$_getMap", 0, 0, null],
      containsKey$1: [function(key) {
        return this._getMap$0().containsKey$1(key);
      }, null, "get$containsKey", 4, 0, null, 4],
      $index: [function(_, key) {
        return J.$index$asx(this._getMap$0(), key);
      }, null, "get$[]", 5, 0, null, 4],
      forEach$1: [function(_, f) {
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]});
        J.forEach$1$ax(this._getMap$0(), f);
      }, null, "get$forEach", 5, 0, null, 15],
      get$keys: [function() {
        return this._getMap$0().get$keys();
      }, null, null, 2, 0, null],
      get$values: [function(_) {
        return J.get$values$z(this._getMap$0());
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this._getMap$0());
      }, null, null, 3, 0, null]
    },
    InternalMap: {
      "^": "Object;$ti"
    },
    JSInvocationMirror: {
      "^": "Object;__js_helper$_memberName,_internalName,_kind,_arguments,_namedArgumentNames,_typeArgumentCount,$ti",
      get$memberName: [function() {
        var t1 = this.__js_helper$_memberName;
        if (!!J.getInterceptor$(t1).$isSymbol0)
          return t1;
        t1 = H.Symbol$unvalidated(H.stringTypeCheck(t1));
        this.__js_helper$_memberName = t1;
        return t1;
      }, null, null, 2, 0, null],
      get$isGetter: [function() {
        return J.$eq$(this._kind, 1);
      }, null, null, 2, 0, null],
      get$isAccessor: [function() {
        return !J.$eq$(this._kind, 0);
      }, null, null, 2, 0, null],
      get$positionalArguments: [function() {
        var t1, t2, argumentCount, list, index;
        if (this.get$isGetter())
          return C.List_empty0;
        t1 = this._arguments;
        t2 = J.getInterceptor$asx(t1);
        argumentCount = J.$sub$n(J.$sub$n(t2.get$length(t1), J.get$length$asx(this._namedArgumentNames)), this._typeArgumentCount);
        if (argumentCount === 0)
          return C.List_empty0;
        list = [];
        if (typeof argumentCount !== "number")
          return H.iae(argumentCount);
        index = 0;
        for (; index < argumentCount; ++index)
          list.push(t2.$index(t1, index));
        return J.JSArray_markUnmodifiableList(list);
      }, null, null, 2, 0, null],
      get$namedArguments: [function() {
        var t1, t2, namedArgumentCount, t3, t4, namedArgumentsStartIndex, t5, map, i, t6;
        if (this.get$isAccessor())
          return C.Map_empty0;
        t1 = this._namedArgumentNames;
        t2 = J.getInterceptor$asx(t1);
        namedArgumentCount = t2.get$length(t1);
        t3 = this._arguments;
        t4 = J.getInterceptor$asx(t3);
        namedArgumentsStartIndex = J.$sub$n(J.$sub$n(t4.get$length(t3), namedArgumentCount), this._typeArgumentCount);
        if (namedArgumentCount === 0)
          return C.Map_empty0;
        t5 = P.Symbol0;
        map = H.JsLinkedHashMap_JsLinkedHashMap$es6(t5, null);
        if (typeof namedArgumentCount !== "number")
          return H.iae(namedArgumentCount);
        i = 0;
        for (; i < namedArgumentCount; ++i) {
          t6 = H.Symbol$unvalidated(H.stringTypeCheck(t2.$index(t1, i)));
          if (typeof namedArgumentsStartIndex !== "number")
            return namedArgumentsStartIndex.$add();
          map.$indexSet(0, t6, t4.$index(t3, namedArgumentsStartIndex + i));
        }
        return H.ConstantMapView$(map, t5, null);
      }, null, null, 2, 0, null],
      $isInvocation: 1,
      static: {
        JSInvocationMirror$: [function(_memberName, _internalName, _kind, _arguments, _namedArgumentNames, _typeArgumentCount) {
          return new H.JSInvocationMirror(_memberName, _internalName, _kind, _arguments, _namedArgumentNames, _typeArgumentCount, []);
        }, null, null, 24, 0, null, 630, 647, 650, 441, 694, 705]
      }
    },
    ReflectionInfo: {
      "^": "Object;jsFunction,data>,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,0cachedSortedIndices<,$ti",
      parameterName$1: [function(parameter) {
        var metadataIndex = this.data[H.intTypeCheck(parameter) + this.optionalParameterCount + 3];
        return H.getMetadata(metadataIndex);
      }, null, "get$parameterName", 4, 0, null, 209],
      defaultValue$1: [function(_, parameter) {
        var t1;
        H.intTypeCheck(parameter);
        t1 = this.requiredParameterCount;
        if (typeof parameter !== "number")
          return parameter.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (parameter < t1)
          return;
        return this.data[3 + parameter - t1];
      }, null, "get$defaultValue", 5, 0, null, 209],
      defaultValueInOrder$1: [function(parameter) {
        var t1;
        H.intTypeCheck(parameter);
        t1 = this.requiredParameterCount;
        if (typeof parameter !== "number")
          return parameter.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (parameter < t1)
          return;
        if (!this.areOptionalParametersNamed || J.$eq$(this.optionalParameterCount, 1))
          return this.defaultValue$1(0, parameter);
        return this.defaultValue$1(0, this.sortedIndex$1(parameter - t1));
      }, null, "get$defaultValueInOrder", 4, 0, null, 209],
      parameterNameInOrder$1: [function(parameter) {
        var t1;
        H.intTypeCheck(parameter);
        t1 = this.requiredParameterCount;
        if (typeof parameter !== "number")
          return parameter.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (parameter < t1)
          return;
        if (!this.areOptionalParametersNamed || J.$eq$(this.optionalParameterCount, 1))
          return this.parameterName$1(parameter);
        return this.parameterName$1(this.sortedIndex$1(parameter - t1));
      }, null, "get$parameterNameInOrder", 4, 0, null, 209],
      sortedIndex$1: [function(unsortedIndex) {
        var _box_0, t1, t2, positions, t3, i, index;
        _box_0 = {};
        H.intTypeCheck(unsortedIndex);
        if (this.cachedSortedIndices == null) {
          t1 = this.optionalParameterCount;
          if (typeof t1 !== "number")
            return H.iae(t1);
          t2 = new Array(t1);
          t2.fixed$length = Array;
          this.cachedSortedIndices = t2;
          positions = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.int);
          for (t2 = this.requiredParameterCount, t3 = J.getInterceptor$ansx(t2), i = 0; i < t1; ++i) {
            index = t3.$add(t2, i);
            positions.$indexSet(0, this.parameterName$1(index), index);
          }
          _box_0.index = 0;
          t1 = J.toList$0$ax(positions.get$keys());
          t2 = J.getInterceptor$ax(t1);
          t2.sort$0(t1);
          t2.forEach$1(t1, new H.ReflectionInfo_sortedIndex_closure(_box_0, this, positions));
        }
        return H.intTypeCheck(J.$index$asx(this.cachedSortedIndices, unsortedIndex));
      }, null, "get$sortedIndex", 4, 0, null, 866],
      static: {
        ReflectionInfo$internal: [function(jsFunction, data, isAccessor, requiredParameterCount, optionalParameterCount, areOptionalParametersNamed, functionType) {
          return new H.ReflectionInfo(jsFunction, data, isAccessor, requiredParameterCount, optionalParameterCount, areOptionalParametersNamed, functionType, []);
        }, null, null, 28, 0, null, 456, 34, 839, 900, 913, 916, 917],
        ReflectionInfo_ReflectionInfo: [function(jsFunction) {
          var data, requiredParametersInfo, optionalParametersInfo;
          data = jsFunction.$reflectionInfo;
          if (data == null)
            return;
          data = J.JSArray_markFixedList(data);
          requiredParametersInfo = data[0];
          optionalParametersInfo = data[1];
          return H.ReflectionInfo$internal(jsFunction, data, (requiredParametersInfo & 2) === 2, requiredParametersInfo >> 2, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2]);
        }, null, null, 4, 0, null, 456]
      }
    },
    ReflectionInfo_sortedIndex_closure: {
      "^": "Closure:15;_box_0,$this,positions,$ti",
      call$1: [function($name) {
        var t1, t2, t3;
        H.stringTypeCheck($name);
        t1 = this.$this.get$cachedSortedIndices();
        t2 = this._box_0;
        t3 = t2.index;
        t2.index = J.$add$ansx(t3, 1);
        J.$indexSet$ax(t1, t3, J.$index$asx(this.positions, $name));
      }, null, null, 4, 0, null, 8, "call"]
    },
    Primitives: {
      "^": "Object;$ti"
    },
    Primitives_initTicker_closure: {
      "^": "Closure:121;performance,$ti",
      call$0: [function() {
        return C.JSNumber_methods.floor$0(1000 * this.performance.now());
      }, null, null, 0, 0, null, "call"]
    },
    Primitives_functionNoSuchMethod_closure: {
      "^": "Closure:22;_box_0,namedArgumentList,$arguments,$ti",
      call$2: [function($name, argument) {
        var t1;
        H.stringTypeCheck($name);
        t1 = this._box_0;
        t1.names = H.S(t1.names) + "$" + H.S($name);
        J.add$1$ax(this.namedArgumentList, $name);
        J.add$1$ax(this.$arguments, argument);
        t1.argumentCount = J.$add$ansx(t1.argumentCount, 1);
      }, null, null, 8, 0, null, 8, 388, "call"]
    },
    Primitives_applyFunctionWithNamedArguments_closure: {
      "^": "Closure:22;_box_0,defaultArguments,$ti",
      call$2: [function(parameter, value) {
        var t1;
        H.stringTypeCheck(parameter);
        t1 = this.defaultArguments;
        if (t1.containsKey$1(parameter))
          J.$indexSet$ax(t1, parameter, value);
        else
          this._box_0.bad = true;
      }, null, null, 8, 0, null, 209, 1, "call"]
    },
    JsCache: {
      "^": "Object;$ti"
    },
    TypeErrorDecoder: {
      "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver,$ti",
      matchTypeError$1: [function(message) {
        var match, result, t1;
        match = new RegExp(this._pattern).exec(message);
        if (match == null)
          return;
        result = Object.create(null);
        t1 = this._arguments;
        if (!J.$eq$(t1, -1))
          result.arguments = match[t1 + 1];
        t1 = this._argumentsExpr;
        if (!J.$eq$(t1, -1))
          result.argumentsExpr = match[t1 + 1];
        t1 = this._expr;
        if (!J.$eq$(t1, -1))
          result.expr = match[t1 + 1];
        t1 = this._method;
        if (!J.$eq$(t1, -1))
          result.method = match[t1 + 1];
        t1 = this._receiver;
        if (!J.$eq$(t1, -1))
          result.receiver = match[t1 + 1];
        return result;
      }, null, "get$matchTypeError", 4, 0, null, 21],
      static: {
        TypeErrorDecoder$: [function(_arguments, _argumentsExpr, _expr, _method, _receiver, _pattern) {
          return new H.TypeErrorDecoder(_pattern, _arguments, _argumentsExpr, _expr, _method, _receiver, []);
        }, null, null, 24, 0, null, 441, 897, 898, 903, 392, 320],
        TypeErrorDecoder_buildJavaScriptObject: [function() {
          return {
            toString: function() {
              return "$receiver$";
            }
          };
        }, null, null, 0, 0, null],
        TypeErrorDecoder_buildJavaScriptObjectWithNonClosure: [function() {
          return {$method$: null,
            toString: function() {
              return "$receiver$";
            }
          };
        }, null, null, 0, 0, null],
        TypeErrorDecoder_extractPattern: [function(message) {
          var match;
          message = H.stringTypeCheck(H.quoteStringForRegExp(H.stringTypeCheck(message).replace(String({}), '$receiver$')));
          match = message.match(/\\\$[a-zA-Z]+\\\$/g);
          if (match == null)
            match = H.setRuntimeTypeInfo([], [P.String]);
          return H.TypeErrorDecoder$(match.indexOf("\\$arguments\\$"), match.indexOf("\\$argumentsExpr\\$"), match.indexOf("\\$expr\\$"), match.indexOf("\\$method\\$"), match.indexOf("\\$receiver\\$"), message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'));
        }, null, null, 4, 0, null, 21],
        TypeErrorDecoder_provokeCallErrorOn: [function(expression) {
          return function($expr$) {
            var $argumentsExpr$ = '$arguments$';
            try {
              $expr$.$method$($argumentsExpr$);
            } catch (e) {
              return e.message;
            }
          }(expression);
        }, null, null, 4, 0, null, 147],
        TypeErrorDecoder_provokeCallErrorOnNull: [function() {
          return function() {
            var $argumentsExpr$ = '$arguments$';
            try {
              null.$method$($argumentsExpr$);
            } catch (e) {
              return e.message;
            }
          }();
        }, null, null, 0, 0, null],
        TypeErrorDecoder_provokeCallErrorOnUndefined: [function() {
          return function() {
            var $argumentsExpr$ = '$arguments$';
            try {
              (void 0).$method$($argumentsExpr$);
            } catch (e) {
              return e.message;
            }
          }();
        }, null, null, 0, 0, null],
        TypeErrorDecoder_provokePropertyErrorOn: [function(expression) {
          return function($expr$) {
            try {
              $expr$.$method$;
            } catch (e) {
              return e.message;
            }
          }(expression);
        }, null, null, 4, 0, null, 147],
        TypeErrorDecoder_provokePropertyErrorOnNull: [function() {
          return function() {
            try {
              null.$method$;
            } catch (e) {
              return e.message;
            }
          }();
        }, null, null, 0, 0, null],
        TypeErrorDecoder_provokePropertyErrorOnUndefined: [function() {
          return function() {
            try {
              (void 0).$method$;
            } catch (e) {
              return e.message;
            }
          }();
        }, null, null, 0, 0, null]
      }
    },
    NullError: {
      "^": "Error;_message,_method,$ti",
      toString$0: [function(_) {
        var t1 = this._method;
        if (t1 == null)
          return "NoSuchMethodError: " + H.S(this._message);
        return "NoSuchMethodError: method not found: '" + H.S(t1) + "' on null";
      }, null, "get$toString", 1, 0, null],
      $isNoSuchMethodError: 1,
      static: {
        NullError$: [function(_message, match) {
          var t1 = match == null ? null : match.method;
          return new H.NullError(_message, t1, []);
        }, null, null, 8, 0, null, 316, 148]
      }
    },
    JsNoSuchMethodError: {
      "^": "Error;_message,_method,_receiver,$ti",
      toString$0: [function(_) {
        var t1, t2;
        t1 = this._method;
        if (t1 == null)
          return "NoSuchMethodError: " + H.S(this._message);
        t2 = this._receiver;
        if (t2 == null)
          return "NoSuchMethodError: method not found: '" + H.S(t1) + "' (" + H.S(this._message) + ")";
        return "NoSuchMethodError: method not found: '" + H.S(t1) + "' on '" + H.S(t2) + "' (" + H.S(this._message) + ")";
      }, null, "get$toString", 1, 0, null],
      $isNoSuchMethodError: 1,
      static: {
        JsNoSuchMethodError$: [function(_message, match) {
          var t1, t2;
          t1 = match == null;
          t2 = t1 ? null : match.method;
          t1 = t1 ? null : match.receiver;
          return new H.JsNoSuchMethodError(_message, t2, t1, []);
        }, null, null, 8, 0, null, 316, 148]
      }
    },
    UnknownJsTypeError: {
      "^": "Error;_message,$ti",
      toString$0: [function(_) {
        var t1 = this._message;
        return J.get$isEmpty$asx(t1) ? "Error" : "Error: " + H.S(t1);
      }, null, "get$toString", 1, 0, null],
      static: {
        UnknownJsTypeError$: [function(_message) {
          return new H.UnknownJsTypeError(_message, []);
        }, null, null, 4, 0, null, 316]
      }
    },
    ExceptionAndStackTrace: {
      "^": "Object;dartException,stackTrace<,$ti",
      static: {
        ExceptionAndStackTrace$: [function(dartException, stackTrace) {
          return new H.ExceptionAndStackTrace(dartException, stackTrace, []);
        }, null, null, 8, 0, null, 588, 20]
      }
    },
    unwrapException_saveStackTrace: {
      "^": "Closure:3;ex,$ti",
      call$1: [function(error) {
        if (!!J.getInterceptor$(error).$isError)
          if (error.$thrownJsError == null)
            error.$thrownJsError = this.ex;
        return error;
      }, null, null, 4, 0, null, 14, "call"]
    },
    _StackTrace: {
      "^": "Object;_exception,0_trace,$ti",
      toString$0: [function(_) {
        var t1, trace;
        t1 = this._trace;
        if (t1 != null)
          return t1;
        t1 = this._exception;
        trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
        t1 = trace == null ? "" : trace;
        this._trace = t1;
        return t1;
      }, null, "get$toString", 1, 0, null],
      $isStackTrace: 1,
      static: {
        _StackTrace$: [function(_exception) {
          return new H._StackTrace(_exception, []);
        }, null, null, 4, 0, null, 594]
      }
    },
    Closure: {
      "^": "Object;$ti",
      toString$0: [function(_) {
        return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
      }, null, "get$toString", 1, 0, null],
      get$$call: function() {
        return this;
      },
      $isFunction: 1,
      get$$call: function() {
        return this;
      }
    },
    Closure_fromTearOff_closure: {
      "^": "Closure:1;$ti"
    },
    TearOffClosure: {
      "^": "Closure;$ti"
    },
    StaticClosure: {
      "^": "TearOffClosure;$ti",
      toString$0: [function(_) {
        var $name = this.$static_name;
        if ($name == null)
          return "Closure of unknown static method";
        return "Closure '" + H.S(H.unminifyOrTag($name)) + "'";
      }, null, "get$toString", 1, 0, null],
      static: {
        StaticClosure$: [function() {
          return new H.StaticClosure([]);
        }, null, null, 0, 0, null]
      }
    },
    BoundClosure: {
      "^": "TearOffClosure;_self,_target,_receiver,_name,$ti",
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof H.BoundClosure))
          return false;
        return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        var t1, receiverHashCode;
        t1 = this._receiver;
        if (t1 == null)
          receiverHashCode = H.Primitives_objectHashCode(this._self);
        else
          receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
        t1 = H.Primitives_objectHashCode(this._target);
        if (typeof receiverHashCode !== "number")
          return receiverHashCode.$xor();
        if (typeof t1 !== "number")
          return H.iae(t1);
        return (receiverHashCode ^ t1) >>> 0;
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        var receiver = this._receiver;
        if (receiver == null)
          receiver = this._self;
        return "Closure '" + H.S(this._name) + "' of " + H.S(H.Primitives_objectToHumanReadableString(receiver));
      }, null, "get$toString", 1, 0, null],
      static: {
        BoundClosure$: [function(_self, _target, _receiver, _name) {
          return new H.BoundClosure(_self, _target, _receiver, _name, []);
        }, null, null, 16, 0, null, 661, 266, 392, 293],
        BoundClosure_selfOf: [function(closure) {
          return H.interceptedTypeCheck(closure, "$isBoundClosure")._self;
        }, null, null, 4, 0, null, 193],
        BoundClosure_receiverOf: [function(closure) {
          return H.interceptedTypeCheck(closure, "$isBoundClosure")._receiver;
        }, null, null, 4, 0, null, 193],
        BoundClosure_selfFieldName: [function() {
          var t1 = $.BoundClosure_selfFieldNameCache;
          if (t1 == null) {
            t1 = H.BoundClosure_computeFieldNamed("self");
            $.BoundClosure_selfFieldNameCache = t1;
          }
          return t1;
        }, null, null, 0, 0, null],
        BoundClosure_receiverFieldName: [function() {
          var t1 = $.BoundClosure_receiverFieldNameCache;
          if (t1 == null) {
            t1 = H.BoundClosure_computeFieldNamed("receiver");
            $.BoundClosure_receiverFieldNameCache = t1;
          }
          return t1;
        }, null, null, 0, 0, null],
        BoundClosure_computeFieldNamed: [function(fieldName) {
          var template, names, t1, i, t2, $name;
          H.stringTypeCheck(fieldName);
          template = H.BoundClosure$("self", "target", "receiver", "name");
          names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template));
          t1 = J.getInterceptor$asx(names);
          i = 0;
          while (true) {
            t2 = t1.get$length(names);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            $name = t1.$index(names, i);
            if (template[$name] === fieldName)
              return $name;
            ++i;
          }
        }, null, null, 4, 0, null, 698]
      }
    },
    Instantiation: {
      "^": "Closure;$ti",
      Instantiation$1: [function(_genericClosure) {
        if (false)
          H.instantiatedGenericFunctionType(0, 0);
      }, null, null, 4, 0, null, 876],
      toString$0: [function(_) {
        var types = "<" + H.S(J.join$1$ax(this.get$_types(), ", ")) + ">";
        return H.S(this._genericClosure) + " with " + types;
      }, null, "get$toString", 1, 0, null]
    },
    Instantiation1: {
      "^": "Instantiation;_genericClosure,$ti",
      get$_types: [function() {
        return [H.createRuntimeType(H.getTypeArgumentByIndex(this, 0))];
      }, null, null, 2, 0, null],
      call$1: function(a0) {
        return this._genericClosure.call$1$1(a0, this.$ti[0]);
      },
      $signature: function() {
        return H.instantiatedGenericFunctionType(H.extractFunctionTypeObjectFromInternal(this._genericClosure), this.$ti);
      },
      static: {
        Instantiation1$: [function(f, T1) {
          var t1 = new H.Instantiation1(f, [T1]);
          t1.Instantiation$1(f);
          return t1;
        }, null, null, 4, 0, null, 15]
      }
    },
    Instantiation2: {
      "^": "Instantiation;$ti"
    },
    Instantiation3: {
      "^": "Instantiation;$ti"
    },
    Instantiation4: {
      "^": "Instantiation;$ti"
    },
    Instantiation5: {
      "^": "Instantiation;$ti"
    },
    Instantiation6: {
      "^": "Instantiation;$ti"
    },
    Instantiation7: {
      "^": "Instantiation;$ti"
    },
    Instantiation8: {
      "^": "Instantiation;$ti"
    },
    Instantiation9: {
      "^": "Instantiation;$ti"
    },
    Instantiation10: {
      "^": "Instantiation;$ti"
    },
    Instantiation11: {
      "^": "Instantiation;$ti"
    },
    Instantiation12: {
      "^": "Instantiation;$ti"
    },
    Instantiation13: {
      "^": "Instantiation;$ti"
    },
    Instantiation14: {
      "^": "Instantiation;$ti"
    },
    Instantiation15: {
      "^": "Instantiation;$ti"
    },
    Instantiation16: {
      "^": "Instantiation;$ti"
    },
    Instantiation17: {
      "^": "Instantiation;$ti"
    },
    Instantiation18: {
      "^": "Instantiation;$ti"
    },
    Instantiation19: {
      "^": "Instantiation;$ti"
    },
    Instantiation20: {
      "^": "Instantiation;$ti"
    },
    Creates: {
      "^": "Object;$ti"
    },
    Returns: {
      "^": "Object;$ti"
    },
    JSName: {
      "^": "Object;$ti"
    },
    JavaScriptIndexingBehavior: {
      "^": "JSMutableIndexable;$ti"
    },
    TypeErrorImplementation: {
      "^": "Error;message>,$ti",
      toString$0: [function(_) {
        return this.message;
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isAssertionError: 1,
      $isTypeError: 1,
      static: {
        TypeErrorImplementation$: [function(value, type) {
          return new H.TypeErrorImplementation("TypeError: " + H.S(P.Error_safeToString(value)) + ": type '" + H.S(H._typeDescription(value)) + "' is not a subtype of type '" + H.S(type) + "'", []);
        }, null, null, 8, 0, null, 1, 29],
        TypeErrorImplementation$fromMessage: [function(message) {
          return new H.TypeErrorImplementation(message, []);
        }, null, null, 4, 0, null, 21]
      }
    },
    CastErrorImplementation: {
      "^": "Error;message>,$ti",
      toString$0: [function(_) {
        return this.message;
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isCastError: 1,
      static: {
        CastErrorImplementation$: [function(value, type) {
          return new H.CastErrorImplementation("CastError: " + H.S(P.Error_safeToString(value)) + ": type '" + H.S(H._typeDescription(value)) + "' is not a subtype of type '" + H.S(type) + "'", []);
        }, null, null, 8, 0, null, 1, 29]
      }
    },
    FallThroughErrorImplementation: {
      "^": "FallThroughError;$ti"
    },
    RuntimeError: {
      "^": "Error;message>,$ti",
      toString$0: [function(_) {
        return "RuntimeError: " + H.S(this.message);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        RuntimeError$: [function(message) {
          return new H.RuntimeError(message, []);
        }, null, null, 4, 0, null, 21]
      }
    },
    DeferredNotLoadedError: {
      "^": "Error;$ti",
      $isNoSuchMethodError: 1
    },
    UnimplementedNoSuchMethodError: {
      "^": "Error;$ti",
      $isNoSuchMethodError: 1
    },
    MainError: {
      "^": "Error;$ti",
      $isNoSuchMethodError: 1
    },
    _AssertionError: {
      "^": "AssertionError;$ti"
    },
    _UnreachableError: {
      "^": "AssertionError;$ti"
    },
    TypeImpl: {
      "^": "Object;_rti,0__typeName,0_unmangledName,0_hashCode,$ti",
      get$_typeName: [function() {
        var t1 = this.__typeName;
        if (t1 == null) {
          t1 = H.stringTypeCheck(H.runtimeTypeToString(this._rti));
          this.__typeName = t1;
        }
        return t1;
      }, null, null, 2, 0, null],
      toString$0: [function(_) {
        return this.get$_typeName();
      }, null, "get$toString", 1, 0, null],
      get$hashCode: [function(_) {
        var t1 = this._hashCode;
        if (t1 == null) {
          t1 = H.intTypeCheck(J.get$hashCode$(this.get$_typeName()));
          this._hashCode = t1;
        }
        return t1;
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.TypeImpl && J.$eq$(this.get$_typeName(), other.get$_typeName());
      }, null, "get$==", 5, 0, null, 3],
      $isType: 1,
      static: {
        TypeImpl$: [function(_rti) {
          return new H.TypeImpl(_rti, []);
        }, null, null, 4, 0, null, 788]
      }
    },
    TypeVariable: {
      "^": "Object;$ti"
    },
    JsLinkedHashMap: {
      "^": "MapBase;__js_helper$_length<,0__js_helper$_strings,0__js_helper$_nums,0__js_helper$_rest,0__js_helper$_first<,0__js_helper$_last,__js_helper$_modifications<,$ti",
      get$length: [function(_) {
        return this.__js_helper$_length;
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this.__js_helper$_length, 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 3, 0, null],
      get$keys: [function() {
        return H.LinkedHashMapKeyIterable$(this, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 2, 0, null],
      get$values: [function(_) {
        return H.MappedIterable_MappedIterable(this.get$keys(), new H.JsLinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      containsKey$1: [function(key) {
        var strings, nums;
        if (H.JsLinkedHashMap__isStringKey(key)) {
          strings = this.__js_helper$_strings;
          if (strings == null)
            return false;
          return this._containsTableEntry$2(strings, key);
        } else if (H.JsLinkedHashMap__isNumericKey(key)) {
          nums = this.__js_helper$_nums;
          if (nums == null)
            return false;
          return this._containsTableEntry$2(nums, key);
        } else
          return this.internalContainsKey$1(key);
      }, null, "get$containsKey", 4, 0, null, 4],
      internalContainsKey$1: ["super$JsLinkedHashMap$internalContainsKey", function(key) {
        var rest = this.__js_helper$_rest;
        if (rest == null)
          return false;
        return J.$ge$n(this.internalFindBucketIndex$2(this.__js_helper$_getBucket$2(rest, key), key), 0);
      }, null, "get$internalContainsKey", 4, 0, null, 4],
      addAll$1: [function(_, other) {
        H.assertSubtype(other, "$isMap", this.$ti, "$asMap").forEach$1(0, new H.JsLinkedHashMap_addAll_closure(this));
      }, null, "get$addAll", 5, 0, null, 3],
      $index: [function(_, key) {
        var strings, cell, t1, nums;
        if (H.JsLinkedHashMap__isStringKey(key)) {
          strings = this.__js_helper$_strings;
          if (strings == null)
            return;
          cell = this._getTableCell$2(strings, key);
          t1 = cell == null ? null : cell.hashMapCellValue;
          return t1;
        } else if (H.JsLinkedHashMap__isNumericKey(key)) {
          nums = this.__js_helper$_nums;
          if (nums == null)
            return;
          cell = this._getTableCell$2(nums, key);
          t1 = cell == null ? null : cell.hashMapCellValue;
          return t1;
        } else
          return this.internalGet$1(key);
      }, null, "get$[]", 5, 0, null, 4],
      internalGet$1: ["super$JsLinkedHashMap$internalGet", function(key) {
        var rest, bucket, index;
        rest = this.__js_helper$_rest;
        if (rest == null)
          return;
        bucket = this.__js_helper$_getBucket$2(rest, key);
        index = this.internalFindBucketIndex$2(bucket, key);
        if (typeof index !== "number")
          return index.$lt();
        if (index < 0)
          return;
        return bucket[index].hashMapCellValue;
      }, null, "get$internalGet", 4, 0, null, 4],
      $indexSet: [function(_, key, value) {
        var strings, nums;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
        if (H.JsLinkedHashMap__isStringKey(key)) {
          strings = this.__js_helper$_strings;
          if (strings == null) {
            strings = this._newHashTable$0();
            this.__js_helper$_strings = strings;
          }
          this.__js_helper$_addHashTableEntry$3(strings, key, value);
        } else if (H.JsLinkedHashMap__isNumericKey(key)) {
          nums = this.__js_helper$_nums;
          if (nums == null) {
            nums = this._newHashTable$0();
            this.__js_helper$_nums = nums;
          }
          this.__js_helper$_addHashTableEntry$3(nums, key, value);
        } else
          this.internalSet$2(key, value);
      }, null, "get$[]=", 9, 0, null, 4, 1],
      internalSet$2: ["super$JsLinkedHashMap$internalSet", function(key, value) {
        var rest, hash, bucket, index;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
        rest = this.__js_helper$_rest;
        if (rest == null) {
          rest = this._newHashTable$0();
          this.__js_helper$_rest = rest;
        }
        hash = this.internalComputeHashCode$1(key);
        bucket = this._getTableBucket$2(rest, hash);
        if (bucket == null)
          this._setTableEntry$3(rest, hash, [this.__js_helper$_newLinkedCell$2(key, value)]);
        else {
          index = this.internalFindBucketIndex$2(bucket, key);
          if (typeof index !== "number")
            return index.$ge();
          if (index >= 0)
            bucket[index].hashMapCellValue = value;
          else
            bucket.push(this.__js_helper$_newLinkedCell$2(key, value));
        }
      }, null, "get$internalSet", 8, 0, null, 4, 1],
      putIfAbsent$2: [function(key, ifAbsent) {
        var value;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(this, 1)});
        if (this.containsKey$1(key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      remove$1: [function(_, key) {
        if (H.JsLinkedHashMap__isStringKey(key))
          return this.__js_helper$_removeHashTableEntry$2(this.__js_helper$_strings, key);
        else if (H.JsLinkedHashMap__isNumericKey(key))
          return this.__js_helper$_removeHashTableEntry$2(this.__js_helper$_nums, key);
        else
          return this.internalRemove$1(key);
      }, null, "get$remove", 5, 0, null, 4],
      internalRemove$1: ["super$JsLinkedHashMap$internalRemove", function(key) {
        var rest, bucket, index, cell;
        rest = this.__js_helper$_rest;
        if (rest == null)
          return;
        bucket = this.__js_helper$_getBucket$2(rest, key);
        index = this.internalFindBucketIndex$2(bucket, key);
        if (typeof index !== "number")
          return index.$lt();
        if (index < 0)
          return;
        cell = bucket.splice(index, 1)[0];
        this.__js_helper$_unlinkCell$1(cell);
        return cell.hashMapCellValue;
      }, null, "get$internalRemove", 4, 0, null, 4],
      clear$0: [function(_) {
        if (J.$gt$n(this.__js_helper$_length, 0)) {
          this.__js_helper$_last = null;
          this.__js_helper$_first = null;
          this.__js_helper$_rest = null;
          this.__js_helper$_nums = null;
          this.__js_helper$_strings = null;
          this.__js_helper$_length = 0;
          this.__js_helper$_modified$0();
        }
      }, null, "get$clear", 1, 0, null],
      forEach$1: [function(_, action) {
        var cell, modifications, t1;
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]});
        cell = this.__js_helper$_first;
        modifications = this.__js_helper$_modifications;
        for (; cell != null;) {
          action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
          t1 = this.__js_helper$_modifications;
          if (modifications == null ? t1 != null : modifications !== t1)
            throw H.wrapException(P.ConcurrentModificationError$(this));
          cell = cell.__js_helper$_next;
        }
      }, null, "get$forEach", 5, 0, null, 63],
      __js_helper$_addHashTableEntry$3: [function(table, key, value) {
        var cell;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
        cell = this._getTableCell$2(table, key);
        if (cell == null)
          this._setTableEntry$3(table, key, this.__js_helper$_newLinkedCell$2(key, value));
        else
          cell.hashMapCellValue = value;
      }, null, "get$__js_helper$_addHashTableEntry", 12, 0, null, 51, 4, 1],
      __js_helper$_removeHashTableEntry$2: [function(table, key) {
        var cell;
        if (table == null)
          return;
        cell = this._getTableCell$2(table, key);
        if (cell == null)
          return;
        this.__js_helper$_unlinkCell$1(cell);
        this._deleteTableEntry$2(table, key);
        return cell.hashMapCellValue;
      }, null, "get$__js_helper$_removeHashTableEntry", 8, 0, null, 51, 4],
      __js_helper$_modified$0: [function() {
        this.__js_helper$_modifications = H.intTypeCheck(J.$and$bn(J.$add$ansx(this.__js_helper$_modifications, 1), 67108863));
      }, null, "get$__js_helper$_modified", 0, 0, null],
      __js_helper$_newLinkedCell$2: [function(key, value) {
        var cell, last;
        cell = H.LinkedHashMapCell$(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)));
        if (this.__js_helper$_first == null) {
          this.__js_helper$_last = cell;
          this.__js_helper$_first = cell;
        } else {
          last = this.__js_helper$_last;
          cell.__js_helper$_previous = last;
          last.__js_helper$_next = cell;
          this.__js_helper$_last = cell;
        }
        this.__js_helper$_length = H.intTypeCheck(J.$add$ansx(this.__js_helper$_length, 1));
        this.__js_helper$_modified$0();
        return cell;
      }, null, "get$__js_helper$_newLinkedCell", 8, 0, null, 4, 1],
      __js_helper$_unlinkCell$1: [function(cell) {
        var previous, next;
        H.interceptedTypeCheck(cell, "$isLinkedHashMapCell");
        previous = cell.__js_helper$_previous;
        next = cell.__js_helper$_next;
        if (previous == null)
          this.__js_helper$_first = next;
        else
          previous.__js_helper$_next = next;
        if (next == null)
          this.__js_helper$_last = previous;
        else
          next.__js_helper$_previous = previous;
        this.__js_helper$_length = H.intTypeCheck(J.$sub$n(this.__js_helper$_length, 1));
        this.__js_helper$_modified$0();
      }, null, "get$__js_helper$_unlinkCell", 4, 0, null, 292],
      internalComputeHashCode$1: [function(key) {
        return J.get$hashCode$(key) & 0x3ffffff;
      }, null, "get$internalComputeHashCode", 4, 0, null, 4],
      __js_helper$_getBucket$2: [function(table, key) {
        return this._getTableBucket$2(table, this.internalComputeHashCode$1(key));
      }, null, "get$__js_helper$_getBucket", 8, 0, null, 51, 4],
      internalFindBucketIndex$2: [function(bucket, key) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i].hashMapCellKey, key))
            return i;
        return -1;
      }, null, "get$internalFindBucketIndex", 8, 0, null, 135, 4],
      toString$0: [function(_) {
        return P.MapBase_mapToString(this);
      }, null, "get$toString", 1, 0, null],
      _getTableCell$2: [function(table, key) {
        return table[key];
      }, null, "get$_getTableCell", 8, 0, null, 51, 4],
      _getTableBucket$2: [function(table, key) {
        return table[key];
      }, null, "get$_getTableBucket", 8, 0, null, 51, 4],
      _setTableEntry$3: [function(table, key, value) {
        table[key] = value;
      }, null, "get$_setTableEntry", 12, 0, null, 51, 4, 1],
      _deleteTableEntry$2: [function(table, key) {
        delete table[key];
      }, null, "get$_deleteTableEntry", 8, 0, null, 51, 4],
      _containsTableEntry$2: [function(table, key) {
        return this._getTableCell$2(table, key) != null;
      }, null, "get$_containsTableEntry", 8, 0, null, 51, 4],
      _newHashTable$0: [function() {
        var table = Object.create(null);
        this._setTableEntry$3(table, "<non-identifier-key>", table);
        this._deleteTableEntry$2(table, "<non-identifier-key>");
        return table;
      }, null, "get$_newHashTable", 0, 0, null],
      $isInternalMap: 1,
      $isLinkedHashMap: 1,
      static: {
        JsLinkedHashMap$: [function($K, $V) {
          return new H.JsLinkedHashMap(0, 0, [$K, $V]);
        }, null, null, 0, 0, null],
        JsLinkedHashMap_JsLinkedHashMap$es6: [function($K, $V) {
          var t1 = H.JsLinkedHashMap$($K, $V);
          return t1;
        }, null, null, 0, 0, null],
        JsLinkedHashMap__isStringKey: [function(key) {
          return typeof key === "string";
        }, null, null, 4, 0, null, 4],
        JsLinkedHashMap__isNumericKey: [function(key) {
          return typeof key === "number" && (key & 0x3ffffff) === key;
        }, null, null, 4, 0, null, 4]
      }
    },
    JsLinkedHashMap_values_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(each) {
        var t1 = this.$this;
        return J.$index$asx(t1, H.assertSubtypeOfRuntimeType(each, H.getTypeArgumentByIndex(t1, 0)));
      }, null, null, 4, 0, null, 290, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
      }
    },
    JsLinkedHashMap_addAll_closure: {
      "^": "Closure;$this,$ti",
      call$2: [function(key, value) {
        var t1 = this.$this;
        J.$indexSet$ax(t1, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
      }, null, null, 8, 0, null, 4, 1, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
      }
    },
    Es6LinkedHashMap: {
      "^": "JsLinkedHashMap;$ti"
    },
    LinkedHashMapCell: {
      "^": "Object;hashMapCellKey<,hashMapCellValue,0__js_helper$_next<,0__js_helper$_previous,$ti",
      static: {
        LinkedHashMapCell$: [function(hashMapCellKey, hashMapCellValue) {
          return new H.LinkedHashMapCell(hashMapCellKey, hashMapCellValue, []);
        }, null, null, 8, 0, null, 861, 862]
      }
    },
    LinkedHashMapKeyIterable: {
      "^": "EfficientLengthIterable;_map,$ti",
      get$length: [function(_) {
        return H.intTypeCheck(this._map.get$__js_helper$_length());
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this._map.get$__js_helper$_length(), 0);
      }, null, null, 3, 0, null],
      get$iterator: [function(_) {
        var t1 = this._map;
        return H.LinkedHashMapKeyIterator$(t1, H.intTypeCheck(t1.get$__js_helper$_modifications()), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      contains$1: [function(_, element) {
        return H.boolTypeCheck(this._map.containsKey$1(element));
      }, null, "get$contains", 5, 0, null, 10],
      forEach$1: [function(_, f) {
        var t1, cell, modifications, t2;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
        t1 = this._map;
        cell = H.interceptedTypeCheck(t1.get$__js_helper$_first(), "$isLinkedHashMapCell");
        modifications = H.intTypeCheck(t1.get$__js_helper$_modifications());
        for (; cell != null;) {
          f.call$1(cell.hashMapCellKey);
          t2 = t1.get$__js_helper$_modifications();
          if (modifications == null ? t2 != null : modifications !== t2)
            throw H.wrapException(P.ConcurrentModificationError$(t1));
          cell = cell.__js_helper$_next;
        }
      }, null, "get$forEach", 5, 0, null, 15],
      static: {
        LinkedHashMapKeyIterable$: [function(_map, $E) {
          return new H.LinkedHashMapKeyIterable(_map, [$E]);
        }, null, null, 4, 0, null, 141]
      }
    },
    LinkedHashMapKeyIterator: {
      "^": "Object;_map,__js_helper$_modifications<,0__js_helper$_cell,0__js_helper$_current,$ti",
      set$__js_helper$_current: function(_current) {
        this.__js_helper$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
      },
      LinkedHashMapKeyIterator$2: [function(_map, _modifications, $E) {
        this.__js_helper$_cell = H.interceptedTypeCheck(this._map.get$__js_helper$_first(), "$isLinkedHashMapCell");
      }, null, null, 8, 0, null, 141, 244],
      get$current: [function() {
        return this.__js_helper$_current;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        var t1 = this._map;
        if (!J.$eq$(this.__js_helper$_modifications, t1.get$__js_helper$_modifications()))
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        else {
          t1 = this.__js_helper$_cell;
          if (t1 == null) {
            this.set$__js_helper$_current(null);
            return false;
          } else {
            this.set$__js_helper$_current(t1.get$hashMapCellKey());
            this.__js_helper$_cell = H.interceptedTypeCheck(this.__js_helper$_cell.get$__js_helper$_next(), "$isLinkedHashMapCell");
            return true;
          }
        }
      }, null, "get$moveNext", 0, 0, null],
      $isIterator: 1,
      static: {
        LinkedHashMapKeyIterator$: [function(_map, _modifications, $E) {
          var t1 = new H.LinkedHashMapKeyIterator(_map, _modifications, [$E]);
          t1.LinkedHashMapKeyIterator$2(_map, _modifications, $E);
          return t1;
        }, null, null, 8, 0, null, 141, 244]
      }
    },
    initHooks_closure: {
      "^": "Closure:3;getTag,$ti",
      call$1: [function(o) {
        return this.getTag(o);
      }, null, null, 4, 0, null, 25, "call"]
    },
    initHooks_closure0: {
      "^": "Closure:207;getUnknownTag,$ti",
      call$2: [function(o, tag) {
        return this.getUnknownTag(o, H.stringTypeCheck(tag));
      }, null, null, 8, 0, null, 25, 109, "call"]
    },
    initHooks_closure1: {
      "^": "Closure:115;prototypeForTag,$ti",
      call$1: [function(tag) {
        return this.prototypeForTag(H.stringTypeCheck(tag));
      }, null, null, 4, 0, null, 109, "call"]
    },
    JSSyntaxRegExp: {
      "^": "Object;pattern>,_nativeRegExp,0_nativeGlobalRegExp,0_nativeAnchoredRegExp,$ti",
      toString$0: [function(_) {
        return "RegExp/" + H.S(this.pattern) + "/";
      }, null, "get$toString", 1, 0, null],
      get$_nativeGlobalVersion: [function() {
        var t1 = this._nativeGlobalRegExp;
        if (t1 != null)
          return t1;
        t1 = H.JSSyntaxRegExp_makeNative(this.pattern, this.get$_isMultiLine(), this.get$_isCaseSensitive(), true);
        this._nativeGlobalRegExp = t1;
        return t1;
      }, null, null, 2, 0, null],
      get$_nativeAnchoredVersion: [function() {
        var t1 = this._nativeAnchoredRegExp;
        if (t1 != null)
          return t1;
        t1 = H.JSSyntaxRegExp_makeNative(H.S(this.pattern) + "|()", this.get$_isMultiLine(), this.get$_isCaseSensitive(), true);
        this._nativeAnchoredRegExp = t1;
        return t1;
      }, null, null, 2, 0, null],
      get$_isMultiLine: [function() {
        return this._nativeRegExp.multiline;
      }, null, null, 2, 0, null],
      get$_isCaseSensitive: [function() {
        return !this._nativeRegExp.ignoreCase;
      }, null, null, 2, 0, null],
      firstMatch$1: [function(string) {
        var m = this._nativeRegExp.exec(H.checkString(H.stringTypeCheck(string)));
        if (m == null)
          return;
        return H._MatchImplementation$(this, m);
      }, null, "get$firstMatch", 4, 0, null, 30],
      hasMatch$1: [function(string) {
        return this._nativeRegExp.test(H.checkString(H.stringTypeCheck(string)));
      }, null, "get$hasMatch", 4, 0, null, 30],
      allMatches$2: [function(_, string, start) {
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        H.checkString(string);
        H.checkInt(start);
        if (typeof start !== "number")
          return start.$lt();
        if (start < 0 || start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return H._AllMatchesIterable$(this, string, start);
      }, function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      }, "allMatches$1", null, null, "get$allMatches", 5, 2, null, 16, 30, 5],
      _execGlobal$2: [function(string, start) {
        var regexp, match;
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        regexp = this.get$_nativeGlobalVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        return H._MatchImplementation$(this, match);
      }, null, "get$_execGlobal", 8, 0, null, 30, 5],
      _execAnchored$2: [function(string, start) {
        var regexp, match;
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        regexp = this.get$_nativeAnchoredVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        if (0 >= match.length)
          return H.ioore(match, -1);
        if (match.pop() != null)
          return;
        return H._MatchImplementation$(this, match);
      }, null, "get$_execAnchored", 8, 0, null, 30, 5],
      matchAsPrefix$2: [function(_, string, start) {
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        if (typeof start !== "number")
          return start.$lt();
        if (start < 0 || start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return this._execAnchored$2(string, start);
      }, function($receiver, string) {
        return this.matchAsPrefix$2($receiver, string, 0);
      }, "matchAsPrefix$1", null, null, "get$matchAsPrefix", 5, 2, null, 16, 30, 5],
      $isPattern: 1,
      $isRegExp: 1,
      static: {
        JSSyntaxRegExp$: [function(source, caseSensitive, multiLine) {
          return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, multiLine, caseSensitive, false), []);
        }, null, null, 4, 5, null, 27, 18, 11, 299, 274],
        JSSyntaxRegExp_makeNative: [function(source, multiLine, caseSensitive, global) {
          var m, i, g, regexp;
          H.stringTypeCheck(source);
          H.boolTypeCheck(multiLine);
          H.boolTypeCheck(caseSensitive);
          H.boolTypeCheck(global);
          H.checkString(source);
          m = multiLine === true ? "m" : "";
          i = caseSensitive === true ? "" : "i";
          g = global ? "g" : "";
          regexp = function(source, modifiers) {
            try {
              return new RegExp(source, modifiers);
            } catch (e) {
              return e;
            }
          }(source, m + i + g);
          if (regexp instanceof RegExp)
            return regexp;
          throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
        }, null, null, 16, 0, null, 11, 274, 299, 621]
      }
    },
    _MatchImplementation: {
      "^": "Object;pattern>,_match,$ti",
      _MatchImplementation$2: [function(pattern, _match) {
      }, null, null, 8, 0, null, 36, 362],
      get$start: [function(_) {
        return this._match.index;
      }, null, null, 3, 0, null],
      get$end: [function() {
        return H.intTypeCheck(J.$add$ansx(this.get$start(this), this._match[0].length));
      }, null, null, 2, 0, null],
      group$1: [function(index) {
        return J.$index$asx(this._match, H.intTypeCheck(index));
      }, null, "get$group", 4, 0, null, 6],
      $index: [function(_, index) {
        return this.group$1(H.intTypeCheck(index));
      }, null, "get$[]", 5, 0, null, 6],
      $isMatch: 1,
      static: {
        _MatchImplementation$: [function(pattern, _match) {
          var t1 = new H._MatchImplementation(pattern, _match, []);
          t1._MatchImplementation$2(pattern, _match);
          return t1;
        }, null, null, 8, 0, null, 36, 362]
      }
    },
    _AllMatchesIterable: {
      "^": "IterableBase;_re,_string,__js_helper$_start,$ti",
      get$iterator: [function(_) {
        return H._AllMatchesIterator$(this._re, this._string, this.__js_helper$_start);
      }, null, null, 3, 0, null],
      $asIterableBase: function() {
        return [P.Match];
      },
      $asIterable: function() {
        return [P.Match];
      },
      static: {
        _AllMatchesIterable$: [function(_re, _string, _start) {
          return new H._AllMatchesIterable(_re, _string, _start, []);
        }, null, null, 12, 0, null, 653, 304, 185]
      }
    },
    _AllMatchesIterator: {
      "^": "Object;_regExp,_string,_nextIndex,0__js_helper$_current,$ti",
      get$current: [function() {
        return this.__js_helper$_current;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        var t1, match, nextIndex;
        t1 = this._string;
        if (t1 == null)
          return false;
        if (J.$le$n(this._nextIndex, J.get$length$asx(t1))) {
          match = this._regExp._execGlobal$2(this._string, this._nextIndex);
          if (match != null) {
            this.__js_helper$_current = match;
            nextIndex = match.get$end();
            if (J.$eq$(match.get$start(match), nextIndex)) {
              if (typeof nextIndex !== "number")
                return nextIndex.$add();
              ++nextIndex;
            }
            this._nextIndex = nextIndex;
            return true;
          }
        }
        this.__js_helper$_current = null;
        this._string = null;
        return false;
      }, null, "get$moveNext", 0, 0, null],
      $isIterator: 1,
      $asIterator: function() {
        return [P.Match];
      },
      static: {
        _AllMatchesIterator$: [function(_regExp, _string, _nextIndex) {
          return new H._AllMatchesIterator(_regExp, _string, _nextIndex, []);
        }, null, null, 12, 0, null, 656, 304, 670]
      }
    },
    StringMatch: {
      "^": "Object;start>,input<,pattern>,$ti",
      get$end: [function() {
        return J.$add$ansx(this.start, J.get$length$asx(this.pattern));
      }, null, null, 2, 0, null],
      $index: [function(_, g) {
        return this.group$1(H.intTypeCheck(g));
      }, null, "get$[]", 5, 0, null, 391],
      group$1: [function(group_) {
        H.intTypeCheck(group_);
        if (group_ !== 0)
          throw H.wrapException(P.RangeError$value(group_, null, null));
        return this.pattern;
      }, null, "get$group", 4, 0, null, 890],
      $isMatch: 1,
      static: {
        StringMatch$: [function(start, input, pattern) {
          return new H.StringMatch(start, input, pattern, []);
        }, null, null, 12, 0, null, 5, 55, 36]
      }
    },
    _StringAllMatchesIterable: {
      "^": "Iterable;_input,_pattern,__js_helper$_index,$ti",
      get$iterator: [function(_) {
        return H._StringAllMatchesIterator$(this._input, this._pattern, this.__js_helper$_index);
      }, null, null, 3, 0, null],
      get$first: [function(_) {
        var t1, t2, index;
        t1 = this._input;
        t2 = this._pattern;
        index = H.intTypeCheck(H.stringIndexOfStringUnchecked(t1, t2, this.__js_helper$_index));
        if (typeof index !== "number")
          return index.$ge();
        if (index >= 0)
          return H.StringMatch$(index, t1, t2);
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, null, 3, 0, null],
      $asIterable: function() {
        return [P.Match];
      },
      static: {
        _StringAllMatchesIterable$: [function(_input, _pattern, _index) {
          return new H._StringAllMatchesIterable(_input, _pattern, _index, []);
        }, null, null, 12, 0, null, 375, 320, 378]
      }
    },
    _StringAllMatchesIterator: {
      "^": "Object;_input,_pattern,__js_helper$_index,0__js_helper$_current,$ti",
      moveNext$0: [function() {
        var t1, t2, t3, t4, index, t5, end;
        t1 = this._pattern;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._input;
        t4 = J.getInterceptor$asx(t3);
        if (J.$gt$n(J.$add$ansx(this.__js_helper$_index, t2.get$length(t1)), t4.get$length(t3))) {
          this.__js_helper$_current = null;
          return false;
        }
        index = H.stringIndexOfStringUnchecked(t3, t1, this.__js_helper$_index);
        t5 = J.getInterceptor$n(index);
        if (H.boolTypeCheck(t5.$lt(index, 0))) {
          this.__js_helper$_index = H.intTypeCheck(J.$add$ansx(t4.get$length(t3), 1));
          this.__js_helper$_current = null;
          return false;
        }
        end = H.intTypeCheck(t5.$add(index, t2.get$length(t1)));
        this.__js_helper$_current = H.StringMatch$(H.intTypeCheck(index), t3, t1);
        t1 = this.__js_helper$_index;
        if (end == null ? t1 == null : end === t1) {
          if (typeof end !== "number")
            return end.$add();
          ++end;
        }
        this.__js_helper$_index = end;
        return true;
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return this.__js_helper$_current;
      }, null, null, 2, 0, null],
      $isIterator: 1,
      $asIterator: function() {
        return [P.Match];
      },
      static: {
        _StringAllMatchesIterator$: [function(_input, _pattern, _index) {
          return new H._StringAllMatchesIterator(_input, _pattern, _index, []);
        }, null, null, 12, 0, null, 375, 320, 378]
      }
    }
  }], ["dart._js_names", "dart:_js_names",, H, {
    "^": "",
    extractKeys: [function(victim) {
      return J.JSArray_JSArray$markFixed(victim ? Object.keys(victim) : [], null);
    }, null, null, 4, 0, null, 892],
    unmangleGlobalNameIfPreservedAnyways: [function($name) {
      return H.stringTypeCheck(H.JsCache_fetch(init.mangledGlobalNames, H.stringTypeCheck($name)));
    }, null, null, 4, 0, null, 8],
    unmangleAllIdentifiersIfPreservedAnyways: [function(str) {
      return function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(H.stringTypeCheck(str), init.mangledGlobalNames);
    }, null, null, 4, 0, null, 82],
    _LazyMangledNamesMap: {
      "^": "Object;$ti"
    },
    _LazyMangledInstanceNamesMap: {
      "^": "_LazyMangledNamesMap;$ti"
    },
    _LazyReflectiveNamesMap: {
      "^": "Object;$ti"
    }
  }], ["dart2js._js_primitives", "dart:_js_primitives",, H, {
    "^": "",
    printString: [function(string) {
      H.stringTypeCheck(string);
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }, null, null, 4, 0, null, 30]
  }], ["metadata", "dart:_metadata",, H, {
    "^": "",
    SupportedBrowser: {
      "^": "Object;$ti"
    },
    Experimental: {
      "^": "Object;$ti"
    },
    DomName: {
      "^": "Object;$ti"
    },
    DocsEditable: {
      "^": "Object;$ti"
    },
    Unstable: {
      "^": "Object;$ti"
    }
  }], ["dart.typed_data.implementation", "dart:_native_typed_data",, H, {
    "^": "",
    _checkLength: [function($length) {
      return typeof $length === "number" && Math.floor($length) === $length ? $length : H.throwExpression(P.ArgumentError$("Invalid length " + H.S($length)));
    }, null, null, 4, 0, null, 35],
    _checkViewArguments: [function(buffer, offsetInBytes, $length) {
      if (!J.getInterceptor$(buffer).$isNativeByteBuffer)
        throw H.wrapException(P.ArgumentError$("Invalid view buffer"));
      if (typeof offsetInBytes !== "number" || Math.floor(offsetInBytes) !== offsetInBytes)
        throw H.wrapException(P.ArgumentError$("Invalid view offsetInBytes " + H.S(offsetInBytes)));
      if ($length != null && (typeof $length !== "number" || Math.floor($length) !== $length))
        throw H.wrapException(P.ArgumentError$("Invalid view length " + H.S($length)));
    }, null, null, 12, 0, null, 216, 136, 35],
    _ensureNativeList: [function(list) {
      var t1, t2, result, i;
      H.listTypeCheck(list);
      t1 = J.getInterceptor$(list);
      if (!!t1.$isJSIndexable)
        return list;
      t2 = t1.get$length(list);
      if (typeof t2 !== "number")
        return H.iae(t2);
      result = new Array(t2);
      result.fixed$length = Array;
      i = 0;
      while (true) {
        t2 = t1.get$length(list);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        C.JSArray_methods.$indexSet(result, i, t1.$index(list, i));
        ++i;
      }
      return result;
    }, null, null, 4, 0, null, 68],
    NativeByteData_NativeByteData$view: [function(buffer, offsetInBytes, $length) {
      H.interceptedTypeCheck(buffer, "$isByteBuffer");
      H.intTypeCheck(offsetInBytes);
      H.intTypeCheck($length);
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? H.NativeByteData__create2(buffer, offsetInBytes) : H.NativeByteData__create3(buffer, offsetInBytes, $length);
    }, null, null, 12, 0, null, 216, 136, 35],
    NativeByteData__create2: [function(arg1, arg2) {
      return new DataView(arg1, arg2);
    }, null, null, 8, 0, null, 91, 126],
    NativeByteData__create3: [function(arg1, arg2, arg3) {
      return new DataView(arg1, arg2, arg3);
    }, null, null, 12, 0, null, 91, 126, 291],
    NativeFloat32List_NativeFloat32List: [function($length) {
      return H.NativeFloat32List__create1(H._checkLength(H.intTypeCheck($length)));
    }, null, null, 4, 0, null, 35],
    NativeFloat32List__create1: [function(arg) {
      return new Float32Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeFloat64List__create1: [function(arg) {
      return new Float64Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeInt16List__create1: [function(arg) {
      return new Int16Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeInt32List__create1: [function(arg) {
      return new Int32Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeInt8List_NativeInt8List$fromList: [function(elements) {
      return H.NativeInt8List__create1(H._ensureNativeList(H.assertSubtype(elements, "$isList", [P.int], "$asList")));
    }, null, null, 4, 0, null, 80],
    NativeInt8List__create1: [function(arg) {
      return new Int8Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeUint16List__create1: [function(arg) {
      return new Uint16Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeUint32List_NativeUint32List$fromList: [function(elements) {
      return H.NativeUint32List__create1(H._ensureNativeList(H.assertSubtype(elements, "$isList", [P.int], "$asList")));
    }, null, null, 4, 0, null, 80],
    NativeUint32List__create1: [function(arg) {
      return new Uint32Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeUint8ClampedList__create1: [function(arg) {
      return new Uint8ClampedArray(arg);
    }, null, null, 4, 0, null, 44],
    NativeUint8List_NativeUint8List: [function($length) {
      return H.NativeUint8List__create1(H._checkLength(H.intTypeCheck($length)));
    }, null, null, 4, 0, null, 35],
    NativeUint8List_NativeUint8List$fromList: [function(elements) {
      return H.NativeUint8List__create1(H._ensureNativeList(H.assertSubtype(elements, "$isList", [P.int], "$asList")));
    }, null, null, 4, 0, null, 80],
    NativeUint8List_NativeUint8List$view: [function(buffer, offsetInBytes, $length) {
      H.interceptedTypeCheck(buffer, "$isByteBuffer");
      H.intTypeCheck(offsetInBytes);
      H.intTypeCheck($length);
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? H.NativeUint8List__create2(buffer, offsetInBytes) : H.NativeUint8List__create3(buffer, offsetInBytes, $length);
    }, null, null, 12, 0, null, 216, 136, 35],
    NativeUint8List__create1: [function(arg) {
      return new Uint8Array(arg);
    }, null, null, 4, 0, null, 44],
    NativeUint8List__create2: [function(arg1, arg2) {
      return new Uint8Array(arg1, arg2);
    }, null, null, 8, 0, null, 91, 126],
    NativeUint8List__create3: [function(arg1, arg2, arg3) {
      return new Uint8Array(arg1, arg2, arg3);
    }, null, null, 12, 0, null, 91, 126, 291],
    _isInvalidArrayIndex: [function(index) {
      H.intTypeCheck(index);
      return index >>> 0 !== index;
    }, null, null, 4, 0, null, 6],
    _checkValidIndex: [function(index, list, $length) {
      var t1;
      H.intTypeCheck(index);
      H.listTypeCheck(list);
      H.intTypeCheck($length);
      if (!H._isInvalidArrayIndex(index)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = index >= $length;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseIndexError(list, index));
    }, null, null, 12, 0, null, 6, 68, 35],
    _checkValidRange: [function(start, end, $length) {
      var t1;
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      H.intTypeCheck($length);
      if (!H._isInvalidArrayIndex(start))
        if (end == null) {
          if (typeof start !== "number")
            return start.$gt();
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = start > $length;
        } else if (!H._isInvalidArrayIndex(end)) {
          if (typeof start !== "number")
            return start.$gt();
          if (!(start > end)) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = end > $length;
          } else
            t1 = true;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      if (end == null)
        return $length;
      return end;
    }, null, null, 12, 0, null, 5, 7, 35],
    NativeByteBuffer: {
      "^": "Interceptor;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_ByteBuffer_RkP;
      }, null, null, 3, 0, null],
      asUint8List$2: [function(receiver, offsetInBytes, $length) {
        return H.NativeUint8List_NativeUint8List$view(receiver, H.intTypeCheck(offsetInBytes), H.intTypeCheck($length));
      }, null, "get$asUint8List", 1, 4, null, 16, 0, 136, 35],
      asByteData$2: [function(receiver, offsetInBytes, $length) {
        return H.NativeByteData_NativeByteData$view(receiver, H.intTypeCheck(offsetInBytes), H.intTypeCheck($length));
      }, null, "get$asByteData", 1, 4, null, 16, 0, 136, 35],
      $isNativeByteBuffer: 1,
      $isByteBuffer: 1,
      "%": "ArrayBuffer"
    },
    NativeFloat32x4List: {
      "^": "_NativeFloat32x4List_Object_ListMixin_FixedLengthListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.Float32x4];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Float32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float32x4];
      },
      $isTypedData: 1,
      $isFloat32x4List: 1
    },
    NativeInt32x4List: {
      "^": "_NativeInt32x4List_Object_ListMixin_FixedLengthListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.Int32x4];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Int32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Int32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Int32x4];
      },
      $isTypedData: 1,
      $isInt32x4List: 1
    },
    NativeFloat64x2List: {
      "^": "_NativeFloat64x2List_Object_ListMixin_FixedLengthListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.Float64x2];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Float64x2];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float64x2];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float64x2];
      },
      $isTypedData: 1,
      $isFloat64x2List: 1
    },
    NativeTypedData: {
      "^": "Interceptor;0buffer=,$ti",
      _invalidPosition$3: [function(receiver, position, $length, $name) {
        H.intTypeCheck(position);
        H.intTypeCheck($length);
        H.stringTypeCheck($name);
        if (typeof position !== "number" || Math.floor(position) !== position)
          throw H.wrapException(P.ArgumentError$value(position, $name, "Invalid list position"));
        else
          throw H.wrapException(P.RangeError$range(position, 0, $length, $name, null));
      }, null, "get$_invalidPosition", 13, 0, null, 69, 35, 8],
      _checkPosition$3: [function(receiver, position, $length, $name) {
        var t1;
        H.intTypeCheck(position);
        H.intTypeCheck($length);
        H.stringTypeCheck($name);
        if (!(position >>> 0 !== position)) {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = position > $length;
        } else
          t1 = true;
        if (t1)
          this._invalidPosition$3(receiver, position, $length, $name);
      }, null, "get$_checkPosition", 13, 0, null, 69, 35, 8],
      $isNativeTypedData: 1,
      $isTypedData: 1,
      "%": ";ArrayBufferView;NativeTypedArray|_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin|_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|_NativeTypedArrayOfInt_NativeTypedArray_ListMixin|_NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfInt"
    },
    NativeByteData: {
      "^": "NativeTypedData;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_ByteData_zNC;
      }, null, null, 3, 0, null],
      getUint32$2: [function(receiver, byteOffset, endian) {
        return this._getUint32$2(receiver, H.intTypeCheck(byteOffset), C.Endian_true === H.interceptedTypeCheck(endian, "$isEndian"));
      }, null, "get$getUint32", 5, 2, null, 940, 396, 1005],
      _getUint32$2: [function(receiver, byteOffset, littleEndian) {
        return receiver.getUint32(H.intTypeCheck(byteOffset), H.boolTypeCheck(littleEndian));
      }, null, "get$_getUint32", 5, 2, null, 0, 396, 1032],
      $isNativeByteData: 1,
      $isByteData: 1,
      "%": "DataView"
    },
    NativeTypedArray: {
      "^": "NativeTypedData;$ti",
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      _setRangeFast$4: [function(receiver, start, end, source, skipCount) {
        var targetLength, count, sourceLength;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.interceptedTypeCheck(source, "$isNativeTypedArray");
        H.intTypeCheck(skipCount);
        targetLength = receiver.length;
        this._checkPosition$3(receiver, start, targetLength, "start");
        this._checkPosition$3(receiver, end, targetLength, "end");
        if (typeof start !== "number")
          return start.$gt();
        if (typeof end !== "number")
          return H.iae(end);
        if (start > end)
          throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
        count = end - start;
        if (typeof skipCount !== "number")
          return skipCount.$lt();
        if (skipCount < 0)
          throw H.wrapException(P.ArgumentError$(skipCount));
        sourceLength = source.length;
        if (sourceLength - skipCount < count)
          throw H.wrapException(P.StateError$("Not enough elements"));
        if (skipCount !== 0 || sourceLength !== count)
          source = source.subarray(skipCount, skipCount + count);
        receiver.set(source, start);
      }, null, "get$_setRangeFast", 17, 0, null, 5, 7, 11, 87],
      $isJSIndexable: 1,
      $asJSIndexable: Isolate.functionThatReturnsNull,
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: Isolate.functionThatReturnsNull,
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull
    },
    NativeTypedArrayOfDouble: {
      "^": "_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin;$ti",
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.doubleTypeCheck(value);
        H._checkValidIndex(index, receiver, receiver.length);
        receiver[index] = value;
      }, null, "get$[]=", 9, 0, null, 6, 1],
      setRange$4: [function(receiver, start, end, iterable, skipCount) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [P.double], "$asIterable");
        H.intTypeCheck(skipCount);
        if (!!J.getInterceptor$(iterable).$isNativeTypedArrayOfDouble) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.double];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $asList: function() {
        return [P.double];
      }
    },
    NativeTypedArrayOfInt: {
      "^": "_NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin;$ti",
      $indexSet: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.intTypeCheck(value);
        H._checkValidIndex(index, receiver, receiver.length);
        receiver[index] = value;
      }, null, "get$[]=", 9, 0, null, 6, 1],
      setRange$4: [function(receiver, start, end, iterable, skipCount) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [P.int], "$asIterable");
        H.intTypeCheck(skipCount);
        if (!!J.getInterceptor$(iterable).$isNativeTypedArrayOfInt) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.int];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      }
    },
    NativeFloat32List: {
      "^": "NativeTypedArrayOfDouble;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Float32List_LB7;
      }, null, null, 3, 0, null],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeFloat32List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeFloat32List: 1,
      $is_TypedFloatList: 1,
      $isFloat32List: 1,
      "%": "Float32Array"
    },
    NativeFloat64List: {
      "^": "NativeTypedArrayOfDouble;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Float64List_LB7;
      }, null, null, 3, 0, null],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeFloat64List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeFloat64List: 1,
      $is_TypedFloatList: 1,
      $isFloat64List: 1,
      "%": "Float64Array"
    },
    NativeInt16List: {
      "^": "NativeTypedArrayOfInt;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Int16List_uXf;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeInt16List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeInt16List: 1,
      $is_TypedIntList: 1,
      $isInt16List: 1,
      "%": "Int16Array"
    },
    NativeInt32List: {
      "^": "NativeTypedArrayOfInt;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Int32List_O50;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeInt32List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeInt32List: 1,
      $is_TypedIntList: 1,
      $isInt32List: 1,
      "%": "Int32Array"
    },
    NativeInt8List: {
      "^": "NativeTypedArrayOfInt;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Int8List_ekJ;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeInt8List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeInt8List: 1,
      $is_TypedIntList: 1,
      $isInt8List: 1,
      "%": "Int8Array"
    },
    NativeUint16List: {
      "^": "NativeTypedArrayOfInt;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint16List_2bx;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeUint16List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeUint16List: 1,
      $is_TypedIntList: 1,
      $isUint16List: 1,
      "%": "Uint16Array"
    },
    NativeUint32List: {
      "^": "NativeTypedArrayOfInt;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint32List_2bx;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeUint32List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeUint32List: 1,
      $is_TypedIntList: 1,
      $isUint32List: 1,
      "%": "Uint32Array"
    },
    NativeUint8ClampedList: {
      "^": "NativeTypedArrayOfInt;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint8ClampedList_Jik;
      }, null, null, 3, 0, null],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeUint8ClampedList__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeUint8ClampedList: 1,
      $is_TypedIntList: 1,
      $isUint8ClampedList: 1,
      "%": "CanvasPixelArray|Uint8ClampedArray"
    },
    NativeUint8List: {
      "^": "NativeTypedArrayOfInt;$ti",
      get$runtimeType: [function(receiver) {
        return C.Type_Uint8List_WLA;
      }, null, null, 3, 0, null],
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      sublist$2: [function(receiver, start, end) {
        H.intTypeCheck(start);
        return H.NativeUint8List__create1(receiver.subarray(start, H._checkValidRange(start, H.intTypeCheck(end), receiver.length)));
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      $isNativeUint8List: 1,
      $is_TypedIntList: 1,
      $isUint8List: 1,
      "%": ";Uint8Array"
    },
    NativeFloat32x4: {
      "^": "Object;$ti",
      $isFloat32x4: 1
    },
    NativeInt32x4: {
      "^": "Object;$ti",
      $isInt32x4: 1
    },
    NativeFloat64x2: {
      "^": "Object;$ti",
      $isFloat64x2: 1
    },
    _NativeFloat32x4List_Object_ListMixin: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Float32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float32x4];
      }
    },
    _NativeFloat32x4List_Object_ListMixin_FixedLengthListMixin: {
      "^": "_NativeFloat32x4List_Object_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.Float32x4];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Float32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float32x4];
      }
    },
    _NativeFloat64x2List_Object_ListMixin: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Float64x2];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float64x2];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float64x2];
      }
    },
    _NativeFloat64x2List_Object_ListMixin_FixedLengthListMixin: {
      "^": "_NativeFloat64x2List_Object_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.Float64x2];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Float64x2];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float64x2];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float64x2];
      }
    },
    _NativeInt32x4List_Object_ListMixin: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Int32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Int32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Int32x4];
      }
    },
    _NativeInt32x4List_Object_ListMixin_FixedLengthListMixin: {
      "^": "_NativeInt32x4List_Object_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.Int32x4];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Int32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Int32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Int32x4];
      }
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: {
      "^": "NativeTypedArray+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $asList: function() {
        return [P.double];
      }
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: {
      "^": "_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin+FixedLengthListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.double];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $asList: function() {
        return [P.double];
      }
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: {
      "^": "NativeTypedArray+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      }
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: {
      "^": "_NativeTypedArrayOfInt_NativeTypedArray_ListMixin+FixedLengthListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isFixedLengthListMixin: 1,
      $asFixedLengthListMixin: function() {
        return [P.int];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      }
    }
  }], ["dart.async", "dart:async",, P, {
    "^": "",
    _AsyncRun__scheduleImmediate: [function(callback) {
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      $.$get$_AsyncRun__scheduleImmediateClosure().call$1(callback);
    }, null, null, 4, 0, null, 43],
    _AsyncRun__initializeScheduleImmediate: [function() {
      var t1, div, span;
      t1 = {};
      H.requiresPreamble();
      if (self.scheduleImmediate != null)
        return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
    }, null, null, 0, 0, null],
    _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
      self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    }, "call$1", "async__AsyncRun__scheduleImmediateJsOverride$closure", 4, 0, 40, 43],
    _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
      self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    }, "call$1", "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", 4, 0, 40, 43],
    _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
      P.Timer__createTimer(C.Duration_0, H.functionTypeCheck(callback, {func: 1, ret: -1}));
    }, "call$1", "async__AsyncRun__scheduleImmediateWithTimer$closure", 4, 0, 40, 43],
    Timer__createTimer: [function(duration, callback) {
      var milliseconds;
      H.interceptedTypeCheck(duration, "$isDuration");
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      milliseconds = duration.get$inMilliseconds();
      if (typeof milliseconds !== "number")
        return milliseconds.$lt();
      if (milliseconds < 0)
        milliseconds = 0;
      return P._TimerImpl$(milliseconds, callback);
    }, null, null, 8, 0, null, 208, 43],
    _hasTimer: [function() {
      H.requiresPreamble();
      return self.setTimeout != null;
    }, null, null, 0, 0, null],
    _makeAsyncAwaitCompleter: [1, function($T) {
      return P._AsyncAwaitCompleter$($T);
    }, function() {
      return P._makeAsyncAwaitCompleter(null);
    }, null, "call$0", null, 0, 0, null],
    _asyncStartSync: [function(bodyFunction, completer) {
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      H.interceptedTypeCheck(completer, "$is_AsyncAwaitCompleter");
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer.get$future();
    }, null, null, 8, 0, null, 285, 284],
    _asyncAwait: [function(object, bodyFunction) {
      P._awaitOnObject(object, H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]}));
    }, null, null, 8, 0, null, 9, 285],
    _asyncReturn: [function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").complete$1(0, object);
    }, null, null, 8, 0, null, 9, 284],
    _asyncRethrow: [function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").completeError$2(H.unwrapException(object), H.getTraceFromException(object));
    }, null, null, 8, 0, null, 9, 284],
    _awaitOnObject: [function(object, bodyFunction) {
      var thenCallback, errorCallback, t1, t2, future;
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      thenCallback = new P._awaitOnObject_closure(bodyFunction);
      errorCallback = new P._awaitOnObject_closure0(bodyFunction);
      t1 = J.getInterceptor$(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$1$2(H.functionTypeCheck(thenCallback, {func: 1, ret: {futureOr: 1}, args: [,]}), errorCallback, null);
      else {
        t2 = {func: 1, ret: {futureOr: 1}, args: [,]};
        if (!!t1.$isFuture)
          object.then$1$2$onError(H.functionTypeCheck(thenCallback, t2), errorCallback, null);
        else {
          future = P._Future$(null);
          future._setValue$1(object);
          future._thenNoZoneRegistration$1$2(H.functionTypeCheck(thenCallback, t2), null, null);
        }
      }
    }, null, null, 8, 0, null, 9, 285],
    _wrapJsFunctionForAsync: [function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      return P.Zone_current().registerBinaryCallback$3$1(new P._wrapJsFunctionForAsync_closure($protected), P.Null, P.int, null);
    }, null, null, 4, 0, null, 64],
    _makeSyncStarIterable: [1, function(body, $T) {
      return P._SyncStarIterable$(body, $T);
    }, function(body) {
      return P._makeSyncStarIterable(body, null);
    }, null, "call$1", null, 4, 0, null, 201],
    _rethrow: [function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      error = H.wrapException(error);
      error.stack = J.toString$0$(stackTrace);
      throw error;
    }, null, null, 8, 0, null, 14, 20],
    Future_Future: [function(computation, $T) {
      var result;
      H.functionTypeCheck(computation, {func: 1, ret: {futureOr: 1, type: $T}});
      result = P._Future$($T);
      P.Timer_run(new P.Future_Future_closure(result, computation));
      return result;
    }, null, null, 4, 0, null, 419],
    Future_Future$sync: [function(computation, $T) {
      var result, error, stackTrace, future, replacement, t1, exception, replacement0;
      H.functionTypeCheck(computation, {func: 1, ret: {futureOr: 1, type: $T}});
      try {
        result = computation.call$0();
        t1 = result;
        if (H.checkSubtype(t1, "$isFuture", [$T], "$asFuture"))
          return result;
        else if (!!J.getInterceptor$(result).$isFuture) {
          t1 = P._Future$immediate(result, $T);
          return t1;
        } else {
          t1 = P._Future$value(H.assertSubtypeOfRuntimeType(result, $T), $T);
          return t1;
        }
      } catch (exception) {
        error = H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        future = P._Future$($T);
        replacement0 = P.Zone_current().errorCallback$2(error, stackTrace);
        replacement = replacement0;
        if (replacement != null)
          future._asyncCompleteError$2(P._nonNullError(J.get$error$z(replacement)), replacement.get$stackTrace());
        else
          future._asyncCompleteError$2(error, stackTrace);
        return future;
      }
    }, null, null, 4, 0, null, 419],
    Future_Future$value: [function(value, $T) {
      return P._Future$immediate(H.futureOrCheck(value, {futureOr: 1, type: $T}), $T);
    }, null, null, 0, 2, null, 0, 1],
    Future_Future$error: [function(error, stackTrace, $T) {
      var replacement;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      error = P._nonNullError(error);
      if (P.Zone_current() !== C.C__RootZone) {
        replacement = P.Zone_current().errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = P._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
      }
      return P._Future$immediateError(error, stackTrace, $T);
    }, null, null, 4, 2, null, 0, 14, 20],
    Future_wait: [1, function(futures, cleanUp, eagerError, $T) {
      var _box_0, result, handleError, future, pos, e, st, t1, t2, exception;
      _box_0 = {};
      H.assertSubtype(futures, "$isIterable", [[P.Future, $T]], "$asIterable");
      H.boolTypeCheck(eagerError);
      H.functionTypeCheck(cleanUp, {func: 1, ret: -1, args: [$T]});
      t1 = [P.List, $T];
      result = P._Future$(t1);
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.error = null;
      _box_0.stackTrace = null;
      handleError = new P.Future_wait_handleError(_box_0, cleanUp, eagerError, result);
      try {
        for (t2 = J.get$iterator$ax(futures); t2.moveNext$0();) {
          future = t2.get$current();
          pos = _box_0.remaining;
          future.then$1$2$onError(new P.Future_wait_closure(_box_0, pos, result, cleanUp, eagerError, $T), handleError, null);
          _box_0.remaining = J.$add$ansx(_box_0.remaining, 1);
        }
        if (J.$eq$(_box_0.remaining, 0)) {
          t2 = P.Future_Future$value(C.List_empty2, t1);
          return t2;
        }
        t2 = _box_0.remaining;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = new Array(t2);
        t2.fixed$length = Array;
        _box_0.values = H.setRuntimeTypeInfo(t2, [$T]);
      } catch (exception) {
        e = H.unwrapException(exception);
        st = H.getTraceFromException(exception);
        if (J.$eq$(_box_0.remaining, 0) || eagerError)
          return P.Future_Future$error(e, st, t1);
        else {
          _box_0.error = e;
          _box_0.stackTrace = st;
        }
      }
      return result;
    }, function(futures, cleanUp, eagerError) {
      return P.Future_wait(futures, cleanUp, eagerError, null);
    }, null, "call$3$cleanUp$eagerError", null, 4, 5, null, 0, 18, 602, 603, 604],
    Future_forEach: [1, function(elements, action, $T) {
      H.assertSubtype(elements, "$isIterable", [$T], "$asIterable");
      H.functionTypeCheck(action, {func: 1, ret: {futureOr: 1}, args: [$T]});
      return P.Future_doWhile(new P.Future_forEach_closure(J.get$iterator$ax(elements), action));
    }, function(elements, action) {
      return P.Future_forEach(elements, action, null);
    }, null, "call$2", null, 8, 0, null, 80, 63],
    Future__kTrue: [function(_) {
      return true;
    }, "call$1", "async_Future__kTrue$closure", 4, 0, 17, 12],
    Future_doWhile: [function(action) {
      var t1, doneSignal, nextIteration;
      t1 = {};
      H.functionTypeCheck(action, {func: 1, ret: {futureOr: 1, type: P.bool}});
      doneSignal = P._Future$(null);
      t1.nextIteration = null;
      nextIteration = P.Zone_current().bindUnaryCallbackGuarded$1$1(new P.Future_doWhile_closure(t1, action, doneSignal), P.bool);
      t1.nextIteration = nextIteration;
      nextIteration.call$1(true);
      return doneSignal;
    }, null, null, 4, 0, null, 63],
    Completer_Completer: [function($T) {
      return P._AsyncCompleter$($T);
    }, null, null, 0, 0, null],
    Completer_Completer$sync: [function($T) {
      return P._SyncCompleter$($T);
    }, null, null, 0, 0, null],
    _completeWithErrorCallback: [function(result, error, stackTrace) {
      var t1, replacement;
      H.interceptedTypeCheck(result, "$is_Future");
      t1 = P.Zone_current();
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      replacement = t1.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = P._nonNullError(replacement.error);
        stackTrace = replacement.stackTrace;
      }
      result._completeError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
    }, null, null, 12, 0, null, 59, 14, 20],
    _asyncCompleteWithErrorCallback: [function(result, error, stackTrace) {
      var t1, replacement;
      H.interceptedTypeCheck(result, "$is_Future");
      t1 = P.Zone_current();
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      replacement = t1.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = P._nonNullError(replacement.error);
        stackTrace = replacement.stackTrace;
      }
      result._asyncCompleteError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
    }, null, null, 12, 0, null, 59, 14, 20],
    _nonNullError: [function(error) {
      return error == null ? P.NullThrownError$() : error;
    }, null, null, 4, 0, null, 14],
    _registerErrorHandler: [function(errorHandler, zone) {
      H.interceptedTypeCheck(errorHandler, "$isFunction");
      H.interceptedTypeCheck(zone, "$isZone");
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object, P.StackTrace]}))
        return zone.registerBinaryCallback$3$1(errorHandler, null, P.Object, P.StackTrace);
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object]}))
        return zone.registerUnaryCallback$2$1(errorHandler, null, P.Object);
      throw H.wrapException(P.ArgumentError$value(errorHandler, "onError", "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a a valid result"));
    }, null, null, 8, 0, null, 626, 122],
    _microtaskLoop: [function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = t1.next;
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.callback.call$0();
      }
    }, null, null, 0, 0, null],
    _startMicrotaskLoop: [function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          P._AsyncRun__scheduleImmediate(P.async___startMicrotaskLoop$closure());
      }
    }, "call$0", "async___startMicrotaskLoop$closure", 0, 0, 0],
    _scheduleAsyncCallback: [function(callback) {
      var newEntry = P._AsyncCallbackEntry$(H.functionTypeCheck(callback, {func: 1, ret: -1}));
      if ($._nextCallback == null) {
        $._lastCallback = newEntry;
        $._nextCallback = newEntry;
        if (!$._isInCallbackLoop)
          P._AsyncRun__scheduleImmediate(P.async___startMicrotaskLoop$closure());
      } else {
        $._lastCallback.set$next(newEntry);
        $._lastCallback = newEntry;
      }
    }, null, null, 4, 0, null, 43],
    _schedulePriorityAsyncCallback: [function(callback) {
      var entry, t1;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      if ($._nextCallback == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = P._AsyncCallbackEntry$(callback);
      t1 = $._lastPriorityCallback;
      if (t1 == null) {
        entry.next = H.interceptedTypeCheck($._nextCallback, "$is_AsyncCallbackEntry");
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = H.interceptedTypeCheck(t1.get$next(), "$is_AsyncCallbackEntry");
        $._lastPriorityCallback.set$next(entry);
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }, null, null, 4, 0, null, 43],
    scheduleMicrotask: [function(callback) {
      var currentZone;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      currentZone = H.interceptedTypeCheck(P.Zone_current(), "$is_Zone");
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
        return;
      }
      if (C.C__RootZone === currentZone.get$_scheduleMicrotask().zone && C.C__RootZone.inSameErrorZone$1(currentZone)) {
        P._rootScheduleMicrotask(null, null, currentZone, currentZone.registerCallback$1$1(callback, -1));
        return;
      }
      P.Zone_current().scheduleMicrotask$1(P.Zone_current().bindCallbackGuarded$1(callback));
    }, null, null, 4, 0, null, 43],
    Stream_Stream$fromIterable: [function(elements, $T) {
      return P._GeneratedStreamImpl$(new P.Stream_Stream$fromIterable_closure(H.assertSubtype(elements, "$isIterable", [$T], "$asIterable"), $T), $T);
    }, null, null, 4, 0, null, 80],
    Stream_Stream$eventTransformed: [function(source, mapSink, $T) {
      return P._BoundSinkStream$(H.interceptedTypeCheck(source, "$isStream"), H.functionTypeCheck(mapSink, {func: 1, ret: [P.EventSink,,], args: [[P.EventSink, $T]]}), null, $T);
    }, null, null, 8, 0, null, 11, 629],
    StreamIterator_StreamIterator: [function(stream, $T) {
      return P._StreamIterator$(H.assertSubtype(stream, "$isStream", [$T], "$asStream"), $T);
    }, null, null, 4, 0, null, 57],
    StreamController_StreamController: [function(onCancel, onListen, onPause, onResume, sync, $T) {
      var t1 = {func: 1, ret: -1};
      H.functionTypeCheck(onListen, t1);
      H.functionTypeCheck(onPause, t1);
      H.functionTypeCheck(onResume, t1);
      H.functionTypeCheck(onCancel, {func: 1});
      return H.boolTypeCheck(sync) ? P._SyncStreamController$(onListen, onPause, onResume, onCancel, $T) : P._AsyncStreamController$(onListen, onPause, onResume, onCancel, $T);
    }, null, null, 0, 11, null, 0, 0, 0, 0, 18, 139, 138, 277, 276, 275],
    StreamController_StreamController$broadcast: [function(onCancel, onListen, sync, $T) {
      var t1 = {func: 1, ret: -1};
      H.functionTypeCheck(onListen, t1);
      H.functionTypeCheck(onCancel, t1);
      return H.boolTypeCheck(sync) ? P._SyncBroadcastStreamController$(onListen, onCancel, $T) : P._AsyncBroadcastStreamController$(onListen, onCancel, $T);
    }, null, null, 0, 7, null, 0, 0, 18, 139, 138, 275],
    _runGuarded: [function(notificationHandler) {
      var e, s, exception;
      H.functionTypeCheck(notificationHandler, {func: 1});
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P.Zone_current().handleUncaughtError$2(e, s);
      }
    }, null, null, 4, 0, null, 634],
    _nullDataHandler: [function(value) {
    }, "call$1", "async___nullDataHandler$closure", 4, 0, 2, 1],
    _nullErrorHandler: [function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      P.Zone_current().handleUncaughtError$2(error, stackTrace);
    }, function(error) {
      return P._nullErrorHandler(error, null);
    }, "call$2", "call$1", "async___nullErrorHandler$closure", 4, 2, 5, 0, 14, 20],
    _nullDoneHandler: [function() {
    }, "call$0", "async___nullDoneHandler$closure", 0, 0, 0],
    _cancelAndValue: [function(subscription, future, value) {
      var cancelFuture;
      H.interceptedTypeCheck(subscription, "$isStreamSubscription");
      H.interceptedTypeCheck(future, "$is_Future");
      cancelFuture = subscription.cancel$0();
      if (!!J.getInterceptor$(cancelFuture).$isFuture && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
      else
        future._complete$1(value);
    }, null, null, 12, 0, null, 88, 318, 1],
    _addErrorWithReplacement: [function(sink, error, stackTrace) {
      var t1, replacement;
      H.interceptedTypeCheck(sink, "$is_EventSink");
      t1 = P.Zone_current();
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      replacement = t1.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = P._nonNullError(replacement.error);
        stackTrace = replacement.stackTrace;
      }
      sink._addError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
    }, null, null, 12, 0, null, 48, 14, 20],
    Timer_Timer: [function(duration, callback) {
      H.interceptedTypeCheck(duration, "$isDuration");
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      if (J.$eq$(P.Zone_current(), C.C__RootZone))
        return P.Zone_current().createTimer$2(duration, callback);
      return P.Zone_current().createTimer$2(duration, P.Zone_current().bindCallbackGuarded$1(callback));
    }, null, null, 8, 0, null, 208, 43],
    Timer_run: [function(callback) {
      P.Timer_Timer(C.Duration_0, H.functionTypeCheck(callback, {func: 1, ret: -1}));
    }, null, null, 4, 0, null, 43],
    Zone_current: [function() {
      return $.Zone__current;
    }, null, null, 2, 0, null],
    Zone__enter: [function(zone) {
      var previous;
      H.interceptedTypeCheck(zone, "$isZone");
      previous = $.Zone__current;
      $.Zone__current = zone;
      return previous;
    }, null, null, 4, 0, null, 122],
    Zone__leave: [function(previous) {
      $.Zone__current = H.interceptedTypeCheck(previous, "$isZone");
    }, null, null, 4, 0, null, 658],
    _rootHandleUncaughtError: [function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
    }, null, null, 20, 0, null, 168, 24, 122, 14, 20],
    _rootRun: [1, function($self, $parent, zone, f, $R) {
      var old, t1;
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      H.functionTypeCheck(f, {func: 1, ret: $R});
      if (J.$eq$($.Zone__current, zone))
        return f.call$0();
      old = P.Zone__enter(zone);
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        P.Zone__leave(old);
      }
    }, function($self, $parent, zone, f) {
      return P._rootRun($self, $parent, zone, f, null);
    }, null, "call$4", null, 16, 0, null, 168, 24, 122, 15],
    _rootRunUnary: [1, function($self, $parent, zone, f, arg, $R, $T) {
      var old, t1;
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      if (J.$eq$($.Zone__current, zone))
        return f.call$1(arg);
      old = P.Zone__enter(zone);
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        P.Zone__leave(old);
      }
    }, function($self, $parent, zone, f, arg) {
      return P._rootRunUnary($self, $parent, zone, f, arg, null, null);
    }, null, "call$5", null, 20, 0, null, 168, 24, 122, 15, 44],
    _rootRunBinary: [1, function($self, $parent, zone, f, arg1, arg2, $R, T1, T2) {
      var old, t1;
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      if (J.$eq$($.Zone__current, zone))
        return f.call$2(arg1, arg2);
      old = P.Zone__enter(zone);
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        P.Zone__leave(old);
      }
    }, function($self, $parent, zone, f, arg1, arg2) {
      return P._rootRunBinary($self, $parent, zone, f, arg1, arg2, null, null, null);
    }, null, "call$6", null, 24, 0, null, 168, 24, 122, 15, 91, 126],
    _rootScheduleMicrotask: [function($self, $parent, zone, f) {
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      H.functionTypeCheck(f, {func: 1, ret: -1});
      if (C.C__RootZone !== zone)
        f = !C.C__RootZone.inSameErrorZone$1(zone) ? zone.bindCallbackGuarded$1(f) : zone.bindCallback$1$1(f, -1);
      P._scheduleAsyncCallback(f);
    }, "call$4", "async___rootScheduleMicrotask$closure", 16, 0, 210, 168, 24, 122, 15],
    _AsyncRun__initializeScheduleImmediate_internalCallback: {
      "^": "Closure:4;_box_0,$ti",
      call$1: [function(_) {
        var t1, f;
        t1 = this._box_0;
        f = t1.storedCallback;
        t1.storedCallback = null;
        f.call$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    _AsyncRun__initializeScheduleImmediate_closure: {
      "^": "Closure:123;_box_0,div,span,$ti",
      call$1: [function(callback) {
        var t1, t2;
        this._box_0.storedCallback = H.functionTypeCheck(callback, {func: 1, ret: -1});
        t1 = this.div;
        t2 = this.span;
        t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
      }, null, null, 4, 0, null, 43, "call"]
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
      "^": "Closure:1;callback,$ti",
      call$0: [function() {
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
      "^": "Closure:1;callback,$ti",
      call$0: [function() {
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _TimerImpl: {
      "^": "Object;_once,0_handle,_tick,$ti",
      set$_handle: function(_handle) {
        this._handle = H.intTypeCheck(_handle);
      },
      set$_tick: function(_tick) {
        this._tick = H.intTypeCheck(_tick);
      },
      _TimerImpl$2: [function(milliseconds, callback) {
        if (P._hasTimer())
          this._handle = self.setTimeout(H.convertDartClosureToJS(new P._TimerImpl_internalCallback(this, callback), 0), milliseconds);
        else
          throw H.wrapException(P.UnsupportedError$("`setTimeout()` not found."));
      }, null, null, 8, 0, null, 236, 43],
      cancel$0: [function() {
        if (P._hasTimer()) {
          var t1 = this._handle;
          if (t1 == null)
            return;
          if (this._once)
            self.clearTimeout(t1);
          else
            self.clearInterval(t1);
          this._handle = null;
        } else
          throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
      }, null, "get$cancel", 0, 0, null],
      $isTimer: 1,
      static: {
        _TimerImpl$: [function(milliseconds, callback) {
          var t1 = new P._TimerImpl(true, 0, []);
          t1._TimerImpl$2(milliseconds, callback);
          return t1;
        }, null, null, 8, 0, null, 236, 43]
      }
    },
    _TimerImpl_internalCallback: {
      "^": "Closure:0;$this,callback,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.set$_handle(null);
        t1.set$_tick(1);
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _AsyncAwaitCompleter: {
      "^": "Object;_completer<,isSync,$ti",
      complete$1: [function(_, value) {
        var t1;
        H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
        if (this.isSync)
          J.complete$1$z(this._completer, value);
        else if (H.checkSubtype(value, "$isFuture", this.$ti, "$asFuture")) {
          t1 = this._completer;
          value.then$1$2$onError(J.get$complete$z(t1), t1.get$completeError(), -1);
        } else
          P.scheduleMicrotask(new P._AsyncAwaitCompleter_complete_closure(this, value));
      }, function($receiver) {
        return this.complete$1($receiver, null);
      }, "complete$0", "call$1", "call$0", "get$complete", 1, 2, 36, 0, 1],
      completeError$2: [function(e, st) {
        H.interceptedTypeCheck(st, "$isStackTrace");
        if (this.isSync)
          this._completer.completeError$2(e, st);
        else
          P.scheduleMicrotask(new P._AsyncAwaitCompleter_completeError_closure(this, e, st));
      }, function(e) {
        return this.completeError$2(e, null);
      }, "completeError$1", "call$2", "call$1", "get$completeError", 4, 2, 5, 0, 19, 662],
      get$future: [function() {
        return this._completer.get$future();
      }, null, null, 2, 0, null],
      get$isCompleted: [function() {
        return this._completer.get$isCompleted();
      }, null, null, 2, 0, null],
      $isCompleter: 1,
      static: {
        _AsyncAwaitCompleter$: [function($T) {
          return new P._AsyncAwaitCompleter(P.Completer_Completer$sync($T), false, [$T]);
        }, null, null, 0, 0, null]
      }
    },
    _AsyncAwaitCompleter_complete_closure: {
      "^": "Closure:1;$this,value,$ti",
      call$0: [function() {
        J.complete$1$z(this.$this.get$_completer(), this.value);
      }, null, null, 0, 0, null, "call"]
    },
    _AsyncAwaitCompleter_completeError_closure: {
      "^": "Closure:1;$this,e,st,$ti",
      call$0: [function() {
        this.$this.get$_completer().completeError$2(this.e, this.st);
      }, null, null, 0, 0, null, "call"]
    },
    _awaitOnObject_closure: {
      "^": "Closure:6;bodyFunction,$ti",
      call$1: [function(result) {
        return this.bodyFunction.call$2(0, result);
      }, null, null, 4, 0, null, 59, "call"]
    },
    _awaitOnObject_closure0: {
      "^": "Closure:59;bodyFunction,$ti",
      call$2: [function(error, stackTrace) {
        this.bodyFunction.call$2(1, H.ExceptionAndStackTrace$(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
      }, null, null, 8, 0, null, 14, 20, "call"]
    },
    _wrapJsFunctionForAsync_closure: {
      "^": "Closure:87;$protected,$ti",
      call$2: [function(errorCode, result) {
        this.$protected(H.intTypeCheck(errorCode), result);
      }, null, null, 8, 0, null, 663, 59, "call"]
    },
    _AsyncStarStreamController: {
      "^": "Object;$ti"
    },
    _IterationMarker: {
      "^": "Object;value>,state,$ti",
      toString$0: [function(_) {
        return "IterationMarker(" + H.S(this.state) + ", " + H.S(this.value) + ")";
      }, null, "get$toString", 1, 0, null],
      static: {
        _IterationMarker$_: [function(state, value) {
          return new P._IterationMarker(value, state, []);
        }, null, null, 8, 0, null, 78, 1],
        _IterationMarker_yieldStar: [function(values) {
          return P._IterationMarker$_(1, values);
        }, null, null, 4, 0, null, 347],
        _IterationMarker_endOfIteration: [function() {
          return C._IterationMarker_null_2;
        }, null, null, 0, 0, null],
        _IterationMarker_uncaughtError: [function(error) {
          return P._IterationMarker$_(3, error);
        }, null, null, 4, 0, null, 14]
      }
    },
    _SyncStarIterator: {
      "^": "Object;_body,0_async$_current,0_nestedIterator,0_suspendedBodies,$ti",
      set$_async$_current: function(_current) {
        this._async$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
      },
      get$current: [function() {
        var t1 = this._nestedIterator;
        if (t1 == null)
          return this._async$_current;
        return H.assertSubtypeOfRuntimeType(t1.get$current(), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 2, 0, null],
      _runBody$0: [function() {
        return function(body, SUCCESS, ERROR) {
          var errorValue,
            errorCode = SUCCESS;
          while (true)
            try {
              return body(errorCode, errorValue);
            } catch (error) {
              errorValue = error;
              errorCode = ERROR;
            }
        }(this._body, 0, 1);
      }, null, "get$_runBody", 0, 0, null],
      moveNext$0: [function() {
        var t1, value, state, inner;
        for (; true;) {
          t1 = this._nestedIterator;
          if (t1 != null)
            if (t1.moveNext$0())
              return true;
            else
              this._nestedIterator = null;
          value = this._runBody$0();
          if (value instanceof P._IterationMarker) {
            state = value.state;
            if (state === 2) {
              t1 = this._suspendedBodies;
              if (t1 == null || J.get$isEmpty$asx(t1)) {
                this.set$_async$_current(null);
                return false;
              }
              this._body = J.removeLast$0$ax(this._suspendedBodies);
              continue;
            } else {
              t1 = value.value;
              if (state === 3)
                throw t1;
              else {
                inner = H.interceptedTypeCheck(J.get$iterator$ax(t1), "$isIterator");
                if (inner instanceof P._SyncStarIterator) {
                  t1 = this._suspendedBodies;
                  if (t1 == null) {
                    t1 = [];
                    this._suspendedBodies = t1;
                  }
                  J.add$1$ax(t1, this._body);
                  this._body = inner._body;
                  continue;
                } else {
                  this._nestedIterator = inner;
                  continue;
                }
              }
            }
          } else {
            this.set$_async$_current(value);
            return true;
          }
        }
        return false;
      }, null, "get$moveNext", 0, 0, null],
      $isIterator: 1,
      static: {
        _SyncStarIterator$: [function(_body, $T) {
          return new P._SyncStarIterator(_body, [$T]);
        }, null, null, 4, 0, null, 586]
      }
    },
    _SyncStarIterable: {
      "^": "IterableBase;_outerHelper,$ti",
      get$iterator: [function(_) {
        return P._SyncStarIterator$(this._outerHelper(), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      static: {
        _SyncStarIterable$: [function(_outerHelper, $T) {
          return new P._SyncStarIterable(_outerHelper, [$T]);
        }, null, null, 4, 0, null, 590]
      }
    },
    _BroadcastStream: {
      "^": "_ControllerStream;_controller,$ti",
      get$isBroadcast: [function() {
        return true;
      }, null, null, 2, 0, null],
      static: {
        _BroadcastStream$: [function(controller, $T) {
          return new P._BroadcastStream(controller, [$T]);
        }, null, null, 4, 0, null, 265]
      }
    },
    _BroadcastSubscription: {
      "^": "_ControllerSubscription;_eventState,0_async$_next,0_async$_previous,_controller,0_onData,0_onError,0_onDone,_zone,_state,0_cancelFuture,0_pending,$ti",
      set$_async$_next: function(_next) {
        this._async$_next = H.assertSubtype(_next, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
      },
      set$_async$_previous: function(_previous) {
        this._async$_previous = H.assertSubtype(_previous, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
      },
      _BroadcastSubscription$5: [function(controller, onData, onError, onDone, cancelOnError, $T) {
        this.set$_async$_previous(this);
        this.set$_async$_next(this);
      }, null, null, 20, 0, null, 265, 32, 31, 47, 45],
      _expectsEvent$1: [function(eventId) {
        H.intTypeCheck(eventId);
        return J.$eq$(J.$and$bn(this._eventState, 1), eventId);
      }, null, "get$_expectsEvent", 4, 0, null, 666],
      _toggleEventId$0: [function() {
        this._eventState = H.intTypeCheck(J.$xor$n(this._eventState, 1));
      }, null, "get$_toggleEventId", 0, 0, null],
      get$_isFiring: [function() {
        return !J.$eq$(J.$and$bn(this._eventState, 2), 0);
      }, null, null, 2, 0, null],
      _setRemoveAfterFiring$0: [function() {
        this._eventState = H.intTypeCheck(J.$or$n(this._eventState, 4));
      }, null, "get$_setRemoveAfterFiring", 0, 0, null],
      get$_removeAfterFiring: [function() {
        return !J.$eq$(J.$and$bn(this._eventState, 4), 0);
      }, null, null, 2, 0, null],
      _onPause$0: [function() {
      }, "call$0", "get$_onPause", 0, 0, 0],
      _onResume$0: [function() {
      }, "call$0", "get$_onResume", 0, 0, 0],
      static: {
        _BroadcastSubscription$: [function(controller, onData, onError, onDone, cancelOnError, $T) {
          var t1, t2;
          t1 = P.Zone_current();
          t2 = cancelOnError ? 1 : 0;
          t2 = new P._BroadcastSubscription(0, controller, t1, t2, [$T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._BroadcastSubscription$5(controller, onData, onError, onDone, cancelOnError, $T);
          return t2;
        }, null, null, 20, 0, null, 265, 32, 31, 47, 45]
      }
    },
    _BroadcastStreamController: {
      "^": "Object;onListen<,onCancel,_state<,0_firstSubscription,0_lastSubscription,0_addStreamState,0_doneFuture<,$ti",
      set$onListen: function(onListen) {
        this.onListen = H.functionTypeCheck(onListen, {func: 1, ret: -1});
      },
      set$onCancel: function(onCancel) {
        this.onCancel = H.functionTypeCheck(onCancel, {func: 1});
      },
      set$_state: function(_state) {
        this._state = H.intTypeCheck(_state);
      },
      set$_firstSubscription: function(_firstSubscription) {
        this._firstSubscription = H.assertSubtype(_firstSubscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
      },
      set$_lastSubscription: function(_lastSubscription) {
        this._lastSubscription = H.assertSubtype(_lastSubscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
      },
      set$_addStreamState: function(_addStreamState) {
        this._addStreamState = H.assertSubtype(_addStreamState, "$is_AddStreamState", this.$ti, "$as_AddStreamState");
      },
      get$stream: [function(_) {
        return P._BroadcastStream$(this, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      get$isClosed: [function() {
        return !J.$eq$(J.$and$bn(this._state, 4), 0);
      }, null, null, 2, 0, null],
      get$_hasOneListener: [function() {
        var t1, t2;
        t1 = this._firstSubscription;
        t2 = this._lastSubscription;
        return t1 == null ? t2 == null : t1 === t2;
      }, null, null, 2, 0, null],
      get$_isFiring: [function() {
        return !J.$eq$(J.$and$bn(this._state, 2), 0);
      }, null, null, 2, 0, null],
      get$_mayAddEvent: [function() {
        return J.$lt$n(this._state, 4);
      }, null, null, 2, 0, null],
      _ensureDoneFuture$0: [function() {
        var t1 = this._doneFuture;
        if (t1 != null)
          return t1;
        t1 = P._Future$(null);
        this._doneFuture = t1;
        return t1;
      }, null, "get$_ensureDoneFuture", 0, 0, null],
      get$_isEmpty: [function() {
        return this._firstSubscription == null;
      }, null, null, 2, 0, null],
      _addListener$1: [function(subscription) {
        var oldLast;
        H.assertSubtype(subscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
        subscription._eventState = H.intTypeCheck(J.$and$bn(this._state, 1));
        oldLast = this._lastSubscription;
        this.set$_lastSubscription(subscription);
        subscription.set$_async$_next(null);
        subscription.set$_async$_previous(oldLast);
        if (oldLast == null)
          this.set$_firstSubscription(subscription);
        else
          oldLast.set$_async$_next(subscription);
      }, null, "get$_addListener", 4, 0, null, 88],
      _removeListener$1: [function(subscription) {
        var previous, next;
        H.assertSubtype(subscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
        previous = subscription._async$_previous;
        next = subscription._async$_next;
        if (previous == null)
          this.set$_firstSubscription(next);
        else
          previous.set$_async$_next(next);
        if (next == null)
          this.set$_lastSubscription(previous);
        else
          next.set$_async$_previous(previous);
        subscription.set$_async$_previous(subscription);
        subscription.set$_async$_next(subscription);
      }, null, "get$_removeListener", 4, 0, null, 88],
      _subscribe$4: [function(onData, onError, onDone, cancelOnError) {
        var t1, subscription, t2;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        H.boolTypeCheck(cancelOnError);
        if (this.get$isClosed())
          return P._DoneStreamSubscription$(onDone == null ? P.async___nullDoneHandler$closure() : onDone, t1);
        subscription = P._BroadcastSubscription$(this, onData, onError, onDone, cancelOnError, t1);
        this._addListener$1(H.assertSubtype(subscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription"));
        t1 = this._firstSubscription;
        t2 = this._lastSubscription;
        if (t1 == null ? t2 == null : t1 === t2)
          P._runGuarded(this.onListen);
        return subscription;
      }, null, "get$_subscribe", 16, 0, null, 32, 31, 47, 45],
      _recordCancel$1: [function(sub) {
        var t1 = this.$ti;
        sub = H.assertSubtype(H.assertSubtype(sub, "$isStreamSubscription", t1, "$asStreamSubscription"), "$is_BroadcastSubscription", t1, "$as_BroadcastSubscription");
        t1 = sub._async$_next;
        if (t1 == null ? sub == null : t1 === sub)
          return;
        if (sub.get$_isFiring())
          sub._setRemoveAfterFiring$0();
        else {
          this._removeListener$1(sub);
          if (!this.get$_isFiring() && this.get$_isEmpty())
            this._callOnCancel$0();
        }
        return;
      }, null, "get$_recordCancel", 4, 0, null, 672],
      _recordPause$1: [function(subscription) {
        H.assertSubtype(subscription, "$isStreamSubscription", this.$ti, "$asStreamSubscription");
      }, null, "get$_recordPause", 4, 0, null, 88],
      _recordResume$1: [function(subscription) {
        H.assertSubtype(subscription, "$isStreamSubscription", this.$ti, "$asStreamSubscription");
      }, null, "get$_recordResume", 4, 0, null, 88],
      _addEventError$0: ["super$_BroadcastStreamController$_addEventError", function() {
        if (this.get$isClosed())
          return P.StateError$("Cannot add new events after calling close");
        return P.StateError$("Cannot add new events while doing an addStream");
      }, null, "get$_addEventError", 0, 0, null],
      add$1: [function(_, data) {
        H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._sendData$1(data);
      }, "call$1", "get$add", 5, 0, 2, 34],
      addError$2: [function(error, stackTrace) {
        var replacement;
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        error = P._nonNullError(error);
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        replacement = P.Zone_current().errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = P._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this._sendError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 4, 2, 5, 0, 14, 20],
      close$0: [function(_) {
        var doneFuture;
        if (this.get$isClosed())
          return this._doneFuture;
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._state = H.intTypeCheck(J.$or$n(this._state, 4));
        doneFuture = this._ensureDoneFuture$0();
        this._sendDone$0();
        return doneFuture;
      }, "call$0", "get$close", 1, 0, 8],
      _add$1: [function(data) {
        this._sendData$1(H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$_add", 4, 0, null, 34],
      _addError$2: [function(error, stackTrace) {
        this._sendError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
      }, "call$2", "get$_addError", 8, 0, 13, 14, 20],
      _close$0: [function() {
        var addState = this._addStreamState;
        this.set$_addStreamState(null);
        this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967287));
        C.JSNull_methods.complete$0(addState);
      }, null, "get$_close", 0, 0, null],
      _forEachListener$1: [function(action) {
        var id, subscription, next;
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this, 0)]]});
        if (this.get$_isFiring())
          throw H.wrapException(P.StateError$("Cannot fire new event. Controller is already firing an event"));
        if (this.get$_isEmpty())
          return;
        id = J.$and$bn(this._state, 1);
        this._state = H.intTypeCheck(J.$xor$n(this._state, 3));
        subscription = this._firstSubscription;
        for (; subscription != null;)
          if (subscription._expectsEvent$1(id)) {
            subscription._eventState = H.intTypeCheck(J.$or$n(subscription._eventState, 2));
            action.call$1(subscription);
            subscription._toggleEventId$0();
            next = subscription._async$_next;
            if (subscription.get$_removeAfterFiring())
              this._removeListener$1(subscription);
            subscription._eventState = H.intTypeCheck(J.$and$bn(subscription._eventState, 4294967293));
            subscription = next;
          } else
            subscription = subscription._async$_next;
        this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967293));
        if (this.get$_isEmpty())
          this._callOnCancel$0();
      }, null, "get$_forEachListener", 4, 0, null, 63],
      _callOnCancel$0: [function() {
        if (this.get$isClosed() && this._doneFuture.get$_mayComplete())
          this._doneFuture._asyncComplete$1(null);
        P._runGuarded(this.onCancel);
      }, null, "get$_callOnCancel", 0, 0, null],
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isStreamController: 1,
      $is_StreamControllerLifecycle: 1,
      $is_EventSink: 1,
      $is_EventDispatch: 1,
      $isSink: 1
    },
    _SyncBroadcastStreamController: {
      "^": "_BroadcastStreamController;onListen,onCancel,_state,0_firstSubscription,0_lastSubscription,0_addStreamState,0_doneFuture,$ti",
      get$_mayAddEvent: [function() {
        return P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) && !this.get$_isFiring();
      }, null, null, 2, 0, null],
      _addEventError$0: [function() {
        if (this.get$_isFiring())
          return P.StateError$("Cannot fire new event. Controller is already firing an event");
        return this.super$_BroadcastStreamController$_addEventError();
      }, null, "get$_addEventError", 0, 0, null],
      _sendData$1: [function(data) {
        H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
        if (this.get$_isEmpty())
          return;
        if (this.get$_hasOneListener()) {
          this._state = H.intTypeCheck(J.$or$n(this._state, 2));
          this._firstSubscription._add$1(data);
          this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967293));
          if (this.get$_isEmpty())
            this._callOnCancel$0();
          return;
        }
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(this, data));
      }, null, "get$_sendData", 4, 0, null, 34],
      _sendError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        if (this.get$_isEmpty())
          return;
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(this, error, stackTrace));
      }, null, "get$_sendError", 8, 0, null, 14, 20],
      _sendDone$0: [function() {
        if (!this.get$_isEmpty())
          this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure(this));
        else
          this._doneFuture._asyncComplete$1(null);
      }, null, "get$_sendDone", 0, 0, null],
      $isSynchronousStreamController: 1,
      static: {
        _SyncBroadcastStreamController$: [function(onListen, onCancel, $T) {
          return new P._SyncBroadcastStreamController(onListen, onCancel, 0, [$T]);
        }, null, null, 8, 0, null, 138, 139]
      }
    },
    _SyncBroadcastStreamController__sendData_closure: {
      "^": "Closure;$this,data,$ti",
      call$1: [function(subscription) {
        H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this.$this, 0)], "$as_BufferingStreamSubscription")._add$1(this.data);
      }, null, null, 4, 0, null, 88, "call"],
      $signature: function() {
        return {func: 1, ret: P.Null, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    _SyncBroadcastStreamController__sendError_closure: {
      "^": "Closure;$this,error,stackTrace,$ti",
      call$1: [function(subscription) {
        H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this.$this, 0)], "$as_BufferingStreamSubscription")._addError$2(this.error, this.stackTrace);
      }, null, null, 4, 0, null, 88, "call"],
      $signature: function() {
        return {func: 1, ret: P.Null, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    _SyncBroadcastStreamController__sendDone_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(subscription) {
        H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this.$this, 0)], "$as_BufferingStreamSubscription")._close$0();
      }, null, null, 4, 0, null, 88, "call"],
      $signature: function() {
        return {func: 1, ret: P.Null, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    _AsyncBroadcastStreamController: {
      "^": "_BroadcastStreamController;onListen,onCancel,_state,0_firstSubscription,0_lastSubscription,0_addStreamState,0_doneFuture,$ti",
      _sendData$1: [function(data) {
        var t1, subscription;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.assertSubtypeOfRuntimeType(data, t1);
        for (subscription = this._firstSubscription; subscription != null; subscription = subscription._async$_next)
          subscription._addPending$1(P._DelayedData$(data, t1));
      }, null, "get$_sendData", 4, 0, null, 34],
      _sendError$2: [function(error, stackTrace) {
        var subscription;
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        for (subscription = this._firstSubscription; subscription != null; subscription = subscription._async$_next)
          subscription._addPending$1(P._DelayedError$(error, stackTrace));
      }, null, "get$_sendError", 8, 0, null, 14, 20],
      _sendDone$0: [function() {
        if (!this.get$_isEmpty())
          for (var subscription = this._firstSubscription; subscription != null; subscription = subscription._async$_next)
            subscription._addPending$1(C.C__DelayedDone);
        else
          this._doneFuture._asyncComplete$1(null);
      }, null, "get$_sendDone", 0, 0, null],
      static: {
        _AsyncBroadcastStreamController$: [function(onListen, onCancel, $T) {
          return new P._AsyncBroadcastStreamController(onListen, onCancel, 0, [$T]);
        }, null, null, 8, 0, null, 138, 139]
      }
    },
    _AsBroadcastStreamController: {
      "^": "_SyncBroadcastStreamController;$ti"
    },
    DeferredLibrary: {
      "^": "Object;$ti"
    },
    DeferredLoadException: {
      "^": "Object;$ti",
      $isException: 1
    },
    FutureOr: {
      "^": "Object;$ti"
    },
    Future: {
      "^": "Object;$ti"
    },
    Future_Future_closure: {
      "^": "Closure:1;result,computation,$ti",
      call$0: [function() {
        var e, s, exception;
        try {
          this.result._complete$1(this.computation.call$0());
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.result, e, s);
        }
      }, null, null, 0, 0, null, "call"]
    },
    Future_wait_handleError: {
      "^": "Closure:9;_box_0,cleanUp,eagerError,result,$ti",
      call$2: [function(theError, theStackTrace) {
        var t1, remaining, t2, t3, value;
        t1 = this._box_0;
        remaining = J.$sub$n(t1.remaining, 1);
        t1.remaining = remaining;
        t2 = t1.values;
        if (t2 != null) {
          t3 = this.cleanUp;
          if (t3 != null)
            for (t2 = J.get$iterator$ax(t2); t2.moveNext$0();) {
              value = t2.get$current();
              if (value != null)
                P.Future_Future$sync(new P.Future_wait_handleError_closure(t3, value), null);
            }
          t1.values = null;
          if (J.$eq$(t1.remaining, 0) || this.eagerError)
            this.result._completeError$2(theError, H.interceptedTypeCheck(theStackTrace, "$isStackTrace"));
          else {
            t1.error = theError;
            t1.stackTrace = H.interceptedTypeCheck(theStackTrace, "$isStackTrace");
          }
        } else if (remaining === 0 && !this.eagerError)
          this.result._completeError$2(t1.error, t1.stackTrace);
      }, null, null, 8, 0, null, 676, 677, "call"]
    },
    Future_wait_handleError_closure: {
      "^": "Closure:1;cleanUp,value,$ti",
      call$0: [function() {
        this.cleanUp.call$1(this.value);
      }, null, null, 0, 0, null, "call"]
    },
    Future_wait_closure: {
      "^": "Closure;_box_0,pos,result,cleanUp,eagerError,T,$ti",
      call$1: [function(value) {
        var t1, t2;
        H.assertSubtypeOfRuntimeType(value, this.T);
        t1 = this._box_0;
        t1.remaining = J.$sub$n(t1.remaining, 1);
        t2 = t1.values;
        if (t2 != null) {
          J.$indexSet$ax(t2, this.pos, value);
          if (J.$eq$(t1.remaining, 0))
            this.result._completeWithValue$1(t1.values);
        } else {
          t2 = this.cleanUp;
          if (t2 != null && value != null)
            P.Future_Future$sync(new P.Future_wait__closure(t2, value), null);
          if (J.$eq$(t1.remaining, 0) && !this.eagerError)
            this.result._completeError$2(t1.error, t1.stackTrace);
        }
      }, null, null, 4, 0, null, 1, "call"],
      $signature: function() {
        return {func: 1, ret: P.Null, args: [this.T]};
      }
    },
    Future_wait__closure: {
      "^": "Closure:1;cleanUp,value,$ti",
      call$0: [function() {
        this.cleanUp.call$1(this.value);
      }, null, null, 0, 0, null, "call"]
    },
    Future_forEach_closure: {
      "^": "Closure:204;iterator,action,$ti",
      call$0: [function() {
        var t1, result;
        t1 = this.iterator;
        if (!t1.moveNext$0())
          return false;
        result = this.action.call$1(t1.get$current());
        if (!!J.getInterceptor$(result).$isFuture)
          return result.then$1$1(P.async_Future__kTrue$closure(), P.bool);
        return true;
      }, null, null, 0, 0, null, "call"]
    },
    Future_doWhile_closure: {
      "^": "Closure:16;_box_0,action,doneSignal,$ti",
      call$1: [function(keepGoing) {
        var result, error, stackTrace, t1, t2, exception, t3;
        H.boolTypeCheck(keepGoing);
        for (t1 = [P.bool], t2 = this.action; keepGoing;) {
          result = null;
          try {
            result = t2.call$0();
          } catch (exception) {
            error = H.unwrapException(exception);
            stackTrace = H.getTraceFromException(exception);
            P._asyncCompleteWithErrorCallback(this.doneSignal, error, stackTrace);
            return;
          }
          t3 = result;
          if (H.checkSubtype(t3, "$isFuture", t1, "$asFuture")) {
            result.then$1$2$onError(H.functionTypeCheck(this._box_0.nextIteration, {func: 1, ret: {futureOr: 1}, args: [P.bool]}), this.doneSignal.get$_completeError(), null);
            return;
          }
          keepGoing = H.boolTypeCheck(result);
        }
        this.doneSignal._complete$1(null);
      }, null, null, 4, 0, null, 680, "call"]
    },
    TimeoutException: {
      "^": "Object;$ti",
      $isException: 1
    },
    Completer: {
      "^": "Object;$ti"
    },
    _Completer: {
      "^": "Object;future<,$ti",
      completeError$2: [function(error, stackTrace) {
        var replacement;
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        error = P._nonNullError(error);
        if (!this.future.get$_mayComplete())
          throw H.wrapException(P.StateError$("Future already completed"));
        replacement = P.Zone_current().errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = P._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this._completeError$2(error, stackTrace);
      }, function(error) {
        return this.completeError$2(error, null);
      }, "completeError$1", "call$2", "call$1", "get$completeError", 4, 2, 5, 0, 14, 20],
      get$isCompleted: [function() {
        return !this.future.get$_mayComplete();
      }, null, null, 2, 0, null],
      $isCompleter: 1
    },
    _AsyncCompleter: {
      "^": "_Completer;future,$ti",
      complete$1: [function(_, value) {
        var t1;
        H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
        t1 = this.future;
        if (!t1.get$_mayComplete())
          throw H.wrapException(P.StateError$("Future already completed"));
        t1._asyncComplete$1(value);
      }, function($receiver) {
        return this.complete$1($receiver, null);
      }, "complete$0", "call$1", "call$0", "get$complete", 1, 2, 36, 0, 1],
      _completeError$2: [function(error, stackTrace) {
        this.future._asyncCompleteError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
      }, "call$2", "get$_completeError", 8, 0, 13, 14, 20],
      static: {
        _AsyncCompleter$: [function($T) {
          return new P._AsyncCompleter(P._Future$($T), [$T]);
        }, null, null, 0, 0, null]
      }
    },
    _SyncCompleter: {
      "^": "_Completer;future,$ti",
      complete$1: [function(_, value) {
        var t1;
        H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
        t1 = this.future;
        if (!t1.get$_mayComplete())
          throw H.wrapException(P.StateError$("Future already completed"));
        t1._complete$1(value);
      }, function($receiver) {
        return this.complete$1($receiver, null);
      }, "complete$0", "call$1", "call$0", "get$complete", 1, 2, 36, 0, 1],
      _completeError$2: [function(error, stackTrace) {
        this.future._completeError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
      }, "call$2", "get$_completeError", 8, 0, 13, 14, 20],
      static: {
        _SyncCompleter$: [function($T) {
          return new P._SyncCompleter(P._Future$($T), [$T]);
        }, null, null, 0, 0, null]
      }
    },
    _FutureListener: {
      "^": "Object;0_nextListener,result>,state,callback,errorCallback,$ti",
      get$_zone: [function() {
        return this.result.get$_zone();
      }, null, null, 2, 0, null],
      get$handlesValue: [function() {
        return !J.$eq$(J.$and$bn(this.state, 1), 0);
      }, null, null, 2, 0, null],
      get$handlesError: [function() {
        return !J.$eq$(J.$and$bn(this.state, 2), 0);
      }, null, null, 2, 0, null],
      get$hasErrorTest: [function() {
        return J.$eq$(this.state, 6);
      }, null, null, 2, 0, null],
      get$handlesComplete: [function() {
        return J.$eq$(this.state, 8);
      }, null, null, 2, 0, null],
      get$_onValue: [function() {
        return H.functionTypeCheck(this.callback, {func: 1, ret: {futureOr: 1, type: H.getTypeArgumentByIndex(this, 1)}, args: [H.getTypeArgumentByIndex(this, 0)]});
      }, null, null, 2, 0, null],
      get$_onError: [function() {
        return this.errorCallback;
      }, null, null, 2, 0, null],
      get$_errorTest: [function() {
        return H.functionTypeCheck(this.callback, {func: 1, ret: P.bool, args: [P.Object]});
      }, null, null, 2, 0, null],
      get$_whenCompleteAction: [function() {
        return H.functionTypeCheck(this.callback, {func: 1});
      }, null, null, 2, 0, null],
      get$hasErrorCallback: [function() {
        return this.get$_onError() != null;
      }, null, null, 2, 0, null],
      handleValue$1: [function(sourceResult) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.assertSubtypeOfRuntimeType(sourceResult, t1);
        return this.get$_zone().runUnary$2$2(this.get$_onValue(), sourceResult, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 1)}, t1);
      }, null, "get$handleValue", 4, 0, null, 686],
      matchesErrorTest$1: [function(asyncError) {
        H.interceptedTypeCheck(asyncError, "$isAsyncError");
        if (!this.get$hasErrorTest())
          return true;
        return this.get$_zone().runUnary$2$2(this.get$_errorTest(), asyncError.error, P.bool, P.Object);
      }, null, "get$matchesErrorTest", 4, 0, null, 450],
      handleError$1: [function(asyncError) {
        var errorCallback, t1, t2;
        H.interceptedTypeCheck(asyncError, "$isAsyncError");
        errorCallback = this.errorCallback;
        t1 = P.Object;
        t2 = {futureOr: 1, type: H.getTypeArgumentByIndex(this, 1)};
        if (H.functionTypeTest(errorCallback, {func: 1, args: [P.Object, P.StackTrace]}))
          return H.futureOrCheck(this.get$_zone().runBinary$3$3(errorCallback, asyncError.error, asyncError.stackTrace, null, t1, P.StackTrace), t2);
        else
          return H.futureOrCheck(this.get$_zone().runUnary$2$2(H.functionTypeCheck(errorCallback, {func: 1, args: [P.Object]}), asyncError.error, null, t1), t2);
      }, null, "get$handleError", 4, 0, null, 450],
      handleWhenComplete$0: [function() {
        return this.get$_zone().run$1$1(this.get$_whenCompleteAction(), null);
      }, null, "get$handleWhenComplete", 0, 0, null],
      errorCallback$2: function(arg0, arg1) {
        return this.errorCallback.call$2(arg0, arg1);
      },
      static: {
        _FutureListener$then: [function(result, onValue, errorCallback, $S, $T) {
          var t1 = errorCallback == null ? 1 : 3;
          return new P._FutureListener(result, t1, onValue, errorCallback, [$S, $T]);
        }, null, null, 12, 0, null, 59, 420, 421],
        _FutureListener$catchError: [function(result, errorCallback, test, $S, $T) {
          var t1 = test == null ? 2 : 6;
          return new P._FutureListener(result, t1, test, errorCallback, [$S, $T]);
        }, null, null, 12, 0, null, 59, 421, 41],
        _FutureListener$whenComplete: [function(result, onComplete, $S, $T) {
          return new P._FutureListener(result, 8, onComplete, null, [$S, $T]);
        }, null, null, 8, 0, null, 59, 608]
      }
    },
    _Future: {
      "^": "Object;_state<,_zone<,0_resultOrListeners<,$ti",
      set$_state: function(_state) {
        this._state = H.intTypeCheck(_state);
      },
      _Future$immediate$1: [function(result, $T) {
        this._asyncComplete$1(result);
      }, null, null, 4, 0, null, 59],
      _Future$zoneValue$2: [function(value, _zone, $T) {
        this._setValue$1(value);
      }, null, null, 8, 0, null, 1, 423],
      _Future$immediateError$2: [function(error, stackTrace, $T) {
        this._asyncCompleteError$2(error, stackTrace);
      }, null, null, 4, 2, null, 0, 14, 20],
      get$_mayComplete: [function() {
        return J.$eq$(this._state, 0);
      }, null, null, 2, 0, null],
      get$_mayAddListener: [function() {
        return J.$le$n(this._state, 1);
      }, null, null, 2, 0, null],
      get$_isChained: [function() {
        return J.$eq$(this._state, 2);
      }, null, null, 2, 0, null],
      get$_isComplete: [function() {
        return J.$ge$n(this._state, 4);
      }, null, null, 2, 0, null],
      get$_hasError: [function() {
        return J.$eq$(this._state, 8);
      }, null, null, 2, 0, null],
      _setChained$1: [function(source) {
        H.interceptedTypeCheck(source, "$is_Future");
        this._state = 2;
        this._resultOrListeners = source;
      }, null, "get$_setChained", 4, 0, null, 11],
      then$1$2$onError: [1, function(f, onError, $R) {
        var t1, currentZone;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $R}, args: [t1]});
        H.interceptedTypeCheck(onError, "$isFunction");
        currentZone = P.Zone_current();
        if (currentZone !== C.C__RootZone) {
          f = currentZone.registerUnaryCallback$2$1(f, {futureOr: 1, type: $R}, t1);
          if (onError != null)
            onError = P._registerErrorHandler(onError, currentZone);
        }
        return this._thenNoZoneRegistration$1$2(f, onError, $R);
      }, function(f, onError) {
        return this.then$1$2$onError(f, onError, null);
      }, "then$2$onError", function(f, $R) {
        return this.then$1$2$onError(f, null, $R);
      }, "then$1$1", null, "call$2$onError", null, "get$then", 4, 3, null, 0, 15, 31],
      _thenNoZoneRegistration$1$2: [1, function(f, onError, $E) {
        var t1, result;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $E}, args: [t1]});
        H.interceptedTypeCheck(onError, "$isFunction");
        result = P._Future$($E);
        this._addListener$1(P._FutureListener$then(result, f, onError, t1, $E));
        return result;
      }, function(f, onError) {
        return this._thenNoZoneRegistration$1$2(f, onError, null);
      }, "_thenNoZoneRegistration$2", null, "call$2", "get$_thenNoZoneRegistration", 8, 0, null, 15, 31],
      catchError$2$test: [function(onError, test) {
        var t1, result, t2;
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [,]});
        t1 = H.getTypeArgumentByIndex(this, 0);
        result = P._Future$(t1);
        t2 = result._zone;
        if (t2 !== C.C__RootZone) {
          onError = P._registerErrorHandler(onError, t2);
          if (test != null)
            test = t2.registerUnaryCallback$2$1(test, P.bool, null);
        }
        this._addListener$1(P._FutureListener$catchError(result, onError, test, t1, t1));
        return result;
      }, function(onError) {
        return this.catchError$2$test(onError, null);
      }, "catchError$1", null, null, "get$catchError", 4, 3, null, 0, 31, 41],
      whenComplete$1: [function(action) {
        var t1, result, t2;
        H.functionTypeCheck(action, {func: 1});
        t1 = H.getTypeArgumentByIndex(this, 0);
        result = P._Future$(t1);
        t2 = result._zone;
        this._addListener$1(P._FutureListener$whenComplete(result, t2 !== C.C__RootZone ? t2.registerCallback$1$1(action, null) : action, t1, t1));
        return result;
      }, null, "get$whenComplete", 4, 0, null, 63],
      _setPendingComplete$0: [function() {
        this._state = 1;
      }, null, "get$_setPendingComplete", 0, 0, null],
      _clearPendingComplete$0: [function() {
        this._state = 0;
      }, null, "get$_clearPendingComplete", 0, 0, null],
      get$_error: [function() {
        return H.interceptedTypeCheck(this._resultOrListeners, "$isAsyncError");
      }, null, null, 2, 0, null],
      get$_chainSource: [function() {
        return H.interceptedTypeCheck(this._resultOrListeners, "$is_Future");
      }, null, null, 2, 0, null],
      _setValue$1: [function(value) {
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
        this._state = 4;
        this._resultOrListeners = value;
      }, null, "get$_setValue", 4, 0, null, 1],
      _setErrorObject$1: [function(error) {
        H.interceptedTypeCheck(error, "$isAsyncError");
        this._state = 8;
        this._resultOrListeners = error;
      }, null, "get$_setErrorObject", 4, 0, null, 14],
      _setError$2: [function(error, stackTrace) {
        this._setErrorObject$1(P.AsyncError$(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
      }, null, "get$_setError", 8, 0, null, 14, 20],
      _cloneResult$1: [function(source) {
        H.interceptedTypeCheck(source, "$is_Future");
        this._state = H.intTypeCheck(source._state);
        this._resultOrListeners = source._resultOrListeners;
      }, null, "get$_cloneResult", 4, 0, null, 11],
      _addListener$1: [function(listener) {
        var source;
        H.interceptedTypeCheck(listener, "$is_FutureListener");
        if (this.get$_mayAddListener()) {
          listener._nextListener = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
          this._resultOrListeners = listener;
        } else {
          if (this.get$_isChained()) {
            source = this.get$_chainSource();
            if (!source.get$_isComplete()) {
              source._addListener$1(listener);
              return;
            }
            this._cloneResult$1(source);
          }
          this._zone.scheduleMicrotask$1(new P._Future__addListener_closure(this, listener));
        }
      }, null, "get$_addListener", 4, 0, null, 133],
      _prependListeners$1: [function(listeners) {
        var _box_0, existingListeners, cursor, cursor0, source;
        _box_0 = {};
        _box_0.listeners = listeners;
        H.interceptedTypeCheck(listeners, "$is_FutureListener");
        if (listeners == null)
          return;
        if (this.get$_mayAddListener()) {
          existingListeners = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
          this._resultOrListeners = listeners;
          if (existingListeners != null) {
            for (cursor = listeners; cursor0 = cursor._nextListener, cursor0 != null; cursor = cursor0)
              ;
            cursor._nextListener = existingListeners;
          }
        } else {
          if (this.get$_isChained()) {
            source = this.get$_chainSource();
            if (!source.get$_isComplete()) {
              source._prependListeners$1(listeners);
              return;
            }
            this._cloneResult$1(source);
          }
          _box_0.listeners = this._reverseListeners$1(listeners);
          this._zone.scheduleMicrotask$1(new P._Future__prependListeners_closure(_box_0, this));
        }
      }, null, "get$_prependListeners", 4, 0, null, 279],
      _removeListeners$0: [function() {
        var current = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
        this._resultOrListeners = null;
        return this._reverseListeners$1(current);
      }, null, "get$_removeListeners", 0, 0, null],
      _reverseListeners$1: [function(listeners) {
        var current, prev, next;
        H.interceptedTypeCheck(listeners, "$is_FutureListener");
        for (current = listeners, prev = null; current != null; prev = current, current = next) {
          next = current._nextListener;
          current._nextListener = prev;
        }
        return prev;
      }, null, "get$_reverseListeners", 4, 0, null, 279],
      _complete$1: [function(value) {
        var t1, t2, listeners;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.futureOrCheck(value, {futureOr: 1, type: t1});
        t2 = this.$ti;
        if (H.checkSubtype(value, "$isFuture", t2, "$asFuture"))
          if (H.checkSubtype(value, "$is_Future", t2, null))
            P._Future__chainCoreFuture(value, this);
          else
            P._Future__chainForeignFuture(value, this);
        else {
          listeners = this._removeListeners$0();
          this._setValue$1(H.assertSubtypeOfRuntimeType(value, t1));
          P._Future__propagateToListeners(this, listeners);
        }
      }, null, "get$_complete", 4, 0, null, 1],
      _completeWithValue$1: [function(value) {
        var listeners;
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }, null, "get$_completeWithValue", 4, 0, null, 1],
      _completeError$2: [function(error, stackTrace) {
        var listeners;
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        listeners = this._removeListeners$0();
        this._setError$2(error, stackTrace);
        P._Future__propagateToListeners(this, listeners);
      }, function(error) {
        return this._completeError$2(error, null);
      }, "_completeError$1", "call$2", "call$1", "get$_completeError", 4, 2, 5, 0, 14, 20],
      _asyncComplete$1: [function(value) {
        H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
        if (H.checkSubtype(value, "$isFuture", this.$ti, "$asFuture")) {
          this._chainFuture$1(value);
          return;
        }
        this._setPendingComplete$0();
        this._zone.scheduleMicrotask$1(new P._Future__asyncComplete_closure(this, value));
      }, null, "get$_asyncComplete", 4, 0, null, 1],
      _chainFuture$1: [function(value) {
        var t1 = this.$ti;
        H.assertSubtype(value, "$isFuture", t1, "$asFuture");
        if (H.checkSubtype(value, "$is_Future", t1, null)) {
          if (value.get$_hasError()) {
            this._setPendingComplete$0();
            this._zone.scheduleMicrotask$1(new P._Future__chainFuture_closure(this, value));
          } else
            P._Future__chainCoreFuture(value, this);
          return;
        }
        P._Future__chainForeignFuture(value, this);
      }, null, "get$_chainFuture", 4, 0, null, 1],
      _asyncCompleteError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        this._setPendingComplete$0();
        this._zone.scheduleMicrotask$1(new P._Future__asyncCompleteError_closure(this, error, stackTrace));
      }, null, "get$_asyncCompleteError", 8, 0, null, 14, 20],
      $isFuture: 1,
      static: {
        _Future$: [function($T) {
          return new P._Future(0, P.Zone_current(), [$T]);
        }, null, null, 0, 0, null],
        _Future$immediate: [function(result, $T) {
          var t1 = new P._Future(0, P.Zone_current(), [$T]);
          t1._Future$immediate$1(result, $T);
          return t1;
        }, null, null, 4, 0, null, 59],
        _Future$zoneValue: [function(value, _zone, $T) {
          var t1 = new P._Future(0, _zone, [$T]);
          t1._Future$zoneValue$2(value, _zone, $T);
          return t1;
        }, null, null, 8, 0, null, 1, 423],
        _Future$immediateError: [function(error, stackTrace, $T) {
          var t1 = new P._Future(0, P.Zone_current(), [$T]);
          t1._Future$immediateError$2(error, stackTrace, $T);
          return t1;
        }, null, null, 4, 2, null, 0, 14, 20],
        _Future$value: [function(value, $T) {
          var t1, t2;
          t1 = P.Zone_current();
          t2 = new P._Future(0, t1, [$T]);
          t2._Future$zoneValue$2(value, t1, $T);
          return t2;
        }, null, null, 4, 0, null, 1],
        _Future__chainForeignFuture: [function(source, target) {
          var e, s, exception;
          H.interceptedTypeCheck(source, "$isFuture");
          H.interceptedTypeCheck(target, "$is_Future");
          target._setPendingComplete$0();
          try {
            source.then$1$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target), null);
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
          }
        }, null, null, 8, 0, null, 11, 89],
        _Future__chainCoreFuture: [function(source, target) {
          var listeners;
          H.interceptedTypeCheck(source, "$is_Future");
          H.interceptedTypeCheck(target, "$is_Future");
          for (; source.get$_isChained();)
            source = source.get$_chainSource();
          if (source.get$_isComplete()) {
            listeners = target._removeListeners$0();
            target._cloneResult$1(source);
            P._Future__propagateToListeners(target, listeners);
          } else {
            listeners = H.interceptedTypeCheck(target._resultOrListeners, "$is_FutureListener");
            target._setChained$1(source);
            source._prependListeners$1(listeners);
          }
        }, null, null, 8, 0, null, 11, 89],
        _Future__propagateToListeners: [function(source, listeners) {
          var _box_1, t1, _box_0, hasError, asyncError, listeners0, sourceResult, zone, t2, oldZone, result;
          _box_1 = {};
          _box_1.source = source;
          H.interceptedTypeCheck(source, "$is_Future");
          H.interceptedTypeCheck(listeners, "$is_FutureListener");
          for (t1 = source; true;) {
            _box_0 = {};
            hasError = t1.get$_hasError();
            if (listeners == null) {
              if (hasError) {
                asyncError = _box_1.source.get$_error();
                _box_1.source.get$_zone().handleUncaughtError$2(asyncError.error, asyncError.stackTrace);
              }
              return;
            }
            for (; listeners0 = listeners._nextListener, listeners0 != null; listeners = listeners0) {
              listeners._nextListener = null;
              P._Future__propagateToListeners(_box_1.source, listeners);
            }
            sourceResult = _box_1.source.get$_resultOrListeners();
            _box_0.listenerHasError = hasError;
            _box_0.listenerValueOrError = sourceResult;
            t1 = !hasError;
            if (!t1 || listeners.get$handlesValue() || listeners.get$handlesComplete()) {
              zone = listeners.get$_zone();
              if (hasError && !_box_1.source.get$_zone().inSameErrorZone$1(zone)) {
                asyncError = _box_1.source.get$_error();
                _box_1.source.get$_zone().handleUncaughtError$2(asyncError.error, asyncError.stackTrace);
                return;
              }
              t2 = P.Zone_current();
              oldZone = (t2 == null ? zone != null : t2 !== zone) ? P.Zone__enter(zone) : null;
              if (listeners.get$handlesComplete())
                new P._Future__propagateToListeners_handleWhenCompleteCallback(_box_1, _box_0, listeners, hasError).call$0();
              else if (t1) {
                if (listeners.get$handlesValue())
                  new P._Future__propagateToListeners_handleValueCallback(_box_0, listeners, sourceResult).call$0();
              } else if (listeners.get$handlesError())
                new P._Future__propagateToListeners_handleError(_box_1, _box_0, listeners).call$0();
              if (oldZone != null)
                P.Zone__leave(oldZone);
              t1 = _box_0.listenerValueOrError;
              if (!!J.getInterceptor$(t1).$isFuture) {
                result = listeners.result;
                if (!!t1.$is_Future)
                  if (t1.get$_isComplete()) {
                    listeners = result._removeListeners$0();
                    result._cloneResult$1(t1);
                    _box_1.source = t1;
                    continue;
                  } else
                    P._Future__chainCoreFuture(t1, result);
                else
                  P._Future__chainForeignFuture(t1, result);
                return;
              }
            }
            result = listeners.result;
            listeners = result._removeListeners$0();
            t1 = _box_0.listenerHasError;
            t2 = _box_0.listenerValueOrError;
            if (!t1)
              result._setValue$1(t2);
            else
              result._setErrorObject$1(H.interceptedTypeCheck(t2, "$isAsyncError"));
            _box_1.source = result;
            t1 = result;
          }
        }, null, null, 8, 0, null, 11, 279]
      }
    },
    _Future__addListener_closure: {
      "^": "Closure:1;$this,listener,$ti",
      call$0: [function() {
        P._Future__propagateToListeners(this.$this, this.listener);
      }, null, null, 0, 0, null, "call"]
    },
    _Future__prependListeners_closure: {
      "^": "Closure:1;_box_0,$this,$ti",
      call$0: [function() {
        P._Future__propagateToListeners(this.$this, this._box_0.listeners);
      }, null, null, 0, 0, null, "call"]
    },
    _Future__chainForeignFuture_closure: {
      "^": "Closure:4;target,$ti",
      call$1: [function(value) {
        var t1 = this.target;
        t1._clearPendingComplete$0();
        t1._complete$1(value);
      }, null, null, 4, 0, null, 1, "call"]
    },
    _Future__chainForeignFuture_closure0: {
      "^": "Closure:80;target,$ti",
      call$2: [function(error, stackTrace) {
        this.target._completeError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
      }, function(error) {
        return this.call$2(error, null);
      }, "call$1", null, null, null, 4, 2, null, 0, 14, 20, "call"]
    },
    _Future__chainForeignFuture_closure1: {
      "^": "Closure:1;target,e,s,$ti",
      call$0: [function() {
        this.target._completeError$2(this.e, this.s);
      }, null, null, 0, 0, null, "call"]
    },
    _Future__asyncComplete_closure: {
      "^": "Closure:1;$this,value,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1._completeWithValue$1(H.assertSubtypeOfRuntimeType(this.value, H.getTypeArgumentByIndex(t1, 0)));
      }, null, null, 0, 0, null, "call"]
    },
    _Future__chainFuture_closure: {
      "^": "Closure:1;$this,value,$ti",
      call$0: [function() {
        P._Future__chainCoreFuture(this.value, this.$this);
      }, null, null, 0, 0, null, "call"]
    },
    _Future__asyncCompleteError_closure: {
      "^": "Closure:1;$this,error,stackTrace,$ti",
      call$0: [function() {
        this.$this._completeError$2(this.error, this.stackTrace);
      }, null, null, 0, 0, null, "call"]
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: {
      "^": "Closure:0;_box_1,_box_0,listener,hasError,$ti",
      call$0: [function() {
        var completeResult, e, s, exception, t1, t2, originalSource;
        completeResult = null;
        try {
          completeResult = this.listener.handleWhenComplete$0();
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          if (this.hasError) {
            t1 = J.get$error$z(this._box_1.source.get$_error());
            t2 = e;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
          t2 = this._box_0;
          if (t1)
            t2.listenerValueOrError = this._box_1.source.get$_error();
          else
            t2.listenerValueOrError = P.AsyncError$(e, s);
          t2.listenerHasError = true;
          return;
        }
        if (!!J.getInterceptor$(completeResult).$isFuture) {
          if (completeResult instanceof P._Future && completeResult.get$_isComplete()) {
            if (completeResult.get$_hasError()) {
              t1 = this._box_0;
              t1.listenerValueOrError = completeResult.get$_error();
              t1.listenerHasError = true;
            }
            return;
          }
          originalSource = this._box_1.source;
          t1 = this._box_0;
          t1.listenerValueOrError = completeResult.then$1$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource), null);
          t1.listenerHasError = false;
        }
      }, null, null, 0, 0, null, "call"]
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
      "^": "Closure:82;originalSource,$ti",
      call$1: [function(_) {
        return this.originalSource;
      }, null, null, 4, 0, null, 12, "call"]
    },
    _Future__propagateToListeners_handleValueCallback: {
      "^": "Closure:0;_box_0,listener,sourceResult,$ti",
      call$0: [function() {
        var e, s, exception, t1;
        try {
          this._box_0.listenerValueOrError = this.listener.handleValue$1(this.sourceResult);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = this._box_0;
          t1.listenerValueOrError = P.AsyncError$(e, s);
          t1.listenerHasError = true;
        }
      }, null, null, 0, 0, null, "call"]
    },
    _Future__propagateToListeners_handleError: {
      "^": "Closure:0;_box_1,_box_0,listener,$ti",
      call$0: [function() {
        var asyncError, e, s, t1, t2, exception, t3, t4;
        try {
          asyncError = this._box_1.source.get$_error();
          t1 = this.listener;
          if (t1.matchesErrorTest$1(asyncError) && t1.get$hasErrorCallback()) {
            t2 = this._box_0;
            t2.listenerValueOrError = t1.handleError$1(asyncError);
            t2.listenerHasError = false;
          }
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = this._box_1;
          t2 = J.get$error$z(t1.source.get$_error());
          t3 = e;
          t4 = this._box_0;
          if (t2 == null ? t3 == null : t2 === t3)
            t4.listenerValueOrError = t1.source.get$_error();
          else
            t4.listenerValueOrError = P.AsyncError$(e, s);
          t4.listenerHasError = true;
        }
      }, null, null, 0, 0, null, "call"]
    },
    _AsyncCallbackEntry: {
      "^": "Object;callback,0next<,$ti",
      set$next: function(next) {
        this.next = H.interceptedTypeCheck(next, "$is_AsyncCallbackEntry");
      },
      static: {
        _AsyncCallbackEntry$: [function(callback) {
          return new P._AsyncCallbackEntry(callback, []);
        }, null, null, 4, 0, null, 43]
      }
    },
    _AsyncRun: {
      "^": "Object;$ti"
    },
    Stream: {
      "^": "Object;$ti",
      get$isBroadcast: [function() {
        return false;
      }, null, null, 2, 0, null],
      where$1: [function(_, test) {
        var t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
        return P._WhereStream$(this, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]}), t1);
      }, null, "get$where", 5, 0, null, 41],
      map$1$1: [1, function(_, convert, $S) {
        var t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
        return P._MapStream$(this, H.functionTypeCheck(convert, {func: 1, ret: $S, args: [t1]}), t1, $S);
      }, function($receiver, convert) {
        return this.map$1$1($receiver, convert, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 188],
      asyncMap$1$1: [1, function(convert, $E) {
        var t1, t2, controller;
        t1 = {};
        H.functionTypeCheck(convert, {func: 1, ret: {futureOr: 1, type: $E}, args: [H.getRuntimeTypeArgument(this, "Stream", 0)]});
        t1.controller = null;
        t1.subscription = null;
        t2 = new P.Stream_asyncMap_onListen(t1, this, convert, $E);
        if (this.get$isBroadcast()) {
          controller = P.StreamController_StreamController$broadcast(new P.Stream_asyncMap_closure(t1), t2, true, $E);
          t1.controller = controller;
          t1 = controller;
        } else {
          controller = P.StreamController_StreamController(new P.Stream_asyncMap_closure0(t1), t2, new P.Stream_asyncMap_closure1(t1), new P.Stream_asyncMap_closure2(t1), true, $E);
          t1.controller = controller;
          t1 = controller;
        }
        return t1.get$stream(t1);
      }, function(convert) {
        return this.asyncMap$1$1(convert, null);
      }, "asyncMap$1", null, "call$1", "get$asyncMap", 4, 0, null, 188],
      transform$1$1: ["super$Stream$transform", 1, function(_, streamTransformer, $S) {
        return H.assertSubtype(streamTransformer, "$isStreamTransformer", [H.getRuntimeTypeArgument(this, "Stream", 0), $S], "$asStreamTransformer").bind$1(this);
      }, function($receiver, streamTransformer) {
        return this.transform$1$1($receiver, streamTransformer, null);
      }, "transform$1", null, "call$1", "get$transform", 5, 0, null, 371],
      get$length: [function(_) {
        var t1, future;
        t1 = {};
        future = P._Future$(P.int);
        t1.count = 0;
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1, this), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
        return future;
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        var t1, future;
        t1 = {};
        future = P._Future$(P.bool);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, this, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
        return future;
      }, null, null, 3, 0, null],
      get$first: [function(_) {
        var t1, future;
        t1 = {};
        future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
        return future;
      }, null, null, 3, 0, null]
    },
    Stream_Stream$fromIterable_closure: {
      "^": "Closure;elements,T,$ti",
      call$0: [function() {
        return P._IterablePendingEvents$(this.elements, this.T);
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        return {func: 1, ret: [P._IterablePendingEvents, this.T]};
      }
    },
    Stream_asyncMap_onListen: {
      "^": "Closure:0;_box_0,$this,convert,E,$ti",
      call$0: [function() {
        var t1, add, t2, addError, t3;
        t1 = this._box_0;
        add = J.get$add$ax(t1.controller);
        t2 = this.E;
        addError = H.assertSubtype(t1.controller, "$is_EventSink", [t2], "$as_EventSink").get$_addError();
        t3 = this.$this;
        t1.subscription = t3.listen$3$onDone$onError(new P.Stream_asyncMap_onListen_closure(t1, t3, this.convert, t2, add, addError), J.get$close$z(t1.controller), addError);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_asyncMap_onListen_closure: {
      "^": "Closure;_box_0,$this,convert,E,add,addError,$ti",
      call$1: [function($event) {
        var newValue, e, s, t1, exception, t2, t3;
        t1 = this.$this;
        H.assertSubtypeOfRuntimeType($event, H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0));
        newValue = null;
        try {
          newValue = this.convert.call$1($event);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this._box_0.controller.addError$2(e, s);
          return;
        }
        t1 = newValue;
        t2 = this.E;
        t3 = this._box_0;
        if (H.checkSubtype(t1, "$isFuture", [t2], "$asFuture")) {
          J.pause$0$z(t3.subscription);
          newValue.then$1$2$onError(this.add, this.addError, -1).whenComplete$1(t3.subscription.get$resume());
        } else
          J.add$1$ax(t3.controller, H.assertSubtypeOfRuntimeType(newValue, t2));
      }, null, null, 4, 0, null, 22, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0)]};
      }
    },
    Stream_asyncMap_closure: {
      "^": "Closure:1;_box_0,$ti",
      call$0: [function() {
        this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, null, "call"]
    },
    Stream_asyncMap_closure1: {
      "^": "Closure:1;_box_0,$ti",
      call$0: [function() {
        J.pause$0$z(this._box_0.subscription);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_asyncMap_closure2: {
      "^": "Closure:1;_box_0,$ti",
      call$0: [function() {
        this._box_0.subscription.resume$0();
      }, null, null, 0, 0, null, "call"]
    },
    Stream_asyncMap_closure0: {
      "^": "Closure:8;_box_0,$ti",
      call$0: [function() {
        return this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, null, "call"]
    },
    Stream_length_closure: {
      "^": "Closure;_box_0,$this,$ti",
      call$1: [function(_) {
        var t1 = this.$this;
        H.assertSubtypeOfRuntimeType(_, H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0));
        t1 = this._box_0;
        t1.count = J.$add$ansx(t1.count, 1);
      }, null, null, 4, 0, null, 12, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0)]};
      }
    },
    Stream_length_closure0: {
      "^": "Closure:1;_box_0,future,$ti",
      call$0: [function() {
        this.future._complete$1(this._box_0.count);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_isEmpty_closure: {
      "^": "Closure;_box_0,$this,future,$ti",
      call$1: [function(_) {
        var t1 = this.$this;
        H.assertSubtypeOfRuntimeType(_, H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0));
        P._cancelAndValue(this._box_0.subscription, this.future, false);
      }, null, null, 4, 0, null, 12, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0)]};
      }
    },
    Stream_isEmpty_closure0: {
      "^": "Closure:1;future,$ti",
      call$0: [function() {
        this.future._complete$1(true);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_first_closure: {
      "^": "Closure;_box_0,$this,future,$ti",
      call$1: [function(value) {
        var t1 = this.$this;
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0));
        P._cancelAndValue(this._box_0.subscription, this.future, value);
      }, null, null, 4, 0, null, 1, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgumentIntercepted(J.getInterceptor$(t1), t1, "Stream", 0)]};
      }
    },
    Stream_first_closure0: {
      "^": "Closure:1;future,$ti",
      call$0: [function() {
        var e, s, t1, exception;
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, null, "call"]
    },
    StreamSubscription: {
      "^": "Object;$ti"
    },
    EventSink: {
      "^": "Object;$ti",
      $isSink: 1
    },
    StreamView: {
      "^": "Stream;$ti",
      get$isBroadcast: [function() {
        return this._stream.get$isBroadcast();
      }, null, null, 2, 0, null],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "StreamView", 0)]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        return this._stream.listen$4$cancelOnError$onDone$onError(onData, H.boolTypeCheck(cancelOnError), onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31]
    },
    StreamConsumer: {
      "^": "Object;$ti"
    },
    StreamSink: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isSink: 1
    },
    StreamTransformer: {
      "^": "Object;$ti"
    },
    StreamTransformerBase: {
      "^": "Object;$ti",
      $isStreamTransformer: 1
    },
    StreamIterator: {
      "^": "Object;$ti"
    },
    _ControllerEventSinkWrapper: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isSink: 1
    },
    StreamController: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isSink: 1
    },
    SynchronousStreamController: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isStreamController: 1,
      $isSink: 1
    },
    _StreamControllerLifecycle: {
      "^": "Object;$ti"
    },
    _StreamController: {
      "^": "Object;_state<,0_doneFuture<,onListen<,onCancel,$ti",
      set$_state: function(_state) {
        this._state = H.intTypeCheck(_state);
      },
      set$onListen: function(onListen) {
        this.onListen = H.functionTypeCheck(onListen, {func: 1, ret: -1});
      },
      set$onCancel: function(onCancel) {
        this.onCancel = H.functionTypeCheck(onCancel, {func: 1});
      },
      get$stream: [function(_) {
        return P._ControllerStream$(this, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      get$_isCanceled: [function() {
        return !J.$eq$(J.$and$bn(this._state, 2), 0);
      }, null, null, 2, 0, null],
      get$hasListener: [function() {
        return !J.$eq$(J.$and$bn(this._state, 1), 0);
      }, null, null, 2, 0, null],
      get$_isInitialState: [function() {
        return J.$eq$(J.$and$bn(this._state, 3), 0);
      }, null, null, 2, 0, null],
      get$isClosed: [function() {
        return !J.$eq$(J.$and$bn(this._state, 4), 0);
      }, null, null, 2, 0, null],
      get$_isAddingStream: [function() {
        return !J.$eq$(J.$and$bn(this._state, 8), 0);
      }, null, null, 2, 0, null],
      get$_mayAddEvent: [function() {
        return J.$lt$n(this._state, 4);
      }, null, null, 2, 0, null],
      get$_pendingEvents: [function() {
        if (!this.get$_isAddingStream())
          return H.assertSubtype(this._varData, "$is_PendingEvents", this.$ti, "$as_PendingEvents");
        var t1 = this.$ti;
        return H.assertSubtype(H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").get$varData(), "$is_PendingEvents", t1, "$as_PendingEvents");
      }, null, null, 2, 0, null],
      _ensurePendingEvents$0: [function() {
        var t1, state;
        if (!this.get$_isAddingStream()) {
          t1 = this._varData;
          if (t1 == null) {
            t1 = P._StreamImplEvents$(H.getTypeArgumentByIndex(this, 0));
            this._varData = t1;
          }
          return H.assertSubtype(t1, "$is_StreamImplEvents", this.$ti, "$as_StreamImplEvents");
        }
        t1 = this.$ti;
        state = H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState");
        if (state.get$varData() == null)
          state.set$varData(P._StreamImplEvents$(H.getTypeArgumentByIndex(this, 0)));
        return H.assertSubtype(state.get$varData(), "$is_StreamImplEvents", t1, "$as_StreamImplEvents");
      }, null, "get$_ensurePendingEvents", 0, 0, null],
      get$_subscription: [function() {
        if (this.get$_isAddingStream()) {
          var t1 = this.$ti;
          return H.assertSubtype(H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").get$varData(), "$is_ControllerSubscription", t1, "$as_ControllerSubscription");
        }
        return H.assertSubtype(this._varData, "$is_ControllerSubscription", this.$ti, "$as_ControllerSubscription");
      }, null, null, 2, 0, null],
      _badEventState$0: [function() {
        if (this.get$isClosed())
          return P.StateError$("Cannot add event after closing");
        return P.StateError$("Cannot add event while adding a stream");
      }, null, "get$_badEventState", 0, 0, null],
      _ensureDoneFuture$0: [function() {
        var t1 = this._doneFuture;
        if (t1 == null) {
          t1 = H.interceptedTypeCheck(this.get$_isCanceled() ? $.$get$Future__nullFuture() : P._Future$(null), "$is_Future");
          this._doneFuture = t1;
        }
        return t1;
      }, null, "get$_ensureDoneFuture", 0, 0, null],
      add$1: [function(_, value) {
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._badEventState$0());
        this._add$1(value);
      }, "call$1", "get$add", 5, 0, 2, 1],
      addError$2: [function(error, stackTrace) {
        var replacement;
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._badEventState$0());
        error = P._nonNullError(error);
        replacement = P.Zone_current().errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = P._nonNullError(replacement.error);
          stackTrace = replacement.stackTrace;
        }
        this._addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 4, 2, 5, 0, 14, 20],
      close$0: [function(_) {
        if (this.get$isClosed())
          return this._ensureDoneFuture$0();
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._badEventState$0());
        this._closeUnchecked$0();
        return this._ensureDoneFuture$0();
      }, "call$0", "get$close", 1, 0, 8],
      _closeUnchecked$0: [function() {
        this._state = H.intTypeCheck(J.$or$n(this._state, 4));
        if (this.get$hasListener())
          this._sendDone$0();
        else if (this.get$_isInitialState())
          J.add$1$ax(this._ensurePendingEvents$0(), C.C__DelayedDone);
      }, null, "get$_closeUnchecked", 0, 0, null],
      _add$1: [function(value) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.assertSubtypeOfRuntimeType(value, t1);
        if (this.get$hasListener())
          this._sendData$1(value);
        else if (this.get$_isInitialState())
          J.add$1$ax(this._ensurePendingEvents$0(), P._DelayedData$(value, t1));
      }, null, "get$_add", 4, 0, null, 1],
      _addError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        if (this.get$hasListener())
          this._sendError$2(error, stackTrace);
        else if (this.get$_isInitialState())
          J.add$1$ax(this._ensurePendingEvents$0(), P._DelayedError$(error, stackTrace));
      }, "call$2", "get$_addError", 8, 0, 13, 14, 20],
      _close$0: [function() {
        var addState = H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", this.$ti, "$as_StreamControllerAddStreamState");
        this._varData = addState.get$varData();
        this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967287));
        C.JSNull_methods.complete$0(addState);
      }, null, "get$_close", 0, 0, null],
      _subscribe$4: [function(onData, onError, onDone, cancelOnError) {
        var t1, subscription, pendingEvents, addState;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        H.boolTypeCheck(cancelOnError);
        if (!this.get$_isInitialState())
          throw H.wrapException(P.StateError$("Stream has already been listened to."));
        subscription = P._ControllerSubscription$(this, onData, onError, onDone, cancelOnError, t1);
        pendingEvents = this.get$_pendingEvents();
        this._state = H.intTypeCheck(J.$or$n(this._state, 1));
        if (this.get$_isAddingStream()) {
          addState = H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", this.$ti, "$as_StreamControllerAddStreamState");
          addState.set$varData(subscription);
          addState.resume$0();
        } else
          this._varData = subscription;
        subscription._setPendingEvents$1(pendingEvents);
        subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
        return subscription;
      }, null, "get$_subscribe", 16, 0, null, 32, 31, 47, 45],
      _recordCancel$1: [function(subscription) {
        var result, e, s, t1, exception, result0;
        t1 = this.$ti;
        H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
        result = null;
        if (this.get$_isAddingStream())
          result = H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").cancel$0();
        this._varData = null;
        this._state = H.intTypeCheck(J.$or$n(J.$and$bn(this._state, 4294967286), 2));
        t1 = this.onCancel;
        if (t1 != null)
          if (result == null)
            try {
              result = H.interceptedTypeCheck(t1.call$0(), "$isFuture");
            } catch (exception) {
              e = H.unwrapException(exception);
              s = H.getTraceFromException(exception);
              result0 = P._Future$(null);
              result0._asyncCompleteError$2(e, s);
              result = result0;
            }
          else
            result = result.whenComplete$1(t1);
        t1 = new P._StreamController__recordCancel_complete(this);
        if (result != null)
          result = result.whenComplete$1(t1);
        else
          t1.call$0();
        return result;
      }, null, "get$_recordCancel", 4, 0, null, 88],
      _recordPause$1: [function(subscription) {
        var t1 = this.$ti;
        H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
        if (this.get$_isAddingStream())
          C.JSNull_methods.pause$0(H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState"));
        P._runGuarded(this.onPause);
      }, null, "get$_recordPause", 4, 0, null, 88],
      _recordResume$1: [function(subscription) {
        var t1 = this.$ti;
        H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
        if (this.get$_isAddingStream())
          H.assertSubtype(this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").resume$0();
        P._runGuarded(this.onResume);
      }, null, "get$_recordResume", 4, 0, null, 88],
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isStreamController: 1,
      $is_StreamControllerLifecycle: 1,
      $is_EventSink: 1,
      $is_EventDispatch: 1,
      $isSink: 1
    },
    _StreamController__subscribe_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        P._runGuarded(this.$this.get$onListen());
      }, null, null, 0, 0, null, "call"]
    },
    _StreamController__recordCancel_complete: {
      "^": "Closure:0;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        if (t1.get$_doneFuture() != null && t1.get$_doneFuture().get$_mayComplete())
          t1.get$_doneFuture()._asyncComplete$1(null);
      }, null, null, 0, 0, null, "call"]
    },
    _SyncStreamControllerDispatch: {
      "^": "Object;$ti",
      _sendData$1: [function(data) {
        H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
        this.get$_subscription()._add$1(data);
      }, null, "get$_sendData", 4, 0, null, 34],
      _sendError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        this.get$_subscription()._addError$2(error, stackTrace);
      }, null, "get$_sendError", 8, 0, null, 14, 20],
      _sendDone$0: [function() {
        this.get$_subscription()._close$0();
      }, null, "get$_sendDone", 0, 0, null],
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isStreamController: 1,
      $isSynchronousStreamController: 1,
      $is_StreamControllerLifecycle: 1,
      $is_StreamController: 1,
      $is_EventSink: 1,
      $is_EventDispatch: 1,
      $isSink: 1
    },
    _AsyncStreamControllerDispatch: {
      "^": "Object;$ti",
      _sendData$1: [function(data) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.assertSubtypeOfRuntimeType(data, t1);
        this.get$_subscription()._addPending$1(P._DelayedData$(data, t1));
      }, null, "get$_sendData", 4, 0, null, 34],
      _sendError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        this.get$_subscription()._addPending$1(P._DelayedError$(error, stackTrace));
      }, null, "get$_sendError", 8, 0, null, 14, 20],
      _sendDone$0: [function() {
        this.get$_subscription()._addPending$1(C.C__DelayedDone);
      }, null, "get$_sendDone", 0, 0, null],
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isStreamController: 1,
      $is_StreamControllerLifecycle: 1,
      $is_StreamController: 1,
      $is_EventSink: 1,
      $is_EventDispatch: 1,
      $isSink: 1
    },
    _AsyncStreamController: {
      "^": "_StreamController+_AsyncStreamControllerDispatch;0_varData,_state,0_doneFuture,onListen,onPause,onResume,onCancel,$ti",
      $is_AsyncStreamControllerDispatch: 1,
      static: {
        _AsyncStreamController$: [function(onListen, onPause, onResume, onCancel, $T) {
          return new P._AsyncStreamController(0, onListen, onPause, onResume, onCancel, [$T]);
        }, null, null, 16, 0, null, 138, 277, 276, 139]
      }
    },
    _SyncStreamController: {
      "^": "_StreamController+_SyncStreamControllerDispatch;0_varData,_state,0_doneFuture,onListen,onPause,onResume,onCancel,$ti",
      $isSynchronousStreamController: 1,
      $is_SyncStreamControllerDispatch: 1,
      static: {
        _SyncStreamController$: [function(onListen, onPause, onResume, onCancel, $T) {
          return new P._SyncStreamController(0, onListen, onPause, onResume, onCancel, [$T]);
        }, null, null, 16, 0, null, 138, 277, 276, 139]
      }
    },
    _ControllerStream: {
      "^": "_StreamImpl;_controller,$ti",
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        return this._controller._subscribe$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), H.interceptedTypeCheck(onError, "$isFunction"), H.functionTypeCheck(onDone, {func: 1, ret: -1}), H.boolTypeCheck(cancelOnError));
      }, null, "get$_createSubscription", 16, 0, null, 32, 31, 47, 45],
      get$hashCode: [function(_) {
        return J.$xor$n(J.get$hashCode$(this._controller), 892482866);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof P._ControllerStream))
          return false;
        t1 = other._controller;
        t2 = this._controller;
        return t1 == null ? t2 == null : t1 === t2;
      }, null, "get$==", 5, 0, null, 3],
      static: {
        _ControllerStream$: [function(_controller, $T) {
          return new P._ControllerStream(_controller, [$T]);
        }, null, null, 4, 0, null, 430]
      }
    },
    _ControllerSubscription: {
      "^": "_BufferingStreamSubscription;_controller,0_onData,0_onError,0_onDone,_zone,_state,0_cancelFuture,0_pending,$ti",
      _onCancel$0: [function() {
        return this._controller._recordCancel$1(this);
      }, null, "get$_onCancel", 0, 0, null],
      _onPause$0: [function() {
        this._controller._recordPause$1(this);
      }, "call$0", "get$_onPause", 0, 0, 0],
      _onResume$0: [function() {
        this._controller._recordResume$1(this);
      }, "call$0", "get$_onResume", 0, 0, 0],
      static: {
        _ControllerSubscription$: [function(_controller, onData, onError, onDone, cancelOnError, $T) {
          var t1, t2;
          t1 = P.Zone_current();
          t2 = cancelOnError ? 1 : 0;
          t2 = new P._ControllerSubscription(_controller, t1, t2, [$T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          return t2;
        }, null, null, 20, 0, null, 430, 32, 31, 47, 45]
      }
    },
    _StreamSinkWrapper: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isSink: 1
    },
    _AddStreamState: {
      "^": "Object;$ti"
    },
    _StreamControllerAddStreamState: {
      "^": "_AddStreamState;$ti"
    },
    _EventSink: {
      "^": "Object;$ti"
    },
    _EventDispatch: {
      "^": "Object;$ti"
    },
    _BufferingStreamSubscription: {
      "^": "Object;0_onData,0_onError<,0_onDone<,_zone<,_state<,0_cancelFuture,0_pending,$ti",
      set$_onData: function(_onData) {
        this._onData = H.functionTypeCheck(_onData, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]});
      },
      set$_onDone: function(_onDone) {
        this._onDone = H.functionTypeCheck(_onDone, {func: 1, ret: -1});
      },
      set$_state: function(_state) {
        this._state = H.intTypeCheck(_state);
      },
      set$_pending: function(_pending) {
        this._pending = H.assertSubtype(_pending, "$is_PendingEvents", [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)], "$as_PendingEvents");
      },
      _BufferingStreamSubscription$4: [function(onData, onError, onDone, cancelOnError, $T) {
        this.onData$1(onData);
        this.onError$1(0, onError);
        this.onDone$1(onDone);
      }, null, null, 16, 0, null, 32, 31, 47, 45],
      _setPendingEvents$1: [function(pendingEvents) {
        H.assertSubtype(pendingEvents, "$is_PendingEvents", [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)], "$as_PendingEvents");
        if (pendingEvents == null)
          return;
        this.set$_pending(pendingEvents);
        if (!pendingEvents.get$isEmpty(pendingEvents)) {
          this._state = H.intTypeCheck(J.$or$n(this._state, 64));
          this._pending.schedule$1(this);
        }
      }, null, "get$_setPendingEvents", 4, 0, null, 702],
      onData$1: [function(handleData) {
        var t1 = H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0);
        H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [t1]});
        if (handleData == null)
          handleData = P.async___nullDataHandler$closure();
        this.set$_onData(this._zone.registerUnaryCallback$2$1(handleData, null, t1));
      }, null, "get$onData", 4, 0, null, 283],
      onError$1: [function(_, handleError) {
        H.interceptedTypeCheck(handleError, "$isFunction");
        if (handleError == null)
          handleError = P.async___nullErrorHandler$closure();
        if (H.functionTypeTest(handleError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
          this._onError = H.interceptedTypeCheck(this._zone.registerBinaryCallback$3$1(handleError, null, P.Object, P.StackTrace), "$isFunction");
        else if (H.functionTypeTest(handleError, {func: 1, ret: -1, args: [P.Object]}))
          this._onError = H.interceptedTypeCheck(this._zone.registerUnaryCallback$2$1(handleError, null, P.Object), "$isFunction");
        else
          throw H.wrapException(P.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace."));
      }, "call$1", "get$onError", 5, 0, 33, 322],
      onDone$1: [function(handleDone) {
        H.functionTypeCheck(handleDone, {func: 1, ret: -1});
        if (handleDone == null)
          handleDone = P.async___nullDoneHandler$closure();
        this.set$_onDone(this._zone.registerCallback$1$1(handleDone, -1));
      }, null, "get$onDone", 4, 0, null, 294],
      pause$1: [function(_, resumeSignal) {
        var wasPaused, wasInputPaused;
        H.interceptedTypeCheck(resumeSignal, "$isFuture");
        if (this.get$_isCanceled())
          return;
        wasPaused = this.get$_isPaused();
        wasInputPaused = this.get$_isInputPaused();
        this._state = H.intTypeCheck(J.$or$n(J.$add$ansx(this._state, 128), 4));
        if (resumeSignal != null)
          resumeSignal.whenComplete$1(this.get$resume());
        if (!wasPaused && this._pending != null)
          this._pending.cancelSchedule$0();
        if (!wasInputPaused && !this.get$_inCallback())
          this._guardCallback$1(this.get$_onPause());
      }, function($receiver) {
        return this.pause$1($receiver, null);
      }, "pause$0", null, null, "get$pause", 1, 2, null, 0, 175],
      resume$0: [function() {
        if (this.get$_isCanceled())
          return;
        if (this.get$_isPaused()) {
          this._decrementPauseCount$0();
          if (!this.get$_isPaused())
            if (this.get$_hasPending() && !J.get$isEmpty$asx(this._pending))
              this._pending.schedule$1(this);
            else {
              this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967291));
              if (!this.get$_inCallback())
                this._guardCallback$1(this.get$_onResume());
            }
        }
      }, "call$0", "get$resume", 0, 0, 0],
      cancel$0: [function() {
        this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967279));
        if (!this.get$_isCanceled())
          this._cancel$0();
        var t1 = this._cancelFuture;
        return t1 == null ? $.$get$Future__nullFuture() : t1;
      }, null, "get$cancel", 0, 0, null],
      get$_isInputPaused: [function() {
        return !J.$eq$(J.$and$bn(this._state, 4), 0);
      }, null, null, 2, 0, null],
      get$_isClosed: [function() {
        return !J.$eq$(J.$and$bn(this._state, 2), 0);
      }, null, null, 2, 0, null],
      get$_isCanceled: [function() {
        return !J.$eq$(J.$and$bn(this._state, 8), 0);
      }, null, null, 2, 0, null],
      get$_waitsForCancel: [function() {
        return !J.$eq$(J.$and$bn(this._state, 16), 0);
      }, null, null, 2, 0, null],
      get$_inCallback: [function() {
        return !J.$eq$(J.$and$bn(this._state, 32), 0);
      }, null, null, 2, 0, null],
      get$_hasPending: [function() {
        return !J.$eq$(J.$and$bn(this._state, 64), 0);
      }, null, null, 2, 0, null],
      get$_isPaused: [function() {
        return J.$ge$n(this._state, 128);
      }, null, null, 2, 0, null],
      get$_canFire: [function() {
        return J.$lt$n(this._state, 32);
      }, null, null, 2, 0, null],
      get$_mayResumeInput: [function() {
        if (!this.get$_isPaused()) {
          var t1 = this._pending;
          t1 = t1 == null || J.get$isEmpty$asx(t1);
        } else
          t1 = false;
        return t1;
      }, null, null, 2, 0, null],
      get$_cancelOnError: [function() {
        return !J.$eq$(J.$and$bn(this._state, 1), 0);
      }, null, null, 2, 0, null],
      _cancel$0: [function() {
        this._state = H.intTypeCheck(J.$or$n(this._state, 8));
        if (this.get$_hasPending())
          this._pending.cancelSchedule$0();
        if (!this.get$_inCallback())
          this.set$_pending(null);
        this._cancelFuture = H.interceptedTypeCheck(this._onCancel$0(), "$isFuture");
      }, null, "get$_cancel", 0, 0, null],
      _decrementPauseCount$0: [function() {
        this._state = H.intTypeCheck(J.$sub$n(this._state, 128));
      }, null, "get$_decrementPauseCount", 0, 0, null],
      _add$1: ["super$_BufferingStreamSubscription$_add", function(data) {
        var t1 = H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0);
        H.assertSubtypeOfRuntimeType(data, t1);
        if (this.get$_isCanceled())
          return;
        if (this.get$_canFire())
          this._sendData$1(data);
        else
          this._addPending$1(P._DelayedData$(data, t1));
      }, null, "get$_add", 4, 0, null, 34],
      _addError$2: ["super$_BufferingStreamSubscription$_addError", function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        if (this.get$_isCanceled())
          return;
        if (this.get$_canFire())
          this._sendError$2(error, stackTrace);
        else
          this._addPending$1(P._DelayedError$(error, stackTrace));
      }, "call$2", "get$_addError", 8, 0, 13, 14, 20],
      _close$0: ["super$_BufferingStreamSubscription$_close", function() {
        if (this.get$_isCanceled())
          return;
        this._state = H.intTypeCheck(J.$or$n(this._state, 2));
        if (this.get$_canFire())
          this._sendDone$0();
        else
          this._addPending$1(C.C__DelayedDone);
      }, null, "get$_close", 0, 0, null],
      _onPause$0: [function() {
      }, "call$0", "get$_onPause", 0, 0, 0],
      _onResume$0: [function() {
      }, "call$0", "get$_onResume", 0, 0, 0],
      _onCancel$0: [function() {
        return;
      }, null, "get$_onCancel", 0, 0, null],
      _addPending$1: [function($event) {
        var t1, pending;
        H.interceptedTypeCheck($event, "$is_DelayedEvent");
        t1 = H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0);
        pending = H.assertSubtype(this._pending, "$is_StreamImplEvents", [t1], "$as_StreamImplEvents");
        if (pending == null) {
          pending = P._StreamImplEvents$(t1);
          this.set$_pending(pending);
        }
        pending.add$1(0, $event);
        if (!this.get$_hasPending()) {
          this._state = H.intTypeCheck(J.$or$n(this._state, 64));
          if (!this.get$_isPaused())
            this._pending.schedule$1(this);
        }
      }, null, "get$_addPending", 4, 0, null, 22],
      _sendData$1: [function(data) {
        var t1, wasInputPaused;
        t1 = H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0);
        H.assertSubtypeOfRuntimeType(data, t1);
        wasInputPaused = this.get$_isInputPaused();
        this._state = H.intTypeCheck(J.$or$n(this._state, 32));
        this._zone.runUnaryGuarded$1$2(this._onData, data, t1);
        this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967263));
        this._checkState$1(wasInputPaused);
      }, null, "get$_sendData", 4, 0, null, 34],
      _sendError$2: [function(error, stackTrace) {
        var wasInputPaused, t1, t2;
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        wasInputPaused = this.get$_isInputPaused();
        t1 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
        if (this.get$_cancelOnError()) {
          this._state = H.intTypeCheck(J.$or$n(this._state, 16));
          this._cancel$0();
          t2 = this._cancelFuture;
          if (!!J.getInterceptor$(t2).$isFuture && t2 !== $.$get$Future__nullFuture())
            t2.whenComplete$1(t1);
          else
            t1.call$0();
        } else {
          t1.call$0();
          this._checkState$1(wasInputPaused);
        }
      }, null, "get$_sendError", 8, 0, null, 14, 20],
      _sendDone$0: [function() {
        var t1, t2;
        t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
        this._cancel$0();
        this._state = H.intTypeCheck(J.$or$n(this._state, 16));
        t2 = this._cancelFuture;
        if (!!J.getInterceptor$(t2).$isFuture && t2 !== $.$get$Future__nullFuture())
          t2.whenComplete$1(t1);
        else
          t1.call$0();
      }, null, "get$_sendDone", 0, 0, null],
      _guardCallback$1: [function(callback) {
        var wasInputPaused;
        H.functionTypeCheck(callback, {func: 1, ret: -1});
        wasInputPaused = this.get$_isInputPaused();
        this._state = H.intTypeCheck(J.$or$n(this._state, 32));
        callback.call$0();
        this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967263));
        this._checkState$1(wasInputPaused);
      }, null, "get$_guardCallback", 4, 0, null, 43],
      _checkState$1: [function(wasInputPaused) {
        var isInputPaused;
        H.boolTypeCheck(wasInputPaused);
        if (this.get$_hasPending() && J.get$isEmpty$asx(this._pending)) {
          this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967231));
          if (this.get$_isInputPaused() && this.get$_mayResumeInput())
            this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967291));
        }
        for (; true; wasInputPaused = isInputPaused) {
          if (this.get$_isCanceled()) {
            this.set$_pending(null);
            return;
          }
          isInputPaused = this.get$_isInputPaused();
          if (wasInputPaused == isInputPaused)
            break;
          this._state = H.intTypeCheck(J.$xor$n(this._state, 32));
          if (isInputPaused)
            this._onPause$0();
          else
            this._onResume$0();
          this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967263));
        }
        if (this.get$_hasPending() && !this.get$_isPaused())
          this._pending.schedule$1(this);
      }, null, "get$_checkState", 4, 0, null, 730],
      $isStreamSubscription: 1,
      $is_EventSink: 1,
      $is_EventDispatch: 1,
      static: {
        _BufferingStreamSubscription$: [function(onData, onError, onDone, cancelOnError, $T) {
          var t1, t2;
          t1 = P.Zone_current();
          t2 = cancelOnError ? 1 : 0;
          t2 = new P._BufferingStreamSubscription(t1, t2, [$T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          return t2;
        }, null, null, 16, 0, null, 32, 31, 47, 45]
      }
    },
    _BufferingStreamSubscription__sendError_sendError: {
      "^": "Closure:0;$this,error,stackTrace,$ti",
      call$0: [function() {
        var t1, onError, t2, t3;
        t1 = this.$this;
        if (t1.get$_isCanceled() && !t1.get$_waitsForCancel())
          return;
        t1.set$_state(J.$or$n(t1.get$_state(), 32));
        onError = t1.get$_onError();
        t2 = this.error;
        t3 = P.Object;
        if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
          t1.get$_zone().runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, P.StackTrace);
        else
          t1.get$_zone().runUnaryGuarded$1$2(H.functionTypeCheck(t1.get$_onError(), {func: 1, ret: -1, args: [P.Object]}), t2, t3);
        t1.set$_state(J.$and$bn(t1.get$_state(), 4294967263));
      }, null, null, 0, 0, null, "call"]
    },
    _BufferingStreamSubscription__sendDone_sendDone: {
      "^": "Closure:0;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        if (!t1.get$_waitsForCancel())
          return;
        t1.set$_state(J.$or$n(t1.get$_state(), 42));
        t1.get$_zone().runGuarded$1(t1.get$_onDone());
        t1.set$_state(J.$and$bn(t1.get$_state(), 4294967263));
      }, null, null, 0, 0, null, "call"]
    },
    _StreamImpl: {
      "^": "Stream;$ti",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var subscription = this._createSubscription$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), H.interceptedTypeCheck(onError, "$isFunction"), H.functionTypeCheck(onDone, {func: 1, ret: -1}), true === H.boolTypeCheck(cancelOnError));
        this._onListen$1(subscription);
        return subscription;
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return P._BufferingStreamSubscription$(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]}), H.interceptedTypeCheck(onError, "$isFunction"), H.functionTypeCheck(onDone, {func: 1, ret: -1}), H.boolTypeCheck(cancelOnError), t1);
      }, null, "get$_createSubscription", 16, 0, null, 32, 31, 47, 45],
      _onListen$1: [function(subscription) {
        H.interceptedTypeCheck(subscription, "$isStreamSubscription");
      }, null, "get$_onListen", 4, 0, null, 88]
    },
    _GeneratedStreamImpl: {
      "^": "_StreamImpl;_pending,_isUsed,$ti",
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        H.boolTypeCheck(cancelOnError);
        if (this._isUsed)
          throw H.wrapException(P.StateError$("Stream has already been listened to."));
        this._isUsed = true;
        t1 = P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, t1);
        t1._setPendingEvents$1(this._pending.call$0());
        return t1;
      }, null, "get$_createSubscription", 16, 0, null, 32, 31, 47, 45],
      static: {
        _GeneratedStreamImpl$: [function(_pending, $T) {
          return new P._GeneratedStreamImpl(_pending, false, [$T]);
        }, null, null, 4, 0, null, 640]
      }
    },
    _IterablePendingEvents: {
      "^": "_PendingEvents;_async$_iterator,_state,$ti",
      set$_async$_iterator: function(_iterator) {
        this._async$_iterator = H.assertSubtype(_iterator, "$isIterator", this.$ti, "$asIterator");
      },
      get$isEmpty: [function(_) {
        return this._async$_iterator == null;
      }, null, null, 3, 0, null],
      handleNext$1: [function(dispatch) {
        var hasMore, e, s, t1, exception;
        H.assertSubtype(dispatch, "$is_EventDispatch", this.$ti, "$as_EventDispatch");
        t1 = this._async$_iterator;
        if (t1 == null)
          throw H.wrapException(P.StateError$("No events pending."));
        hasMore = null;
        try {
          hasMore = t1.moveNext$0();
          if (hasMore)
            dispatch._sendData$1(this._async$_iterator.get$current());
          else {
            this.set$_async$_iterator(null);
            dispatch._sendDone$0();
          }
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          if (hasMore == null) {
            this.set$_async$_iterator(C.C_EmptyIterator);
            dispatch._sendError$2(e, s);
          } else
            dispatch._sendError$2(e, s);
        }
      }, null, "get$handleNext", 4, 0, null, 174],
      clear$0: [function(_) {
        if (this.get$isScheduled())
          this.cancelSchedule$0();
        this.set$_async$_iterator(null);
      }, null, "get$clear", 1, 0, null],
      static: {
        _IterablePendingEvents$: [function(data, $T) {
          return new P._IterablePendingEvents(J.get$iterator$ax(data), 0, [$T]);
        }, null, null, 4, 0, null, 34]
      }
    },
    _DelayedEvent: {
      "^": "Object;0next<,$ti",
      set$next: function(next) {
        this.next = H.interceptedTypeCheck(next, "$is_DelayedEvent");
      }
    },
    _DelayedData: {
      "^": "_DelayedEvent;value>,0next,$ti",
      perform$1: [function(dispatch) {
        H.assertSubtype(dispatch, "$is_EventDispatch", this.$ti, "$as_EventDispatch")._sendData$1(this.value);
      }, null, "get$perform", 4, 0, null, 174],
      static: {
        _DelayedData$: [function(value, $T) {
          return new P._DelayedData(value, [$T]);
        }, null, null, 4, 0, null, 1]
      }
    },
    _DelayedError: {
      "^": "_DelayedEvent;error>,stackTrace<,0next,$ti",
      perform$1: [function(dispatch) {
        H.interceptedTypeCheck(dispatch, "$is_EventDispatch")._sendError$2(this.error, this.stackTrace);
      }, null, "get$perform", 4, 0, null, 174],
      error$1: function($receiver, arg0) {
        return this.error.call$1(arg0);
      },
      $as_DelayedEvent: Isolate.functionThatReturnsNull,
      static: {
        _DelayedError$: [function(error, stackTrace) {
          return new P._DelayedError(error, stackTrace, []);
        }, null, null, 8, 0, null, 14, 20]
      }
    },
    _DelayedDone: {
      "^": "Object;$ti",
      perform$1: [function(dispatch) {
        H.interceptedTypeCheck(dispatch, "$is_EventDispatch")._sendDone$0();
      }, null, "get$perform", 4, 0, null, 174],
      get$next: [function() {
        return;
      }, null, null, 2, 0, null],
      set$next: [function(_) {
        H.interceptedTypeCheck(_, "$is_DelayedEvent");
        throw H.wrapException(P.StateError$("No events after a done."));
      }, null, null, 6, 0, null, 12],
      $is_DelayedEvent: 1,
      $as_DelayedEvent: Isolate.functionThatReturnsNull
    },
    _PendingEvents: {
      "^": "Object;_state<,$ti",
      set$_state: function(_state) {
        this._state = H.intTypeCheck(_state);
      },
      get$isScheduled: [function() {
        return J.$eq$(this._state, 1);
      }, null, null, 2, 0, null],
      get$_eventScheduled: [function() {
        return J.$ge$n(this._state, 1);
      }, null, null, 2, 0, null],
      schedule$1: [function(dispatch) {
        H.assertSubtype(dispatch, "$is_EventDispatch", this.$ti, "$as_EventDispatch");
        if (this.get$isScheduled())
          return;
        if (this.get$_eventScheduled()) {
          this._state = 1;
          return;
        }
        P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
        this._state = 1;
      }, null, "get$schedule", 4, 0, null, 174],
      cancelSchedule$0: [function() {
        if (this.get$isScheduled())
          this._state = 3;
      }, null, "get$cancelSchedule", 0, 0, null]
    },
    _PendingEvents_schedule_closure: {
      "^": "Closure:1;$this,dispatch,$ti",
      call$0: [function() {
        var t1, oldState;
        t1 = this.$this;
        oldState = t1.get$_state();
        t1.set$_state(0);
        if (oldState === 3)
          return;
        t1.handleNext$1(this.dispatch);
      }, null, null, 0, 0, null, "call"]
    },
    _StreamImplEvents: {
      "^": "_PendingEvents;0firstPendingEvent,0lastPendingEvent,_state,$ti",
      get$isEmpty: [function(_) {
        return this.lastPendingEvent == null;
      }, null, null, 3, 0, null],
      add$1: [function(_, $event) {
        var t1;
        H.interceptedTypeCheck($event, "$is_DelayedEvent");
        t1 = this.lastPendingEvent;
        if (t1 == null) {
          this.lastPendingEvent = $event;
          this.firstPendingEvent = $event;
        } else {
          t1.set$next($event);
          this.lastPendingEvent = $event;
        }
      }, "call$1", "get$add", 5, 0, 97, 22],
      handleNext$1: [function(dispatch) {
        var $event, t1;
        H.assertSubtype(dispatch, "$is_EventDispatch", this.$ti, "$as_EventDispatch");
        $event = this.firstPendingEvent;
        t1 = H.interceptedTypeCheck($event.get$next(), "$is_DelayedEvent");
        this.firstPendingEvent = t1;
        if (t1 == null)
          this.lastPendingEvent = null;
        $event.perform$1(dispatch);
      }, null, "get$handleNext", 4, 0, null, 174],
      clear$0: [function(_) {
        if (this.get$isScheduled())
          this.cancelSchedule$0();
        this.lastPendingEvent = null;
        this.firstPendingEvent = null;
      }, null, "get$clear", 1, 0, null],
      static: {
        _StreamImplEvents$: [function($T) {
          return new P._StreamImplEvents(0, [$T]);
        }, null, null, 0, 0, null]
      }
    },
    _DoneStreamSubscription: {
      "^": "Object;_zone<,_state<,_onDone<,$ti",
      set$_state: function(_state) {
        this._state = H.intTypeCheck(_state);
      },
      set$_onDone: function(_onDone) {
        this._onDone = H.functionTypeCheck(_onDone, {func: 1, ret: -1});
      },
      _DoneStreamSubscription$1: [function(_onDone, $T) {
        this._schedule$0();
      }, null, null, 4, 0, null, 432],
      get$_isSent: [function() {
        return !J.$eq$(J.$and$bn(this._state, 1), 0);
      }, null, null, 2, 0, null],
      get$_isScheduled: [function() {
        return !J.$eq$(J.$and$bn(this._state, 2), 0);
      }, null, null, 2, 0, null],
      get$isPaused: [function() {
        return J.$ge$n(this._state, 4);
      }, null, null, 2, 0, null],
      _schedule$0: [function() {
        if (this.get$_isScheduled())
          return;
        this._zone.scheduleMicrotask$1(this.get$_sendDone());
        this._state = H.intTypeCheck(J.$or$n(this._state, 2));
      }, null, "get$_schedule", 0, 0, null],
      onData$1: [function(handleData) {
        H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      }, null, "get$onData", 4, 0, null, 283],
      onError$1: [function(_, handleError) {
        H.interceptedTypeCheck(handleError, "$isFunction");
      }, "call$1", "get$onError", 5, 0, 33, 322],
      onDone$1: [function(handleDone) {
        this.set$_onDone(H.functionTypeCheck(handleDone, {func: 1, ret: -1}));
      }, null, "get$onDone", 4, 0, null, 294],
      pause$1: [function(_, resumeSignal) {
        H.interceptedTypeCheck(resumeSignal, "$isFuture");
        this._state = H.intTypeCheck(J.$add$ansx(this._state, 4));
        if (resumeSignal != null)
          resumeSignal.whenComplete$1(this.get$resume());
      }, function($receiver) {
        return this.pause$1($receiver, null);
      }, "pause$0", null, null, "get$pause", 1, 2, null, 0, 175],
      resume$0: [function() {
        if (this.get$isPaused()) {
          this._state = H.intTypeCheck(J.$sub$n(this._state, 4));
          if (!this.get$isPaused() && !this.get$_isSent())
            this._schedule$0();
        }
      }, "call$0", "get$resume", 0, 0, 0],
      cancel$0: [function() {
        return $.$get$Future__nullFuture();
      }, null, "get$cancel", 0, 0, null],
      _sendDone$0: [function() {
        this._state = H.intTypeCheck(J.$and$bn(this._state, 4294967293));
        if (this.get$isPaused())
          return;
        this._state = H.intTypeCheck(J.$or$n(this._state, 1));
        var t1 = this._onDone;
        if (t1 != null)
          this._zone.runGuarded$1(t1);
      }, "call$0", "get$_sendDone", 0, 0, 0],
      $isStreamSubscription: 1,
      static: {
        _DoneStreamSubscription$: [function(_onDone, $T) {
          var t1 = new P._DoneStreamSubscription(P.Zone_current(), 0, _onDone, [$T]);
          t1._DoneStreamSubscription$1(_onDone, $T);
          return t1;
        }, null, null, 4, 0, null, 432]
      }
    },
    _AsBroadcastStream: {
      "^": "Stream;$ti"
    },
    _BroadcastSubscriptionWrapper: {
      "^": "Object;$ti",
      $isStreamSubscription: 1
    },
    _StreamIterator: {
      "^": "Object;0_subscription,_stateData,_isPaused,$ti",
      get$current: [function() {
        if (this._subscription != null && this._isPaused)
          return H.assertSubtypeOfRuntimeType(this._stateData, H.getTypeArgumentByIndex(this, 0));
        return;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        if (this._subscription != null) {
          if (this._isPaused) {
            var future = P._Future$(P.bool);
            this._stateData = future;
            this._isPaused = false;
            this._subscription.resume$0();
            return future;
          }
          throw H.wrapException(P.StateError$("Already waiting for next."));
        }
        return this._initializeOrDone$0();
      }, null, "get$moveNext", 0, 0, null],
      _initializeOrDone$0: [function() {
        var stateData, future;
        stateData = this._stateData;
        if (stateData != null) {
          this._subscription = H.interceptedTypeCheck(H.assertSubtype(stateData, "$isStream", this.$ti, "$asStream").listen$4$cancelOnError$onDone$onError(this.get$_onData(), true, this.get$_onDone(), this.get$_onError()), "$isStreamSubscription");
          future = P._Future$(P.bool);
          this._stateData = future;
          return future;
        }
        return $.$get$Future__falseFuture();
      }, null, "get$_initializeOrDone", 0, 0, null],
      _onData$1: [function(data) {
        var moveNextFuture, t1;
        H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
        moveNextFuture = H.assertSubtype(this._stateData, "$is_Future", [P.bool], "$as_Future");
        this._stateData = data;
        this._isPaused = true;
        moveNextFuture._complete$1(true);
        t1 = this._subscription;
        if (t1 != null && this._isPaused)
          J.pause$0$z(t1);
      }, "call$1", "get$_onData", 4, 0, 2, 34],
      _onError$2: [function(error, stackTrace) {
        var moveNextFuture;
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        moveNextFuture = H.assertSubtype(this._stateData, "$is_Future", [P.bool], "$as_Future");
        this._subscription = null;
        this._stateData = null;
        moveNextFuture._completeError$2(error, stackTrace);
      }, function(error) {
        return this._onError$2(error, null);
      }, "_onError$1", "call$2", "call$1", "get$_onError", 4, 2, 5, 0, 14, 20],
      _onDone$0: [function() {
        var moveNextFuture = H.assertSubtype(this._stateData, "$is_Future", [P.bool], "$as_Future");
        this._subscription = null;
        this._stateData = null;
        moveNextFuture._complete$1(false);
      }, "call$0", "get$_onDone", 0, 0, 0],
      $isStreamIterator: 1,
      static: {
        _StreamIterator$: [function(stream, $T) {
          return new P._StreamIterator(stream, false, [$T]);
        }, null, null, 4, 0, null, 57]
      }
    },
    _EmptyStream: {
      "^": "Stream;$ti"
    },
    _cancelAndValue_closure: {
      "^": "Closure:0;future,value,$ti",
      call$0: [function() {
        return this.future._complete$1(this.value);
      }, null, null, 0, 0, null, "call"]
    },
    _ForwardingStream: {
      "^": "Stream;_source<,$ti",
      get$isBroadcast: [function() {
        return this._source.get$isBroadcast();
      }, null, null, 2, 0, null],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        return this._createSubscription$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "_ForwardingStream", 1)]}), H.interceptedTypeCheck(onError, "$isFunction"), H.functionTypeCheck(onDone, {func: 1, ret: -1}), true === H.boolTypeCheck(cancelOnError));
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      _createSubscription$4: [function(onData, onError, onDone, cancelOnError) {
        var t1 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 1);
        return P._ForwardingStreamSubscription$(this, H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]}), H.interceptedTypeCheck(onError, "$isFunction"), H.functionTypeCheck(onDone, {func: 1, ret: -1}), H.boolTypeCheck(cancelOnError), H.getRuntimeTypeArgument(this, "_ForwardingStream", 0), t1);
      }, null, "get$_createSubscription", 16, 0, null, 32, 31, 47, 45],
      _handleData$2: [function(data, sink) {
        var t1;
        H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0));
        t1 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 1);
        H.assertSubtype(sink, "$is_EventSink", [t1], "$as_EventSink")._add$1(H.assertSubtypeOfRuntimeType(data, t1));
      }, null, "get$_handleData", 8, 0, null, 34, 48],
      _handleError$3: [function(error, stackTrace, sink) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        H.assertSubtype(sink, "$is_EventSink", [H.getRuntimeTypeArgument(this, "_ForwardingStream", 1)], "$as_EventSink")._addError$2(error, stackTrace);
      }, null, "get$_handleError", 12, 0, null, 14, 20, 48],
      _handleDone$1: [function(sink) {
        H.assertSubtype(sink, "$is_EventSink", [H.getRuntimeTypeArgument(this, "_ForwardingStream", 1)], "$as_EventSink")._close$0();
      }, null, "get$_handleDone", 4, 0, null, 48],
      $asStream: function($S, $T) {
        return [$T];
      }
    },
    _ForwardingStreamSubscription: {
      "^": "_BufferingStreamSubscription;_stream,0_subscription,0_onData,0_onError,0_onDone,_zone,_state,0_cancelFuture,0_pending,$ti",
      set$_subscription: function(_subscription) {
        this._subscription = H.assertSubtype(_subscription, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
      },
      _ForwardingStreamSubscription$5: [function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
        this.set$_subscription(this._stream.get$_source().listen$3$onDone$onError(this.get$_handleData(), this.get$_handleDone(), this.get$_handleError()));
      }, null, null, 20, 0, null, 273, 32, 31, 47, 45],
      _add$1: [function(data) {
        H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 1));
        if (this.get$_isClosed())
          return;
        this.super$_BufferingStreamSubscription$_add(data);
      }, null, "get$_add", 4, 0, null, 34],
      _addError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        if (this.get$_isClosed())
          return;
        this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
      }, "call$2", "get$_addError", 8, 0, 13, 14, 20],
      _onPause$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        J.pause$0$z(t1);
      }, "call$0", "get$_onPause", 0, 0, 0],
      _onResume$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.resume$0();
      }, "call$0", "get$_onResume", 0, 0, 0],
      _onCancel$0: [function() {
        var t1 = this._subscription;
        if (t1 != null) {
          this.set$_subscription(null);
          return t1.cancel$0();
        }
        return;
      }, null, "get$_onCancel", 0, 0, null],
      _handleData$1: [function(data) {
        this._stream._handleData$2(H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0)), this);
      }, "call$1", "get$_handleData", 4, 0, 2, 34],
      _handleError$2: [function(error, stackTrace) {
        this._stream._handleError$3(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"), this);
      }, "call$2", "get$_handleError", 8, 0, 100, 14, 20],
      _handleDone$0: [function() {
        this._stream._handleDone$1(this);
      }, "call$0", "get$_handleDone", 0, 0, 0],
      $asStreamSubscription: function($S, $T) {
        return [$T];
      },
      $as_EventSink: function($S, $T) {
        return [$T];
      },
      $as_EventDispatch: function($S, $T) {
        return [$T];
      },
      $as_BufferingStreamSubscription: function($S, $T) {
        return [$T];
      },
      static: {
        _ForwardingStreamSubscription$: [function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
          var t1, t2;
          t1 = P.Zone_current();
          t2 = cancelOnError ? 1 : 0;
          t2 = new P._ForwardingStreamSubscription(_stream, t1, t2, [$S, $T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._ForwardingStreamSubscription$5(_stream, onData, onError, onDone, cancelOnError, $S, $T);
          return t2;
        }, null, null, 20, 0, null, 273, 32, 31, 47, 45]
      }
    },
    _WhereStream: {
      "^": "_ForwardingStream;_test,_source,$ti",
      _handleData$2: [function(inputEvent, sink) {
        var satisfies, e, s, exception;
        H.assertSubtypeOfRuntimeType(inputEvent, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtype(sink, "$is_EventSink", this.$ti, "$as_EventSink");
        satisfies = null;
        try {
          satisfies = this._test.call$1(inputEvent);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          return;
        }
        if (satisfies)
          sink._add$1(inputEvent);
      }, null, "get$_handleData", 8, 0, null, 467, 48],
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      },
      static: {
        _WhereStream$: [function(source, test, $T) {
          return new P._WhereStream(test, source, [$T]);
        }, null, null, 8, 0, null, 11, 41]
      }
    },
    _MapStream: {
      "^": "_ForwardingStream;_transform,_source,$ti",
      _handleData$2: [function(inputEvent, sink) {
        var outputEvent, e, s, exception;
        H.assertSubtypeOfRuntimeType(inputEvent, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtype(sink, "$is_EventSink", [H.getTypeArgumentByIndex(this, 1)], "$as_EventSink");
        outputEvent = null;
        try {
          outputEvent = this._transform.call$1(inputEvent);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          return;
        }
        sink._add$1(outputEvent);
      }, null, "get$_handleData", 8, 0, null, 467, 48],
      static: {
        _MapStream$: [function(source, transform, $S, $T) {
          return new P._MapStream(transform, source, [$S, $T]);
        }, null, null, 8, 0, null, 11, 204]
      }
    },
    _ExpandStream: {
      "^": "_ForwardingStream;$ti"
    },
    _HandleErrorStream: {
      "^": "_ForwardingStream;$ti",
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _TakeStream: {
      "^": "_ForwardingStream;$ti",
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _StateStreamSubscription: {
      "^": "_ForwardingStreamSubscription;$ti",
      $asStreamSubscription: null,
      $as_EventSink: null,
      $as_EventDispatch: null,
      $as_BufferingStreamSubscription: null,
      $as_ForwardingStreamSubscription: function($T) {
        return [$T, $T];
      }
    },
    _TakeWhileStream: {
      "^": "_ForwardingStream;$ti",
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _SkipStream: {
      "^": "_ForwardingStream;$ti",
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _SkipWhileStream: {
      "^": "_ForwardingStream;$ti",
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _DistinctStream: {
      "^": "_ForwardingStream;$ti",
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _EventSinkWrapper: {
      "^": "Object;_async$_sink,$ti",
      add$1: [function(_, data) {
        this._async$_sink._add$1(H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0)));
      }, "call$1", "get$add", 5, 0, 2, 34],
      addError$2: [function(error, stackTrace) {
        this._async$_sink._addError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 4, 2, 5, 0, 14, 20],
      close$0: [function(_) {
        this._async$_sink._close$0();
      }, "call$0", "get$close", 1, 0, 0],
      $isEventSink: 1,
      $isSink: 1,
      static: {
        _EventSinkWrapper$: [function(_sink, $T) {
          return new P._EventSinkWrapper(_sink, [$T]);
        }, null, null, 4, 0, null, 60]
      }
    },
    _SinkTransformerStreamSubscription: {
      "^": "_BufferingStreamSubscription;0_transformerSink,0_subscription,0_onData,0_onError,0_onDone,_zone,_state,0_cancelFuture,0_pending,$ti",
      set$_transformerSink: function(_transformerSink) {
        this._transformerSink = H.assertSubtype(_transformerSink, "$isEventSink", [H.getTypeArgumentByIndex(this, 0)], "$asEventSink");
      },
      set$_subscription: function(_subscription) {
        this._subscription = H.assertSubtype(_subscription, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
      },
      _SinkTransformerStreamSubscription$6: [function(source, mapper, onData, onError, onDone, cancelOnError, $S, $T) {
        this.set$_transformerSink(mapper.call$1(P._EventSinkWrapper$(this, $T)));
        this.set$_subscription(source.listen$3$onDone$onError(this.get$_handleData(), this.get$_handleDone(), this.get$_handleError()));
      }, null, null, 24, 0, null, 11, 436, 32, 31, 47, 45],
      get$_isSubscribed: [function() {
        return this._subscription != null;
      }, null, null, 2, 0, null],
      _add$1: [function(data) {
        H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 1));
        if (this.get$_isClosed())
          throw H.wrapException(P.StateError$("Stream is already closed"));
        this.super$_BufferingStreamSubscription$_add(data);
      }, null, "get$_add", 4, 0, null, 34],
      _addError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        if (this.get$_isClosed())
          throw H.wrapException(P.StateError$("Stream is already closed"));
        this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
      }, "call$2", "get$_addError", 8, 0, 13, 14, 20],
      _close$0: [function() {
        if (this.get$_isClosed())
          throw H.wrapException(P.StateError$("Stream is already closed"));
        this.super$_BufferingStreamSubscription$_close();
      }, null, "get$_close", 0, 0, null],
      _onPause$0: [function() {
        if (this.get$_isSubscribed())
          J.pause$0$z(this._subscription);
      }, "call$0", "get$_onPause", 0, 0, 0],
      _onResume$0: [function() {
        if (this.get$_isSubscribed())
          this._subscription.resume$0();
      }, "call$0", "get$_onResume", 0, 0, 0],
      _onCancel$0: [function() {
        if (this.get$_isSubscribed()) {
          var subscription = this._subscription;
          this.set$_subscription(null);
          return subscription.cancel$0();
        }
        return;
      }, null, "get$_onCancel", 0, 0, null],
      _handleData$1: [function(data) {
        var e, s, exception;
        H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
        try {
          J.add$1$ax(this._transformerSink, data);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this._addError$2(e, s);
        }
      }, "call$1", "get$_handleData", 4, 0, 2, 34],
      _handleError$2: [function(error, stackTrace) {
        var e, s, exception, t1;
        try {
          this._transformerSink.addError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = e;
          if (t1 == null ? error == null : t1 === error)
            this._addError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
          else
            this._addError$2(e, s);
        }
      }, function(error) {
        return this._handleError$2(error, null);
      }, "_handleError$1", "call$2", "call$1", "get$_handleError", 4, 2, 114, 0, 14, 20],
      _handleDone$0: [function() {
        var e, s, exception;
        try {
          this.set$_subscription(null);
          J.close$0$z(this._transformerSink);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this._addError$2(e, s);
        }
      }, "call$0", "get$_handleDone", 0, 0, 0],
      $asStreamSubscription: function($S, $T) {
        return [$T];
      },
      $as_EventSink: function($S, $T) {
        return [$T];
      },
      $as_EventDispatch: function($S, $T) {
        return [$T];
      },
      $as_BufferingStreamSubscription: function($S, $T) {
        return [$T];
      },
      static: {
        _SinkTransformerStreamSubscription$: [function(source, mapper, onData, onError, onDone, cancelOnError, $S, $T) {
          var t1, t2;
          t1 = P.Zone_current();
          t2 = cancelOnError ? 1 : 0;
          t2 = new P._SinkTransformerStreamSubscription(t1, t2, [$S, $T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._SinkTransformerStreamSubscription$6(source, mapper, onData, onError, onDone, cancelOnError, $S, $T);
          return t2;
        }, null, null, 24, 0, null, 11, 436, 32, 31, 47, 45]
      }
    },
    _StreamSinkTransformer: {
      "^": "StreamTransformerBase;$ti"
    },
    _BoundSinkStream: {
      "^": "Stream;_sinkMapper,_stream,$ti",
      get$isBroadcast: [function() {
        return this._stream.get$isBroadcast();
      }, null, null, 2, 0, null],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var t1 = H.getTypeArgumentByIndex(this, 1);
        return P._SinkTransformerStreamSubscription$(this._stream, this._sinkMapper, H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]}), H.interceptedTypeCheck(onError, "$isFunction"), H.functionTypeCheck(onDone, {func: 1, ret: -1}), true === H.boolTypeCheck(cancelOnError), H.getTypeArgumentByIndex(this, 0), t1);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      $asStream: function($S, $T) {
        return [$T];
      },
      static: {
        _BoundSinkStream$: [function(_stream, _sinkMapper, $S, $T) {
          return new P._BoundSinkStream(_sinkMapper, _stream, [$S, $T]);
        }, null, null, 8, 0, null, 273, 654]
      }
    },
    _HandlerEventSink: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $asEventSink: function($S, $T) {
        return [$S];
      },
      $isSink: 1,
      $asSink: function($S, $T) {
        return [$S];
      }
    },
    _StreamHandlerTransformer: {
      "^": "_StreamSinkTransformer;$ti"
    },
    _StreamBindTransformer: {
      "^": "StreamTransformerBase;$ti"
    },
    _StreamSubscriptionTransformer: {
      "^": "StreamTransformerBase;_onListen,$ti",
      bind$1: [function(stream) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return P._BoundSubscriptionStream$(H.assertSubtype(stream, "$isStream", [t1], "$asStream"), this._onListen, t1, H.getTypeArgumentByIndex(this, 1));
      }, null, "get$bind", 4, 0, null, 57],
      static: {
        _StreamSubscriptionTransformer$: [function(_onListen, $S, $T) {
          return new P._StreamSubscriptionTransformer(_onListen, [$S, $T]);
        }, null, null, 4, 0, null, 437]
      }
    },
    _BoundSubscriptionStream: {
      "^": "Stream;_onListen,_stream,$ti",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var result;
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 1)]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        result = this._onListen.call$2(this._stream, true === H.boolTypeCheck(cancelOnError));
        result.onData$1(onData);
        result.onError$1(0, onError);
        result.onDone$1(onDone);
        return result;
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      $asStream: function($S, $T) {
        return [$T];
      },
      static: {
        _BoundSubscriptionStream$: [function(_stream, _onListen, $S, $T) {
          return new P._BoundSubscriptionStream(_onListen, _stream, [$S, $T]);
        }, null, null, 8, 0, null, 273, 437]
      }
    },
    Timer: {
      "^": "Object;$ti"
    },
    AsyncError: {
      "^": "Object;error>,stackTrace<,$ti",
      toString$0: [function(_) {
        return H.S(this.error);
      }, null, "get$toString", 1, 0, null],
      error$1: function($receiver, arg0) {
        return this.error.call$1(arg0);
      },
      $isError: 1,
      static: {
        AsyncError$: [function(error, stackTrace) {
          return new P.AsyncError(error, stackTrace, []);
        }, null, null, 8, 0, null, 14, 20]
      }
    },
    _ZoneFunction: {
      "^": "Object;zone,$function,$ti"
    },
    ZoneSpecification: {
      "^": "Object;$ti"
    },
    _ZoneSpecification: {
      "^": "Object;$ti",
      $isZoneSpecification: 1
    },
    ZoneDelegate: {
      "^": "Object;$ti"
    },
    Zone: {
      "^": "Object;$ti"
    },
    _ZoneDelegate: {
      "^": "Object;$ti",
      $isZoneDelegate: 1
    },
    _Zone: {
      "^": "Object;$ti",
      inSameErrorZone$1: [function(otherZone) {
        var t1, t2;
        H.interceptedTypeCheck(otherZone, "$isZone");
        if (this !== otherZone) {
          t1 = this.get$errorZone();
          t2 = otherZone.get$errorZone();
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = true;
        return t1;
      }, null, "get$inSameErrorZone", 4, 0, null, 743],
      $isZone: 1
    },
    _CustomZone: {
      "^": "_Zone;$ti"
    },
    _rootHandleUncaughtError_closure: {
      "^": "Closure:1;_box_0,stackTrace,$ti",
      call$0: [function() {
        var t1, t2, error;
        t1 = this._box_0;
        t2 = t1.error;
        if (t2 == null) {
          error = P.NullThrownError$();
          t1.error = error;
          t1 = error;
        } else
          t1 = t2;
        t2 = this.stackTrace;
        if (t2 == null)
          throw H.wrapException(t1);
        P._rethrow(t1, t2);
      }, null, null, 0, 0, null, "call"]
    },
    _RootZone: {
      "^": "_Zone;$ti",
      get$_scheduleMicrotask: [function() {
        return C._ZoneFunction__RootZone__rootScheduleMicrotask;
      }, null, null, 2, 0, null],
      get$errorZone: [function() {
        return this;
      }, null, null, 2, 0, null],
      runGuarded$1: [function(f) {
        var e, s, exception;
        H.functionTypeCheck(f, {func: 1, ret: -1});
        try {
          if (C.C__RootZone === $.Zone__current) {
            f.call$0();
            return;
          }
          P._rootRun(null, null, this, f, -1);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this.handleUncaughtError$2(e, s);
        }
      }, null, "get$runGuarded", 4, 0, null, 15],
      runUnaryGuarded$1$2: [1, function(f, arg, $T) {
        var e, s, exception;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]});
        H.assertSubtypeOfRuntimeType(arg, $T);
        try {
          if (C.C__RootZone === $.Zone__current) {
            f.call$1(arg);
            return;
          }
          P._rootRunUnary(null, null, this, f, arg, -1, $T);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this.handleUncaughtError$2(e, s);
        }
      }, function(f, arg) {
        return this.runUnaryGuarded$1$2(f, arg, null);
      }, "runUnaryGuarded$2", null, "call$2", "get$runUnaryGuarded", 8, 0, null, 15, 44],
      runBinaryGuarded$2$3: [1, function(f, arg1, arg2, T1, T2) {
        var e, s, exception;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [T1, T2]});
        H.assertSubtypeOfRuntimeType(arg1, T1);
        H.assertSubtypeOfRuntimeType(arg2, T2);
        try {
          if (C.C__RootZone === $.Zone__current) {
            f.call$2(arg1, arg2);
            return;
          }
          P._rootRunBinary(null, null, this, f, arg1, arg2, -1, T1, T2);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this.handleUncaughtError$2(e, s);
        }
      }, function(f, arg1, arg2) {
        return this.runBinaryGuarded$2$3(f, arg1, arg2, null, null);
      }, "runBinaryGuarded$3", null, "call$3", "get$runBinaryGuarded", 12, 0, null, 15, 91, 126],
      bindCallback$1$1: [1, function(f, $R) {
        return new P._RootZone_bindCallback_closure(this, H.functionTypeCheck(f, {func: 1, ret: $R}), $R);
      }, function(f) {
        return this.bindCallback$1$1(f, null);
      }, "bindCallback$1", null, "call$1", "get$bindCallback", 4, 0, null, 15],
      bindCallbackGuarded$1: [function(f) {
        return new P._RootZone_bindCallbackGuarded_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1}));
      }, null, "get$bindCallbackGuarded", 4, 0, null, 15],
      bindUnaryCallbackGuarded$1$1: [1, function(f, $T) {
        return new P._RootZone_bindUnaryCallbackGuarded_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]}), $T);
      }, function(f) {
        return this.bindUnaryCallbackGuarded$1$1(f, null);
      }, "bindUnaryCallbackGuarded$1", null, "call$1", "get$bindUnaryCallbackGuarded", 4, 0, null, 15],
      $index: [function(_, key) {
        return;
      }, null, "get$[]", 5, 0, null, 4],
      handleUncaughtError$2: [function(error, stackTrace) {
        P._rootHandleUncaughtError(null, null, this, error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
      }, null, "get$handleUncaughtError", 8, 0, null, 14, 20],
      run$1$1: [1, function(f, $R) {
        H.functionTypeCheck(f, {func: 1, ret: $R});
        if ($.Zone__current === C.C__RootZone)
          return f.call$0();
        return P._rootRun(null, null, this, f, $R);
      }, function(f) {
        return this.run$1$1(f, null);
      }, "run$1", null, "call$1", "get$run", 4, 0, null, 15],
      runUnary$2$2: [1, function(f, arg, $R, $T) {
        H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
        H.assertSubtypeOfRuntimeType(arg, $T);
        if ($.Zone__current === C.C__RootZone)
          return f.call$1(arg);
        return P._rootRunUnary(null, null, this, f, arg, $R, $T);
      }, function(f, arg) {
        return this.runUnary$2$2(f, arg, null, null);
      }, "runUnary$2", null, "call$2", "get$runUnary", 8, 0, null, 15, 44],
      runBinary$3$3: [1, function(f, arg1, arg2, $R, T1, T2) {
        H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
        H.assertSubtypeOfRuntimeType(arg1, T1);
        H.assertSubtypeOfRuntimeType(arg2, T2);
        if ($.Zone__current === C.C__RootZone)
          return f.call$2(arg1, arg2);
        return P._rootRunBinary(null, null, this, f, arg1, arg2, $R, T1, T2);
      }, function(f, arg1, arg2) {
        return this.runBinary$3$3(f, arg1, arg2, null, null, null);
      }, "runBinary$3", null, "call$3", "get$runBinary", 12, 0, null, 15, 91, 126],
      registerCallback$1$1: [1, function(f, $R) {
        return H.functionTypeCheck(f, {func: 1, ret: $R});
      }, function(f) {
        return this.registerCallback$1$1(f, null);
      }, "registerCallback$1", null, "call$1", "get$registerCallback", 4, 0, null, 15],
      registerUnaryCallback$2$1: [1, function(f, $R, $T) {
        return H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      }, function(f) {
        return this.registerUnaryCallback$2$1(f, null, null);
      }, "registerUnaryCallback$1", null, "call$1", "get$registerUnaryCallback", 4, 0, null, 15],
      registerBinaryCallback$3$1: [1, function(f, $R, T1, T2) {
        return H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      }, function(f) {
        return this.registerBinaryCallback$3$1(f, null, null, null);
      }, "registerBinaryCallback$1", null, "call$1", "get$registerBinaryCallback", 4, 0, null, 15],
      errorCallback$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        return;
      }, null, "get$errorCallback", 8, 0, null, 14, 20],
      scheduleMicrotask$1: [function(f) {
        P._rootScheduleMicrotask(null, null, this, H.functionTypeCheck(f, {func: 1, ret: -1}));
      }, null, "get$scheduleMicrotask", 4, 0, null, 15],
      createTimer$2: [function(duration, f) {
        return P.Timer__createTimer(H.interceptedTypeCheck(duration, "$isDuration"), H.functionTypeCheck(f, {func: 1, ret: -1}));
      }, null, "get$createTimer", 8, 0, null, 208, 15]
    },
    _RootZone_bindCallback_closure: {
      "^": "Closure;$this,f,R,$ti",
      call$0: [function() {
        return this.$this.run$1$1(this.f, this.R);
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        return {func: 1, ret: this.R};
      }
    },
    _RootZone_bindCallbackGuarded_closure: {
      "^": "Closure:0;$this,f,$ti",
      call$0: [function() {
        return this.$this.runGuarded$1(this.f);
      }, null, null, 0, 0, null, "call"]
    },
    _RootZone_bindUnaryCallbackGuarded_closure: {
      "^": "Closure;$this,f,T,$ti",
      call$1: [function(arg) {
        var t1 = this.T;
        return this.$this.runUnaryGuarded$1$2(this.f, H.assertSubtypeOfRuntimeType(arg, t1), t1);
      }, null, null, 4, 0, null, 44, "call"],
      $signature: function() {
        return {func: 1, ret: -1, args: [this.T]};
      }
    }
  }], ["dart.collection", "dart:collection",, P, {
    "^": "",
    _HashMap__isStringKey: [function(key) {
      return typeof key === "string" && key !== "__proto__";
    }, null, null, 4, 0, null, 4],
    _HashMap__isNumericKey: [function(key) {
      return typeof key === "number" && (key & 0x3ffffff) === key;
    }, null, null, 4, 0, null, 4],
    _HashMap__hasTableEntry: [function(table, key) {
      return table[key] != null;
    }, null, null, 8, 0, null, 51, 4],
    _HashMap__getTableEntry: [function(table, key) {
      var entry = table[key];
      return entry === table ? null : entry;
    }, null, null, 8, 0, null, 51, 4],
    _HashMap__setTableEntry: [function(table, key, value) {
      if (value == null)
        table[key] = table;
      else
        table[key] = value;
    }, null, null, 12, 0, null, 51, 4, 1],
    _HashMap__deleteTableEntry: [function(table, key) {
      delete table[key];
    }, null, null, 8, 0, null, 51, 4],
    _HashMap__newHashTable: [function() {
      var table = Object.create(null);
      P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
      P._HashMap__deleteTableEntry(table, "<non-identifier-key>");
      return table;
    }, null, null, 0, 0, null],
    LinkedHashMap_LinkedHashMap: [function(equals, hashCode, isValidKey, $K, $V) {
      H.functionTypeCheck(equals, {func: 1, ret: P.bool, args: [$K, $K]});
      H.functionTypeCheck(hashCode, {func: 1, ret: P.int, args: [$K]});
      H.functionTypeCheck(isValidKey, {func: 1, ret: P.bool, args: [,]});
      if (isValidKey == null)
        if (hashCode == null) {
          if (equals == null)
            return H.JsLinkedHashMap_JsLinkedHashMap$es6($K, $V);
          hashCode = P.collection___defaultHashCode$closure();
        } else {
          if (P.core__identityHashCode$closure() === hashCode && (P.core__identical$closure() == null ? equals == null : P.core__identical$closure() === equals))
            return P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6($K, $V);
          if (equals == null)
            equals = P.collection___defaultEquals$closure();
        }
      else {
        if (hashCode == null)
          hashCode = P.collection___defaultHashCode$closure();
        if (equals == null)
          equals = P.collection___defaultEquals$closure();
      }
      return P._LinkedCustomHashMap$(equals, hashCode, isValidKey, $K, $V);
    }, null, null, 0, 7, null, 0, 0, 0, 475, 478, 297],
    LinkedHashMap_LinkedHashMap$_literal: [function(keyValuePairs, $K, $V) {
      return H.assertSubtype(H.fillLiteralMap(H.listTypeCheck(keyValuePairs), H.JsLinkedHashMap_JsLinkedHashMap$es6($K, $V)), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
    }, null, null, 4, 0, null, 311],
    LinkedHashMap_LinkedHashMap$_empty: [function($K, $V) {
      return H.JsLinkedHashMap_JsLinkedHashMap$es6($K, $V);
    }, null, null, 0, 0, null],
    LinkedHashMap__makeEmpty: [function() {
      return H.JsLinkedHashMap$(null, null);
    }, null, null, 0, 0, null],
    LinkedHashMap__makeLiteral: [function(keyValuePairs) {
      return H.fillLiteralMap(keyValuePairs, H.JsLinkedHashMap$(null, null));
    }, null, null, 4, 0, null, 311],
    LinkedHashSet_LinkedHashSet: [function(equals, hashCode, isValidKey, $E) {
      H.functionTypeCheck(equals, {func: 1, ret: P.bool, args: [$E, $E]});
      H.functionTypeCheck(hashCode, {func: 1, ret: P.int, args: [$E]});
      H.functionTypeCheck(isValidKey, {func: 1, ret: P.bool, args: [,]});
      if (isValidKey == null)
        if (hashCode == null) {
          if (equals == null)
            return P._LinkedHashSet$($E);
          hashCode = P.collection___defaultHashCode$closure();
        } else {
          if (P.core__identityHashCode$closure() === hashCode && (P.core__identical$closure() == null ? equals == null : P.core__identical$closure() === equals))
            return P._LinkedIdentityHashSet$($E);
          if (equals == null)
            equals = P.collection___defaultEquals$closure();
        }
      else {
        if (hashCode == null)
          hashCode = P.collection___defaultHashCode$closure();
        if (equals == null)
          equals = P.collection___defaultEquals$closure();
      }
      return P._LinkedCustomHashSet$(equals, hashCode, isValidKey, $E);
    }, null, null, 0, 7, null, 0, 0, 0, 475, 478, 297],
    _defaultEquals: [function(a, b) {
      return J.$eq$(a, b);
    }, "call$2", "collection___defaultEquals$closure", 8, 0, 211, 33, 54],
    _defaultHashCode: [function(a) {
      return J.get$hashCode$(a);
    }, "call$1", "collection___defaultHashCode$closure", 4, 0, 47, 33],
    IterableBase_iterableToShortString: [function(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      H.stringTypeCheck(leftDelimiter);
      H.stringTypeCheck(rightDelimiter);
      if (P._isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return H.S(leftDelimiter) + "..." + H.S(rightDelimiter);
      }
      parts = [];
      t1 = $.$get$_toStringVisiting();
      J.add$1$ax(t1, iterable);
      try {
        P._iterablePartsToStrings(iterable, parts);
      } finally {
        J.removeLast$0$ax(t1);
      }
      t1 = P.StringBuffer$(leftDelimiter);
      t1.writeAll$2(parts, ", ");
      t1.write$1(rightDelimiter);
      return t1.toString$0(0);
    }, null, null, 4, 4, null, 500, 511, 13, 512, 513],
    IterableBase_iterableToFullString: [function(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      H.stringTypeCheck(leftDelimiter);
      H.stringTypeCheck(rightDelimiter);
      if (P._isToStringVisiting(iterable))
        return H.S(leftDelimiter) + "..." + H.S(rightDelimiter);
      buffer = P.StringBuffer$(leftDelimiter);
      t1 = $.$get$_toStringVisiting();
      J.add$1$ax(t1, iterable);
      try {
        buffer.writeAll$2(iterable, ", ");
      } finally {
        J.removeLast$0$ax(t1);
      }
      buffer.write$1(rightDelimiter);
      return J.toString$0$(buffer);
    }, null, null, 4, 4, null, 500, 511, 13, 512, 513],
    _isToStringVisiting: [function(o) {
      var i, t1, t2;
      i = 0;
      while (true) {
        t1 = $.$get$_toStringVisiting();
        t2 = J.get$length$asx(t1);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        t1 = J.$index$asx(t1, i);
        if (o == null ? t1 == null : o === t1)
          return true;
        ++i;
      }
      return false;
    }, null, null, 4, 0, null, 25],
    _iterablePartsToStrings: [function(iterable, parts) {
      var it, t1, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, t2, elision;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      H.listTypeCheck(parts);
      it = J.get$iterator$ax(iterable);
      t1 = J.getInterceptor$asx(parts);
      $length = 0;
      count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current());
        t1.add$1(parts, next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        ultimateString = H.stringTypeCheck(t1.removeLast$0(parts));
        penultimateString = H.stringTypeCheck(t1.removeLast$0(parts));
      } else {
        penultimate = it.get$current();
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            t1.add$1(parts, H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          penultimateString = H.stringTypeCheck(t1.removeLast$0(parts));
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current();
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current();
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                t2 = H.numTypeCheck(J.$add$ansx(J.get$length$asx(t1.removeLast$0(parts)), 2));
                if (typeof t2 !== "number")
                  return H.iae(t2);
                $length = H.intTypeCheck($length - t2);
                --count;
              }
              t1.add$1(parts, "...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      t2 = J.$add$ansx(t1.get$length(parts), 2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (count > t2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && J.$gt$n(t1.get$length(parts), 3)))
          break;
        t2 = H.numTypeCheck(J.$add$ansx(J.get$length$asx(t1.removeLast$0(parts)), 2));
        if (typeof t2 !== "number")
          return H.iae(t2);
        $length = H.intTypeCheck($length - t2);
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        t1.add$1(parts, elision);
      t1.add$1(parts, penultimateString);
      t1.add$1(parts, ultimateString);
    }, null, null, 8, 0, null, 13, 154],
    LinkedHashMap_LinkedHashMap$from: [function(other, $K, $V) {
      var result;
      H.interceptedTypeCheck(other, "$isMap");
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
      other.forEach$1(0, new P.LinkedHashMap_LinkedHashMap$from_closure(result, $K, $V));
      return result;
    }, null, null, 4, 0, null, 3],
    LinkedHashMap_LinkedHashMap$fromIterable: [function(iterable, key, value, $K, $V) {
      var map;
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      H.functionTypeCheck(key, {func: 1, ret: $K, args: [,]});
      H.functionTypeCheck(value, {func: 1, ret: $V, args: [,]});
      map = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
      P.MapBase__fillMapWithMappedIterable(map, iterable, key, value);
      return map;
    }, null, null, 4, 5, null, 0, 0, 13, 4, 1],
    LinkedHashSet_LinkedHashSet$from: [function(elements, $E) {
      var result, t1;
      H.listSuperNativeTypeCheck(elements, "$isIterable");
      result = P.LinkedHashSet_LinkedHashSet(null, null, null, $E);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        result.add$1(0, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
      return result;
    }, null, null, 4, 0, null, 80],
    ListBase_listToString: [function(list) {
      return P.IterableBase_iterableToFullString(H.listTypeCheck(list), "[", "]");
    }, null, null, 4, 0, null, 68],
    ListMixin__compareAny: [function(a, b) {
      return P.Comparable_compare(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    }, "call$2", "collection_ListMixin__compareAny$closure", 8, 0, 71, 33, 54],
    MapBase_mapToString: [function(m) {
      var t1, result;
      t1 = {};
      H.interceptedTypeCheck(m, "$isMap");
      if (P._isToStringVisiting(m))
        return "{...}";
      result = P.StringBuffer$("");
      try {
        J.add$1$ax($.$get$_toStringVisiting(), m);
        result.write$1("{");
        t1.first = true;
        J.forEach$1$ax(m, new P.MapBase_mapToString_closure(t1, result));
        result.write$1("}");
      } finally {
        J.removeLast$0$ax($.$get$_toStringVisiting());
      }
      return J.toString$0$(result);
    }, null, null, 4, 0, null, 910],
    MapBase__id: [function(x) {
      return x;
    }, "call$1", "collection_MapBase__id$closure", 4, 0, 3, 37],
    MapBase__fillMapWithMappedIterable: [function(map, iterable, key, value) {
      var t1, element;
      H.interceptedTypeCheck(map, "$isMap");
      H.listSuperNativeTypeCheck(iterable, "$isIterable");
      t1 = {func: 1, args: [,]};
      H.functionTypeCheck(key, t1);
      H.functionTypeCheck(value, t1);
      if (key == null)
        key = P.collection_MapBase__id$closure();
      if (value == null)
        value = P.collection_MapBase__id$closure();
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
        element = t1.get$current();
        map.$indexSet(0, key.call$1(element), value.call$1(element));
      }
    }, null, null, 16, 0, null, 111, 13, 4, 1],
    _HashMap: {
      "^": "MapBase;_collection$_length<,0_keys<,$ti",
      get$length: [function(_) {
        return this._collection$_length;
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this._collection$_length, 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 3, 0, null],
      get$keys: [function() {
        return P._HashMapKeyIterable$(this, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 2, 0, null],
      get$values: [function(_) {
        return H.MappedIterable_MappedIterable(this.get$keys(), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      containsKey$1: [function(key) {
        var strings, nums;
        if (P._HashMap__isStringKey(key)) {
          strings = this._strings;
          return strings == null ? false : P._HashMap__hasTableEntry(strings, key);
        } else if (P._HashMap__isNumericKey(key)) {
          nums = this._nums;
          return nums == null ? false : P._HashMap__hasTableEntry(nums, key);
        } else
          return this._containsKey$1(key);
      }, null, "get$containsKey", 4, 0, null, 4],
      _containsKey$1: [function(key) {
        var rest = this._rest;
        if (rest == null)
          return false;
        return J.$ge$n(this._findBucketIndex$2(this._getBucket$2(rest, key), key), 0);
      }, null, "get$_containsKey", 4, 0, null, 4],
      addAll$1: [function(_, other) {
        H.assertSubtype(other, "$isMap", this.$ti, "$asMap").forEach$1(0, new P._HashMap_addAll_closure(this));
      }, null, "get$addAll", 5, 0, null, 3],
      $index: [function(_, key) {
        var strings, t1, nums;
        if (P._HashMap__isStringKey(key)) {
          strings = this._strings;
          t1 = strings == null ? null : P._HashMap__getTableEntry(strings, key);
          return t1;
        } else if (P._HashMap__isNumericKey(key)) {
          nums = this._nums;
          t1 = nums == null ? null : P._HashMap__getTableEntry(nums, key);
          return t1;
        } else
          return this._get$1(key);
      }, null, "get$[]", 5, 0, null, 4],
      _get$1: [function(key) {
        var rest, bucket, index;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getBucket$2(rest, key);
        index = this._findBucketIndex$2(bucket, key);
        if (typeof index !== "number")
          return index.$lt();
        return index < 0 ? null : bucket[index + 1];
      }, null, "get$_get", 4, 0, null, 4],
      $indexSet: [function(_, key, value) {
        var strings, nums;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
        if (P._HashMap__isStringKey(key)) {
          strings = this._strings;
          if (strings == null) {
            strings = P._HashMap__newHashTable();
            this._strings = strings;
          }
          this._addHashTableEntry$3(strings, key, value);
        } else if (P._HashMap__isNumericKey(key)) {
          nums = this._nums;
          if (nums == null) {
            nums = P._HashMap__newHashTable();
            this._nums = nums;
          }
          this._addHashTableEntry$3(nums, key, value);
        } else
          this._set$2(key, value);
      }, null, "get$[]=", 9, 0, null, 4, 1],
      _set$2: [function(key, value) {
        var rest, hash, bucket, index;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
        rest = this._rest;
        if (rest == null) {
          rest = P._HashMap__newHashTable();
          this._rest = rest;
        }
        hash = this._computeHashCode$1(key);
        bucket = rest[hash];
        if (bucket == null) {
          P._HashMap__setTableEntry(rest, hash, [key, value]);
          this._collection$_length = H.intTypeCheck(J.$add$ansx(this._collection$_length, 1));
          this._keys = null;
        } else {
          index = this._findBucketIndex$2(bucket, key);
          if (typeof index !== "number")
            return index.$ge();
          if (index >= 0)
            bucket[index + 1] = value;
          else {
            bucket.push(key, value);
            this._collection$_length = H.intTypeCheck(J.$add$ansx(this._collection$_length, 1));
            this._keys = null;
          }
        }
      }, null, "get$_set", 8, 0, null, 4, 1],
      putIfAbsent$2: [function(key, ifAbsent) {
        var value;
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(this, 1)});
        if (this.containsKey$1(key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      remove$1: [function(_, key) {
        if (P._HashMap__isStringKey(key))
          return this._removeHashTableEntry$2(this._strings, key);
        else if (P._HashMap__isNumericKey(key))
          return this._removeHashTableEntry$2(this._nums, key);
        else
          return this._remove$1(key);
      }, null, "get$remove", 5, 0, null, 4],
      _remove$1: [function(key) {
        var rest, bucket, index;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getBucket$2(rest, key);
        index = this._findBucketIndex$2(bucket, key);
        if (typeof index !== "number")
          return index.$lt();
        if (index < 0)
          return;
        this._collection$_length = H.intTypeCheck(J.$sub$n(this._collection$_length, 1));
        this._keys = null;
        return bucket.splice(index, 2)[1];
      }, null, "get$_remove", 4, 0, null, 4],
      clear$0: [function(_) {
        if (J.$gt$n(this._collection$_length, 0)) {
          this._keys = null;
          this._rest = null;
          this._nums = null;
          this._strings = null;
          this._collection$_length = 0;
        }
      }, null, "get$clear", 1, 0, null],
      forEach$1: [function(_, action) {
        var t1, keys, $length, i, key;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [t1, H.getTypeArgumentByIndex(this, 1)]});
        keys = this._collection$_computeKeys$0();
        $length = J.get$length$asx(keys);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          key = keys[i];
          action.call$2(H.assertSubtypeOfRuntimeType(key, t1), this.$index(0, key));
          if (keys !== this._keys)
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
      }, null, "get$forEach", 5, 0, null, 63],
      _collection$_computeKeys$0: [function() {
        var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
        t1 = this._keys;
        if (t1 != null)
          return t1;
        t1 = this._collection$_length;
        if (typeof t1 !== "number")
          return H.iae(t1);
        result = new Array(t1);
        result.fixed$length = Array;
        strings = this._strings;
        if (strings != null) {
          names = Object.getOwnPropertyNames(strings);
          entries = names.length;
          for (index = 0, i = 0; i < entries; ++i) {
            result[index] = names[i];
            ++index;
          }
        } else
          index = 0;
        nums = this._nums;
        if (nums != null) {
          names = Object.getOwnPropertyNames(nums);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            result[index] = +names[i];
            ++index;
          }
        }
        rest = this._rest;
        if (rest != null) {
          names = Object.getOwnPropertyNames(rest);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            bucket = rest[names[i]];
            $length = bucket.length;
            for (i0 = 0; i0 < $length; i0 += 2) {
              result[index] = bucket[i0];
              ++index;
            }
          }
        }
        this._keys = result;
        return result;
      }, null, "get$_collection$_computeKeys", 0, 0, null],
      _addHashTableEntry$3: [function(table, key, value) {
        H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
        if (!P._HashMap__hasTableEntry(table, key)) {
          this._collection$_length = H.intTypeCheck(J.$add$ansx(this._collection$_length, 1));
          this._keys = null;
        }
        P._HashMap__setTableEntry(table, key, value);
      }, null, "get$_addHashTableEntry", 12, 0, null, 51, 4, 1],
      _removeHashTableEntry$2: [function(table, key) {
        var value;
        if (table != null && P._HashMap__hasTableEntry(table, key)) {
          value = H.assertSubtypeOfRuntimeType(P._HashMap__getTableEntry(table, key), H.getTypeArgumentByIndex(this, 1));
          P._HashMap__deleteTableEntry(table, key);
          this._collection$_length = H.intTypeCheck(J.$sub$n(this._collection$_length, 1));
          this._keys = null;
          return value;
        } else
          return;
      }, null, "get$_removeHashTableEntry", 8, 0, null, 51, 4],
      _getBucket$2: [function(table, key) {
        return table[this._computeHashCode$1(key)];
      }, null, "get$_getBucket", 8, 0, null, 51, 4],
      $isHashMap: 1
    },
    _HashMap_values_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(each) {
        var t1 = this.$this;
        return J.$index$asx(t1, H.assertSubtypeOfRuntimeType(each, H.getTypeArgumentByIndex(t1, 0)));
      }, null, null, 4, 0, null, 290, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
      }
    },
    _HashMap_addAll_closure: {
      "^": "Closure;$this,$ti",
      call$2: [function(key, value) {
        var t1 = this.$this;
        J.$indexSet$ax(t1, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
      }, null, null, 8, 0, null, 4, 1, "call"],
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
      }
    },
    _IdentityHashMap: {
      "^": "_HashMap;_collection$_length,0_strings,0_nums,0_rest,0_keys,$ti",
      _computeHashCode$1: [function(key) {
        return P.identityHashCode(key) & 0x3ffffff;
      }, null, "get$_computeHashCode", 4, 0, null, 4],
      _findBucketIndex$2: [function(bucket, key) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; i += 2) {
          t1 = bucket[i];
          if (t1 == null ? key == null : t1 === key)
            return i;
        }
        return -1;
      }, null, "get$_findBucketIndex", 8, 0, null, 135, 4],
      static: {
        _IdentityHashMap$: [function($K, $V) {
          return new P._IdentityHashMap(0, [$K, $V]);
        }, null, null, 0, 0, null]
      }
    },
    _CustomHashMap: {
      "^": "_HashMap;$ti"
    },
    _HashMapKeyIterable: {
      "^": "EfficientLengthIterable;_collection$_map,$ti",
      get$length: [function(_) {
        return H.intTypeCheck(this._collection$_map.get$_collection$_length());
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this._collection$_map.get$_collection$_length(), 0);
      }, null, null, 3, 0, null],
      get$iterator: [function(_) {
        var t1 = this._collection$_map;
        return P._HashMapKeyIterator$(t1, H.listTypeCheck(t1._collection$_computeKeys$0()), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      contains$1: [function(_, element) {
        return H.boolTypeCheck(this._collection$_map.containsKey$1(element));
      }, null, "get$contains", 5, 0, null, 10],
      forEach$1: [function(_, f) {
        var t1, keys, $length, i;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
        t1 = this._collection$_map;
        keys = H.listTypeCheck(t1._collection$_computeKeys$0());
        for ($length = keys.length, i = 0; i < $length; ++i) {
          f.call$1(keys[i]);
          if (keys !== t1.get$_keys())
            throw H.wrapException(P.ConcurrentModificationError$(t1));
        }
      }, null, "get$forEach", 5, 0, null, 15],
      static: {
        _HashMapKeyIterable$: [function(_map, $E) {
          return new P._HashMapKeyIterable(_map, [$E]);
        }, null, null, 4, 0, null, 141]
      }
    },
    _HashMapKeyIterator: {
      "^": "Object;_collection$_map,_keys<,_collection$_offset,0_collection$_current,$ti",
      set$_collection$_current: function(_current) {
        this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
      },
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        var keys, offset, t1;
        keys = this._keys;
        offset = this._collection$_offset;
        t1 = this._collection$_map;
        if (keys !== t1.get$_keys())
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        else {
          t1 = keys.length;
          if (typeof offset !== "number")
            return offset.$ge();
          if (offset >= t1) {
            this.set$_collection$_current(null);
            return false;
          } else {
            this.set$_collection$_current(keys[offset]);
            this._collection$_offset = offset + 1;
            return true;
          }
        }
      }, null, "get$moveNext", 0, 0, null],
      $isIterator: 1,
      static: {
        _HashMapKeyIterator$: [function(_map, _keys, $E) {
          return new P._HashMapKeyIterator(_map, _keys, 0, [$E]);
        }, null, null, 8, 0, null, 141, 752]
      }
    },
    _LinkedIdentityHashMap: {
      "^": "JsLinkedHashMap;__js_helper$_length,0__js_helper$_strings,0__js_helper$_nums,0__js_helper$_rest,0__js_helper$_first,0__js_helper$_last,__js_helper$_modifications,$ti",
      internalComputeHashCode$1: [function(key) {
        return P.identityHashCode(key) & 0x3ffffff;
      }, null, "get$internalComputeHashCode", 4, 0, null, 4],
      internalFindBucketIndex$2: [function(bucket, key) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].hashMapCellKey;
          if (t1 == null ? key == null : t1 === key)
            return i;
        }
        return -1;
      }, null, "get$internalFindBucketIndex", 8, 0, null, 135, 4],
      static: {
        _LinkedIdentityHashMap__LinkedIdentityHashMap$es6: [function($K, $V) {
          var t1 = P._LinkedIdentityHashMap$($K, $V);
          return t1;
        }, null, null, 0, 0, null],
        _LinkedIdentityHashMap$: [function($K, $V) {
          return new P._LinkedIdentityHashMap(0, 0, [$K, $V]);
        }, null, null, 0, 0, null]
      }
    },
    _Es6LinkedIdentityHashMap: {
      "^": "_LinkedIdentityHashMap;$ti"
    },
    _Es6LinkedIdentityHashMap_addAll_closure: {
      "^": "Closure;$ti"
    },
    _Es6MapIterable: {
      "^": "EfficientLengthIterable;$ti"
    },
    _Es6MapIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    _LinkedCustomHashMap: {
      "^": "JsLinkedHashMap;_equals,_collection$_hashCode,_validKey,__js_helper$_length,0__js_helper$_strings,0__js_helper$_nums,0__js_helper$_rest,0__js_helper$_first,0__js_helper$_last,__js_helper$_modifications,$ti",
      $index: [function(_, key) {
        if (!this._validKey.call$1(key))
          return;
        return this.super$JsLinkedHashMap$internalGet(key);
      }, null, "get$[]", 5, 0, null, 4],
      $indexSet: [function(_, key, value) {
        this.super$JsLinkedHashMap$internalSet(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)));
      }, null, "get$[]=", 9, 0, null, 4, 1],
      containsKey$1: [function(key) {
        if (!this._validKey.call$1(key))
          return false;
        return this.super$JsLinkedHashMap$internalContainsKey(key);
      }, null, "get$containsKey", 4, 0, null, 4],
      remove$1: [function(_, key) {
        if (!this._validKey.call$1(key))
          return;
        return this.super$JsLinkedHashMap$internalRemove(key);
      }, null, "get$remove", 5, 0, null, 4],
      internalComputeHashCode$1: [function(key) {
        return this._collection$_hashCode.call$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0))) & 0x3ffffff;
      }, null, "get$internalComputeHashCode", 4, 0, null, 4],
      internalFindBucketIndex$2: [function(bucket, key) {
        var $length, t1, t2, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (t1 = H.getTypeArgumentByIndex(this, 0), t2 = this._equals, i = 0; i < $length; ++i)
          if (t2.call$2(H.assertSubtypeOfRuntimeType(bucket[i].hashMapCellKey, t1), H.assertSubtypeOfRuntimeType(key, t1)))
            return i;
        return -1;
      }, null, "get$internalFindBucketIndex", 8, 0, null, 135, 4],
      static: {
        _LinkedCustomHashMap$: [function(_equals, _hashCode, validKey, $K, $V) {
          var t1 = validKey != null ? validKey : new P._LinkedCustomHashMap_closure($K);
          return new P._LinkedCustomHashMap(_equals, _hashCode, t1, 0, 0, [$K, $V]);
        }, null, null, 12, 0, null, 809, 829, 549]
      }
    },
    _LinkedCustomHashMap_closure: {
      "^": "Closure:17;K,$ti",
      call$1: [function(v) {
        return H.checkSubtypeOfRuntimeType(v, this.K);
      }, null, null, 4, 0, null, 112, "call"]
    },
    _HashSet: {
      "^": "_HashSetBase;$ti",
      $isHashSet: 1
    },
    _IdentityHashSet: {
      "^": "_HashSet;$ti"
    },
    _CustomHashSet: {
      "^": "_HashSet;$ti"
    },
    _HashSetIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    _LinkedHashSet: {
      "^": "_HashSetBase;_collection$_length<,0_strings,0_nums,0_rest,0_first<,0_last,_modifications<,$ti",
      get$iterator: [function(_) {
        return P._LinkedHashSetIterator$(this, this._modifications, H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return this._collection$_length;
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this._collection$_length, 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 3, 0, null],
      contains$1: [function(_, object) {
        var strings, nums;
        if (P._LinkedHashSet__isStringElement(object)) {
          strings = this._strings;
          if (strings == null)
            return false;
          return H.interceptedTypeCheck(P._LinkedHashSet__getTableEntry(strings, object), "$is_LinkedHashSetCell") != null;
        } else if (P._LinkedHashSet__isNumericElement(object)) {
          nums = this._nums;
          if (nums == null)
            return false;
          return H.interceptedTypeCheck(P._LinkedHashSet__getTableEntry(nums, object), "$is_LinkedHashSetCell") != null;
        } else
          return this._contains$1(object);
      }, null, "get$contains", 5, 0, null, 9],
      _contains$1: ["super$_LinkedHashSet$_contains", function(object) {
        var rest = this._rest;
        if (rest == null)
          return false;
        return J.$ge$n(this._findBucketIndex$2(this._getBucket$2(rest, object), object), 0);
      }, null, "get$_contains", 4, 0, null, 9],
      forEach$1: [function(_, action) {
        var t1, cell, modifications, t2;
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [t1]});
        cell = this._first;
        modifications = this._modifications;
        for (; cell != null;) {
          action.call$1(H.assertSubtypeOfRuntimeType(cell._collection$_element, t1));
          t2 = this._modifications;
          if (modifications == null ? t2 != null : modifications !== t2)
            throw H.wrapException(P.ConcurrentModificationError$(this));
          cell = cell._next;
        }
      }, null, "get$forEach", 5, 0, null, 63],
      get$first: [function(_) {
        var t1 = this._first;
        if (t1 == null)
          throw H.wrapException(P.StateError$("No elements"));
        return H.assertSubtypeOfRuntimeType(t1.get$_collection$_element(), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        var t1 = this._last;
        if (t1 == null)
          throw H.wrapException(P.StateError$("No elements"));
        return H.assertSubtypeOfRuntimeType(t1.get$_collection$_element(), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      add$1: [function(_, element) {
        var strings, nums;
        H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
        if (P._LinkedHashSet__isStringElement(element)) {
          strings = this._strings;
          if (strings == null) {
            strings = P._LinkedHashSet__newHashTable();
            this._strings = strings;
          }
          return this._addHashTableEntry$2(strings, element);
        } else if (P._LinkedHashSet__isNumericElement(element)) {
          nums = this._nums;
          if (nums == null) {
            nums = P._LinkedHashSet__newHashTable();
            this._nums = nums;
          }
          return this._addHashTableEntry$2(nums, element);
        } else
          return this._collection$_add$1(element);
      }, "call$1", "get$add", 5, 0, 18, 10],
      _collection$_add$1: ["super$_LinkedHashSet$_add", function(element) {
        var rest, hash, bucket, index;
        H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
        rest = this._rest;
        if (rest == null) {
          rest = P._LinkedHashSet__newHashTable();
          this._rest = rest;
        }
        hash = this._computeHashCode$1(element);
        bucket = rest[hash];
        if (bucket == null)
          P._LinkedHashSet__setTableEntry(rest, hash, [this._newLinkedCell$1(element)]);
        else {
          index = this._findBucketIndex$2(bucket, element);
          if (typeof index !== "number")
            return index.$ge();
          if (index >= 0)
            return false;
          bucket.push(this._newLinkedCell$1(element));
        }
        return true;
      }, null, "get$_collection$_add", 4, 0, null, 10],
      remove$1: [function(_, object) {
        if (P._LinkedHashSet__isStringElement(object))
          return this._removeHashTableEntry$2(this._strings, object);
        else if (P._LinkedHashSet__isNumericElement(object))
          return this._removeHashTableEntry$2(this._nums, object);
        else
          return this._remove$1(object);
      }, null, "get$remove", 5, 0, null, 9],
      _remove$1: ["super$_LinkedHashSet$_remove", function(object) {
        var rest, bucket, index;
        rest = this._rest;
        if (rest == null)
          return false;
        bucket = this._getBucket$2(rest, object);
        index = this._findBucketIndex$2(bucket, object);
        if (typeof index !== "number")
          return index.$lt();
        if (index < 0)
          return false;
        this._unlinkCell$1(bucket.splice(index, 1)[0]);
        return true;
      }, null, "get$_remove", 4, 0, null, 9],
      clear$0: [function(_) {
        if (J.$gt$n(this._collection$_length, 0)) {
          this._last = null;
          this._first = null;
          this._rest = null;
          this._nums = null;
          this._strings = null;
          this._collection$_length = 0;
          this._modified$0();
        }
      }, null, "get$clear", 1, 0, null],
      _addHashTableEntry$2: [function(table, element) {
        H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
        if (H.interceptedTypeCheck(P._LinkedHashSet__getTableEntry(table, element), "$is_LinkedHashSetCell") != null)
          return false;
        P._LinkedHashSet__setTableEntry(table, element, this._newLinkedCell$1(element));
        return true;
      }, null, "get$_addHashTableEntry", 8, 0, null, 51, 10],
      _removeHashTableEntry$2: [function(table, element) {
        var cell;
        if (table == null)
          return false;
        cell = H.interceptedTypeCheck(P._LinkedHashSet__getTableEntry(table, element), "$is_LinkedHashSetCell");
        if (cell == null)
          return false;
        this._unlinkCell$1(cell);
        P._LinkedHashSet__deleteTableEntry(table, element);
        return true;
      }, null, "get$_removeHashTableEntry", 8, 0, null, 51, 10],
      _modified$0: [function() {
        this._modifications = H.intTypeCheck(J.$and$bn(J.$add$ansx(this._modifications, 1), 67108863));
      }, null, "get$_modified", 0, 0, null],
      _newLinkedCell$1: [function(element) {
        var cell, last;
        cell = P._LinkedHashSetCell$(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0)));
        if (this._first == null) {
          this._last = cell;
          this._first = cell;
        } else {
          last = this._last;
          cell._previous = last;
          last._next = cell;
          this._last = cell;
        }
        this._collection$_length = H.intTypeCheck(J.$add$ansx(this._collection$_length, 1));
        this._modified$0();
        return cell;
      }, null, "get$_newLinkedCell", 4, 0, null, 10],
      _unlinkCell$1: [function(cell) {
        var previous, next;
        H.interceptedTypeCheck(cell, "$is_LinkedHashSetCell");
        previous = cell._previous;
        next = cell._next;
        if (previous == null)
          this._first = next;
        else
          previous._next = next;
        if (next == null)
          this._last = previous;
        else
          next._previous = previous;
        this._collection$_length = H.intTypeCheck(J.$sub$n(this._collection$_length, 1));
        this._modified$0();
      }, null, "get$_unlinkCell", 4, 0, null, 292],
      _computeHashCode$1: [function(element) {
        return J.get$hashCode$(element) & 0x3ffffff;
      }, null, "get$_computeHashCode", 4, 0, null, 10],
      _getBucket$2: [function(table, element) {
        return table[this._computeHashCode$1(element)];
      }, null, "get$_getBucket", 8, 0, null, 51, 10],
      _findBucketIndex$2: [function(bucket, element) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i]._collection$_element, element))
            return i;
        return -1;
      }, null, "get$_findBucketIndex", 8, 0, null, 135, 10],
      $isLinkedHashSet: 1,
      static: {
        _LinkedHashSet$: [function($E) {
          return new P._LinkedHashSet(0, 0, [$E]);
        }, null, null, 0, 0, null],
        _LinkedHashSet__isStringElement: [function(element) {
          return typeof element === "string" && element !== "__proto__";
        }, null, null, 4, 0, null, 10],
        _LinkedHashSet__isNumericElement: [function(element) {
          return typeof element === "number" && (element & 0x3ffffff) === element;
        }, null, null, 4, 0, null, 10],
        _LinkedHashSet__getTableEntry: [function(table, key) {
          return table[key];
        }, null, null, 8, 0, null, 51, 4],
        _LinkedHashSet__setTableEntry: [function(table, key, value) {
          table[key] = value;
        }, null, null, 12, 0, null, 51, 4, 1],
        _LinkedHashSet__deleteTableEntry: [function(table, key) {
          delete table[key];
        }, null, null, 8, 0, null, 51, 4],
        _LinkedHashSet__newHashTable: [function() {
          var table = Object.create(null);
          P._LinkedHashSet__setTableEntry(table, "<non-identifier-key>", table);
          P._LinkedHashSet__deleteTableEntry(table, "<non-identifier-key>");
          return table;
        }, null, null, 0, 0, null]
      }
    },
    _LinkedIdentityHashSet: {
      "^": "_LinkedHashSet;_collection$_length,0_strings,0_nums,0_rest,0_first,0_last,_modifications,$ti",
      _computeHashCode$1: [function(key) {
        return P.identityHashCode(key) & 0x3ffffff;
      }, null, "get$_computeHashCode", 4, 0, null, 4],
      _findBucketIndex$2: [function(bucket, element) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i]._collection$_element;
          if (t1 == null ? element == null : t1 === element)
            return i;
        }
        return -1;
      }, null, "get$_findBucketIndex", 8, 0, null, 135, 10],
      static: {
        _LinkedIdentityHashSet$: [function($E) {
          return new P._LinkedIdentityHashSet(0, 0, [$E]);
        }, null, null, 0, 0, null]
      }
    },
    _LinkedCustomHashSet: {
      "^": "_LinkedHashSet;_equality,_hasher,_validKey,_collection$_length,0_strings,0_nums,0_rest,0_first,0_last,_modifications,$ti",
      _findBucketIndex$2: [function(bucket, element) {
        var $length, t1, i, t2;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (t1 = H.getTypeArgumentByIndex(this, 0), i = 0; i < $length; ++i) {
          t2 = H.assertSubtypeOfRuntimeType(bucket[i]._collection$_element, t1);
          H.assertSubtypeOfRuntimeType(element, t1);
          if (this._equality.call$2(t2, element))
            return i;
        }
        return -1;
      }, null, "get$_findBucketIndex", 8, 0, null, 135, 10],
      _computeHashCode$1: [function(element) {
        H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
        return this._hasher.call$1(element) & 0x3ffffff;
      }, null, "get$_computeHashCode", 4, 0, null, 10],
      add$1: [function(_, element) {
        return this.super$_LinkedHashSet$_add(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0)));
      }, "call$1", "get$add", 5, 0, 18, 10],
      contains$1: [function(_, object) {
        if (!this._validKey.call$1(object))
          return false;
        return this.super$_LinkedHashSet$_contains(object);
      }, null, "get$contains", 5, 0, null, 9],
      remove$1: [function(_, object) {
        if (!this._validKey.call$1(object))
          return false;
        return this.super$_LinkedHashSet$_remove(object);
      }, null, "get$remove", 5, 0, null, 9],
      removeAll$1: [function(elements) {
        var t1, element;
        for (t1 = J.get$iterator$ax(H.assertSubtype(elements, "$isIterable", [P.Object], "$asIterable")); t1.moveNext$0();) {
          element = t1.get$current();
          if (this._validKey.call$1(element))
            this.super$_LinkedHashSet$_remove(element);
        }
      }, null, "get$removeAll", 4, 0, null, 80],
      static: {
        _LinkedCustomHashSet$: [function(_equality, _hasher, validKey, $E) {
          var t1 = validKey != null ? validKey : new P._LinkedCustomHashSet_closure($E);
          return new P._LinkedCustomHashSet(_equality, _hasher, t1, 0, 0, [$E]);
        }, null, null, 12, 0, null, 837, 838, 549]
      }
    },
    _LinkedCustomHashSet_closure: {
      "^": "Closure:17;E,$ti",
      call$1: [function(x) {
        return H.checkSubtypeOfRuntimeType(x, this.E);
      }, null, null, 4, 0, null, 37, "call"]
    },
    _LinkedHashSetCell: {
      "^": "Object;_collection$_element<,0_next<,0_previous,$ti",
      static: {
        _LinkedHashSetCell$: [function(_element) {
          return new P._LinkedHashSetCell(_element, []);
        }, null, null, 4, 0, null, 92]
      }
    },
    _LinkedHashSetIterator: {
      "^": "Object;_set,_modifications<,0_cell,0_collection$_current,$ti",
      set$_collection$_current: function(_current) {
        this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
      },
      _LinkedHashSetIterator$2: [function(_set, _modifications, $E) {
        this._cell = H.interceptedTypeCheck(this._set.get$_first(), "$is_LinkedHashSetCell");
      }, null, null, 8, 0, null, 489, 244],
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        var t1 = this._set;
        if (!J.$eq$(this._modifications, t1.get$_modifications()))
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        else {
          t1 = this._cell;
          if (t1 == null) {
            this.set$_collection$_current(null);
            return false;
          } else {
            this.set$_collection$_current(H.assertSubtypeOfRuntimeType(t1.get$_collection$_element(), H.getTypeArgumentByIndex(this, 0)));
            this._cell = H.interceptedTypeCheck(this._cell.get$_next(), "$is_LinkedHashSetCell");
            return true;
          }
        }
      }, null, "get$moveNext", 0, 0, null],
      $isIterator: 1,
      static: {
        _LinkedHashSetIterator$: [function(_set, _modifications, $E) {
          var t1 = new P._LinkedHashSetIterator(_set, _modifications, [$E]);
          t1._LinkedHashSetIterator$2(_set, _modifications, $E);
          return t1;
        }, null, null, 8, 0, null, 489, 244]
      }
    },
    UnmodifiableListView: {
      "^": "UnmodifiableListBase;$ti"
    },
    HashMap: {
      "^": "Object;$ti",
      $isMap: 1
    },
    _HashSetBase: {
      "^": "SetBase;$ti"
    },
    HashSet: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isSet: 1
    },
    IterableMixin: {
      "^": "Object;$ti",
      $isIterable: 1
    },
    IterableBase: {
      "^": "Iterable;$ti"
    },
    HasNextIterator: {
      "^": "Object;$ti"
    },
    LinkedHashMap: {
      "^": "Object;$ti",
      $isMap: 1
    },
    LinkedHashMap_LinkedHashMap$from_closure: {
      "^": "Closure:9;result,K,V,$ti",
      call$2: [function(k, v) {
        J.$indexSet$ax(this.result, H.assertSubtypeOfRuntimeType(k, this.K), H.assertSubtypeOfRuntimeType(v, this.V));
      }, null, null, 8, 0, null, 253, 112, "call"]
    },
    LinkedHashSet: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isSet: 1
    },
    LinkedList0: {
      "^": "Iterable;$ti"
    },
    _LinkedListIterator0: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    LinkedListEntry: {
      "^": "Object;$ti"
    },
    ListBase: {
      "^": "_ListBase_Object_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isListMixin: 1,
      $isIterable: 1,
      $isList: 1
    },
    ListMixin: {
      "^": "Object;$ti",
      get$iterator: [function(receiver) {
        return H.ListIterator$(receiver, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      }, null, null, 3, 0, null],
      elementAt$1: [function(receiver, index) {
        return this.$index(receiver, H.intTypeCheck(index));
      }, null, "get$elementAt", 5, 0, null, 6],
      forEach$1: [function(receiver, action) {
        var $length, i;
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]});
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          action.call$1(this.$index(receiver, i));
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
      }, null, "get$forEach", 5, 0, null, 63],
      get$isEmpty: [function(receiver) {
        return J.$eq$(this.get$length(receiver), 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(receiver) {
        return !this.get$isEmpty(receiver);
      }, null, null, 3, 0, null],
      get$first: [function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.$index(receiver, 0);
      }, null, null, 3, 0, null],
      get$last: [function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        return this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
      }, null, null, 3, 0, null],
      get$single: [function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this.get$length(receiver), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return this.$index(receiver, 0);
      }, null, null, 3, 0, null],
      contains$1: [function(receiver, element) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (J.$eq$(this.$index(receiver, i), element))
            return true;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return false;
      }, null, "get$contains", 5, 0, null, 10],
      any$1: [function(receiver, test) {
        var $length, i;
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]});
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.$index(receiver, i)))
            return true;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return false;
      }, null, "get$any", 5, 0, null, 41],
      firstWhere$2$orElse: [function(receiver, test, orElse) {
        var t1, $length, i, element;
        t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          element = this.$index(receiver, i);
          if (test.call$1(element))
            return element;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$firstWhere", 5, 3, null, 0, 41, 98],
      lastWhere$2$orElse: [function(receiver, test, orElse) {
        var t1, $length, i, element;
        t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return $length.$sub();
        i = $length - 1;
        for (; i >= 0; --i) {
          element = this.$index(receiver, i);
          if (test.call$1(element))
            return element;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      join$1: [function(receiver, separator) {
        var buffer;
        H.stringTypeCheck(separator);
        if (J.$eq$(this.get$length(receiver), 0))
          return "";
        buffer = P.StringBuffer$("");
        buffer.writeAll$2(receiver, separator);
        return buffer.toString$0(0);
      }, null, "get$join", 1, 2, null, 39, 90],
      where$1: [function(receiver, test) {
        var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
        return H.WhereIterable$(receiver, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]}), t1);
      }, null, "get$where", 5, 0, null, 41],
      map$1$1: [1, function(receiver, f, $T) {
        var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
        return H.MappedListIterable$(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      skip$1: [function(receiver, count) {
        return H.SubListIterable$(receiver, H.intTypeCheck(count), null, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      }, null, "get$skip", 5, 0, null, 42],
      take$1: [function(receiver, count) {
        return H.SubListIterable$(receiver, 0, H.intTypeCheck(count), H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      }, null, "get$take", 5, 0, null, 42],
      toList$1$growable: [function(receiver, growable) {
        var result, t1, i;
        if (H.boolTypeCheck(growable)) {
          result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
          C.JSArray_methods.set$length(result, this.get$length(receiver));
        } else {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = new Array(t1);
          t1.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
        }
        i = 0;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          C.JSArray_methods.$indexSet(result, i, this.$index(receiver, i));
          ++i;
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95],
      add$1: [function(receiver, element) {
        var t1;
        H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
        t1 = this.get$length(receiver);
        this.set$length(receiver, J.$add$ansx(t1, 1));
        this.$indexSet(receiver, t1, element);
      }, "call$1", "get$add", 5, 0, 2, 10],
      addAll$1: [function(receiver, iterable) {
        var i, t1, element, i0;
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)], "$asIterable");
        i = this.get$length(receiver);
        for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0(); i = i0) {
          element = t1.get$current();
          if (typeof i !== "number")
            return i.$add();
          i0 = i + 1;
          this.set$length(receiver, i0);
          this.$indexSet(receiver, i, element);
        }
      }, null, "get$addAll", 5, 0, null, 13],
      remove$1: [function(receiver, element) {
        var i, t1;
        i = 0;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq$(this.$index(receiver, i), element)) {
            this._closeGap$2(receiver, i, i + 1);
            return true;
          }
          ++i;
        }
        return false;
      }, null, "get$remove", 5, 0, null, 10],
      _closeGap$2: [function(receiver, start, end) {
        var $length, size, i;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        $length = this.get$length(receiver);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        size = end - start;
        if (typeof $length !== "number")
          return H.iae($length);
        i = end;
        for (; i < $length; ++i)
          this.$indexSet(receiver, i - size, this.$index(receiver, i));
        this.set$length(receiver, $length - size);
      }, null, "get$_closeGap", 9, 0, null, 5, 7],
      clear$0: [function(receiver) {
        this.set$length(receiver, 0);
      }, null, "get$clear", 1, 0, null],
      cast$1$0: [1, function(receiver, $R) {
        return P.List_castFrom(receiver, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0), $R);
      }, function($receiver) {
        return this.cast$1$0($receiver, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      removeLast$0: [function(receiver) {
        var result;
        if (J.$eq$(this.get$length(receiver), 0))
          throw H.wrapException(H.IterableElementError_noElement());
        result = this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
        this.set$length(receiver, J.$sub$n(this.get$length(receiver), 1));
        return result;
      }, null, "get$removeLast", 1, 0, null],
      sort$1: [function(receiver, compare) {
        var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
        H.Sort_sort(receiver, compare == null ? P.collection_ListMixin__compareAny$closure() : compare, t1);
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      $add: [function(receiver, other) {
        var t1, result;
        t1 = [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)];
        H.assertSubtype(other, "$isList", t1, "$asList");
        result = H.setRuntimeTypeInfo([], t1);
        C.JSArray_methods.set$length(result, J.$add$ansx(this.get$length(receiver), J.get$length$asx(other)));
        C.JSArray_methods.setRange$3(result, 0, this.get$length(receiver), receiver);
        C.JSArray_methods.setRange$3(result, this.get$length(receiver), result.length, other);
        return result;
      }, null, "get$+", 5, 0, null, 3],
      sublist$2: [function(receiver, start, end) {
        var listLength, $length, result, i;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        listLength = this.get$length(receiver);
        if (end == null)
          end = listLength;
        P.RangeError_checkValidRange(start, end, listLength, null, null, null);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, $length);
        for (i = 0; i < $length; ++i)
          C.JSArray_methods.$indexSet(result, i, this.$index(receiver, start + i));
        return result;
      }, function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      }, "sublist$1", null, null, "get$sublist", 5, 2, null, 0, 5, 7],
      fillRange$3: [function(receiver, start, end, fill) {
        var i;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtypeOfRuntimeType(fill, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          this.$indexSet(receiver, i, fill);
          ++i;
        }
      }, null, "get$fillRange", 9, 2, null, 0, 5, 7, 525],
      setRange$4: ["super$ListMixin$setRange", function(receiver, start, end, iterable, skipCount) {
        var t1, $length, otherStart, otherList, t2, i;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
        H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
        H.intTypeCheck(skipCount);
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length === 0)
          return;
        P.RangeError_checkNotNegative(skipCount, "skipCount", null);
        if (H.checkSubtype(iterable, "$isList", [t1], "$asList")) {
          otherStart = skipCount;
          otherList = iterable;
        } else {
          otherList = J.toList$1$growable$ax(J.skip$1$ax(iterable, skipCount), false);
          otherStart = 0;
        }
        if (typeof otherStart !== "number")
          return otherStart.$add();
        t1 = J.getInterceptor$asx(otherList);
        t2 = t1.get$length(otherList);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (otherStart + $length > t2)
          throw H.wrapException(H.IterableElementError_tooFew());
        if (otherStart < start)
          for (i = $length - 1; i >= 0; --i)
            this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
        else
          for (i = 0; i < $length; ++i)
            this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      replaceRange$3: [function(receiver, start, end, newContents) {
        var t1, removeLength, insertLength, insertEnd, newLength;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(newContents, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)], "$asIterable");
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        t1 = J.getInterceptor$(newContents);
        if (!t1.$isEfficientLengthIterable)
          newContents = t1.toList$0(newContents);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        removeLength = end - start;
        insertLength = J.get$length$asx(newContents);
        if (typeof insertLength !== "number")
          return H.iae(insertLength);
        insertEnd = start + insertLength;
        if (removeLength >= insertLength) {
          this.setRange$3(receiver, start, insertEnd, newContents);
          if (removeLength > insertLength)
            this._closeGap$2(receiver, insertEnd, end);
        } else {
          newLength = J.$add$ansx(this.get$length(receiver), insertLength - removeLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, newContents);
        }
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 961],
      indexOf$2: [function(receiver, element, start) {
        var i, t1;
        H.intTypeCheck(start);
        if (typeof start !== "number")
          return start.$lt();
        if (start < 0)
          start = 0;
        i = start;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq$(this.$index(receiver, i), element))
            return i;
          ++i;
        }
        return -1;
      }, function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      }, "indexOf$1", null, null, "get$indexOf", 5, 2, null, 16, 10, 5],
      insert$2: [function(receiver, index, element) {
        var t1;
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
        P.RangeError_checkValueInInterval(index, 0, this.get$length(receiver), "index", null);
        t1 = this.get$length(receiver);
        if (index == null ? t1 == null : index === t1) {
          this.add$1(receiver, element);
          return;
        }
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$(index));
        this.set$length(receiver, J.$add$ansx(this.get$length(receiver), 1));
        this.setRange$4(receiver, index + 1, this.get$length(receiver), receiver, index);
        this.$indexSet(receiver, index, element);
      }, null, "get$insert", 9, 0, null, 6, 10],
      removeAt$1: [function(receiver, index) {
        var result;
        H.intTypeCheck(index);
        result = this.$index(receiver, index);
        if (typeof index !== "number")
          return index.$add();
        this._closeGap$2(receiver, index, index + 1);
        return result;
      }, null, "get$removeAt", 5, 0, null, 6],
      insertAll$2: [function(receiver, index, iterable) {
        var t1, insertionLength;
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)], "$asIterable");
        P.RangeError_checkValueInInterval(index, 0, this.get$length(receiver), "index", null);
        t1 = J.getInterceptor$(iterable);
        if (!t1.$isEfficientLengthIterable || iterable === receiver)
          iterable = t1.toList$0(iterable);
        t1 = J.getInterceptor$asx(iterable);
        insertionLength = t1.get$length(iterable);
        this.set$length(receiver, J.$add$ansx(this.get$length(receiver), insertionLength));
        if (!J.$eq$(t1.get$length(iterable), insertionLength)) {
          this.set$length(receiver, J.$sub$n(this.get$length(receiver), insertionLength));
          throw H.wrapException(P.ConcurrentModificationError$(iterable));
        }
        if (typeof index !== "number")
          return index.$add();
        if (typeof insertionLength !== "number")
          return H.iae(insertionLength);
        this.setRange$4(receiver, index + insertionLength, this.get$length(receiver), receiver, index);
        this.setAll$2(receiver, index, iterable);
      }, null, "get$insertAll", 9, 0, null, 6, 13],
      setAll$2: [function(receiver, index, iterable) {
        var t1, element, index0;
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)], "$asIterable");
        t1 = J.getInterceptor$(iterable);
        if (!!t1.$isList) {
          t1 = t1.get$length(iterable);
          if (typeof index !== "number")
            return index.$add();
          if (typeof t1 !== "number")
            return H.iae(t1);
          this.setRange$3(receiver, index, index + t1, iterable);
        } else
          for (t1 = t1.get$iterator(iterable); t1.moveNext$0(); index = index0) {
            element = t1.get$current();
            if (typeof index !== "number")
              return index.$add();
            index0 = index + 1;
            this.$indexSet(receiver, index, element);
          }
      }, null, "get$setAll", 9, 0, null, 6, 13],
      get$reversed: [function(receiver) {
        return H.ReversedListIterable$(receiver, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      }, null, null, 3, 0, null],
      toString$0: [function(receiver) {
        return P.IterableBase_iterableToFullString(receiver, "[", "]");
      }, null, "get$toString", 1, 0, null],
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1
    },
    MapBase: {
      "^": "MapMixin;$ti"
    },
    MapBase_mapToString_closure: {
      "^": "Closure:9;_box_0,result,$ti",
      call$2: [function(k, v) {
        var t1 = this._box_0;
        if (!t1.first)
          this.result.write$1(", ");
        t1.first = false;
        t1 = this.result;
        t1.write$1(k);
        t1.write$1(": ");
        t1.write$1(v);
      }, null, null, 8, 0, null, 253, 112, "call"]
    },
    MapMixin: {
      "^": "Object;$ti",
      cast$2$0: [1, function(_, RK, RV) {
        return P.Map_castFrom(this, H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1), RK, RV);
      }, function($receiver) {
        return this.cast$2$0($receiver, null, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      forEach$1: [function(_, action) {
        var t1, key;
        H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)]});
        for (t1 = J.get$iterator$ax(this.get$keys()); t1.moveNext$0();) {
          key = t1.get$current();
          action.call$2(key, this.$index(0, key));
        }
      }, null, "get$forEach", 5, 0, null, 63],
      addAll$1: [function(_, other) {
        var t1, key;
        H.assertSubtype(other, "$isMap", [H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)], "$asMap");
        for (t1 = J.get$iterator$ax(other.get$keys()); t1.moveNext$0();) {
          key = t1.get$current();
          this.$indexSet(0, key, other.$index(0, key));
        }
      }, null, "get$addAll", 5, 0, null, 3],
      putIfAbsent$2: [function(key, ifAbsent) {
        var t1;
        H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(this, "MapMixin", 0));
        H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getRuntimeTypeArgument(this, "MapMixin", 1)});
        if (this.containsKey$1(key))
          return this.$index(0, key);
        t1 = ifAbsent.call$0();
        this.$indexSet(0, key, t1);
        return t1;
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      get$entries: [function(_) {
        return J.map$1$1$ax(this.get$keys(), new P.MapMixin_entries_closure(this), [P.MapEntry, H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)]);
      }, null, null, 3, 0, null],
      map$2$1: [1, function(_, transform, K2, V2) {
        var result, t1, key, entry;
        H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)]});
        result = P.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
        for (t1 = J.get$iterator$ax(this.get$keys()); t1.moveNext$0();) {
          key = t1.get$current();
          entry = transform.call$2(key, this.$index(0, key));
          result.$indexSet(0, entry.key, entry.value);
        }
        return result;
      }, function($receiver, transform) {
        return this.map$2$1($receiver, transform, null, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 204],
      addEntries$1: [function(newEntries) {
        var t1, t2;
        for (t1 = J.get$iterator$ax(H.assertSubtype(newEntries, "$isIterable", [[P.MapEntry, H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)]], "$asIterable")); t1.moveNext$0();) {
          t2 = t1.get$current();
          this.$indexSet(0, t2.key, t2.value);
        }
      }, null, "get$addEntries", 4, 0, null, 963],
      containsKey$1: [function(key) {
        return J.contains$1$asx(this.get$keys(), key);
      }, null, "get$containsKey", 4, 0, null, 4],
      get$length: [function(_) {
        return J.get$length$asx(this.get$keys());
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this.get$keys());
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this.get$keys());
      }, null, null, 3, 0, null],
      get$values: [function(_) {
        return P._MapBaseValueIterable$(this, H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1));
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return P.MapBase_mapToString(this);
      }, null, "get$toString", 1, 0, null],
      $isMap: 1
    },
    MapMixin_entries_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(key) {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 0);
        H.assertSubtypeOfRuntimeType(key, t3);
        return P.MapEntry$_(key, t2.$index(t1, key), t3, H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 1));
      }, null, null, 4, 0, null, 4, "call"],
      $signature: function() {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 0);
        return {func: 1, ret: [P.MapEntry, t3, H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 1)], args: [t3]};
      }
    },
    UnmodifiableMapBase: {
      "^": "MapBase;$ti",
      $is_UnmodifiableMapMixin: 1
    },
    _MapBaseValueIterable: {
      "^": "EfficientLengthIterable;_collection$_map,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this._collection$_map);
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._collection$_map);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._collection$_map);
      }, null, null, 3, 0, null],
      get$first: [function(_) {
        var t1 = this._collection$_map;
        return J.$index$asx(t1, J.get$first$ax(t1.get$keys()));
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        var t1 = this._collection$_map;
        return J.$index$asx(t1, J.get$single$ax(t1.get$keys()));
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        var t1 = this._collection$_map;
        return J.$index$asx(t1, J.get$last$ax(t1.get$keys()));
      }, null, null, 3, 0, null],
      get$iterator: [function(_) {
        return P._MapBaseValueIterator$(this._collection$_map, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }, null, null, 3, 0, null],
      $asEfficientLengthIterable: function($K, $V) {
        return [$V];
      },
      $asIterable: function($K, $V) {
        return [$V];
      },
      static: {
        _MapBaseValueIterable$: [function(_map, $K, $V) {
          return new P._MapBaseValueIterable(_map, [$K, $V]);
        }, null, null, 4, 0, null, 141]
      }
    },
    _MapBaseValueIterator: {
      "^": "Object;_keys<,_collection$_map,0_collection$_current,$ti",
      set$_collection$_current: function(_current) {
        this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
      },
      moveNext$0: [function() {
        var t1 = this._keys;
        if (t1.moveNext$0()) {
          this.set$_collection$_current(J.$index$asx(this._collection$_map, t1.get$current()));
          return true;
        }
        this.set$_collection$_current(null);
        return false;
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return this._collection$_current;
      }, null, null, 2, 0, null],
      $isIterator: 1,
      $asIterator: function($K, $V) {
        return [$V];
      },
      static: {
        _MapBaseValueIterator$: [function(map, $K, $V) {
          return new P._MapBaseValueIterator(J.get$iterator$ax(map.get$keys()), map, [$K, $V]);
        }, null, null, 4, 0, null, 111]
      }
    },
    _UnmodifiableMapMixin: {
      "^": "Object;$ti",
      $indexSet: [function(_, key, value) {
        H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 0));
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 1));
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      }, null, "get$[]=", 9, 0, null, 4, 1],
      addAll$1: [function(_, other) {
        H.assertSubtype(other, "$isMap", [H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 0), H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 1)], "$asMap");
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      }, null, "get$addAll", 5, 0, null, 3],
      clear$0: [function(_) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      }, null, "get$clear", 1, 0, null],
      remove$1: [function(_, key) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      }, null, "get$remove", 5, 0, null, 4],
      putIfAbsent$2: [function(key, ifAbsent) {
        H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 0));
        H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 1)});
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      $isMap: 1
    },
    MapView: {
      "^": "Object;$ti",
      cast$2$0: [1, function(_, RK, RV) {
        return J.cast$2$0$ax(this._collection$_map, RK, RV);
      }, function($receiver) {
        return this.cast$2$0($receiver, null, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      $index: [function(_, key) {
        return J.$index$asx(this._collection$_map, key);
      }, null, "get$[]", 5, 0, null, 4],
      $indexSet: [function(_, key, value) {
        J.$indexSet$ax(this._collection$_map, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)));
      }, null, "get$[]=", 9, 0, null, 4, 1],
      addAll$1: [function(_, other) {
        J.addAll$1$ax(this._collection$_map, H.assertSubtype(other, "$isMap", this.$ti, "$asMap"));
      }, null, "get$addAll", 5, 0, null, 3],
      clear$0: [function(_) {
        J.clear$0$ax(this._collection$_map);
      }, null, "get$clear", 1, 0, null],
      putIfAbsent$2: [function(key, ifAbsent) {
        return this._collection$_map.putIfAbsent$2(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(this, 1)}));
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      containsKey$1: [function(key) {
        return this._collection$_map.containsKey$1(key);
      }, null, "get$containsKey", 4, 0, null, 4],
      forEach$1: [function(_, action) {
        J.forEach$1$ax(this._collection$_map, H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]}));
      }, null, "get$forEach", 5, 0, null, 63],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._collection$_map);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._collection$_map);
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this._collection$_map);
      }, null, null, 3, 0, null],
      get$keys: [function() {
        return this._collection$_map.get$keys();
      }, null, null, 2, 0, null],
      remove$1: [function(_, key) {
        return J.remove$1$ax(this._collection$_map, key);
      }, null, "get$remove", 5, 0, null, 4],
      toString$0: [function(_) {
        return J.toString$0$(this._collection$_map);
      }, null, "get$toString", 1, 0, null],
      get$values: [function(_) {
        return J.get$values$z(this._collection$_map);
      }, null, null, 3, 0, null],
      get$entries: [function(_) {
        return J.get$entries$z(this._collection$_map);
      }, null, null, 3, 0, null],
      map$2$1: [1, function(_, transform, K2, V2) {
        return J.map$2$1$ax(this._collection$_map, H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]}), K2, V2);
      }, function($receiver, transform) {
        return this.map$2$1($receiver, transform, null, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 204],
      $isMap: 1
    },
    UnmodifiableMapView: {
      "^": "_UnmodifiableMapView_MapView__UnmodifiableMapMixin;_collection$_map,$ti",
      cast$2$0: [1, function(_, RK, RV) {
        return P.UnmodifiableMapView$(J.cast$2$0$ax(this._collection$_map, RK, RV), RK, RV);
      }, function($receiver) {
        return this.cast$2$0($receiver, null, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      $is_UnmodifiableMapMixin: 1,
      static: {
        UnmodifiableMapView$: [function(map, $K, $V) {
          return new P.UnmodifiableMapView(map, [$K, $V]);
        }, null, null, 4, 0, null, 111]
      }
    },
    Queue: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    _DoubleLink: {
      "^": "Object;$ti"
    },
    DoubleLinkedQueueEntry: {
      "^": "_DoubleLink;$ti",
      $as_DoubleLink: function($E) {
        return [[P.DoubleLinkedQueueEntry, $E]];
      }
    },
    _DoubleLinkedQueueEntry: {
      "^": "DoubleLinkedQueueEntry;$ti"
    },
    _DoubleLinkedQueueElement: {
      "^": "_DoubleLinkedQueueEntry;$ti"
    },
    _DoubleLinkedQueueSentinel: {
      "^": "_DoubleLinkedQueueEntry;$ti"
    },
    DoubleLinkedQueue: {
      "^": "Iterable;$ti",
      $isEfficientLengthIterable: 1,
      $isQueue: 1
    },
    _DoubleLinkedQueueIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    ListQueue: {
      "^": "ListIterable;$ti",
      $isQueue: 1
    },
    _ListQueueIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    SetMixin: {
      "^": "Object;$ti",
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      clear$0: [function(_) {
        this.removeAll$1(this.toList$0(0));
      }, null, "get$clear", 1, 0, null],
      addAll$1: [function(_, elements) {
        var t1;
        for (t1 = J.get$iterator$ax(H.assertSubtype(elements, "$isIterable", [H.getRuntimeTypeArgument(this, "SetMixin", 0)], "$asIterable")); t1.moveNext$0();)
          this.add$1(0, t1.get$current());
      }, null, "get$addAll", 5, 0, null, 80],
      removeAll$1: [function(elements) {
        var t1;
        for (t1 = J.get$iterator$ax(H.assertSubtype(elements, "$isIterable", [P.Object], "$asIterable")); t1.moveNext$0();)
          this.remove$1(0, t1.get$current());
      }, null, "get$removeAll", 4, 0, null, 80],
      toList$1$growable: [function(_, growable) {
        var result, t1, i, i0;
        if (H.boolTypeCheck(growable)) {
          result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "SetMixin", 0)]);
          C.JSArray_methods.set$length(result, this.get$length(this));
        } else {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = new Array(t1);
          t1.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "SetMixin", 0)]);
        }
        for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
          i0 = i + 1;
          C.JSArray_methods.$indexSet(result, i, t1.get$current());
        }
        return result;
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95],
      map$1$1: [1, function(_, f, $T) {
        var t1 = H.getRuntimeTypeArgument(this, "SetMixin", 0);
        return H.EfficientLengthMappedIterable$(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      get$single: [function(_) {
        var it;
        if (J.$gt$n(this.get$length(this), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current();
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      }, null, "get$toString", 1, 0, null],
      where$1: [function(_, f) {
        var t1 = H.getRuntimeTypeArgument(this, "SetMixin", 0);
        return H.WhereIterable$(this, H.functionTypeCheck(f, {func: 1, ret: P.bool, args: [t1]}), t1);
      }, null, "get$where", 5, 0, null, 15],
      forEach$1: [function(_, f) {
        var t1;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "SetMixin", 0)]});
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          f.call$1(t1.get$current());
      }, null, "get$forEach", 5, 0, null, 15],
      join$1: [function(_, separator) {
        var iterator, buffer;
        H.stringTypeCheck(separator);
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          return "";
        buffer = P.StringBuffer$("");
        if (separator == null || separator === "") {
          do
            buffer.write$1(H.S(iterator.get$current()));
          while (iterator.moveNext$0());
        } else {
          buffer.write$1(H.S(iterator.get$current()));
          for (; iterator.moveNext$0();) {
            buffer.write$1(separator);
            buffer.write$1(H.S(iterator.get$current()));
          }
        }
        return buffer.toString$0(0);
      }, null, "get$join", 1, 2, null, 39, 90],
      any$1: [function(_, test) {
        var t1;
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "SetMixin", 0)]});
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (test.call$1(t1.get$current()))
            return true;
        return false;
      }, null, "get$any", 5, 0, null, 41],
      take$1: [function(_, n) {
        return H.TakeIterable_TakeIterable(this, H.intTypeCheck(n), H.getRuntimeTypeArgument(this, "SetMixin", 0));
      }, null, "get$take", 5, 0, null, 72],
      skip$1: [function(_, n) {
        return H.SkipIterable_SkipIterable(this, H.intTypeCheck(n), H.getRuntimeTypeArgument(this, "SetMixin", 0));
      }, null, "get$skip", 5, 0, null, 72],
      get$first: [function(_) {
        var it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current();
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        do
          result = it.get$current();
        while (it.moveNext$0());
        return result;
      }, null, null, 3, 0, null],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1, result, foundMatching, element;
        t1 = H.getRuntimeTypeArgument(this, "SetMixin", 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element)) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      elementAt$1: [function(_, index) {
        var t1, elementIndex, element;
        H.intTypeCheck(index);
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        P.RangeError_checkNotNegative(index, "index", null);
        for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
          element = t1.get$current();
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      }, null, "get$elementAt", 5, 0, null, 6],
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isSet: 1
    },
    SetBase: {
      "^": "SetMixin;$ti"
    },
    _SplayTreeNode: {
      "^": "Object;$ti"
    },
    _SplayTreeMapNode: {
      "^": "_SplayTreeNode;$ti",
      $as_SplayTreeNode: function($K, $V) {
        return [$K];
      }
    },
    _SplayTree: {
      "^": "Object;$ti"
    },
    _TypeTest: {
      "^": "Object;$ti"
    },
    SplayTreeMap: {
      "^": "_SplayTreeMap__SplayTree_MapMixin;$ti",
      $isMapMixin: 1,
      $as_SplayTree: function($K, $V) {
        return [$K, [P._SplayTreeMapNode, $K, $V]];
      },
      $isMap: 1
    },
    _SplayTreeIterator: {
      "^": "Object;$ti",
      $isIterator: 1,
      $asIterator: function($K, $T) {
        return [$T];
      }
    },
    _SplayTreeKeyIterable: {
      "^": "EfficientLengthIterable;$ti"
    },
    _SplayTreeValueIterable: {
      "^": "EfficientLengthIterable;$ti",
      $asEfficientLengthIterable: function($K, $V) {
        return [$V];
      },
      $asIterable: function($K, $V) {
        return [$V];
      }
    },
    _SplayTreeKeyIterator: {
      "^": "_SplayTreeIterator;$ti",
      $as_SplayTreeIterator: function($K) {
        return [$K, $K];
      },
      $asIterator: null
    },
    _SplayTreeValueIterator: {
      "^": "_SplayTreeIterator;$ti"
    },
    _SplayTreeNodeIterator: {
      "^": "_SplayTreeIterator;$ti",
      $as_SplayTreeIterator: function($K) {
        return [$K, [P._SplayTreeNode, $K]];
      },
      $asIterator: function($K) {
        return [[P._SplayTreeNode, $K]];
      }
    },
    SplayTreeSet: {
      "^": "_SplayTreeSet__SplayTree_IterableMixin_SetMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isIterableMixin: 1,
      $isSetMixin: 1,
      $as_SplayTree: function($E) {
        return [$E, [P._SplayTreeNode, $E]];
      },
      $isIterable: 1,
      $isSet: 1
    },
    _ListBase_Object_ListMixin: {
      "^": "Object+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isListMixin: 1,
      $isIterable: 1,
      $isList: 1
    },
    _SplayTreeMap__SplayTree_MapMixin: {
      "^": "_SplayTree;$ti",
      $isMapMixin: 1,
      $as_SplayTree: function($K, $V) {
        return [$K, [P._SplayTreeMapNode, $K, $V]];
      },
      $isMap: 1
    },
    _SplayTreeSet__SplayTree_IterableMixin: {
      "^": "_SplayTree;$ti",
      $isIterableMixin: 1,
      $as_SplayTree: function($E) {
        return [$E, [P._SplayTreeNode, $E]];
      },
      $isIterable: 1
    },
    _SplayTreeSet__SplayTree_IterableMixin_SetMixin: {
      "^": "_SplayTreeSet__SplayTree_IterableMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isIterableMixin: 1,
      $isSetMixin: 1,
      $as_SplayTree: function($E) {
        return [$E, [P._SplayTreeNode, $E]];
      },
      $isIterable: 1,
      $isSet: 1
    },
    _UnmodifiableMapView_MapView__UnmodifiableMapMixin: {
      "^": "MapView+_UnmodifiableMapMixin;$ti",
      $is_UnmodifiableMapMixin: 1
    }
  }], ["dart.convert", "dart:convert",, P, {
    "^": "",
    _parseJson: [function(source, reviver) {
      var parsed, e, t1, exception;
      H.stringTypeCheck(source);
      H.functionTypeCheck(reviver, {func: 1, args: [,,]});
      t1 = source;
      if (typeof t1 !== "string")
        throw H.wrapException(H.argumentErrorValue(source));
      parsed = null;
      try {
        parsed = JSON.parse(source);
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.FormatException$(String(e), null, null);
        throw H.wrapException(t1);
      }
      if (reviver == null)
        return P._convertJsonToDartLazy(parsed);
      else
        return P._convertJsonToDart(parsed, reviver);
    }, null, null, 8, 0, null, 11, 183],
    _convertJsonToDart: [function(json, reviver) {
      H.functionTypeCheck(reviver, {func: 1, args: [,,]});
      return reviver.call$2(null, new P._convertJsonToDart_walk(reviver).call$1(json));
    }, null, null, 8, 0, null, 2, 183],
    _convertJsonToDartLazy: [function(object) {
      var i;
      if (object == null)
        return;
      if (typeof object != "object")
        return object;
      if (Object.getPrototypeOf(object) !== Array.prototype)
        return P._JsonMap$(object);
      for (i = 0; i < object.length; ++i)
        object[i] = P._convertJsonToDartLazy(object[i]);
      return object;
    }, null, null, 4, 0, null, 9],
    Encoding_getByName: [function($name) {
      H.stringTypeCheck($name);
      if ($name == null)
        return;
      $name = C.JSString_methods.toLowerCase$0($name);
      return J.$index$asx($.$get$Encoding__nameToEncoding(), $name);
    }, null, null, 4, 0, null, 8],
    jsonEncode: [function(object, toEncodable) {
      return C.JsonCodec_null_null.encode$2$toEncodable(object, H.functionTypeCheck(toEncodable, {func: 1, ret: P.Object, args: [P.Object]}));
    }, null, null, 4, 3, null, 0, 9, 114],
    jsonDecode: [function(source, reviver) {
      return C.JsonCodec_null_null.decode$2$reviver(0, H.stringTypeCheck(source), H.functionTypeCheck(reviver, {func: 1, ret: P.Object, args: [P.Object, P.Object]}));
    }, null, null, 4, 3, null, 0, 11, 183],
    JsonUtf8Encoder__utf8Encode: [function(string) {
      var t1, i;
      H.stringTypeCheck(string);
      if (string == null)
        return;
      if (C.JSString_methods.get$isEmpty(string))
        return H.NativeUint8List_NativeUint8List(0);
      $label0$0: {
        for (t1 = string.length, i = 0; i < t1; ++i)
          if (J.$ge$n(C.JSString_methods._codeUnitAt$1(string, i), 128))
            break $label0$0;
        return C.JSString_methods.get$codeUnits(string);
      }
      return C.Utf8Codec_false.encode$1(string);
    }, null, null, 4, 0, null, 30],
    _defaultToEncodable: [function(object) {
      return object.toJson$0();
    }, "call$1", "convert___defaultToEncodable$closure", 4, 0, 3, 9],
    _JsonStringifier_hexDigit: [function(x) {
      H.intTypeCheck(x);
      if (typeof x !== "number")
        return x.$lt();
      return x < 10 ? 48 + x : 87 + x;
    }, null, null, 4, 0, null, 37],
    _isLeadSurrogate: [function(codeUnit) {
      H.intTypeCheck(codeUnit);
      if (typeof codeUnit !== "number")
        return codeUnit.$and();
      return (codeUnit & 64512) === 55296;
    }, null, null, 4, 0, null, 125],
    _isTailSurrogate: [function(codeUnit) {
      H.intTypeCheck(codeUnit);
      if (typeof codeUnit !== "number")
        return codeUnit.$and();
      return (codeUnit & 64512) === 56320;
    }, null, null, 4, 0, null, 125],
    _combineSurrogatePair: [function(lead, tail) {
      H.intTypeCheck(lead);
      H.intTypeCheck(tail);
      if (typeof lead !== "number")
        return lead.$and();
      if (typeof tail !== "number")
        return tail.$and();
      return 65536 + ((lead & 1023) << 10) | tail & 1023;
    }, null, null, 8, 0, null, 756, 757],
    _convertJsonToDart_walk: {
      "^": "Closure:3;reviver,$ti",
      call$1: [function(e) {
        var t1, i, map, processed, keys, t2, t3, key;
        if (e == null || typeof e != "object")
          return e;
        if (Object.getPrototypeOf(e) === Array.prototype) {
          for (t1 = this.reviver, i = 0; i < e.length; ++i)
            e[i] = t1.call$2(i, this.call$1(e[i]));
          return e;
        }
        map = P._JsonMap$(e);
        processed = map._processed;
        keys = map._computeKeys$0();
        t1 = J.getInterceptor$asx(keys);
        t2 = this.reviver;
        i = 0;
        while (true) {
          t3 = t1.get$length(keys);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          key = t1.$index(keys, i);
          processed[key] = t2.call$2(key, this.call$1(e[key]));
          ++i;
        }
        map._original = processed;
        return map;
      }, null, null, 4, 0, null, 19, "call"]
    },
    _JsonMap: {
      "^": "MapBase;_original,_processed,0_data,$ti",
      $index: [function(_, key) {
        var result;
        if (this.get$_isUpgraded())
          return J.$index$asx(this.get$_upgradedMap(), key);
        else if (typeof key !== "string")
          return;
        else {
          result = P._JsonMap__getProperty(this._processed, key);
          return P._JsonMap__isUnprocessed(result) ? this._process$1(key) : result;
        }
      }, null, "get$[]", 5, 0, null, 4],
      get$length: [function(_) {
        return this.get$_isUpgraded() ? J.get$length$asx(this.get$_upgradedMap()) : J.get$length$asx(this._computeKeys$0());
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.$gt$n(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$keys: [function() {
        if (this.get$_isUpgraded())
          return this.get$_upgradedMap().get$keys();
        return P._JsonMapKeyIterable$(this);
      }, null, null, 2, 0, null],
      get$values: [function(_) {
        if (this.get$_isUpgraded())
          return J.get$values$z(this.get$_upgradedMap());
        return H.MappedIterable_MappedIterable(this._computeKeys$0(), new P._JsonMap_values_closure(this), P.String, null);
      }, null, null, 3, 0, null],
      $indexSet: [function(_, key, value) {
        var processed, original;
        H.stringTypeCheck(key);
        if (this.get$_isUpgraded())
          J.$indexSet$ax(this.get$_upgradedMap(), key, value);
        else if (this.containsKey$1(key)) {
          processed = this._processed;
          P._JsonMap__setProperty(processed, key, value);
          original = this._original;
          if (original == null ? processed != null : original !== processed)
            P._JsonMap__setProperty(original, key, null);
        } else
          J.$indexSet$ax(this._upgrade$0(), key, value);
      }, null, "get$[]=", 9, 0, null, 4, 1],
      addAll$1: [function(_, other) {
        H.assertSubtype(other, "$isMap", [P.String, null], "$asMap").forEach$1(0, new P._JsonMap_addAll_closure(this));
      }, null, "get$addAll", 5, 0, null, 3],
      containsKey$1: [function(key) {
        if (this.get$_isUpgraded())
          return this.get$_upgradedMap().containsKey$1(key);
        if (typeof key !== "string")
          return false;
        return P._JsonMap__hasProperty(this._original, key);
      }, null, "get$containsKey", 4, 0, null, 4],
      putIfAbsent$2: [function(key, ifAbsent) {
        var value;
        H.stringTypeCheck(key);
        H.functionTypeCheck(ifAbsent, {func: 1});
        if (this.containsKey$1(key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      remove$1: [function(_, key) {
        if (!this.get$_isUpgraded() && !this.containsKey$1(key))
          return;
        return J.remove$1$ax(this._upgrade$0(), key);
      }, null, "get$remove", 5, 0, null, 4],
      clear$0: [function(_) {
        var t1;
        if (this.get$_isUpgraded())
          J.clear$0$ax(this.get$_upgradedMap());
        else {
          t1 = this._data;
          if (t1 != null)
            J.clear$0$ax(t1);
          this._processed = null;
          this._original = null;
          this._data = P.LinkedHashMap__makeEmpty();
        }
      }, null, "get$clear", 1, 0, null],
      forEach$1: [function(_, f) {
        var keys, t1, i, t2, key, value;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
        if (this.get$_isUpgraded())
          return J.forEach$1$ax(this.get$_upgradedMap(), f);
        keys = this._computeKeys$0();
        t1 = J.getInterceptor$asx(keys);
        i = 0;
        while (true) {
          t2 = t1.get$length(keys);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          key = t1.$index(keys, i);
          value = P._JsonMap__getProperty(this._processed, key);
          if (P._JsonMap__isUnprocessed(value)) {
            value = P._convertJsonToDartLazy(P._JsonMap__getProperty(this._original, key));
            P._JsonMap__setProperty(this._processed, key, value);
          }
          f.call$2(key, value);
          if (keys !== this._data)
            throw H.wrapException(P.ConcurrentModificationError$(this));
          ++i;
        }
      }, null, "get$forEach", 5, 0, null, 15],
      get$_isUpgraded: [function() {
        return this._processed == null;
      }, null, null, 2, 0, null],
      get$_upgradedMap: [function() {
        return this._data;
      }, null, null, 2, 0, null],
      _computeKeys$0: [function() {
        var keys, t1;
        keys = H.listTypeCheck(this._data);
        if (keys == null) {
          t1 = P.String;
          keys = H.setRuntimeTypeInfo(J.JSArray_JSArray$typed(P._JsonMap__getPropertyNames(this._original), t1), [t1]);
          this._data = keys;
        }
        return keys;
      }, null, "get$_computeKeys", 0, 0, null],
      _upgrade$0: [function() {
        var result, keys, t1, i, t2, key;
        if (this.get$_isUpgraded())
          return this.get$_upgradedMap();
        result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
        keys = this._computeKeys$0();
        t1 = J.getInterceptor$asx(keys);
        i = 0;
        while (true) {
          t2 = t1.get$length(keys);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          key = t1.$index(keys, i);
          result.$indexSet(0, key, this.$index(0, key));
          ++i;
        }
        if (t1.get$isEmpty(keys))
          t1.add$1(keys, null);
        else
          t1.clear$0(keys);
        this._processed = null;
        this._original = null;
        this._data = result;
        return result;
      }, null, "get$_upgrade", 0, 0, null],
      _process$1: [function(key) {
        var result;
        H.stringTypeCheck(key);
        if (!P._JsonMap__hasProperty(this._original, key))
          return;
        result = P._convertJsonToDartLazy(P._JsonMap__getProperty(this._original, key));
        return P._JsonMap__setProperty(this._processed, key, result);
      }, null, "get$_process", 4, 0, null, 4],
      $asMapBase: function() {
        return [P.String, null];
      },
      $asMapMixin: function() {
        return [P.String, null];
      },
      $asMap: function() {
        return [P.String, null];
      },
      static: {
        _JsonMap$: [function(_original) {
          return new P._JsonMap(_original, P._JsonMap__newJavaScriptObject(), []);
        }, null, null, 4, 0, null, 968],
        _JsonMap__hasProperty: [function(object, key) {
          return Object.prototype.hasOwnProperty.call(object, H.stringTypeCheck(key));
        }, null, null, 8, 0, null, 9, 4],
        _JsonMap__getProperty: [function(object, key) {
          return object[H.stringTypeCheck(key)];
        }, null, null, 8, 0, null, 9, 4],
        _JsonMap__setProperty: [function(object, key, value) {
          return object[H.stringTypeCheck(key)] = value;
        }, null, null, 12, 0, null, 9, 4, 1],
        _JsonMap__getPropertyNames: [function(object) {
          return Object.keys(object);
        }, null, null, 4, 0, null, 9],
        _JsonMap__isUnprocessed: [function(object) {
          return typeof object == "undefined";
        }, null, null, 4, 0, null, 9],
        _JsonMap__newJavaScriptObject: [function() {
          return Object.create(null);
        }, null, null, 0, 0, null]
      }
    },
    _JsonMap_values_closure: {
      "^": "Closure:3;$this,$ti",
      call$1: [function(each) {
        return J.$index$asx(this.$this, each);
      }, null, null, 4, 0, null, 290, "call"]
    },
    _JsonMap_addAll_closure: {
      "^": "Closure:22;$this,$ti",
      call$2: [function(key, value) {
        J.$indexSet$ax(this.$this, H.stringTypeCheck(key), value);
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    _JsonMapKeyIterable: {
      "^": "ListIterable;_parent,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this._parent);
      }, null, null, 3, 0, null],
      elementAt$1: [function(_, index) {
        var t1;
        H.intTypeCheck(index);
        t1 = this._parent;
        return t1.get$_isUpgraded() ? J.elementAt$1$ax(t1.get$keys(), index) : J.$index$asx(t1._computeKeys$0(), index);
      }, null, "get$elementAt", 5, 0, null, 6],
      get$iterator: [function(_) {
        var t1 = this._parent;
        return t1.get$_isUpgraded() ? J.get$iterator$ax(t1.get$keys()) : J.get$iterator$ax(t1._computeKeys$0());
      }, null, null, 3, 0, null],
      contains$1: [function(_, key) {
        return this._parent.containsKey$1(key);
      }, null, "get$contains", 5, 0, null, 4],
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $asListIterable: function() {
        return [P.String];
      },
      $asIterable: function() {
        return [P.String];
      },
      static: {
        _JsonMapKeyIterable$: [function(_parent) {
          return new P._JsonMapKeyIterable(_parent, []);
        }, null, null, 4, 0, null, 1011]
      }
    },
    _JsonDecoderSink: {
      "^": "_StringSinkConversionSink;_reviver,_sink,_stringSink,$ti",
      close$0: [function(_) {
        var buffer, accumulated, t1, t2;
        this.super$_StringSinkConversionSink$close(0);
        buffer = H.interceptedTypeCheck(this._stringSink, "$isStringBuffer");
        accumulated = J.toString$0$(buffer);
        buffer.clear$0(0);
        t1 = this._sink;
        t2 = J.getInterceptor$ax(t1);
        t2.add$1(t1, P._parseJson(accumulated, this._reviver));
        t2.close$0(t1);
      }, "call$0", "get$close", 1, 0, 0],
      static: {
        _JsonDecoderSink$: [function(_reviver, _sink) {
          return new P._JsonDecoderSink(_reviver, _sink, P.StringBuffer$(""), []);
        }, null, null, 8, 0, null, 1017, 60]
      }
    },
    AsciiCodec: {
      "^": "Encoding;_allowInvalid,$ti",
      get$name: [function(_) {
        return "us-ascii";
      }, null, null, 3, 0, null],
      encode$1: [function(source) {
        H.stringTypeCheck(source);
        return this.get$encoder().convert$1(source);
      }, null, "get$encode", 4, 0, null, 11],
      decode$2$allowInvalid: [function(_, bytes, allowInvalid) {
        H.assertSubtype(bytes, "$isList", [P.int], "$asList");
        H.boolTypeCheck(allowInvalid);
        if (allowInvalid == null ? this._allowInvalid : allowInvalid)
          return C.AsciiDecoder_true_127.convert$1(bytes);
        else
          return C.AsciiDecoder_false_127.convert$1(bytes);
      }, function($receiver, bytes) {
        return this.decode$2$allowInvalid($receiver, bytes, null);
      }, "decode$1", null, null, "get$decode", 5, 3, null, 0, 103, 349],
      get$encoder: [function() {
        return C.AsciiEncoder_127;
      }, null, null, 2, 0, null],
      get$decoder: [function() {
        return this._allowInvalid ? C.AsciiDecoder_true_127 : C.AsciiDecoder_false_127;
      }, null, null, 2, 0, null]
    },
    _UnicodeSubsetEncoder: {
      "^": "Converter;$ti",
      convert$3: [function(string, start, end) {
        var stringLength, $length, result, t1, t2, t3, i, codeUnit, t4;
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        stringLength = string.length;
        P.RangeError_checkValidRange(start, end, stringLength, null, null, null);
        if (end == null)
          end = stringLength;
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        result = H.NativeUint8List_NativeUint8List($length);
        for (t1 = this._subsetMask, t2 = J.getInterceptor$i(t1), t3 = J.getInterceptor$s(string), i = 0; i < $length; ++i) {
          codeUnit = t3.codeUnitAt$1(string, start + i);
          t4 = t2.$not(t1);
          if (typeof codeUnit !== "number")
            return codeUnit.$and();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if ((codeUnit & t4) >>> 0 !== 0)
            throw H.wrapException(P.ArgumentError$("String contains invalid characters."));
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = codeUnit;
        }
        return result;
      }, function(string) {
        return this.convert$3(string, 0, null);
      }, "convert$1", null, null, "get$convert", 4, 4, null, 16, 0, 30, 5, 7],
      startChunkedConversion$1: [function(sink) {
        H.assertSubtype(sink, "$isSink", [[P.List, P.int]], "$asSink");
        if (!(sink instanceof P.ByteConversionSink))
          sink = P._ByteAdapterSink$(sink);
        return P._UnicodeSubsetEncoderSink$(this._subsetMask, sink);
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      bind$1: [function(stream) {
        return this.super$Converter$bind(H.assertSubtype(stream, "$isStream", [P.String], "$asStream"));
      }, null, "get$bind", 4, 0, null, 57],
      $asStreamTransformer: function() {
        return [P.String, [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [P.String, [P.List, P.int]];
      },
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    AsciiEncoder: {
      "^": "_UnicodeSubsetEncoder;_subsetMask,$ti"
    },
    _UnicodeSubsetEncoderSink: {
      "^": "StringConversionSinkBase;_sink,_subsetMask,$ti",
      close$0: [function(_) {
        J.close$0$z(this._sink);
      }, "call$0", "get$close", 1, 0, 0],
      addSlice$4: [function(source, start, end, isLast) {
        var t1, t2, t3, i, codeUnit, t4;
        H.stringTypeCheck(source);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        P.RangeError_checkValidRange(start, end, source.length, null, null, null);
        t1 = this._subsetMask;
        t2 = J.getInterceptor$i(t1);
        t3 = J.getInterceptor$s(source);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          codeUnit = t3.codeUnitAt$1(source, i);
          t4 = t2.$not(t1);
          if (typeof codeUnit !== "number")
            return codeUnit.$and();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if ((codeUnit & t4) >>> 0 !== 0)
            throw H.wrapException(P.ArgumentError$("Source contains invalid character with code point: " + codeUnit + "."));
          ++i;
        }
        J.add$1$ax(this._sink, J.sublist$2$ax(t3.get$codeUnits(source), start, end));
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 11, 5, 7, 53],
      static: {
        _UnicodeSubsetEncoderSink$: [function(_subsetMask, _sink) {
          return new P._UnicodeSubsetEncoderSink(_sink, _subsetMask, []);
        }, null, null, 8, 0, null, 1035, 60]
      }
    },
    _UnicodeSubsetDecoder: {
      "^": "Converter;$ti",
      convert$3: [function(bytes, start, end) {
        var t1, byteCount, t2, t3, i, byte, t4;
        H.assertSubtype(bytes, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = J.getInterceptor$asx(bytes);
        byteCount = t1.get$length(bytes);
        P.RangeError_checkValidRange(start, end, byteCount, null, null, null);
        if (end == null)
          end = byteCount;
        t2 = this._subsetMask;
        t3 = J.getInterceptor$i(t2);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          byte = t1.$index(bytes, i);
          t4 = t3.$not(t2);
          if (typeof byte !== "number")
            return byte.$and();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if ((byte & t4) >>> 0 !== 0) {
            if (!this._allowInvalid)
              throw H.wrapException(P.FormatException$("Invalid value in input: " + byte, null, null));
            return this._convertInvalid$3(bytes, start, end);
          }
          ++i;
        }
        return P.String_String$fromCharCodes(bytes, start, end);
      }, function(bytes) {
        return this.convert$3(bytes, 0, null);
      }, "convert$1", null, null, "get$convert", 4, 4, null, 16, 0, 103, 5, 7],
      _convertInvalid$3: [function(bytes, start, end) {
        var buffer, t1, t2, t3, i, value, t4;
        H.assertSubtype(bytes, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        buffer = P.StringBuffer$("");
        t1 = this._subsetMask;
        t2 = J.getInterceptor$i(t1);
        t3 = J.getInterceptor$asx(bytes);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          value = t3.$index(bytes, i);
          t4 = t2.$not(t1);
          if (typeof value !== "number")
            return value.$and();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if ((value & t4) >>> 0 !== 0)
            value = 65533;
          buffer.writeCharCode$1(value);
          ++i;
        }
        return buffer.toString$0(0);
      }, null, "get$_convertInvalid", 12, 0, null, 103, 5, 7],
      startChunkedConversion$1: [function(sink) {
        return this.super$Converter$startChunkedConversion(H.assertSubtype(sink, "$isSink", [P.String], "$asSink"));
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      bind$1: [function(stream) {
        return this.super$Converter$bind(H.assertSubtype(stream, "$isStream", [[P.List, P.int]], "$asStream"));
      }, null, "get$bind", 4, 0, null, 57],
      $asStreamTransformer: function() {
        return [[P.List, P.int], P.String];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], P.String];
      },
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      }
    },
    AsciiDecoder: {
      "^": "_UnicodeSubsetDecoder;_allowInvalid,_subsetMask,$ti",
      startChunkedConversion$1: [function(sink) {
        var stringSink;
        H.assertSubtype(sink, "$isSink", [P.String], "$asSink");
        stringSink = !!J.getInterceptor$(sink).$isStringConversionSink ? sink : P._StringAdapterSink$(sink);
        if (this._allowInvalid)
          return P._ErrorHandlingAsciiDecoderSink$(stringSink.asUtf8Sink$1(false));
        else
          return P._SimpleAsciiDecoderSink$(stringSink);
      }, null, "get$startChunkedConversion", 4, 0, null, 48]
    },
    _ErrorHandlingAsciiDecoderSink: {
      "^": "ByteConversionSinkBase;_utf8Sink,$ti",
      close$0: [function(_) {
        J.close$0$z(this._utf8Sink);
      }, "call$0", "get$close", 1, 0, 0],
      add$1: [function(_, source) {
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        this.addSlice$4(source, 0, J.get$length$asx(source), false);
      }, "call$1", "get$add", 5, 0, 2, 11],
      addSlice$4: [function(source, start, end, isLast) {
        var t1, t2, t3, i;
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        t1 = J.getInterceptor$asx(source);
        P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        t2 = this._utf8Sink;
        t3 = J.getInterceptor$ax(t2);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          if (!J.$eq$(J.$and$bn(t1.$index(source, i), 4294967168), 0)) {
            if (typeof start !== "number")
              return H.iae(start);
            if (i > start)
              t2.addSlice$4(source, start, i, false);
            t3.add$1(t2, C.List_239_191_189);
            start = i + 1;
          }
          ++i;
        }
        if (typeof start !== "number")
          return start.$lt();
        if (start < end)
          t2.addSlice$4(source, start, end, isLast);
        else if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 11, 5, 7, 53],
      static: {
        _ErrorHandlingAsciiDecoderSink$: [function(_utf8Sink) {
          return new P._ErrorHandlingAsciiDecoderSink(_utf8Sink, []);
        }, null, null, 4, 0, null, 1039]
      }
    },
    _SimpleAsciiDecoderSink: {
      "^": "ByteConversionSinkBase;_sink,$ti",
      close$0: [function(_) {
        J.close$0$z(this._sink);
      }, "call$0", "get$close", 1, 0, 0],
      add$1: [function(_, source) {
        var t1, i, t2;
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        t1 = J.getInterceptor$asx(source);
        i = 0;
        while (true) {
          t2 = t1.get$length(source);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          if (!J.$eq$(J.$and$bn(t1.$index(source, i), 4294967168), 0))
            throw H.wrapException(P.FormatException$("Source contains non-ASCII bytes.", null, null));
          ++i;
        }
        J.add$1$ax(this._sink, P.String_String$fromCharCodes(source, 0, null));
      }, "call$1", "get$add", 5, 0, 2, 11],
      addSlice$4: [function(source, start, end, isLast) {
        var t1, $length;
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        t1 = J.getInterceptor$asx(source);
        $length = t1.get$length(source);
        P.RangeError_checkValidRange(start, end, $length, null, null, null);
        if (typeof start !== "number")
          return start.$lt();
        if (typeof end !== "number")
          return H.iae(end);
        if (start < end)
          this.add$1(0, start !== 0 || end !== $length ? t1.sublist$2(source, start, end) : source);
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 11, 5, 7, 53],
      static: {
        _SimpleAsciiDecoderSink$: [function(_sink) {
          return new P._SimpleAsciiDecoderSink(_sink, []);
        }, null, null, 4, 0, null, 60]
      }
    },
    Base64Codec: {
      "^": "Codec;_encoder,$ti",
      get$encoder: [function() {
        return this._encoder;
      }, null, null, 2, 0, null],
      get$decoder: [function() {
        return C.C_Base64Decoder;
      }, null, null, 2, 0, null],
      decode$1: [function(_, encoded) {
        H.stringTypeCheck(encoded);
        return this.get$decoder().convert$1(encoded);
      }, null, "get$decode", 5, 0, null, 350],
      normalize$3: [function(source, start, end) {
        var inverseAlphabet, t1, t2, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, char0, value, t3, endLength, $length;
        H.stringTypeCheck(source);
        H.intTypeCheck(start);
        end = P.RangeError_checkValidRange(start, H.intTypeCheck(end), source.length, null, null, null);
        inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
        t1 = J.getInterceptor$asx(inverseAlphabet);
        t2 = J.getInterceptor$asx(source);
        i = start;
        sliceStart = i;
        buffer = null;
        firstPadding = -1;
        firstPaddingSourceIndex = -1;
        paddingCount = 0;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          c$0: {
            i0 = i + 1;
            char = t2.codeUnitAt$1(source, i);
            if (char === 37) {
              i1 = i0 + 2;
              if (i1 <= end) {
                char0 = H.parseHexByte(source, i0);
                if (char0 === 37)
                  char0 = -1;
                i0 = i1;
              } else
                char0 = -1;
            } else
              char0 = char;
            if (typeof char0 !== "number")
              return H.iae(char0);
            if (0 <= char0 && char0 <= 127) {
              value = t1.$index(inverseAlphabet, char0);
              if (typeof value !== "number")
                return value.$ge();
              if (value >= 0) {
                char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
                if (char0 == char)
                  break c$0;
                char = char0;
              } else {
                if (value === -1) {
                  if (typeof firstPadding !== "number")
                    return firstPadding.$lt();
                  if (firstPadding < 0) {
                    t3 = buffer == null ? null : buffer.get$length(buffer);
                    if (t3 == null)
                      t3 = 0;
                    if (typeof sliceStart !== "number")
                      return H.iae(sliceStart);
                    firstPadding = J.$add$ansx(t3, i - sliceStart);
                    firstPaddingSourceIndex = i;
                  }
                  ++paddingCount;
                  if (char === 61)
                    break c$0;
                }
                char = char0;
              }
              if (value !== -2) {
                if (buffer == null)
                  buffer = P.StringBuffer$("");
                buffer.write$1(C.JSString_methods.substring$2(source, sliceStart, i));
                buffer.writeCharCode$1(char);
                sliceStart = i0;
                break c$0;
              }
            }
            throw H.wrapException(P.FormatException$("Invalid base64 data", source, i));
          }
          i = i0;
        }
        if (buffer != null) {
          buffer.write$1(t2.substring$2(source, sliceStart, end));
          if (typeof firstPadding !== "number")
            return firstPadding.$ge();
          if (firstPadding >= 0)
            P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, buffer.get$length(buffer));
          else {
            endLength = J.$add$ansx(J.$mod$n(J.$sub$n(buffer.get$length(buffer), 1), 4), 1);
            if (endLength === 1)
              throw H.wrapException(P.FormatException$("Invalid base64 encoding length ", source, end));
            while (true) {
              if (typeof endLength !== "number")
                return endLength.$lt();
              if (!(endLength < 4))
                break;
              buffer.write$1("=");
              ++endLength;
            }
          }
          return C.JSString_methods.replaceRange$3(source, start, end, buffer.toString$0(0));
        }
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if (typeof firstPadding !== "number")
          return firstPadding.$ge();
        if (firstPadding >= 0)
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
        else {
          endLength = C.JSInt_methods.$mod($length, 4);
          if (endLength === 1)
            throw H.wrapException(P.FormatException$("Invalid base64 encoding length ", source, end));
          if (endLength > 1)
            source = t2.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
        }
        return source;
      }, null, "get$normalize", 4, 4, null, 16, 0, 11, 5, 7],
      $asCodec: function() {
        return [[P.List, P.int], P.String];
      },
      static: {
        Base64Codec__checkPadding: [function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
          H.stringTypeCheck(source);
          H.intTypeCheck(sourceIndex);
          H.intTypeCheck(sourceEnd);
          H.intTypeCheck(firstPadding);
          H.intTypeCheck(paddingCount);
          H.intTypeCheck($length);
          if (typeof $length !== "number")
            return $length.$mod();
          if (C.JSInt_methods.$mod($length, 4) !== 0)
            throw H.wrapException(P.FormatException$("Invalid base64 padding, padded length must be multiple of four, is " + $length, source, sourceEnd));
          if (typeof firstPadding !== "number")
            return firstPadding.$add();
          if (typeof paddingCount !== "number")
            return H.iae(paddingCount);
          if (firstPadding + paddingCount !== $length)
            throw H.wrapException(P.FormatException$("Invalid base64 padding, '=' not at the end", source, sourceIndex));
          if (paddingCount > 2)
            throw H.wrapException(P.FormatException$("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
        }, null, null, 24, 0, null, 11, 579, 858, 907, 573, 35]
      }
    },
    Base64Encoder: {
      "^": "Converter;_urlSafe,$ti",
      convert$1: [function(input) {
        var t1;
        H.assertSubtype(input, "$isList", [P.int], "$asList");
        t1 = J.getInterceptor$asx(input);
        if (t1.get$isEmpty(input))
          return "";
        return P.String_String$fromCharCodes(P._Base64Encoder$(this._urlSafe).encode$4(input, 0, t1.get$length(input), true), 0, null);
      }, null, "get$convert", 4, 0, null, 55],
      startChunkedConversion$1: [function(sink) {
        H.assertSubtype(sink, "$isSink", [P.String], "$asSink");
        if (!!J.getInterceptor$(sink).$isStringConversionSink)
          return P._Utf8Base64EncoderSink$(sink.asUtf8Sink$1(false), this._urlSafe);
        return P._AsciiBase64EncoderSink$(sink, this._urlSafe);
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      $asStreamTransformer: function() {
        return [[P.List, P.int], P.String];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], P.String];
      },
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      }
    },
    _Base64Encoder: {
      "^": "Object;_convert$_state,_alphabet,$ti",
      createBuffer$1: [function(bufferLength) {
        return H.NativeUint8List_NativeUint8List(H.intTypeCheck(bufferLength));
      }, null, "get$createBuffer", 4, 0, null, 351],
      encode$4: [function(bytes, start, end, isLast) {
        var count, byteCount, fullChunks, bufferLength, output;
        H.assertSubtype(bytes, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        count = P._Base64Encoder__stateCount(this._convert$_state);
        if (typeof count !== "number")
          return count.$add();
        byteCount = count + (end - start);
        fullChunks = C.JSInt_methods._tdivFast$1(byteCount, 3);
        bufferLength = fullChunks * 4;
        if (isLast && byteCount - fullChunks * 3 > 0)
          bufferLength += 4;
        output = this.createBuffer$1(bufferLength);
        this._convert$_state = H.intTypeCheck(P._Base64Encoder_encodeChunk(this._alphabet, bytes, start, end, isLast, output, 0, this._convert$_state));
        if (bufferLength > 0)
          return output;
        return;
      }, null, "get$encode", 16, 0, null, 103, 5, 7, 53],
      static: {
        _Base64Encoder$: [function(urlSafe) {
          var t1 = urlSafe ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          return new P._Base64Encoder(0, t1, []);
        }, null, null, 4, 0, null, 223],
        _Base64Encoder__encodeState: [function(count, bits) {
          H.intTypeCheck(count);
          H.intTypeCheck(bits);
          if (typeof bits !== "number")
            return bits.$shl();
          if (typeof count !== "number")
            return H.iae(count);
          return (bits << 2 | count) >>> 0;
        }, null, null, 8, 0, null, 42, 300],
        _Base64Encoder__stateBits: [function(state) {
          H.intTypeCheck(state);
          if (typeof state !== "number")
            return state.$shr();
          return C.JSInt_methods._shrOtherPositive$1(state, 2);
        }, null, null, 4, 0, null, 78],
        _Base64Encoder__stateCount: [function(state) {
          H.intTypeCheck(state);
          if (typeof state !== "number")
            return state.$and();
          return state & 3;
        }, null, null, 4, 0, null, 78],
        _Base64Encoder_encodeChunk: [function(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
          var bits, t1, expectedChars, t2, t3, i, byteOr, byte, outputIndex0;
          H.stringTypeCheck(alphabet);
          H.assertSubtype(bytes, "$isList", [P.int], "$asList");
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.boolTypeCheck(isLast);
          H.interceptedTypeCheck(output, "$isUint8List");
          H.intTypeCheck(outputIndex);
          H.intTypeCheck(state);
          bits = P._Base64Encoder__stateBits(state);
          t1 = P._Base64Encoder__stateCount(state);
          if (typeof t1 !== "number")
            return H.iae(t1);
          expectedChars = 3 - t1;
          t1 = J.getInterceptor$asx(bytes);
          t2 = J.getInterceptor$s(alphabet);
          t3 = output && C.NativeUint8List_methods;
          i = start;
          byteOr = 0;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(i < end))
              break;
            byte = t1.$index(bytes, i);
            if (typeof byte !== "number")
              return H.iae(byte);
            byteOr = (byteOr | byte) >>> 0;
            if (typeof bits !== "number")
              return bits.$shl();
            bits = (bits << 8 | byte) & 16777215;
            --expectedChars;
            if (expectedChars === 0) {
              if (typeof outputIndex !== "number")
                return outputIndex.$add();
              outputIndex0 = outputIndex + 1;
              t3.$indexSet(output, outputIndex, t2._codeUnitAt$1(alphabet, bits >>> 18 & 63));
              outputIndex = outputIndex0 + 1;
              C.NativeUint8List_methods.$indexSet(output, outputIndex0, C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 12 & 63));
              outputIndex0 = outputIndex + 1;
              C.NativeUint8List_methods.$indexSet(output, outputIndex, C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 6 & 63));
              outputIndex = outputIndex0 + 1;
              C.NativeUint8List_methods.$indexSet(output, outputIndex0, C.JSString_methods._codeUnitAt$1(alphabet, bits & 63));
              bits = 0;
              expectedChars = 3;
            }
            ++i;
          }
          if (byteOr >= 0 && byteOr <= 255) {
            if (isLast && expectedChars < 3) {
              P._Base64Encoder_writeFinalChunk(alphabet, output, outputIndex, 3 - expectedChars, bits);
              return 0;
            }
            return P._Base64Encoder__encodeState(3 - expectedChars, bits);
          }
          i = start;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (!(i < end))
              break;
            byte = t1.$index(bytes, i);
            if (typeof byte !== "number")
              return byte.$lt();
            if (byte < 0 || byte > 255)
              break;
            ++i;
          }
          throw H.wrapException(P.ArgumentError$value(bytes, "Not a byte value at index " + i + ": 0x" + H.S(J.toRadixString$1$n(t1.$index(bytes, i), 16)), null));
        }, null, null, 32, 0, null, 346, 103, 5, 7, 53, 246, 348, 78],
        _Base64Encoder_writeFinalChunk: [function(alphabet, output, outputIndex, count, bits) {
          var t1, t2, outputIndex0;
          H.stringTypeCheck(alphabet);
          H.interceptedTypeCheck(output, "$isUint8List");
          H.intTypeCheck(outputIndex);
          H.intTypeCheck(count);
          H.intTypeCheck(bits);
          t1 = J.getInterceptor$s(alphabet);
          t2 = output && C.NativeUint8List_methods;
          if (count === 1) {
            if (typeof outputIndex !== "number")
              return outputIndex.$add();
            outputIndex0 = outputIndex + 1;
            if (typeof bits !== "number")
              return bits.$shr();
            t2.$indexSet(output, outputIndex, t1._codeUnitAt$1(alphabet, C.JSInt_methods._shrOtherPositive$1(bits, 2) & 63));
            outputIndex = outputIndex0 + 1;
            C.NativeUint8List_methods.$indexSet(output, outputIndex0, C.JSString_methods._codeUnitAt$1(alphabet, bits << 4 & 63));
            outputIndex0 = outputIndex + 1;
            t1 = output.length;
            if (outputIndex < 0 || outputIndex >= t1)
              return H.ioore(output, outputIndex);
            output[outputIndex] = 61;
            if (outputIndex0 < 0 || outputIndex0 >= t1)
              return H.ioore(output, outputIndex0);
            output[outputIndex0] = 61;
          } else {
            if (typeof outputIndex !== "number")
              return outputIndex.$add();
            outputIndex0 = outputIndex + 1;
            if (typeof bits !== "number")
              return bits.$shr();
            t2.$indexSet(output, outputIndex, t1._codeUnitAt$1(alphabet, C.JSInt_methods._shrOtherPositive$1(bits, 10) & 63));
            outputIndex = outputIndex0 + 1;
            C.NativeUint8List_methods.$indexSet(output, outputIndex0, C.JSString_methods._codeUnitAt$1(alphabet, C.JSInt_methods._shrOtherPositive$1(bits, 4) & 63));
            outputIndex0 = outputIndex + 1;
            C.NativeUint8List_methods.$indexSet(output, outputIndex, C.JSString_methods._codeUnitAt$1(alphabet, bits << 2 & 63));
            if (outputIndex0 < 0 || outputIndex0 >= output.length)
              return H.ioore(output, outputIndex0);
            output[outputIndex0] = 61;
          }
        }, null, null, 20, 0, null, 346, 246, 348, 42, 300]
      }
    },
    _BufferCachingBase64Encoder: {
      "^": "_Base64Encoder;0bufferCache,_convert$_state,_alphabet,$ti",
      createBuffer$1: [function(bufferLength) {
        var t1;
        H.intTypeCheck(bufferLength);
        t1 = this.bufferCache;
        if (t1 == null || J.$lt$n(J.get$length$asx(t1), bufferLength))
          this.bufferCache = H.interceptedTypeCheck(H.NativeUint8List_NativeUint8List(bufferLength), "$isUint8List");
        return P.Uint8List_Uint8List$view(J.get$buffer$x(this.bufferCache), 0, bufferLength);
      }, null, "get$createBuffer", 4, 0, null, 351],
      static: {
        _BufferCachingBase64Encoder$: [function(urlSafe) {
          var t1 = urlSafe ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_" : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          return new P._BufferCachingBase64Encoder(0, t1, []);
        }, null, null, 4, 0, null, 223]
      }
    },
    _Base64EncoderSink: {
      "^": "ByteConversionSinkBase;$ti",
      add$1: [function(_, source) {
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        this._convert$_add$4(source, 0, J.get$length$asx(source), false);
      }, "call$1", "get$add", 5, 0, 2, 11],
      close$0: [function(_) {
        this._convert$_add$4(null, 0, 0, true);
      }, "call$0", "get$close", 1, 0, 0],
      addSlice$4: [function(source, start, end, isLast) {
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        if (end == null)
          throw H.wrapException(P.ArgumentError$notNull("end"));
        P.RangeError_checkValidRange(start, end, J.get$length$asx(source), null, null, null);
        this._convert$_add$4(source, start, end, isLast);
      }, null, "get$addSlice", 16, 0, null, 11, 5, 7, 53]
    },
    _AsciiBase64EncoderSink: {
      "^": "_Base64EncoderSink;_sink,_encoder,$ti",
      _convert$_add$4: [function(source, start, end, isLast) {
        var buffer;
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        buffer = this._encoder.encode$4(source, start, end, isLast);
        if (buffer != null)
          J.add$1$ax(this._sink, P.String_String$fromCharCodes(buffer, 0, null));
        if (isLast)
          J.close$0$z(this._sink);
      }, null, "get$_convert$_add", 16, 0, null, 11, 5, 7, 53],
      static: {
        _AsciiBase64EncoderSink$: [function(_sink, urlSafe) {
          return new P._AsciiBase64EncoderSink(_sink, P._BufferCachingBase64Encoder$(urlSafe), []);
        }, null, null, 8, 0, null, 60, 223]
      }
    },
    _Utf8Base64EncoderSink: {
      "^": "_Base64EncoderSink;_sink,_encoder,$ti",
      _convert$_add$4: [function(source, start, end, isLast) {
        var buffer;
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        buffer = this._encoder.encode$4(source, start, end, isLast);
        if (buffer != null)
          this._sink.addSlice$4(buffer, 0, buffer.length, isLast);
      }, null, "get$_convert$_add", 16, 0, null, 11, 5, 7, 53],
      static: {
        _Utf8Base64EncoderSink$: [function(_sink, urlSafe) {
          return new P._Utf8Base64EncoderSink(_sink, P._Base64Encoder$(urlSafe), []);
        }, null, null, 8, 0, null, 60, 223]
      }
    },
    Base64Decoder: {
      "^": "Converter;$ti",
      convert$3: [function(input, start, end) {
        var decoder, buffer;
        H.stringTypeCheck(input);
        H.intTypeCheck(start);
        end = P.RangeError_checkValidRange(start, H.intTypeCheck(end), input.length, null, null, null);
        if (start == end)
          return H.NativeUint8List_NativeUint8List(0);
        decoder = P._Base64Decoder$();
        buffer = decoder.decode$3(0, input, start, end);
        decoder.close$2(0, input, end);
        return buffer;
      }, function(input) {
        return this.convert$3(input, 0, null);
      }, "convert$1", null, null, "get$convert", 4, 4, null, 16, 0, 55, 5, 7],
      startChunkedConversion$1: [function(sink) {
        return P._Base64DecoderSink$(H.assertSubtype(sink, "$isSink", [[P.List, P.int]], "$asSink"));
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      $asStreamTransformer: function() {
        return [P.String, [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [P.String, [P.List, P.int]];
      },
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    _Base64Decoder: {
      "^": "Object;_convert$_state,$ti",
      decode$3: [function(_, input, start, end) {
        var buffer;
        H.stringTypeCheck(input);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        if (P._Base64Decoder__hasSeenPadding(this._convert$_state)) {
          this._convert$_state = H.intTypeCheck(P._Base64Decoder__checkPadding(input, start, end, this._convert$_state));
          return;
        }
        if (start == end)
          return H.NativeUint8List_NativeUint8List(0);
        buffer = P._Base64Decoder__allocateBuffer(input, start, end, this._convert$_state);
        this._convert$_state = H.intTypeCheck(P._Base64Decoder_decodeChunk(input, start, end, buffer, 0, this._convert$_state));
        return buffer;
      }, null, "get$decode", 13, 0, null, 55, 5, 7],
      close$2: [function(_, input, end) {
        H.stringTypeCheck(input);
        H.intTypeCheck(end);
        if (J.$lt$n(this._convert$_state, P._Base64Decoder__encodePaddingState(0)))
          throw H.wrapException(P.FormatException$("Missing padding character", input, end));
        if (J.$gt$n(this._convert$_state, 0))
          throw H.wrapException(P.FormatException$("Invalid length, must be multiple of four", input, end));
        this._convert$_state = H.intTypeCheck(P._Base64Decoder__encodePaddingState(0));
      }, "call$2", "get$close", 9, 0, 55, 55, 7],
      static: {
        _Base64Decoder$: [function() {
          return new P._Base64Decoder(0, []);
        }, null, null, 0, 0, null],
        _Base64Decoder__encodeCharacterState: [function(count, bits) {
          H.intTypeCheck(count);
          H.intTypeCheck(bits);
          if (typeof bits !== "number")
            return bits.$shl();
          if (typeof count !== "number")
            return H.iae(count);
          return (bits << 2 | count) >>> 0;
        }, null, null, 8, 0, null, 42, 300],
        _Base64Decoder__stateCount: [function(state) {
          H.intTypeCheck(state);
          if (typeof state !== "number")
            return state.$and();
          return state & 3;
        }, null, null, 4, 0, null, 78],
        _Base64Decoder__stateBits: [function(state) {
          H.intTypeCheck(state);
          if (typeof state !== "number")
            return state.$shr();
          return C.JSInt_methods._shrOtherPositive$1(state, 2);
        }, null, null, 4, 0, null, 78],
        _Base64Decoder__encodePaddingState: [function(expectedPadding) {
          H.intTypeCheck(expectedPadding);
          if (typeof expectedPadding !== "number")
            return expectedPadding.$negate();
          return -expectedPadding - 1;
        }, null, null, 4, 0, null, 577],
        _Base64Decoder__statePadding: [function(state) {
          H.intTypeCheck(state);
          if (typeof state !== "number")
            return state.$negate();
          return -state - 1;
        }, null, null, 4, 0, null, 78],
        _Base64Decoder__hasSeenPadding: [function(state) {
          H.intTypeCheck(state);
          if (typeof state !== "number")
            return state.$lt();
          return state < 0;
        }, null, null, 4, 0, null, 78],
        _Base64Decoder_decodeChunk: [function(input, start, end, output, outIndex, state) {
          var bits, count, t1, i, charOr, char, code, outIndex0, t2, expectedPadding;
          H.stringTypeCheck(input);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.interceptedTypeCheck(output, "$isUint8List");
          H.intTypeCheck(outIndex);
          H.intTypeCheck(state);
          bits = P._Base64Decoder__stateBits(state);
          count = P._Base64Decoder__stateCount(state);
          t1 = J.getInterceptor$s(input);
          i = start;
          charOr = 0;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(i < end))
              break;
            c$0: {
              char = t1.codeUnitAt$1(input, i);
              if (typeof char !== "number")
                return H.iae(char);
              charOr = (charOr | char) >>> 0;
              code = J.$index$asx($.$get$_Base64Decoder__inverseAlphabet(), char & 127);
              if (typeof code !== "number")
                return code.$ge();
              if (code >= 0) {
                if (typeof bits !== "number")
                  return bits.$shl();
                bits = (bits << 6 | code) & 16777215;
                if (typeof count !== "number")
                  return count.$add();
                count = count + 1 & 3;
                if (count === 0) {
                  if (typeof outIndex !== "number")
                    return outIndex.$add();
                  outIndex0 = outIndex + 1;
                  t2 = output.length;
                  if (outIndex < 0 || outIndex >= t2)
                    return H.ioore(output, outIndex);
                  output[outIndex] = bits >>> 16 & 255;
                  outIndex = outIndex0 + 1;
                  if (outIndex0 < 0 || outIndex0 >= t2)
                    return H.ioore(output, outIndex0);
                  output[outIndex0] = bits >>> 8 & 255;
                  outIndex0 = outIndex + 1;
                  if (outIndex < 0 || outIndex >= t2)
                    return H.ioore(output, outIndex);
                  output[outIndex] = bits & 255;
                  outIndex = outIndex0;
                  bits = 0;
                }
                break c$0;
              } else {
                if (code === -1) {
                  if (typeof count !== "number")
                    return count.$gt();
                  t2 = count > 1;
                } else
                  t2 = false;
                if (t2) {
                  if (charOr > 127)
                    break;
                  if (count === 3) {
                    if (typeof bits !== "number")
                      return bits.$and();
                    if ((bits & 3) !== 0)
                      throw H.wrapException(P.FormatException$("Invalid encoding before padding", input, i));
                    if (typeof outIndex !== "number")
                      return outIndex.$add();
                    outIndex0 = outIndex + 1;
                    t1 = C.JSInt_methods._shrOtherPositive$1(bits, 10);
                    t2 = output.length;
                    if (outIndex < 0 || outIndex >= t2)
                      return H.ioore(output, outIndex);
                    output[outIndex] = t1;
                    t1 = C.JSInt_methods._shrOtherPositive$1(bits, 2);
                    if (outIndex0 < 0 || outIndex0 >= t2)
                      return H.ioore(output, outIndex0);
                    output[outIndex0] = t1;
                  } else {
                    if (typeof bits !== "number")
                      return bits.$and();
                    if ((bits & 15) !== 0)
                      throw H.wrapException(P.FormatException$("Invalid encoding before padding", input, i));
                    if (typeof outIndex !== "number")
                      return outIndex.$add();
                    t1 = C.JSInt_methods._shrOtherPositive$1(bits, 4);
                    if (outIndex < 0 || outIndex >= output.length)
                      return H.ioore(output, outIndex);
                    output[outIndex] = t1;
                  }
                  if (typeof count !== "number")
                    return H.iae(count);
                  expectedPadding = (3 - count) * 3;
                  return P._Base64Decoder__checkPadding(input, i + 1, end, P._Base64Decoder__encodePaddingState(char === 37 ? expectedPadding + 2 : expectedPadding));
                }
              }
              throw H.wrapException(P.FormatException$("Invalid character", input, i));
            }
            ++i;
          }
          if (charOr >= 0 && charOr <= 127)
            return P._Base64Decoder__encodeCharacterState(count, bits);
          i = start;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (!(i < end))
              break;
            char = t1.codeUnitAt$1(input, i);
            if (typeof char !== "number")
              return char.$lt();
            if (char < 0 || char > 127)
              break;
            ++i;
          }
          throw H.wrapException(P.FormatException$("Invalid character", input, i));
        }, null, null, 24, 0, null, 55, 5, 7, 246, 578, 78],
        _Base64Decoder__allocateBuffer: [function(input, start, end, state) {
          var paddingStart, t1, $length, bufferLength, remainderLength;
          H.stringTypeCheck(input);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.intTypeCheck(state);
          paddingStart = P._Base64Decoder__trimPaddingChars(input, start, end);
          t1 = P._Base64Decoder__stateCount(state);
          if (typeof paddingStart !== "number")
            return paddingStart.$sub();
          if (typeof start !== "number")
            return H.iae(start);
          $length = J.$add$ansx(t1, paddingStart - start);
          if (typeof $length !== "number")
            return $length.$shr();
          bufferLength = C.JSInt_methods._shrOtherPositive$1($length, 2) * 3;
          remainderLength = $length & 3;
          if (remainderLength !== 0) {
            if (typeof end !== "number")
              return H.iae(end);
            t1 = paddingStart < end;
          } else
            t1 = false;
          if (t1)
            bufferLength += remainderLength - 1;
          if (bufferLength > 0)
            return H.NativeUint8List_NativeUint8List(bufferLength);
          return;
        }, null, null, 16, 0, null, 55, 5, 7, 78],
        _Base64Decoder__trimPaddingChars: [function(input, start, end) {
          var t1, newEnd, index, padding, char;
          H.stringTypeCheck(input);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          t1 = J.getInterceptor$s(input);
          newEnd = end;
          index = newEnd;
          padding = 0;
          while (true) {
            if (typeof index !== "number")
              return index.$gt();
            if (typeof start !== "number")
              return H.iae(start);
            if (!(index > start && padding < 2))
              break;
            c$0: {
              --index;
              char = t1.codeUnitAt$1(input, index);
              if (char === 61) {
                ++padding;
                newEnd = index;
                break c$0;
              }
              if (typeof char !== "number")
                return char.$or();
              if ((char | 32) >>> 0 === 100) {
                if (index === start)
                  break;
                --index;
                char = C.JSString_methods.codeUnitAt$1(input, index);
              }
              if (char === 51) {
                if (index === start)
                  break;
                --index;
                char = C.JSString_methods.codeUnitAt$1(input, index);
              }
              if (char === 37) {
                ++padding;
                newEnd = index;
                break c$0;
              }
              break;
            }
          }
          return newEnd;
        }, null, null, 12, 0, null, 55, 5, 7],
        _Base64Decoder__checkPadding: [function(input, start, end, state) {
          var expectedPadding, t1, char;
          H.stringTypeCheck(input);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.intTypeCheck(state);
          if (start == end)
            return state;
          expectedPadding = P._Base64Decoder__statePadding(state);
          t1 = J.getInterceptor$s(input);
          while (true) {
            if (typeof expectedPadding !== "number")
              return expectedPadding.$gt();
            if (!(expectedPadding > 0))
              break;
            char = t1.codeUnitAt$1(input, start);
            if (expectedPadding === 3) {
              if (char === 61) {
                expectedPadding -= 3;
                if (typeof start !== "number")
                  return start.$add();
                ++start;
                break;
              }
              if (char === 37) {
                --expectedPadding;
                if (typeof start !== "number")
                  return start.$add();
                ++start;
                if (start === end)
                  break;
                char = C.JSString_methods.codeUnitAt$1(input, start);
              } else
                break;
            }
            if ((expectedPadding > 3 ? expectedPadding - 3 : expectedPadding) === 2) {
              if (char !== 51)
                break;
              if (typeof start !== "number")
                return start.$add();
              ++start;
              --expectedPadding;
              if (start === end)
                break;
              char = C.JSString_methods.codeUnitAt$1(input, start);
            }
            if (typeof char !== "number")
              return char.$or();
            if ((char | 32) >>> 0 !== 100)
              break;
            if (typeof start !== "number")
              return start.$add();
            ++start;
            --expectedPadding;
            if (start === end)
              break;
          }
          if (start != end)
            throw H.wrapException(P.FormatException$("Invalid padding character", input, start));
          return P._Base64Decoder__encodePaddingState(expectedPadding);
        }, null, null, 16, 0, null, 55, 5, 7, 78]
      }
    },
    _Base64DecoderSink: {
      "^": "StringConversionSinkBase;_sink,_decoder,$ti",
      add$1: [function(_, string) {
        var buffer;
        H.stringTypeCheck(string);
        if (J.get$isEmpty$asx(string))
          return;
        buffer = J.decode$3$z(this._decoder, string, 0, string.length);
        if (buffer != null)
          J.add$1$ax(this._sink, buffer);
      }, "call$1", "get$add", 5, 0, 2, 30],
      close$0: [function(_) {
        J.close$2$z(this._decoder, null, null);
        J.close$0$z(this._sink);
      }, "call$0", "get$close", 1, 0, 0],
      addSlice$4: [function(string, start, end, isLast) {
        var t1, t2, buffer;
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        end = P.RangeError_checkValidRange(start, end, string.length, null, null, null);
        if (start == end)
          return;
        t1 = this._decoder;
        t2 = J.getInterceptor$z(t1);
        buffer = t2.decode$3(t1, string, start, end);
        if (buffer != null)
          J.add$1$ax(this._sink, buffer);
        if (isLast) {
          t2.close$2(t1, string, end);
          J.close$0$z(this._sink);
        }
      }, null, "get$addSlice", 16, 0, null, 30, 5, 7, 53],
      static: {
        _Base64DecoderSink$: [function(_sink) {
          return new P._Base64DecoderSink(_sink, P._Base64Decoder$(), []);
        }, null, null, 4, 0, null, 60]
      }
    },
    ByteConversionSink: {
      "^": "ChunkedConversionSink;$ti",
      $asChunkedConversionSink: function() {
        return [[P.List, P.int]];
      },
      $asSink: function() {
        return [[P.List, P.int]];
      }
    },
    ByteConversionSinkBase: {
      "^": "ByteConversionSink;$ti",
      addSlice$4: [function(chunk, start, end, isLast) {
        H.assertSubtype(chunk, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        this.add$1(0, J.sublist$2$ax(chunk, start, end));
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 116, 5, 7, 53]
    },
    _ByteAdapterSink: {
      "^": "ByteConversionSinkBase;_sink,$ti",
      add$1: [function(_, chunk) {
        J.add$1$ax(this._sink, H.assertSubtype(chunk, "$isList", [P.int], "$asList"));
      }, "call$1", "get$add", 5, 0, 2, 116],
      close$0: [function(_) {
        J.close$0$z(this._sink);
      }, "call$0", "get$close", 1, 0, 0],
      static: {
        _ByteAdapterSink$: [function(_sink) {
          return new P._ByteAdapterSink(_sink, []);
        }, null, null, 4, 0, null, 60]
      }
    },
    _ByteCallbackSink: {
      "^": "ByteConversionSinkBase;_convert$_callback,_buffer,_bufferIndex,$ti",
      set$_buffer: function(_buffer) {
        this._buffer = H.assertSubtype(_buffer, "$isList", [P.int], "$asList");
      },
      add$1: [function(_, chunk) {
        var freeCount, t1, oldLength, grown, t2, t3;
        H.assertSubtype(chunk, "$isIterable", [P.int], "$asIterable");
        freeCount = J.$sub$n(J.get$length$asx(this._buffer), this._bufferIndex);
        t1 = J.getInterceptor$asx(chunk);
        if (J.$gt$n(t1.get$length(chunk), freeCount)) {
          oldLength = J.get$length$asx(this._buffer);
          grown = H.NativeUint8List_NativeUint8List(J.$mul$ns(P._ByteCallbackSink__roundToPowerOf2(J.$add$ansx(t1.get$length(chunk), oldLength)), 2));
          J.setRange$3$ax(grown, 0, J.get$length$asx(this._buffer), this._buffer);
          this.set$_buffer(grown);
        }
        t2 = this._buffer;
        t3 = this._bufferIndex;
        J.setRange$3$ax(t2, t3, J.$add$ansx(t3, t1.get$length(chunk)), chunk);
        this._bufferIndex = H.intTypeCheck(J.$add$ansx(this._bufferIndex, t1.get$length(chunk)));
      }, "call$1", "get$add", 5, 0, 2, 116],
      close$0: [function(_) {
        this._convert$_callback.call$1(J.sublist$2$ax(this._buffer, 0, this._bufferIndex));
      }, "call$0", "get$close", 1, 0, 0],
      static: {
        _ByteCallbackSink$: [function(callback) {
          return new P._ByteCallbackSink(callback, H.NativeUint8List_NativeUint8List(1024), 0, []);
        }, null, null, 4, 0, null, 43],
        _ByteCallbackSink__roundToPowerOf2: [function(v) {
          H.intTypeCheck(v);
          if (typeof v !== "number")
            return v.$sub();
          --v;
          v |= C.JSInt_methods._shrOtherPositive$1(v, 1);
          v |= v >>> 2;
          v |= v >>> 4;
          v |= v >>> 8;
          return ((v | v >>> 16) >>> 0) + 1;
        }, null, null, 4, 0, null, 112]
      }
    },
    ChunkedConversionSink: {
      "^": "Object;$ti",
      $isSink: 1
    },
    _SimpleCallbackSink: {
      "^": "ChunkedConversionSink;$ti"
    },
    _ConverterStreamEventSink: {
      "^": "Object;_eventSink,_chunkedSink,$ti",
      add$1: [function(_, o) {
        J.add$1$ax(this._chunkedSink, H.assertSubtypeOfRuntimeType(o, H.getTypeArgumentByIndex(this, 0)));
      }, "call$1", "get$add", 5, 0, 2, 25],
      addError$2: [function(error, stackTrace) {
        this._eventSink.addError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 4, 2, 5, 0, 14, 20],
      close$0: [function(_) {
        J.close$0$z(this._chunkedSink);
      }, "call$0", "get$close", 1, 0, 0],
      $isEventSink: 1,
      $asEventSink: function($S, $T) {
        return [$S];
      },
      $isSink: 1,
      $asSink: function($S, $T) {
        return [$S];
      },
      static: {
        _ConverterStreamEventSink$: [function(converter, sink, $S, $T) {
          return new P._ConverterStreamEventSink(sink, converter.startChunkedConversion$1(sink), [$S, $T]);
        }, null, null, 8, 0, null, 598, 48]
      }
    },
    Codec: {
      "^": "Object;$ti",
      encode$1: [function(input) {
        H.assertSubtypeOfRuntimeType(input, H.getRuntimeTypeArgument(this, "Codec", 0));
        return this.get$encoder().convert$1(input);
      }, null, "get$encode", 4, 0, null, 55],
      decode$1: [function(_, encoded) {
        H.assertSubtypeOfRuntimeType(encoded, H.getRuntimeTypeArgument(this, "Codec", 1));
        return this.get$decoder().convert$1(encoded);
      }, null, "get$decode", 5, 0, null, 350]
    },
    _FusedCodec: {
      "^": "Codec;$ti",
      $asCodec: function($S, $M, $T) {
        return [$S, $T];
      }
    },
    _InvertedCodec: {
      "^": "Codec;$ti"
    },
    Converter: {
      "^": "StreamTransformerBase;$ti",
      startChunkedConversion$1: ["super$Converter$startChunkedConversion", function(sink) {
        H.assertSubtype(sink, "$isSink", [H.getRuntimeTypeArgument(this, "Converter", 1)], "$asSink");
        throw H.wrapException(P.UnsupportedError$("This converter does not support chunked conversions: " + H.S(this)));
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      bind$1: ["super$Converter$bind", function(stream) {
        return P.Stream_Stream$eventTransformed(H.assertSubtype(stream, "$isStream", [H.getRuntimeTypeArgument(this, "Converter", 0)], "$asStream"), new P.Converter_bind_closure(this), H.getRuntimeTypeArgument(this, "Converter", 1));
      }, null, "get$bind", 4, 0, null, 57]
    },
    Converter_bind_closure: {
      "^": "Closure:132;$this,$ti",
      call$1: [function(sink) {
        return P._ConverterStreamEventSink$(this.$this, H.interceptedTypeCheck(sink, "$isEventSink"), null, null);
      }, null, null, 4, 0, null, 48, "call"]
    },
    _FusedConverter: {
      "^": "Converter;$ti",
      $asStreamTransformer: function($S, $M, $T) {
        return [$S, $T];
      },
      $asStreamTransformerBase: function($S, $M, $T) {
        return [$S, $T];
      },
      $asConverter: function($S, $M, $T) {
        return [$S, $T];
      }
    },
    Encoding: {
      "^": "Codec;$ti",
      $asCodec: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    HtmlEscapeMode: {
      "^": "Object;_convert$_name,escapeLtGt<,escapeQuot<,escapeApos<,escapeSlash<,$ti",
      toString$0: [function(_) {
        return this._convert$_name;
      }, null, "get$toString", 1, 0, null]
    },
    HtmlEscape: {
      "^": "Converter;mode,$ti",
      convert$1: [function(text) {
        var val;
        H.stringTypeCheck(text);
        val = this._convert$3(text, 0, text.length);
        return val == null ? text : val;
      }, null, "get$convert", 4, 0, null, 17],
      _convert$3: [function(text, start, end) {
        var t1, i, result, replacement;
        H.stringTypeCheck(text);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = this.mode;
        i = start;
        result = null;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          if (i < 0 || i >= text.length)
            return H.ioore(text, i);
          switch (text[i]) {
            case "&":
              replacement = "&amp;";
              break;
            case '"':
              replacement = t1.get$escapeQuot() ? "&quot;" : null;
              break;
            case "'":
              replacement = t1.get$escapeApos() ? "&#39;" : null;
              break;
            case "<":
              replacement = t1.get$escapeLtGt() ? "&lt;" : null;
              break;
            case ">":
              replacement = t1.get$escapeLtGt() ? "&gt;" : null;
              break;
            case "/":
              replacement = t1.get$escapeSlash() ? "&#47;" : null;
              break;
            default:
              replacement = null;
          }
          if (replacement != null) {
            if (result == null)
              result = P.StringBuffer$("");
            if (typeof start !== "number")
              return H.iae(start);
            if (i > start)
              result.write$1(C.JSString_methods.substring$2(text, start, i));
            result.write$1(replacement);
            start = i + 1;
          }
          ++i;
        }
        if (result == null)
          return;
        if (typeof start !== "number")
          return H.iae(start);
        if (end > start)
          result.write$1(J.substring$2$s(text, start, end));
        return result.toString$0(0);
      }, null, "get$_convert", 12, 0, null, 17, 5, 7],
      startChunkedConversion$1: [function(sink) {
        H.assertSubtype(sink, "$isSink", [P.String], "$asSink");
        return P._HtmlEscapeSink$(this, !J.getInterceptor$(sink).$isStringConversionSink ? P._StringAdapterSink$(sink) : sink);
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      $asStreamTransformer: function() {
        return [P.String, P.String];
      },
      $asStreamTransformerBase: function() {
        return [P.String, P.String];
      },
      $asConverter: function() {
        return [P.String, P.String];
      }
    },
    _HtmlEscapeSink: {
      "^": "StringConversionSinkBase;_escape,_sink,$ti",
      addSlice$4: [function(chunk, start, end, isLast) {
        var val, t1, t2;
        H.stringTypeCheck(chunk);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        val = this._escape._convert$3(chunk, start, end);
        t1 = this._sink;
        if (val == null)
          t1.addSlice$4(chunk, start, end, isLast);
        else {
          t2 = J.getInterceptor$ax(t1);
          t2.add$1(t1, val);
          if (isLast)
            t2.close$0(t1);
        }
      }, null, "get$addSlice", 16, 0, null, 116, 5, 7, 53],
      close$0: [function(_) {
        J.close$0$z(this._sink);
      }, "call$0", "get$close", 1, 0, 0],
      static: {
        _HtmlEscapeSink$: [function(_escape, _sink) {
          return new P._HtmlEscapeSink(_escape, _sink, []);
        }, null, null, 8, 0, null, 601, 60]
      }
    },
    JsonUnsupportedObjectError: {
      "^": "Error;unsupportedObject,cause,partialResult,$ti",
      toString$0: [function(_) {
        var safeString = P.Error_safeToString(this.unsupportedObject);
        return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + H.S(safeString);
      }, null, "get$toString", 1, 0, null],
      static: {
        JsonUnsupportedObjectError$: [function(unsupportedObject, cause, partialResult) {
          return new P.JsonUnsupportedObjectError(unsupportedObject, cause, partialResult, []);
        }, null, null, 4, 5, null, 0, 0, 606, 607, 631]
      }
    },
    JsonCyclicError: {
      "^": "JsonUnsupportedObjectError;unsupportedObject,cause,partialResult,$ti",
      toString$0: [function(_) {
        return "Cyclic error in JSON stringify";
      }, null, "get$toString", 1, 0, null],
      static: {
        JsonCyclicError$: [function(object) {
          return new P.JsonCyclicError(object, null, null, []);
        }, null, null, 4, 0, null, 9]
      }
    },
    JsonCodec: {
      "^": "Codec;_reviver,_toEncodable,$ti",
      decode$2$reviver: [function(_, source, reviver) {
        H.stringTypeCheck(source);
        H.functionTypeCheck(reviver, {func: 1, args: [P.Object, P.Object]});
        if (reviver == null)
          reviver = this._reviver;
        if (reviver == null)
          return this.get$decoder().convert$1(source);
        return P.JsonDecoder$(reviver).convert$1(source);
      }, function($receiver, source) {
        return this.decode$2$reviver($receiver, source, null);
      }, "decode$1", null, null, "get$decode", 5, 3, null, 0, 11, 183],
      encode$2$toEncodable: [function(value, toEncodable) {
        H.functionTypeCheck(toEncodable, {func: 1, args: [,]});
        if (toEncodable == null)
          toEncodable = this._toEncodable;
        if (toEncodable == null)
          return this.get$encoder().convert$1(value);
        return P.JsonEncoder$(toEncodable).convert$1(value);
      }, function(value) {
        return this.encode$2$toEncodable(value, null);
      }, "encode$1", null, null, "get$encode", 4, 3, null, 0, 1, 114],
      get$encoder: [function() {
        var t1 = this._toEncodable;
        if (t1 == null)
          return C.JsonEncoder_null_null;
        return P.JsonEncoder$(t1);
      }, null, null, 2, 0, null],
      get$decoder: [function() {
        var t1 = this._reviver;
        if (t1 == null)
          return C.JsonDecoder_null;
        return P.JsonDecoder$(t1);
      }, null, null, 2, 0, null],
      $asCodec: function() {
        return [P.Object, P.String];
      }
    },
    JsonEncoder: {
      "^": "Converter;indent,_toEncodable,$ti",
      convert$1: [function(object) {
        return P._JsonStringStringifier_stringify(object, this._toEncodable, this.indent);
      }, null, "get$convert", 4, 0, null, 9],
      startChunkedConversion$1: [function(sink) {
        H.assertSubtype(sink, "$isSink", [P.String], "$asSink");
        if (!J.getInterceptor$(sink).$isStringConversionSink)
          sink = P._StringAdapterSink$(sink);
        else if (!!sink.$is_Utf8EncoderSink)
          return P._JsonUtf8EncoderSink$(sink._sink, this._toEncodable, P.JsonUtf8Encoder__utf8Encode(this.indent), 256);
        return P._JsonEncoderSink$(sink, this._toEncodable, this.indent);
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      bind$1: [function(stream) {
        return this.super$Converter$bind(H.assertSubtype(stream, "$isStream", [P.Object], "$asStream"));
      }, null, "get$bind", 4, 0, null, 57],
      $asStreamTransformer: function() {
        return [P.Object, P.String];
      },
      $asStreamTransformerBase: function() {
        return [P.Object, P.String];
      },
      $asConverter: function() {
        return [P.Object, P.String];
      },
      static: {
        JsonEncoder$: [function(toEncodable) {
          return new P.JsonEncoder(null, toEncodable, []);
        }, null, null, 0, 2, null, 0, 114]
      }
    },
    JsonUtf8Encoder: {
      "^": "Converter;$ti",
      $asStreamTransformer: function() {
        return [P.Object, [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [P.Object, [P.List, P.int]];
      },
      $asConverter: function() {
        return [P.Object, [P.List, P.int]];
      }
    },
    _JsonEncoderSink: {
      "^": "ChunkedConversionSink;_indent,_toEncodable,_sink,_isDone,$ti",
      add$1: [function(_, o) {
        var stringSink;
        if (this._isDone)
          throw H.wrapException(P.StateError$("Only one call to add allowed"));
        this._isDone = true;
        stringSink = this._sink.asStringSink$0();
        P._JsonStringStringifier_printOn(o, stringSink, this._toEncodable, this._indent);
        stringSink.close$0(0);
      }, "call$1", "get$add", 5, 0, 2, 25],
      close$0: [function(_) {
      }, "call$0", "get$close", 1, 0, 0],
      $asChunkedConversionSink: function() {
        return [P.Object];
      },
      $asSink: function() {
        return [P.Object];
      },
      static: {
        _JsonEncoderSink$: [function(_sink, _toEncodable, _indent) {
          return new P._JsonEncoderSink(_indent, _toEncodable, _sink, false, []);
        }, null, null, 12, 0, null, 60, 308, 313]
      }
    },
    _JsonUtf8EncoderSink: {
      "^": "ChunkedConversionSink;_sink,_indent,_toEncodable,_bufferSize,_isDone,$ti",
      _addChunk$3: [function(chunk, start, end) {
        this._sink.addSlice$4(H.interceptedTypeCheck(chunk, "$isUint8List"), H.intTypeCheck(start), H.intTypeCheck(end), false);
      }, "call$3", "get$_addChunk", 12, 0, 136, 116, 5, 7],
      add$1: [function(_, object) {
        if (this._isDone)
          throw H.wrapException(P.StateError$("Only one call to add allowed"));
        this._isDone = true;
        P._JsonUtf8Stringifier_stringify(object, this._indent, this._toEncodable, this._bufferSize, this.get$_addChunk());
        J.close$0$z(this._sink);
      }, "call$1", "get$add", 5, 0, 2, 9],
      close$0: [function(_) {
        if (!this._isDone) {
          this._isDone = true;
          J.close$0$z(this._sink);
        }
      }, "call$0", "get$close", 1, 0, 0],
      $asChunkedConversionSink: function() {
        return [P.Object];
      },
      $asSink: function() {
        return [P.Object];
      },
      static: {
        _JsonUtf8EncoderSink$: [function(_sink, _toEncodable, _indent, _bufferSize) {
          return new P._JsonUtf8EncoderSink(_sink, _indent, _toEncodable, _bufferSize, false, []);
        }, null, null, 16, 0, null, 60, 308, 313, 660]
      }
    },
    JsonDecoder: {
      "^": "Converter;_reviver,$ti",
      startChunkedConversion$1: [function(sink) {
        return P._JsonDecoderSink$(this._reviver, H.assertSubtype(sink, "$isSink", [P.Object], "$asSink"));
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      convert$1: [function(input) {
        return P._parseJson(H.stringTypeCheck(input), this._reviver);
      }, null, "get$convert", 4, 0, null, 55],
      bind$1: [function(stream) {
        return this.super$Converter$bind(H.assertSubtype(stream, "$isStream", [P.String], "$asStream"));
      }, null, "get$bind", 4, 0, null, 57],
      $asStreamTransformer: function() {
        return [P.String, P.Object];
      },
      $asStreamTransformerBase: function() {
        return [P.String, P.Object];
      },
      $asConverter: function() {
        return [P.String, P.Object];
      },
      static: {
        JsonDecoder$: [function(reviver) {
          return new P.JsonDecoder(reviver, []);
        }, null, null, 0, 2, null, 0, 183]
      }
    },
    _JsonStringifier: {
      "^": "Object;$ti",
      writeStringContent$1: [function(s) {
        var $length, t1, offset, i, charCode;
        H.stringTypeCheck(s);
        $length = s.length;
        for (t1 = J.getInterceptor$s(s), offset = 0, i = 0; i < $length; ++i) {
          charCode = t1._codeUnitAt$1(s, i);
          if (typeof charCode !== "number")
            return charCode.$gt();
          if (charCode > 92)
            continue;
          if (charCode < 32) {
            if (i > offset)
              this.writeStringSlice$3(s, offset, i);
            offset = i + 1;
            this.writeCharCode$1(92);
            switch (charCode) {
              case 8:
                this.writeCharCode$1(98);
                break;
              case 9:
                this.writeCharCode$1(116);
                break;
              case 10:
                this.writeCharCode$1(110);
                break;
              case 12:
                this.writeCharCode$1(102);
                break;
              case 13:
                this.writeCharCode$1(114);
                break;
              default:
                this.writeCharCode$1(117);
                this.writeCharCode$1(48);
                this.writeCharCode$1(48);
                this.writeCharCode$1(P._JsonStringifier_hexDigit(C.JSInt_methods._shrOtherPositive$1(charCode, 4) & 15));
                this.writeCharCode$1(P._JsonStringifier_hexDigit(charCode & 15));
                break;
            }
          } else if (charCode === 34 || charCode === 92) {
            if (i > offset)
              this.writeStringSlice$3(s, offset, i);
            offset = i + 1;
            this.writeCharCode$1(92);
            this.writeCharCode$1(charCode);
          }
        }
        if (offset === 0)
          this.writeString$1(s);
        else if (offset < $length)
          this.writeStringSlice$3(s, offset, $length);
      }, null, "get$writeStringContent", 4, 0, null, 50],
      _checkCycle$1: [function(object) {
        var t1, t2, i, t3;
        t1 = this._seen;
        t2 = J.getInterceptor$asx(t1);
        i = 0;
        while (true) {
          t3 = t2.get$length(t1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          t3 = t2.$index(t1, i);
          if (object == null ? t3 == null : object === t3)
            throw H.wrapException(P.JsonCyclicError$(object));
          ++i;
        }
        t2.add$1(t1, object);
      }, null, "get$_checkCycle", 4, 0, null, 9],
      _removeSeen$1: [function(object) {
        J.removeLast$0$ax(this._seen);
      }, null, "get$_removeSeen", 4, 0, null, 9],
      writeObject$1: [function(object) {
        var customJson, e, t1, exception;
        if (this.writeJsonValue$1(object))
          return;
        this._checkCycle$1(object);
        try {
          customJson = this._toEncodable.call$1(object);
          if (!this.writeJsonValue$1(customJson)) {
            t1 = P.JsonUnsupportedObjectError$(object, null, this.get$_partialResult());
            throw H.wrapException(t1);
          }
          this._removeSeen$1(object);
        } catch (exception) {
          e = H.unwrapException(exception);
          t1 = P.JsonUnsupportedObjectError$(object, e, this.get$_partialResult());
          throw H.wrapException(t1);
        }
      }, null, "get$writeObject", 4, 0, null, 9],
      writeJsonValue$1: [function(object) {
        var t1, success;
        if (typeof object === "number") {
          if (!C.JSNumber_methods.get$isFinite(object))
            return false;
          this.writeNumber$1(object);
          return true;
        } else if (object === true) {
          this.writeString$1("true");
          return true;
        } else if (object === false) {
          this.writeString$1("false");
          return true;
        } else if (object == null) {
          this.writeString$1("null");
          return true;
        } else if (typeof object === "string") {
          this.writeString$1('"');
          this.writeStringContent$1(object);
          this.writeString$1('"');
          return true;
        } else {
          t1 = J.getInterceptor$(object);
          if (!!t1.$isList) {
            this._checkCycle$1(object);
            this.writeList$1(object);
            this._removeSeen$1(object);
            return true;
          } else if (!!t1.$isMap) {
            this._checkCycle$1(object);
            success = this.writeMap$1(object);
            this._removeSeen$1(object);
            return success;
          } else
            return false;
        }
      }, null, "get$writeJsonValue", 4, 0, null, 9],
      writeList$1: [function(list) {
        var t1, i, t2;
        H.listTypeCheck(list);
        this.writeString$1("[");
        t1 = J.getInterceptor$asx(list);
        if (J.$gt$n(t1.get$length(list), 0)) {
          this.writeObject$1(t1.$index(list, 0));
          i = 1;
          while (true) {
            t2 = t1.get$length(list);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            this.writeString$1(",");
            this.writeObject$1(t1.$index(list, i));
            ++i;
          }
        }
        this.writeString$1("]");
      }, null, "get$writeList", 4, 0, null, 68],
      writeMap$1: [function(map) {
        var _box_0, t1, keyValueList, separator, i, t2;
        _box_0 = {};
        H.interceptedTypeCheck(map, "$isMap");
        if (map.get$isEmpty(map)) {
          this.writeString$1("{}");
          return true;
        }
        t1 = J.$mul$ns(map.get$length(map), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        keyValueList = new Array(t1);
        keyValueList.fixed$length = Array;
        _box_0.i = 0;
        _box_0.allStringKeys = true;
        map.forEach$1(0, new P._JsonStringifier_writeMap_closure(_box_0, keyValueList));
        if (!_box_0.allStringKeys)
          return false;
        this.writeString$1("{");
        for (t1 = keyValueList.length, separator = '"', i = 0; i < t1; i += 2, separator = ',"') {
          this.writeString$1(separator);
          this.writeStringContent$1(H.stringTypeCheck(keyValueList[i]));
          this.writeString$1('":');
          t2 = i + 1;
          if (t2 >= t1)
            return H.ioore(keyValueList, t2);
          this.writeObject$1(keyValueList[t2]);
        }
        this.writeString$1("}");
        return true;
      }, null, "get$writeMap", 4, 0, null, 111]
    },
    _JsonStringifier_writeMap_closure: {
      "^": "Closure:9;_box_0,keyValueList,$ti",
      call$2: [function(key, value) {
        var t1, t2, t3, t4;
        if (typeof key !== "string")
          this._box_0.allStringKeys = false;
        t1 = this.keyValueList;
        t2 = this._box_0;
        t3 = t2.i;
        t2.i = J.$add$ansx(t3, 1);
        t4 = J.getInterceptor$ax(t1);
        t4.$indexSet(t1, t3, key);
        t3 = t2.i;
        t2.i = J.$add$ansx(t3, 1);
        t4.$indexSet(t1, t3, value);
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    _JsonPrettyPrintMixin: {
      "^": "Object;$ti",
      writeList$1: [function(list) {
        var t1, t2, i;
        H.listTypeCheck(list);
        t1 = J.getInterceptor$asx(list);
        if (t1.get$isEmpty(list))
          this.writeString$1("[]");
        else {
          this.writeString$1("[\n");
          t2 = H.intTypeCheck(J.$add$ansx(this._JsonPrettyPrintMixin__indentLevel, 1));
          this._JsonPrettyPrintMixin__indentLevel = t2;
          this.writeIndentation$1(t2);
          this.writeObject$1(t1.$index(list, 0));
          i = 1;
          while (true) {
            t2 = t1.get$length(list);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            this.writeString$1(",\n");
            this.writeIndentation$1(this._JsonPrettyPrintMixin__indentLevel);
            this.writeObject$1(t1.$index(list, i));
            ++i;
          }
          this.writeString$1("\n");
          t1 = H.intTypeCheck(J.$sub$n(this._JsonPrettyPrintMixin__indentLevel, 1));
          this._JsonPrettyPrintMixin__indentLevel = t1;
          this.writeIndentation$1(t1);
          this.writeString$1("]");
        }
      }, null, "get$writeList", 4, 0, null, 68],
      writeMap$1: [function(map) {
        var _box_0, t1, keyValueList, separator, i, t2;
        _box_0 = {};
        H.interceptedTypeCheck(map, "$isMap");
        if (map.get$isEmpty(map)) {
          this.writeString$1("{}");
          return true;
        }
        t1 = J.$mul$ns(map.get$length(map), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        keyValueList = new Array(t1);
        keyValueList.fixed$length = Array;
        _box_0.i = 0;
        _box_0.allStringKeys = true;
        map.forEach$1(0, new P._JsonPrettyPrintMixin_writeMap_closure(_box_0, keyValueList));
        if (!_box_0.allStringKeys)
          return false;
        this.writeString$1("{\n");
        this._JsonPrettyPrintMixin__indentLevel = H.intTypeCheck(J.$add$ansx(this._JsonPrettyPrintMixin__indentLevel, 1));
        for (t1 = keyValueList.length, separator = "", i = 0; i < t1; i += 2, separator = ",\n") {
          this.writeString$1(separator);
          this.writeIndentation$1(this._JsonPrettyPrintMixin__indentLevel);
          this.writeString$1('"');
          this.writeStringContent$1(H.stringTypeCheck(keyValueList[i]));
          this.writeString$1('": ');
          t2 = i + 1;
          if (t2 >= t1)
            return H.ioore(keyValueList, t2);
          this.writeObject$1(keyValueList[t2]);
        }
        this.writeString$1("\n");
        t1 = H.intTypeCheck(J.$sub$n(this._JsonPrettyPrintMixin__indentLevel, 1));
        this._JsonPrettyPrintMixin__indentLevel = t1;
        this.writeIndentation$1(t1);
        this.writeString$1("}");
        return true;
      }, null, "get$writeMap", 4, 0, null, 111],
      $is_JsonStringifier: 1
    },
    _JsonPrettyPrintMixin_writeMap_closure: {
      "^": "Closure:9;_box_0,keyValueList,$ti",
      call$2: [function(key, value) {
        var t1, t2, t3, t4;
        if (typeof key !== "string")
          this._box_0.allStringKeys = false;
        t1 = this.keyValueList;
        t2 = this._box_0;
        t3 = t2.i;
        t2.i = J.$add$ansx(t3, 1);
        t4 = J.getInterceptor$ax(t1);
        t4.$indexSet(t1, t3, key);
        t3 = t2.i;
        t2.i = J.$add$ansx(t3, 1);
        t4.$indexSet(t1, t3, value);
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    _JsonStringStringifier: {
      "^": "_JsonStringifier;_sink,_seen,_toEncodable,$ti",
      get$_partialResult: [function() {
        var t1 = this._sink;
        return t1 instanceof P.StringBuffer ? t1.toString$0(0) : null;
      }, null, null, 2, 0, null],
      writeNumber$1: [function(number) {
        this._sink.write$1(J.toString$0$(H.numTypeCheck(number)));
      }, null, "get$writeNumber", 4, 0, null, 84],
      writeString$1: [function(string) {
        this._sink.write$1(H.stringTypeCheck(string));
      }, null, "get$writeString", 4, 0, null, 30],
      writeStringSlice$3: [function(string, start, end) {
        this._sink.write$1(J.substring$2$s(H.stringTypeCheck(string), H.intTypeCheck(start), H.intTypeCheck(end)));
      }, null, "get$writeStringSlice", 12, 0, null, 30, 5, 7],
      writeCharCode$1: [function(charCode) {
        this._sink.writeCharCode$1(H.intTypeCheck(charCode));
      }, null, "get$writeCharCode", 4, 0, null, 93],
      static: {
        _JsonStringStringifier$: [function(_sink, _toEncodable) {
          var t1;
          H.functionTypeCheck(_toEncodable, {func: 1, args: [,]});
          t1 = _toEncodable == null ? P.convert___defaultToEncodable$closure() : _toEncodable;
          return new P._JsonStringStringifier(_sink, [], t1, []);
        }, null, null, 8, 0, null, 60, 308],
        _JsonStringStringifier_stringify: [function(object, toEncodable, indent) {
          var output;
          H.functionTypeCheck(toEncodable, {func: 1, args: [,]});
          H.stringTypeCheck(indent);
          output = P.StringBuffer$("");
          P._JsonStringStringifier_printOn(object, output, toEncodable, indent);
          return output.toString$0(0);
        }, null, null, 12, 0, null, 9, 114, 195],
        _JsonStringStringifier_printOn: [function(object, output, toEncodable, indent) {
          H.interceptedTypeCheck(output, "$isStringSink");
          H.functionTypeCheck(toEncodable, {func: 1, args: [,]});
          H.stringTypeCheck(indent);
          (indent == null ? P._JsonStringStringifier$(output, toEncodable) : P._JsonStringStringifierPretty$(output, toEncodable, indent)).writeObject$1(object);
        }, null, null, 16, 0, null, 9, 246, 114, 195]
      }
    },
    _JsonStringStringifierPretty: {
      "^": "__JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin;_indent,_JsonPrettyPrintMixin__indentLevel,_sink,_seen,_toEncodable,$ti",
      writeIndentation$1: [function(count) {
        var t1, i;
        H.intTypeCheck(count);
        if (typeof count !== "number")
          return H.iae(count);
        t1 = this._indent;
        i = 0;
        for (; i < count; ++i)
          this.writeString$1(t1);
      }, null, "get$writeIndentation", 4, 0, null, 42],
      $is_JsonPrettyPrintMixin: 1,
      static: {
        _JsonStringStringifierPretty$: [function(sink, toEncodable, _indent) {
          var t1;
          H.functionTypeCheck(toEncodable, {func: 1, args: [,]});
          t1 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonStringStringifierPretty(_indent, 0, sink, [], t1, []);
        }, null, null, 12, 0, null, 48, 114, 313]
      }
    },
    _JsonUtf8Stringifier: {
      "^": "_JsonStringifier;bufferSize,addChunk,buffer>,index>,_seen,_toEncodable,$ti",
      set$buffer: function(_, buffer) {
        this.buffer = H.interceptedTypeCheck(buffer, "$isUint8List");
      },
      flush$0: [function() {
        if (J.$gt$n(this.index, 0))
          this.addChunk.call$3(this.buffer, 0, this.index);
        this.buffer = null;
        this.index = 0;
      }, null, "get$flush", 0, 0, null],
      get$_partialResult: [function() {
        return;
      }, null, null, 2, 0, null],
      writeNumber$1: [function(number) {
        this.writeAsciiString$1(J.toString$0$(H.numTypeCheck(number)));
      }, null, "get$writeNumber", 4, 0, null, 84],
      writeAsciiString$1: [function(string) {
        var t1, i;
        H.stringTypeCheck(string);
        for (t1 = string.length, i = 0; i < t1; ++i)
          this.writeByte$1(C.JSString_methods._codeUnitAt$1(string, i));
      }, null, "get$writeAsciiString", 4, 0, null, 30],
      writeString$1: [function(string) {
        H.stringTypeCheck(string);
        this.writeStringSlice$3(string, 0, string.length);
      }, null, "get$writeString", 4, 0, null, 30],
      writeStringSlice$3: [function(string, start, end) {
        var t1, i, char, i0, nextChar;
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = J.getInterceptor$s(string);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          c$0: {
            char = t1.codeUnitAt$1(string, i);
            if (typeof char !== "number")
              return char.$le();
            if (char <= 127)
              this.writeByte$1(char);
            else {
              if ((char & 64512) === 55296 && i + 1 < end) {
                i0 = i + 1;
                nextChar = C.JSString_methods.codeUnitAt$1(string, i0);
                if (typeof nextChar !== "number")
                  return nextChar.$and();
                if ((nextChar & 64512) === 56320) {
                  this.writeFourByteCharCode$1(65536 + ((char & 1023) << 10) + (nextChar & 1023));
                  i = i0;
                  break c$0;
                }
              }
              this.writeMultiByteCharCode$1(char);
            }
          }
          ++i;
        }
      }, null, "get$writeStringSlice", 12, 0, null, 30, 5, 7],
      writeCharCode$1: [function(charCode) {
        H.intTypeCheck(charCode);
        if (typeof charCode !== "number")
          return charCode.$le();
        if (charCode <= 127) {
          this.writeByte$1(charCode);
          return;
        }
        this.writeMultiByteCharCode$1(charCode);
      }, null, "get$writeCharCode", 4, 0, null, 93],
      writeMultiByteCharCode$1: [function(charCode) {
        H.intTypeCheck(charCode);
        if (typeof charCode !== "number")
          return charCode.$le();
        if (charCode <= 2047) {
          this.writeByte$1((192 | C.JSInt_methods._shrOtherPositive$1(charCode, 6)) >>> 0);
          this.writeByte$1(128 | charCode & 63);
          return;
        }
        if (charCode <= 65535) {
          this.writeByte$1((224 | C.JSInt_methods._shrOtherPositive$1(charCode, 12)) >>> 0);
          this.writeByte$1(128 | C.JSInt_methods._shrOtherPositive$1(charCode, 6) & 63);
          this.writeByte$1(128 | charCode & 63);
          return;
        }
        this.writeFourByteCharCode$1(charCode);
      }, null, "get$writeMultiByteCharCode", 4, 0, null, 93],
      writeFourByteCharCode$1: [function(charCode) {
        H.intTypeCheck(charCode);
        if (typeof charCode !== "number")
          return charCode.$shr();
        this.writeByte$1((240 | C.JSInt_methods._shrOtherPositive$1(charCode, 18)) >>> 0);
        this.writeByte$1(128 | C.JSInt_methods._shrOtherPositive$1(charCode, 12) & 63);
        this.writeByte$1(128 | C.JSInt_methods._shrOtherPositive$1(charCode, 6) & 63);
        this.writeByte$1(128 | charCode & 63);
      }, null, "get$writeFourByteCharCode", 4, 0, null, 93],
      writeByte$1: [function(byte) {
        var t1, t2;
        H.intTypeCheck(byte);
        if (J.$eq$(this.index, J.get$length$asx(this.buffer))) {
          this.addChunk.call$3(this.buffer, 0, this.index);
          this.buffer = H.interceptedTypeCheck(H.NativeUint8List_NativeUint8List(this.bufferSize), "$isUint8List");
          this.index = 0;
        }
        t1 = this.buffer;
        t2 = this.index;
        this.index = H.intTypeCheck(J.$add$ansx(t2, 1));
        J.$indexSet$ax(t1, t2, byte);
      }, null, "get$writeByte", 4, 0, null, 869],
      static: {
        _JsonUtf8Stringifier$: [function(toEncodable, bufferSize, addChunk) {
          var t1, t2;
          t1 = H.NativeUint8List_NativeUint8List(bufferSize);
          t2 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonUtf8Stringifier(bufferSize, addChunk, t1, 0, [], t2, []);
        }, null, null, 12, 0, null, 114, 242, 314],
        _JsonUtf8Stringifier_stringify: [function(object, indent, toEncodable, bufferSize, addChunk) {
          var stringifier;
          H.assertSubtype(indent, "$isList", [P.int], "$asList");
          H.functionTypeCheck(toEncodable, {func: 1, args: [,]});
          H.intTypeCheck(bufferSize);
          H.functionTypeCheck(addChunk, {func: 1, ret: -1, args: [P.Uint8List, P.int, P.int]});
          stringifier = indent != null ? P._JsonUtf8StringifierPretty$(toEncodable, indent, bufferSize, addChunk) : P._JsonUtf8Stringifier$(toEncodable, bufferSize, addChunk);
          stringifier.writeObject$1(object);
          stringifier.flush$0();
        }, null, null, 20, 0, null, 9, 195, 114, 242, 314]
      }
    },
    _JsonUtf8StringifierPretty: {
      "^": "__JsonUtf8StringifierPretty__JsonUtf8Stringifier__JsonPrettyPrintMixin;indent,_JsonPrettyPrintMixin__indentLevel,bufferSize,addChunk,buffer,index,_seen,_toEncodable,$ti",
      writeIndentation$1: [function(count) {
        var indent, t1, indentLength, char, end, t2, i;
        H.intTypeCheck(count);
        indent = this.indent;
        t1 = J.getInterceptor$asx(indent);
        indentLength = t1.get$length(indent);
        if (indentLength === 1) {
          char = t1.$index(indent, 0);
          while (true) {
            if (typeof count !== "number")
              return count.$gt();
            if (!(count > 0))
              break;
            this.writeByte$1(char);
            --count;
          }
          return;
        }
        while (true) {
          if (typeof count !== "number")
            return count.$gt();
          if (!(count > 0))
            break;
          --count;
          end = J.$add$ansx(this.index, indentLength);
          t2 = J.get$length$asx(this.buffer);
          if (typeof end !== "number")
            return end.$le();
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (end <= t2) {
            J.setRange$3$ax(this.buffer, this.index, end, indent);
            this.index = end;
          } else {
            if (typeof indentLength !== "number")
              return H.iae(indentLength);
            i = 0;
            for (; i < indentLength; ++i)
              this.writeByte$1(t1.$index(indent, i));
          }
        }
      }, null, "get$writeIndentation", 4, 0, null, 42],
      $is_JsonPrettyPrintMixin: 1,
      static: {
        _JsonUtf8StringifierPretty$: [function(toEncodable, indent, bufferSize, addChunk) {
          var t1, t2;
          H.intTypeCheck(bufferSize);
          t1 = H.NativeUint8List_NativeUint8List(bufferSize);
          t2 = toEncodable == null ? P.convert___defaultToEncodable$closure() : toEncodable;
          return new P._JsonUtf8StringifierPretty(indent, 0, bufferSize, addChunk, t1, 0, [], t2, []);
        }, null, null, 16, 0, null, 114, 195, 242, 314]
      }
    },
    Latin1Codec: {
      "^": "Encoding;_allowInvalid,$ti",
      get$name: [function(_) {
        return "iso-8859-1";
      }, null, null, 3, 0, null],
      encode$1: [function(source) {
        H.stringTypeCheck(source);
        return this.get$encoder().convert$1(source);
      }, null, "get$encode", 4, 0, null, 11],
      decode$2$allowInvalid: [function(_, bytes, allowInvalid) {
        H.assertSubtype(bytes, "$isList", [P.int], "$asList");
        H.boolTypeCheck(allowInvalid);
        if (allowInvalid == null ? this._allowInvalid : allowInvalid)
          return C.Latin1Decoder_true_255.convert$1(bytes);
        else
          return C.Latin1Decoder_false_255.convert$1(bytes);
      }, function($receiver, bytes) {
        return this.decode$2$allowInvalid($receiver, bytes, null);
      }, "decode$1", null, null, "get$decode", 5, 3, null, 0, 103, 349],
      get$encoder: [function() {
        return C.Latin1Encoder_255;
      }, null, null, 2, 0, null],
      get$decoder: [function() {
        return this._allowInvalid ? C.Latin1Decoder_true_255 : C.Latin1Decoder_false_255;
      }, null, null, 2, 0, null]
    },
    Latin1Encoder: {
      "^": "_UnicodeSubsetEncoder;_subsetMask,$ti"
    },
    Latin1Decoder: {
      "^": "_UnicodeSubsetDecoder;_allowInvalid,_subsetMask,$ti",
      startChunkedConversion$1: [function(sink) {
        var stringSink;
        H.assertSubtype(sink, "$isSink", [P.String], "$asSink");
        stringSink = !!J.getInterceptor$(sink).$isStringConversionSink ? sink : P._StringAdapterSink$(sink);
        if (!this._allowInvalid)
          return P._Latin1DecoderSink$(stringSink);
        return P._Latin1AllowInvalidDecoderSink$(stringSink);
      }, null, "get$startChunkedConversion", 4, 0, null, 48]
    },
    _Latin1DecoderSink: {
      "^": "ByteConversionSinkBase;_sink,$ti",
      close$0: [function(_) {
        J.close$0$z(this._sink);
        this._sink = null;
      }, "call$0", "get$close", 1, 0, 0],
      add$1: [function(_, source) {
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        this.addSlice$4(source, 0, J.get$length$asx(source), false);
      }, "call$1", "get$add", 5, 0, 2, 11],
      _addSliceToSink$4: [function(source, start, end, isLast) {
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        J.add$1$ax(this._sink, P.String_String$fromCharCodes(source, start, end));
        if (isLast)
          this.close$0(0);
      }, null, "get$_addSliceToSink", 16, 0, null, 11, 5, 7, 53],
      addSlice$4: [function(source, start, end, isLast) {
        var t1;
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        t1 = J.getInterceptor$asx(source);
        end = P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        if (start == end)
          return;
        if (!t1.$isUint8List)
          P._Latin1DecoderSink__checkValidLatin1(source, start, end);
        this._addSliceToSink$4(source, start, end, isLast);
      }, null, "get$addSlice", 16, 0, null, 11, 5, 7, 53],
      static: {
        _Latin1DecoderSink$: [function(_sink) {
          return new P._Latin1DecoderSink(_sink, []);
        }, null, null, 4, 0, null, 60],
        _Latin1DecoderSink__checkValidLatin1: [function(source, start, end) {
          var t1, i, mask, t2;
          H.assertSubtype(source, "$isList", [P.int], "$asList");
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          t1 = J.getInterceptor$asx(source);
          i = start;
          mask = 0;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(i < end))
              break;
            t2 = t1.$index(source, i);
            if (typeof t2 !== "number")
              return H.iae(t2);
            mask = (mask | t2) >>> 0;
            ++i;
          }
          if (mask >= 0 && mask <= 255)
            return;
          P._Latin1DecoderSink__reportInvalidLatin1(source, start, end);
        }, null, null, 12, 0, null, 11, 5, 7],
        _Latin1DecoderSink__reportInvalidLatin1: [function(source, start, end) {
          var t1, i, char;
          H.assertSubtype(source, "$isList", [P.int], "$asList");
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          t1 = J.getInterceptor$asx(source);
          i = start;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(i < end))
              break;
            char = t1.$index(source, i);
            if (typeof char !== "number")
              return char.$lt();
            if (char < 0 || char > 255)
              throw H.wrapException(P.FormatException$("Source contains non-Latin-1 characters.", source, i));
            ++i;
          }
        }, null, null, 12, 0, null, 11, 5, 7]
      }
    },
    _Latin1AllowInvalidDecoderSink: {
      "^": "_Latin1DecoderSink;_sink,$ti",
      addSlice$4: [function(source, start, end, isLast) {
        var t1, i, char;
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        t1 = J.getInterceptor$asx(source);
        P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          char = t1.$index(source, i);
          if (typeof char !== "number")
            return char.$gt();
          if (char > 255 || char < 0) {
            if (typeof start !== "number")
              return H.iae(start);
            if (i > start)
              this._addSliceToSink$4(source, start, i, false);
            this._addSliceToSink$4(C.List_65533, 0, 1, false);
            start = i + 1;
          }
          ++i;
        }
        if (typeof start !== "number")
          return start.$lt();
        if (start < end)
          this._addSliceToSink$4(source, start, end, isLast);
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 11, 5, 7, 53],
      static: {
        _Latin1AllowInvalidDecoderSink$: [function(sink) {
          return new P._Latin1AllowInvalidDecoderSink(sink, []);
        }, null, null, 4, 0, null, 48]
      }
    },
    LineSplitter: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function() {
        return [P.String, P.String];
      },
      $asStreamTransformerBase: function() {
        return [P.String, P.String];
      }
    },
    _LineSplitterSink: {
      "^": "StringConversionSinkBase;$ti"
    },
    _LineSplitterEventSink: {
      "^": "_LineSplitterSink;$ti",
      $isEventSink: 1,
      $asEventSink: function() {
        return [P.String];
      }
    },
    StringConversionSink: {
      "^": "ChunkedConversionSink;$ti",
      $asChunkedConversionSink: function() {
        return [P.String];
      },
      $asSink: function() {
        return [P.String];
      }
    },
    ClosableStringSink: {
      "^": "StringSink;$ti"
    },
    _ClosableStringSink: {
      "^": "Object;_convert$_callback,_sink,$ti",
      close$0: [function(_) {
        this._convert$_callback.call$0();
      }, "call$0", "get$close", 1, 0, 0],
      writeCharCode$1: [function(charCode) {
        this._sink.writeCharCode$1(H.intTypeCheck(charCode));
      }, null, "get$writeCharCode", 4, 0, null, 93],
      write$1: [function(o) {
        this._sink.write$1(o);
      }, null, "get$write", 4, 0, null, 25],
      $isClosableStringSink: 1,
      $isStringSink: 1,
      static: {
        _ClosableStringSink$: [function(_sink, _callback) {
          return new P._ClosableStringSink(_callback, _sink, []);
        }, null, null, 8, 0, null, 60, 696]
      }
    },
    _StringConversionSinkAsStringSinkAdapter: {
      "^": "Object;_buffer,_chunkedSink,$ti",
      close$0: [function(_) {
        if (J.get$isNotEmpty$asx(this._buffer))
          this._flush$0();
        J.close$0$z(this._chunkedSink);
      }, "call$0", "get$close", 1, 0, 0],
      writeCharCode$1: [function(charCode) {
        var t1 = this._buffer;
        t1.writeCharCode$1(H.intTypeCheck(charCode));
        if (J.$gt$n(J.get$length$asx(t1), 16))
          this._flush$0();
      }, null, "get$writeCharCode", 4, 0, null, 93],
      write$1: [function(o) {
        if (J.get$isNotEmpty$asx(this._buffer))
          this._flush$0();
        J.add$1$ax(this._chunkedSink, J.toString$0$(o));
      }, null, "get$write", 4, 0, null, 25],
      _flush$0: [function() {
        var t1, t2, accumulated;
        t1 = this._buffer;
        t2 = J.getInterceptor$(t1);
        accumulated = t2.toString$0(t1);
        t2.clear$0(t1);
        J.add$1$ax(this._chunkedSink, accumulated);
      }, null, "get$_flush", 0, 0, null],
      $isClosableStringSink: 1,
      $isStringSink: 1,
      static: {
        _StringConversionSinkAsStringSinkAdapter$: [function(_chunkedSink) {
          return new P._StringConversionSinkAsStringSinkAdapter(P.StringBuffer$(""), _chunkedSink, []);
        }, null, null, 4, 0, null, 724]
      }
    },
    StringConversionSinkBase: {
      "^": "StringConversionSinkMixin;$ti"
    },
    StringConversionSinkMixin: {
      "^": "Object;$ti",
      add$1: [function(_, str) {
        H.stringTypeCheck(str);
        this.addSlice$4(str, 0, str.length, false);
      }, "call$1", "get$add", 5, 0, 2, 82],
      asUtf8Sink$1: [function(allowMalformed) {
        return P._Utf8ConversionSink$(this, H.boolTypeCheck(allowMalformed));
      }, null, "get$asUtf8Sink", 4, 0, null, 120],
      asStringSink$0: [function() {
        return P._StringConversionSinkAsStringSinkAdapter$(this);
      }, null, "get$asStringSink", 0, 0, null],
      $isChunkedConversionSink: 1,
      $asChunkedConversionSink: function() {
        return [P.String];
      },
      $isStringConversionSink: 1,
      $isSink: 1,
      $asSink: function() {
        return [P.String];
      }
    },
    _StringSinkConversionSink: {
      "^": "StringConversionSinkBase;_stringSink<,$ti",
      close$0: ["super$_StringSinkConversionSink$close", function(_) {
      }, "call$0", "get$close", 1, 0, 0],
      addSlice$4: [function(str, start, end, isLast) {
        var t1, t2, i;
        H.stringTypeCheck(str);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        if (start !== 0 || end !== str.length) {
          t1 = this._stringSink;
          t2 = J.getInterceptor$s(str);
          i = start;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(i < end))
              break;
            t1.writeCharCode$1(t2.codeUnitAt$1(str, i));
            ++i;
          }
        } else
          this._stringSink.write$1(str);
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 82, 5, 7, 53],
      add$1: [function(_, str) {
        this._stringSink.write$1(H.stringTypeCheck(str));
      }, "call$1", "get$add", 5, 0, 2, 82],
      asUtf8Sink$1: [function(allowMalformed) {
        return P._Utf8StringSinkAdapter$(this, this._stringSink, H.boolTypeCheck(allowMalformed));
      }, null, "get$asUtf8Sink", 4, 0, null, 120],
      asStringSink$0: [function() {
        return P._ClosableStringSink$(this._stringSink, this.get$close(this));
      }, null, "get$asStringSink", 0, 0, null]
    },
    _StringCallbackSink: {
      "^": "_StringSinkConversionSink;$ti"
    },
    _StringAdapterSink: {
      "^": "StringConversionSinkBase;_sink,$ti",
      add$1: [function(_, str) {
        J.add$1$ax(this._sink, H.stringTypeCheck(str));
      }, "call$1", "get$add", 5, 0, 2, 82],
      addSlice$4: [function(str, start, end, isLast) {
        H.stringTypeCheck(str);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        if (start === 0 && end === str.length)
          this.add$1(0, str);
        else
          this.add$1(0, J.substring$2$s(str, start, end));
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 82, 5, 7, 53],
      close$0: [function(_) {
        J.close$0$z(this._sink);
      }, "call$0", "get$close", 1, 0, 0],
      static: {
        _StringAdapterSink$: [function(_sink) {
          return new P._StringAdapterSink(_sink, []);
        }, null, null, 4, 0, null, 60]
      }
    },
    _Utf8StringSinkAdapter: {
      "^": "ByteConversionSink;_decoder,_sink,$ti",
      close$0: [function(_) {
        var t1;
        J.close$0$z(this._decoder);
        t1 = this._sink;
        if (t1 != null)
          J.close$0$z(t1);
      }, "call$0", "get$close", 1, 0, 0],
      add$1: [function(_, chunk) {
        H.assertSubtype(chunk, "$isList", [P.int], "$asList");
        this.addSlice$4(chunk, 0, J.get$length$asx(chunk), false);
      }, "call$1", "get$add", 5, 0, 2, 116],
      addSlice$4: [function(codeUnits, startIndex, endIndex, isLast) {
        H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
        H.intTypeCheck(startIndex);
        H.intTypeCheck(endIndex);
        H.boolTypeCheck(isLast);
        this._decoder.convert$3(codeUnits, startIndex, endIndex);
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 113, 76, 249, 53],
      static: {
        _Utf8StringSinkAdapter$: [function(_sink, stringSink, allowMalformed) {
          return new P._Utf8StringSinkAdapter(P._Utf8Decoder$(stringSink, allowMalformed), _sink, []);
        }, null, null, 12, 0, null, 60, 742, 120]
      }
    },
    _Utf8ConversionSink: {
      "^": "ByteConversionSink;_decoder,_chunkedSink,_buffer,$ti",
      close$0: [function(_) {
        var t1, t2, t3, accumulated;
        J.close$0$z(this._decoder);
        t1 = this._buffer;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._chunkedSink;
        if (t2.get$isNotEmpty(t1)) {
          accumulated = t2.toString$0(t1);
          t2.clear$0(t1);
          t3.addSlice$4(accumulated, 0, accumulated.length, true);
        } else
          J.close$0$z(t3);
      }, "call$0", "get$close", 1, 0, 0],
      add$1: [function(_, chunk) {
        H.assertSubtype(chunk, "$isList", [P.int], "$asList");
        this.addSlice$4(chunk, 0, J.get$length$asx(chunk), false);
      }, "call$1", "get$add", 5, 0, 2, 116],
      addSlice$4: [function(chunk, startIndex, endIndex, isLast) {
        var t1, t2, accumulated;
        H.assertSubtype(chunk, "$isList", [P.int], "$asList");
        H.intTypeCheck(startIndex);
        H.intTypeCheck(endIndex);
        H.boolTypeCheck(isLast);
        this._decoder.convert$3(chunk, startIndex, endIndex);
        t1 = this._buffer;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isNotEmpty(t1)) {
          accumulated = t2.toString$0(t1);
          this._chunkedSink.addSlice$4(accumulated, 0, accumulated.length, isLast);
          t2.clear$0(t1);
          return;
        }
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 116, 76, 249, 53],
      static: {
        _Utf8ConversionSink$: [function(sink, allowMalformed) {
          var t1 = P.StringBuffer$("");
          return new P._Utf8ConversionSink(P._Utf8Decoder$(t1, allowMalformed), sink, t1, []);
        }, null, null, 8, 0, null, 48, 120]
      }
    },
    Utf8Codec: {
      "^": "Encoding;_allowMalformed,$ti",
      get$name: [function(_) {
        return "utf-8";
      }, null, null, 3, 0, null],
      decode$2$allowMalformed: [function(_, codeUnits, allowMalformed) {
        H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
        H.boolTypeCheck(allowMalformed);
        return P.Utf8Decoder$(allowMalformed == null ? this._allowMalformed : allowMalformed).convert$1(codeUnits);
      }, function($receiver, codeUnits) {
        return this.decode$2$allowMalformed($receiver, codeUnits, null);
      }, "decode$1", null, null, "get$decode", 5, 3, null, 0, 113, 120],
      get$encoder: [function() {
        return C.C_Utf8Encoder;
      }, null, null, 2, 0, null],
      get$decoder: [function() {
        return P.Utf8Decoder$(this._allowMalformed);
      }, null, null, 2, 0, null]
    },
    Utf8Encoder: {
      "^": "Converter;$ti",
      convert$3: [function(string, start, end) {
        var stringLength, $length, encoder;
        H.stringTypeCheck(string);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        stringLength = string.length;
        P.RangeError_checkValidRange(start, end, stringLength, null, null, null);
        if (end == null)
          end = stringLength;
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length === 0)
          return H.NativeUint8List_NativeUint8List(0);
        encoder = P._Utf8Encoder$withBufferSize($length * 3);
        if (encoder._fillBuffer$3(string, start, end) !== end)
          encoder._writeSurrogate$2(J.codeUnitAt$1$s(string, end - 1), 0);
        return J.sublist$2$ax(encoder._buffer, 0, encoder._bufferIndex);
      }, function(string) {
        return this.convert$3(string, 0, null);
      }, "convert$1", null, null, "get$convert", 4, 4, null, 16, 0, 30, 5, 7],
      startChunkedConversion$1: [function(sink) {
        H.assertSubtype(sink, "$isSink", [[P.List, P.int]], "$asSink");
        return P._Utf8EncoderSink$(!(sink instanceof P.ByteConversionSink) ? P._ByteAdapterSink$(sink) : sink);
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      bind$1: [function(stream) {
        return this.super$Converter$bind(H.assertSubtype(stream, "$isStream", [P.String], "$asStream"));
      }, null, "get$bind", 4, 0, null, 57],
      $asStreamTransformer: function() {
        return [P.String, [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [P.String, [P.List, P.int]];
      },
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    _Utf8Encoder: {
      "^": "Object;_carry,_bufferIndex,_buffer,$ti",
      _writeSurrogate$2: [function(leadingSurrogate, nextCodeUnit) {
        var t1, t2, rune, t3;
        H.intTypeCheck(leadingSurrogate);
        H.intTypeCheck(nextCodeUnit);
        t1 = this._buffer;
        t2 = J.getInterceptor$ax(t1);
        if (P._isTailSurrogate(nextCodeUnit)) {
          rune = P._combineSurrogatePair(leadingSurrogate, nextCodeUnit);
          t3 = this._bufferIndex;
          this._bufferIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
          if (typeof rune !== "number")
            return rune.$shr();
          t2.$indexSet(t1, t3, (240 | C.JSInt_methods._shrOtherPositive$1(rune, 18)) >>> 0);
          t3 = this._bufferIndex;
          this._bufferIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
          t2.$indexSet(t1, t3, 128 | C.JSInt_methods._shrOtherPositive$1(rune, 12) & 63);
          t3 = this._bufferIndex;
          this._bufferIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
          t2.$indexSet(t1, t3, 128 | C.JSInt_methods._shrOtherPositive$1(rune, 6) & 63);
          t3 = this._bufferIndex;
          this._bufferIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
          t2.$indexSet(t1, t3, 128 | rune & 63);
          return true;
        } else {
          t3 = this._bufferIndex;
          this._bufferIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
          if (typeof leadingSurrogate !== "number")
            return leadingSurrogate.$shr();
          t2.$indexSet(t1, t3, (224 | C.JSInt_methods._shrOtherPositive$1(leadingSurrogate, 12)) >>> 0);
          t3 = this._bufferIndex;
          this._bufferIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
          t2.$indexSet(t1, t3, 128 | C.JSInt_methods._shrOtherPositive$1(leadingSurrogate, 6) & 63);
          t3 = this._bufferIndex;
          this._bufferIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
          t2.$indexSet(t1, t3, 128 | leadingSurrogate & 63);
          return false;
        }
      }, null, "get$_writeSurrogate", 8, 0, null, 873, 874],
      _fillBuffer$3: [function(str, start, end) {
        var t1, t2, t3, stringIndex, codeUnit, t4, stringIndex0;
        H.stringTypeCheck(str);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        if (start != end) {
          if (typeof end !== "number")
            return end.$sub();
          t1 = P._isLeadSurrogate(J.codeUnitAt$1$s(str, end - 1));
        } else
          t1 = false;
        if (t1) {
          if (typeof end !== "number")
            return end.$sub();
          --end;
        }
        t1 = this._buffer;
        t2 = J.getInterceptor$asx(t1);
        t3 = J.getInterceptor$s(str);
        stringIndex = start;
        while (true) {
          if (typeof stringIndex !== "number")
            return stringIndex.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(stringIndex < end))
            break;
          codeUnit = t3.codeUnitAt$1(str, stringIndex);
          if (typeof codeUnit !== "number")
            return codeUnit.$le();
          if (codeUnit <= 127) {
            if (J.$ge$n(this._bufferIndex, t2.get$length(t1)))
              break;
            t4 = this._bufferIndex;
            this._bufferIndex = H.intTypeCheck(J.$add$ansx(t4, 1));
            t2.$indexSet(t1, t4, codeUnit);
          } else if (P._isLeadSurrogate(codeUnit)) {
            if (J.$ge$n(J.$add$ansx(this._bufferIndex, 3), t2.get$length(t1)))
              break;
            stringIndex0 = stringIndex + 1;
            if (this._writeSurrogate$2(codeUnit, C.JSString_methods.codeUnitAt$1(str, stringIndex0)))
              stringIndex = stringIndex0;
          } else if (codeUnit <= 2047) {
            if (J.$ge$n(J.$add$ansx(this._bufferIndex, 1), t2.get$length(t1)))
              break;
            t4 = this._bufferIndex;
            this._bufferIndex = H.intTypeCheck(J.$add$ansx(t4, 1));
            t2.$indexSet(t1, t4, (192 | C.JSInt_methods._shrOtherPositive$1(codeUnit, 6)) >>> 0);
            t4 = this._bufferIndex;
            this._bufferIndex = H.intTypeCheck(J.$add$ansx(t4, 1));
            t2.$indexSet(t1, t4, 128 | codeUnit & 63);
          } else {
            if (J.$ge$n(J.$add$ansx(this._bufferIndex, 2), t2.get$length(t1)))
              break;
            t4 = this._bufferIndex;
            this._bufferIndex = H.intTypeCheck(J.$add$ansx(t4, 1));
            t2.$indexSet(t1, t4, (224 | C.JSInt_methods._shrOtherPositive$1(codeUnit, 12)) >>> 0);
            t4 = this._bufferIndex;
            this._bufferIndex = H.intTypeCheck(J.$add$ansx(t4, 1));
            t2.$indexSet(t1, t4, 128 | C.JSInt_methods._shrOtherPositive$1(codeUnit, 6) & 63);
            t4 = this._bufferIndex;
            this._bufferIndex = H.intTypeCheck(J.$add$ansx(t4, 1));
            t2.$indexSet(t1, t4, 128 | codeUnit & 63);
          }
          ++stringIndex;
        }
        return stringIndex;
      }, null, "get$_fillBuffer", 12, 0, null, 82, 5, 7],
      static: {
        _Utf8Encoder$withBufferSize: [function(bufferSize) {
          return new P._Utf8Encoder(0, 0, P._Utf8Encoder__createBuffer(bufferSize), []);
        }, null, null, 4, 0, null, 242],
        _Utf8Encoder__createBuffer: [function(size) {
          return H.NativeUint8List_NativeUint8List(H.intTypeCheck(size));
        }, null, null, 4, 0, null, 239]
      }
    },
    _Utf8EncoderSink: {
      "^": "__Utf8EncoderSink__Utf8Encoder_StringConversionSinkMixin;_sink,_carry,_bufferIndex,_buffer,$ti",
      close$0: [function(_) {
        if (!J.$eq$(this._carry, 0)) {
          this.addSlice$4("", 0, 0, true);
          return;
        }
        J.close$0$z(this._sink);
      }, "call$0", "get$close", 1, 0, 0],
      addSlice$4: [function(str, start, end, isLast) {
        var t1, nextCodeUnit, t2, t3, t4, isLastSlice;
        H.stringTypeCheck(str);
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.boolTypeCheck(isLast);
        this._bufferIndex = 0;
        t1 = start == end;
        if (t1 && !isLast)
          return;
        if (!J.$eq$(this._carry, 0)) {
          nextCodeUnit = !t1 ? J.codeUnitAt$1$s(str, start) : 0;
          if (this._writeSurrogate$2(this._carry, nextCodeUnit)) {
            if (typeof start !== "number")
              return start.$add();
            ++start;
          }
          this._carry = 0;
        }
        t1 = this._sink;
        t2 = this._buffer;
        t3 = J.getInterceptor$s(str);
        t4 = J.getInterceptor$asx(t2);
        do {
          start = this._fillBuffer$3(str, start, end);
          isLastSlice = isLast && start == end;
          if (typeof end !== "number")
            return end.$sub();
          if (start === end - 1 && P._isLeadSurrogate(t3.codeUnitAt$1(str, start))) {
            if (isLast && J.$lt$n(this._bufferIndex, J.$sub$n(t4.get$length(t2), 3)))
              this._writeSurrogate$2(t3.codeUnitAt$1(str, start), 0);
            else
              this._carry = H.intTypeCheck(t3.codeUnitAt$1(str, start));
            if (typeof start !== "number")
              return start.$add();
            ++start;
          }
          t1.addSlice$4(t2, 0, this._bufferIndex, isLastSlice);
          this._bufferIndex = 0;
          if (typeof start !== "number")
            return start.$lt();
        } while (start < end);
        if (isLast)
          this.close$0(0);
      }, null, "get$addSlice", 16, 0, null, 82, 5, 7, 53],
      $isChunkedConversionSink: 1,
      $asChunkedConversionSink: function() {
        return [P.String];
      },
      $isStringConversionSink: 1,
      $isStringConversionSinkMixin: 1,
      $isSink: 1,
      $asSink: function() {
        return [P.String];
      },
      static: {
        _Utf8EncoderSink$: [function(_sink) {
          return new P._Utf8EncoderSink(_sink, 0, 0, P._Utf8Encoder__createBuffer(1024), []);
        }, null, null, 4, 0, null, 60]
      }
    },
    Utf8Decoder: {
      "^": "Converter;_allowMalformed,$ti",
      convert$3: [function(codeUnits, start, end) {
        var t1, result, $length, buffer, decoder;
        H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = this._allowMalformed;
        result = P.Utf8Decoder__convertIntercepted(t1, codeUnits, start, end);
        if (result != null)
          return result;
        $length = J.get$length$asx(codeUnits);
        P.RangeError_checkValidRange(start, end, $length, null, null, null);
        if (end == null)
          end = $length;
        buffer = P.StringBuffer$("");
        decoder = P._Utf8Decoder$(buffer, t1);
        decoder.convert$3(codeUnits, start, end);
        decoder.flush$2(codeUnits, end);
        return buffer.toString$0(0);
      }, function(codeUnits) {
        return this.convert$3(codeUnits, 0, null);
      }, "convert$1", null, null, "get$convert", 4, 4, null, 16, 0, 113, 5, 7],
      startChunkedConversion$1: [function(sink) {
        var stringSink;
        H.assertSubtype(sink, "$isSink", [P.String], "$asSink");
        stringSink = !!J.getInterceptor$(sink).$isStringConversionSink ? sink : P._StringAdapterSink$(sink);
        return stringSink.asUtf8Sink$1(this._allowMalformed);
      }, null, "get$startChunkedConversion", 4, 0, null, 48],
      bind$1: [function(stream) {
        return this.super$Converter$bind(H.assertSubtype(stream, "$isStream", [[P.List, P.int]], "$asStream"));
      }, null, "get$bind", 4, 0, null, 57],
      $asStreamTransformer: function() {
        return [[P.List, P.int], P.String];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], P.String];
      },
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      },
      static: {
        Utf8Decoder__convertIntercepted: [function(allowMalformed, codeUnits, start, end) {
          H.boolTypeCheck(allowMalformed);
          H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          if (codeUnits instanceof Uint8Array)
            return P.Utf8Decoder__convertInterceptedUint8List(allowMalformed, codeUnits, start, end);
          return;
        }, null, null, 16, 0, null, 120, 113, 5, 7],
        Utf8Decoder__convertInterceptedUint8List: [function(allowMalformed, codeUnits, start, end) {
          var decoder, t1, $length;
          H.boolTypeCheck(allowMalformed);
          H.interceptedTypeCheck(codeUnits, "$isNativeUint8List");
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          if (allowMalformed)
            return;
          decoder = $.$get$Utf8Decoder__decoder();
          if (decoder == null)
            return;
          t1 = 0 === start;
          if (t1 && end == null)
            return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
          $length = codeUnits.length;
          end = P.RangeError_checkValidRange(start, end, $length, null, null, null);
          if (t1 && end === $length)
            return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
          return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits.subarray(start, end));
        }, null, null, 16, 0, null, 120, 113, 5, 7],
        Utf8Decoder__useTextDecoderChecked: [function(decoder, codeUnits) {
          H.interceptedTypeCheck(codeUnits, "$isNativeUint8List");
          if (P.Utf8Decoder__unsafe(codeUnits))
            return;
          return P.Utf8Decoder__useTextDecoderUnchecked(decoder, codeUnits);
        }, null, null, 8, 0, null, 544, 113],
        Utf8Decoder__useTextDecoderUnchecked: [function(decoder, codeUnits) {
          var t1, exception;
          H.interceptedTypeCheck(codeUnits, "$isNativeUint8List");
          try {
            t1 = decoder.decode(codeUnits);
            return t1;
          } catch (exception) {
            H.unwrapException(exception);
          }
          return;
        }, null, null, 8, 0, null, 544, 113],
        Utf8Decoder__unsafe: [function(codeUnits) {
          var limit, i, unit2;
          H.interceptedTypeCheck(codeUnits, "$isNativeUint8List");
          limit = codeUnits.length - 2;
          for (i = 0; i < limit; ++i)
            if (codeUnits[i] === 237) {
              unit2 = codeUnits[i + 1];
              if (typeof unit2 !== "number")
                return unit2.$and();
              if ((unit2 & 224) === 160)
                return true;
            }
          return false;
        }, null, null, 4, 0, null, 113],
        Utf8Decoder__makeDecoder: [function() {
          var t1, exception;
          try {
            t1 = new TextDecoder("utf-8", {fatal: true});
            return t1;
          } catch (exception) {
            H.unwrapException(exception);
          }
          return;
        }, null, null, 0, 0, null],
        Utf8Decoder$: [function(allowMalformed) {
          return new P.Utf8Decoder(allowMalformed, []);
        }, null, null, 0, 3, null, 18, 120]
      }
    },
    _Utf8Decoder: {
      "^": "Object;_allowMalformed,_stringSink<,_isFirstCharacter,_convert$_value,_expectedUnits,_extraUnits,$ti",
      get$hasPartialInput: [function() {
        return J.$gt$n(this._expectedUnits, 0);
      }, null, null, 2, 0, null],
      close$0: [function(_) {
        this.flush$0();
      }, "call$0", "get$close", 1, 0, 0],
      flush$2: [function(source, offset) {
        H.assertSubtype(source, "$isList", [P.int], "$asList");
        H.intTypeCheck(offset);
        if (this.get$hasPartialInput()) {
          if (!this._allowMalformed)
            throw H.wrapException(P.FormatException$("Unfinished UTF-8 octet sequence", source, offset));
          this._stringSink.writeCharCode$1(65533);
          this._convert$_value = 0;
          this._expectedUnits = 0;
          this._extraUnits = 0;
        }
      }, function() {
        return this.flush$2(null, null);
      }, "flush$0", null, null, "get$flush", 0, 4, null, 0, 0, 11, 52],
      convert$3: [function(codeUnits, startIndex, endIndex) {
        var value, expectedUnits, extraUnits, scanOneByteCharacters, addSingleBytes, t1, t2, t3, i, unit, t4, oneBytes, i0;
        H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
        H.intTypeCheck(startIndex);
        H.intTypeCheck(endIndex);
        value = this._convert$_value;
        expectedUnits = this._expectedUnits;
        extraUnits = this._extraUnits;
        this._convert$_value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
        scanOneByteCharacters = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
        addSingleBytes = new P._Utf8Decoder_convert_addSingleBytes(this, startIndex, endIndex, codeUnits);
        $label0$0:
          for (t1 = this._stringSink, t2 = this._allowMalformed, t3 = J.getInterceptor$asx(codeUnits), i = startIndex; true; i = i0) {
            $label1$1: {
              if (typeof expectedUnits !== "number")
                return expectedUnits.$gt();
              if (expectedUnits > 0) {
                do {
                  if (i == endIndex)
                    break $label0$0;
                  unit = t3.$index(codeUnits, i);
                  if (typeof unit !== "number")
                    return unit.$and();
                  if ((unit & 192) !== 128) {
                    if (!t2)
                      throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + H.S(C.JSInt_methods.toRadixString$1(unit, 16)), codeUnits, i));
                    this._isFirstCharacter = false;
                    t1.writeCharCode$1(65533);
                    expectedUnits = 0;
                    break $label1$1;
                  } else {
                    if (typeof value !== "number")
                      return value.$shl();
                    value = (value << 6 | unit & 63) >>> 0;
                    --expectedUnits;
                    if (typeof i !== "number")
                      return i.$add();
                    ++i;
                  }
                } while (expectedUnits > 0);
                if (typeof extraUnits !== "number")
                  return extraUnits.$sub();
                t4 = extraUnits - 1;
                if (t4 < 0 || t4 >= 4)
                  return H.ioore(C.List_127_2047_65535_1114111, t4);
                t4 = C.List_127_2047_65535_1114111[t4];
                if (typeof t4 !== "number")
                  return H.iae(t4);
                if (value <= t4) {
                  if (!t2)
                    throw H.wrapException(P.FormatException$("Overlong encoding of 0x" + H.S(C.JSInt_methods.toRadixString$1(value, 16)), codeUnits, i - extraUnits - 1));
                  value = 65533;
                  expectedUnits = 0;
                  extraUnits = 0;
                }
                if (value > 1114111) {
                  if (!t2)
                    throw H.wrapException(P.FormatException$("Character outside valid Unicode range: 0x" + H.S(C.JSInt_methods.toRadixString$1(value, 16)), codeUnits, i - extraUnits - 1));
                  value = 65533;
                }
                if (!this._isFirstCharacter || value !== 65279)
                  t1.writeCharCode$1(value);
                this._isFirstCharacter = false;
              }
            }
            while (true) {
              if (typeof i !== "number")
                return i.$lt();
              if (typeof endIndex !== "number")
                return H.iae(endIndex);
              if (!(i < endIndex))
                break;
              oneBytes = scanOneByteCharacters.call$2(codeUnits, i);
              if (typeof oneBytes !== "number")
                return oneBytes.$gt();
              if (oneBytes > 0) {
                this._isFirstCharacter = false;
                i0 = i + oneBytes;
                addSingleBytes.call$2(i, i0);
                if (i0 === endIndex)
                  break;
                i = i0;
              }
              i0 = i + 1;
              unit = t3.$index(codeUnits, i);
              if (typeof unit !== "number")
                return unit.$lt();
              if (unit < 0) {
                if (!t2)
                  throw H.wrapException(P.FormatException$("Negative UTF-8 code unit: -0x" + H.S(C.JSInt_methods.toRadixString$1(-unit, 16)), codeUnits, i0 - 1));
                t1.writeCharCode$1(65533);
              } else {
                if ((unit & 224) === 192) {
                  value = unit & 31;
                  expectedUnits = 1;
                  extraUnits = 1;
                  continue $label0$0;
                }
                if ((unit & 240) === 224) {
                  value = unit & 15;
                  expectedUnits = 2;
                  extraUnits = 2;
                  continue $label0$0;
                }
                if ((unit & 248) === 240 && unit < 245) {
                  value = unit & 7;
                  expectedUnits = 3;
                  extraUnits = 3;
                  continue $label0$0;
                }
                if (!t2)
                  throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + H.S(C.JSInt_methods.toRadixString$1(unit, 16)), codeUnits, i0 - 1));
                this._isFirstCharacter = false;
                t1.writeCharCode$1(65533);
                value = 65533;
                expectedUnits = 0;
                extraUnits = 0;
              }
              i = i0;
            }
            break $label0$0;
          }
        if (typeof expectedUnits !== "number")
          return expectedUnits.$gt();
        if (expectedUnits > 0) {
          this._convert$_value = value;
          this._expectedUnits = expectedUnits;
          this._extraUnits = extraUnits;
        }
      }, null, "get$convert", 12, 0, null, 113, 76, 249],
      static: {
        _Utf8Decoder$: [function(_stringSink, _allowMalformed) {
          return new P._Utf8Decoder(_allowMalformed, _stringSink, true, 0, 0, 0, []);
        }, null, null, 8, 0, null, 762, 774]
      }
    },
    _Utf8Decoder_convert_scanOneByteCharacters: {
      "^": "Closure:175;endIndex,$ti",
      call$2: [function(units, from) {
        var to, t1, i, unit;
        H.assertSubtype(units, "$isList", [P.int], "$asList");
        H.intTypeCheck(from);
        to = this.endIndex;
        t1 = J.getInterceptor$asx(units);
        i = from;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof to !== "number")
            return H.iae(to);
          if (!(i < to))
            break;
          unit = t1.$index(units, i);
          if (typeof unit !== "number")
            return unit.$and();
          if ((unit & 127) !== unit) {
            if (typeof from !== "number")
              return H.iae(from);
            return i - from;
          }
          ++i;
        }
        if (typeof from !== "number")
          return H.iae(from);
        return to - from;
      }, null, null, 8, 0, null, 884, 121, "call"]
    },
    _Utf8Decoder_convert_addSingleBytes: {
      "^": "Closure:193;$this,startIndex,endIndex,codeUnits,$ti",
      call$2: [function(from, to) {
        H.intTypeCheck(from);
        H.intTypeCheck(to);
        this.$this.get$_stringSink().write$1(P.String_String$fromCharCodes(this.codeUnits, from, to));
      }, null, null, 8, 0, null, 121, 222, "call"]
    },
    __JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin: {
      "^": "_JsonStringStringifier+_JsonPrettyPrintMixin;$ti",
      $is_JsonPrettyPrintMixin: 1
    },
    __JsonUtf8StringifierPretty__JsonUtf8Stringifier__JsonPrettyPrintMixin: {
      "^": "_JsonUtf8Stringifier+_JsonPrettyPrintMixin;$ti",
      $is_JsonPrettyPrintMixin: 1
    },
    __Utf8EncoderSink__Utf8Encoder_StringConversionSinkMixin: {
      "^": "_Utf8Encoder+StringConversionSinkMixin;$ti",
      $isChunkedConversionSink: 1,
      $asChunkedConversionSink: function() {
        return [P.String];
      },
      $isStringConversionSink: 1,
      $isStringConversionSinkMixin: 1,
      $isSink: 1,
      $asSink: function() {
        return [P.String];
      }
    }
  }], ["dart.core", "dart:core",, P, {
    "^": "",
    _symbolToString: [function(symbol) {
      return H.Symbol_getName(H.interceptedTypeCheck(symbol, "$isSymbol0"));
    }, null, null, 4, 0, null, 289],
    _symbolMapToStringMap: [function(map) {
      var result;
      H.assertSubtype(map, "$isMap", [P.Symbol0, null], "$asMap");
      if (map == null)
        return;
      result = H.JsLinkedHashMap_JsLinkedHashMap$es6(P.String, null);
      map.forEach$1(0, new P._symbolMapToStringMap_closure(result));
      return result;
    }, null, null, 4, 0, null, 111],
    identityHashCode: [function(object) {
      return H.objectHashCode(object);
    }, "call$1", "core__identityHashCode$closure", 4, 0, 212, 9],
    Function_apply: [function($function, positionalArguments, namedArguments) {
      var t1 = P.Function__apply1(H.interceptedTypeCheck($function, "$isFunction"), H.listTypeCheck(positionalArguments), H.assertSubtype(namedArguments, "$isMap", [P.Symbol0, null], "$asMap"));
      return t1;
    }, null, null, 8, 2, null, 0, 64, 153, 157],
    Function__apply1: [function($function, positionalArguments, namedArguments) {
      H.interceptedTypeCheck($function, "$isFunction");
      H.listTypeCheck(positionalArguments);
      return H.Primitives_applyFunction($function, positionalArguments, namedArguments == null ? null : P._symbolMapToStringMap(H.assertSubtype(namedArguments, "$isMap", [P.Symbol0, null], "$asMap")));
    }, null, null, 12, 0, null, 64, 153, 157],
    int_parse: [function(source, onError, radix) {
      var value;
      H.stringTypeCheck(source);
      H.intTypeCheck(radix);
      H.functionTypeCheck(onError, {func: 1, ret: P.int, args: [P.String]});
      value = P.int_tryParse(source, radix);
      if (value != null)
        return value;
      if (onError != null)
        return onError.call$1(source);
      throw H.wrapException(P.FormatException$(source, null, null));
    }, null, null, 4, 5, null, 0, 0, 11, 31, 264],
    int_tryParse: [function(source, radix) {
      return H.Primitives_parseInt(H.stringTypeCheck(source), H.intTypeCheck(radix));
    }, null, null, 4, 3, null, 0, 11, 264],
    double_tryParse: [function(source) {
      return H.Primitives_parseDouble(H.stringTypeCheck(source));
    }, null, null, 4, 0, null, 11],
    Error__objectToString: [function(object) {
      if (object instanceof H.Closure)
        return object.toString$0(0);
      return H.Primitives_objectToHumanReadableString(object);
    }, null, null, 4, 0, null, 9],
    Error__stringToSafeString: [function(string) {
      return H.jsonEncodeNative(H.stringTypeCheck(string));
    }, null, null, 4, 0, null, 30],
    List_List$filled: [function($length, fill, growable, $E) {
      var result, t1, i, t2;
      H.intTypeCheck($length);
      H.assertSubtypeOfRuntimeType(fill, $E);
      result = H.boolTypeCheck(growable) ? J.JSArray_JSArray$growable($length, $E) : J.JSArray_JSArray$fixed($length, $E);
      if ($length !== 0 && fill != null) {
        t1 = J.getInterceptor$asx(result);
        i = 0;
        while (true) {
          t2 = t1.get$length(result);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          t1.$indexSet(result, i, fill);
          ++i;
        }
      }
      return H.assertSubtype(result, "$isList", [$E], "$asList");
    }, null, null, 8, 3, null, 18, 35, 525, 95],
    List_List$from: [function(elements, growable, $E) {
      var list, t1;
      H.listSuperNativeTypeCheck(elements, "$isIterable");
      H.boolTypeCheck(growable);
      list = H.setRuntimeTypeInfo([], [$E]);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        C.JSArray_methods.add$1(list, H.assertSubtypeOfRuntimeType(t1.get$current(), $E));
      if (growable)
        return list;
      return H.makeListFixedLength(list, $E);
    }, null, null, 4, 3, null, 27, 80, 95],
    List_List$unmodifiable: [function(elements, $E) {
      return H.makeFixedListUnmodifiable(H.assertSubtype(P.List_List$from(H.listSuperNativeTypeCheck(elements, "$isIterable"), false, $E), "$isList", [$E], "$asList"), $E);
    }, null, null, 4, 0, null, 80],
    String_String$fromCharCodes: [function(charCodes, start, end) {
      var t1 = P.int;
      H.assertSubtype(charCodes, "$isIterable", [t1], "$asIterable");
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array)
        return P.String__stringFromJSArray(H.assertSubtype(charCodes, "$isJSArray", [t1], "$asJSArray"), start, end);
      if (!!J.getInterceptor$(charCodes).$isNativeUint8List)
        return P.String__stringFromUint8List(charCodes, start, end);
      return P.String__stringFromIterable(charCodes, start, end);
    }, null, null, 4, 4, null, 16, 0, 187, 5, 7],
    String_String$fromCharCode: [function(charCode) {
      return H.Primitives_stringFromCharCode(H.intTypeCheck(charCode));
    }, null, null, 4, 0, null, 93],
    String__stringFromJSArray: [function(list, start, endOrNull) {
      var t1, len, end, t2;
      H.listTypeCheck(list);
      H.intTypeCheck(start);
      H.intTypeCheck(endOrNull);
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      end = P.RangeError_checkValidRange(start, endOrNull, len, null, null, null);
      if (typeof start !== "number")
        return start.$gt();
      if (start <= 0) {
        if (typeof end !== "number")
          return end.$lt();
        if (typeof len !== "number")
          return H.iae(len);
        t2 = end < len;
      } else
        t2 = true;
      return H.Primitives_stringFromCharCodes(t2 ? t1.sublist$2(list, start, end) : list);
    }, null, null, 12, 0, null, 68, 5, 353],
    String__stringFromUint8List: [function(charCodes, start, endOrNull) {
      H.interceptedTypeCheck(charCodes, "$isNativeUint8List");
      H.intTypeCheck(start);
      return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, H.intTypeCheck(endOrNull), charCodes.length, null, null, null));
    }, null, null, 12, 0, null, 187, 5, 353],
    String__stringFromIterable: [function(charCodes, start, end) {
      var t1, it, i, list;
      H.assertSubtype(charCodes, "$isIterable", [P.int], "$asIterable");
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      if (typeof start !== "number")
        return start.$lt();
      if (start < 0)
        throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), null, null));
      t1 = end == null;
      if (!t1 && end < start)
        throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), null, null));
      it = J.get$iterator$ax(charCodes);
      for (i = 0; i < start; ++i)
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(start, 0, i, null, null));
      list = [];
      if (t1)
        for (; it.moveNext$0();)
          list.push(it.get$current());
      else
        for (i = start; i < end; ++i) {
          if (!it.moveNext$0())
            throw H.wrapException(P.RangeError$range(end, start, i, null, null));
          list.push(it.get$current());
        }
      return H.Primitives_stringFromCharCodes(list);
    }, null, null, 12, 0, null, 187, 5, 7],
    RegExp_RegExp: [function(source, caseSensitive, multiLine) {
      H.stringTypeCheck(source);
      H.boolTypeCheck(multiLine);
      return H.JSSyntaxRegExp$(source, H.boolTypeCheck(caseSensitive), multiLine);
    }, null, null, 4, 5, null, 27, 18, 11, 299, 274],
    identical: [function(a, b) {
      return a == null ? b == null : a === b;
    }, "call$2", "core__identical$closure", 8, 0, 213, 33, 54],
    Uri_base: [function() {
      var uri = H.Primitives_currentUri();
      if (uri != null)
        return P.Uri_parse(uri, 0, null);
      throw H.wrapException(P.UnsupportedError$("'Uri.base' is not supported"));
    }, null, null, 2, 0, null],
    StackTrace_current: [function() {
      var stackTrace, exception;
      if ($.$get$_hasErrorStackProperty())
        return H.getTraceFromException(new Error());
      try {
        throw H.wrapException("");
      } catch (exception) {
        H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        return stackTrace;
      }
    }, null, null, 2, 0, null],
    Comparable_compare: [function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    }, null, null, 8, 0, null, 33, 54],
    Error_safeToString: [function(object) {
      if (typeof object === "number" || typeof object === "boolean" || null == object)
        return J.toString$0$(object);
      if (typeof object === "string")
        return P.Error__stringToSafeString(object);
      return P.Error__objectToString(object);
    }, null, null, 4, 0, null, 9],
    Exception_Exception: [function(message) {
      return P._Exception$(message);
    }, null, null, 0, 2, null, 0, 21],
    Iterable_castFrom: [1, function(source, $S, $T) {
      return H.CastIterable_CastIterable(H.assertSubtype(source, "$isIterable", [$S], "$asIterable"), $S, $T);
    }, function(source) {
      return P.Iterable_castFrom(source, null, null);
    }, null, "call$1", null, 4, 0, null, 11],
    List_List$generate: [function($length, generator, growable, $E) {
      var result, t1, i;
      H.intTypeCheck($length);
      H.functionTypeCheck(generator, {func: 1, ret: $E, args: [P.int]});
      if (H.boolTypeCheck(growable)) {
        result = H.setRuntimeTypeInfo([], [$E]);
        C.JSArray_methods.set$length(result, $length);
      } else {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = new Array($length);
        t1.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t1, [$E]);
      }
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i)
        C.JSArray_methods.$indexSet(result, i, generator.call$1(i));
      return result;
    }, null, null, 8, 3, null, 27, 35, 591, 95],
    List_castFrom: [1, function(source, $S, $T) {
      return H.CastList$(H.assertSubtype(source, "$isList", [$S], "$asList"), $S, $T);
    }, function(source) {
      return P.List_castFrom(source, null, null);
    }, null, "call$1", null, 4, 0, null, 11],
    Map_castFrom: [1, function(source, $K, $V, K2, V2) {
      return H.CastMap$(H.assertSubtype(source, "$isMap", [$K, $V], "$asMap"), $K, $V, K2, V2);
    }, function(source) {
      return P.Map_castFrom(source, null, null, null, null);
    }, null, "call$1", null, 4, 0, null, 11],
    Map_Map$fromEntries: [function(entries, $K, $V) {
      var t1;
      H.assertSubtype(entries, "$isIterable", [[P.MapEntry, $K, $V]], "$asIterable");
      t1 = P.LinkedHashMap_LinkedHashMap$_empty($K, $V);
      t1.addEntries$1(entries);
      return t1;
    }, null, null, 4, 0, null, 206],
    num_parse: [function(input, onError) {
      var result;
      H.stringTypeCheck(input);
      H.functionTypeCheck(onError, {func: 1, ret: P.num, args: [P.String]});
      result = P.num_tryParse(input);
      if (result != null)
        return result;
      if (onError == null)
        throw H.wrapException(P.FormatException$(input, null, null));
      return onError.call$1(input);
    }, null, null, 4, 2, null, 0, 55, 31],
    num_tryParse: [function(input) {
      var source, t1;
      source = J.trim$0$s(H.stringTypeCheck(input));
      t1 = P.int_tryParse(source, null);
      return t1 == null ? P.double_tryParse(source) : t1;
    }, null, null, 4, 0, null, 55],
    print: [function(object) {
      var line, t1;
      line = H.S(object);
      t1 = $.printToZone;
      if (t1 == null)
        H.printToConsole(line);
      else
        t1.call$1(line);
    }, null, null, 4, 0, null, 9],
    Uri_parse: [function(uri, start, end) {
      var t1, dataDelta, t2, indices, state, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, isSimple, scheme, t3, schemeAuth, delta;
      H.stringTypeCheck(uri);
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      if (end == null)
        end = uri.length;
      if (typeof start !== "number")
        return start.$add();
      t1 = start + 5;
      if (end >= t1) {
        dataDelta = P._startsWithData(uri, start);
        if (dataDelta === 0)
          return P.UriData__parse(start > 0 || end < uri.length ? J.substring$2$s(uri, start, end) : uri, 5, null).get$uri();
        else if (dataDelta === 32)
          return P.UriData__parse(J.substring$2$s(uri, t1, end), 0, null).get$uri();
      }
      t2 = new Array(8);
      t2.fixed$length = Array;
      indices = H.setRuntimeTypeInfo(t2, [P.int]);
      C.JSArray_methods.$indexSet(indices, 0, 0);
      t2 = start - 1;
      C.JSArray_methods.$indexSet(indices, 1, t2);
      C.JSArray_methods.$indexSet(indices, 2, t2);
      C.JSArray_methods.$indexSet(indices, 7, t2);
      C.JSArray_methods.$indexSet(indices, 3, start);
      C.JSArray_methods.$indexSet(indices, 4, start);
      C.JSArray_methods.$indexSet(indices, 5, end);
      C.JSArray_methods.$indexSet(indices, 6, end);
      state = P._scan(uri, start, end, 0, indices);
      if (typeof state !== "number")
        return state.$ge();
      if (state >= 14)
        C.JSArray_methods.$indexSet(indices, 7, end);
      t2 = indices.length;
      if (1 >= t2)
        return H.ioore(indices, 1);
      schemeEnd = indices[1];
      if (typeof schemeEnd !== "number")
        return schemeEnd.$ge();
      if (schemeEnd >= start)
        if (P._scan(uri, start, schemeEnd, 20, indices) === 20)
          C.JSArray_methods.$indexSet(indices, 7, schemeEnd);
      if (2 >= t2)
        return H.ioore(indices, 2);
      hostStart = J.$add$ansx(indices[2], 1);
      if (3 >= t2)
        return H.ioore(indices, 3);
      portStart = indices[3];
      if (4 >= t2)
        return H.ioore(indices, 4);
      pathStart = indices[4];
      if (5 >= t2)
        return H.ioore(indices, 5);
      queryStart = indices[5];
      if (6 >= t2)
        return H.ioore(indices, 6);
      fragmentStart = indices[6];
      if (typeof fragmentStart !== "number")
        return fragmentStart.$lt();
      if (typeof queryStart !== "number")
        return H.iae(queryStart);
      if (fragmentStart < queryStart)
        queryStart = fragmentStart;
      if (typeof pathStart !== "number")
        return pathStart.$lt();
      if (typeof hostStart !== "number")
        return H.iae(hostStart);
      if (pathStart < hostStart)
        pathStart = queryStart;
      else if (pathStart <= schemeEnd)
        pathStart = schemeEnd + 1;
      if (typeof portStart !== "number")
        return portStart.$lt();
      if (portStart < hostStart)
        portStart = pathStart;
      if (7 >= t2)
        return H.ioore(indices, 7);
      isSimple = J.$lt$n(indices[7], start);
      if (isSimple)
        if (hostStart > schemeEnd + 3) {
          scheme = null;
          isSimple = false;
        } else {
          t2 = portStart > start;
          if (t2 && portStart + 1 === pathStart) {
            scheme = null;
            isSimple = false;
          } else {
            if (!(queryStart < end && queryStart === pathStart + 2 && J.startsWith$2$s(uri, "..", pathStart)))
              t3 = queryStart > pathStart + 2 && J.startsWith$2$s(uri, "/..", queryStart - 3);
            else
              t3 = true;
            if (t3) {
              scheme = null;
              isSimple = false;
            } else {
              if (schemeEnd === start + 4)
                if (J.startsWith$2$s(uri, "file", start)) {
                  if (hostStart <= start) {
                    if (!C.JSString_methods.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = C.JSString_methods.$add(schemeAuth, C.JSString_methods.substring$2(uri, pathStart, end));
                    schemeEnd -= start;
                    t1 = delta - start;
                    queryStart += t1;
                    fragmentStart += t1;
                    end = uri.length;
                    start = 0;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else if (pathStart === queryStart)
                    if (start === 0 && end === uri.length) {
                      uri = C.JSString_methods.replaceRange$3(uri, pathStart, queryStart, "/");
                      ++queryStart;
                      ++fragmentStart;
                      ++end;
                    } else {
                      uri = H.S(C.JSString_methods.substring$2(uri, start, pathStart)) + "/" + H.S(C.JSString_methods.substring$2(uri, queryStart, end));
                      schemeEnd -= start;
                      hostStart -= start;
                      portStart -= start;
                      pathStart -= start;
                      t1 = 1 - start;
                      queryStart += t1;
                      fragmentStart += t1;
                      end = uri.length;
                      start = 0;
                    }
                  scheme = "file";
                } else if (C.JSString_methods.startsWith$2(uri, "http", start)) {
                  if (t2 && portStart + 3 === pathStart && C.JSString_methods.startsWith$2(uri, "80", portStart + 1))
                    if (start === 0 && end === uri.length) {
                      uri = C.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                      pathStart -= 3;
                      queryStart -= 3;
                      fragmentStart -= 3;
                      end -= 3;
                    } else {
                      uri = J.$add$ansx(C.JSString_methods.substring$2(uri, start, portStart), C.JSString_methods.substring$2(uri, pathStart, end));
                      schemeEnd -= start;
                      hostStart -= start;
                      portStart -= start;
                      t1 = 3 + start;
                      pathStart -= t1;
                      queryStart -= t1;
                      fragmentStart -= t1;
                      end = uri.length;
                      start = 0;
                    }
                  scheme = "http";
                } else
                  scheme = null;
              else if (schemeEnd === t1 && J.startsWith$2$s(uri, "https", start)) {
                if (t2 && portStart + 4 === pathStart && J.startsWith$2$s(uri, "443", portStart + 1)) {
                  t1 = start === 0 && end === uri.length;
                  t2 = J.getInterceptor$asx(uri);
                  if (t1) {
                    uri = t2.replaceRange$3(uri, portStart, pathStart, "");
                    pathStart -= 4;
                    queryStart -= 4;
                    fragmentStart -= 4;
                    end -= 3;
                  } else {
                    uri = J.$add$ansx(t2.substring$2(uri, start, portStart), C.JSString_methods.substring$2(uri, pathStart, end));
                    schemeEnd -= start;
                    hostStart -= start;
                    portStart -= start;
                    t1 = 4 + start;
                    pathStart -= t1;
                    queryStart -= t1;
                    fragmentStart -= t1;
                    end = uri.length;
                    start = 0;
                  }
                }
                scheme = "https";
              } else
                scheme = null;
              isSimple = true;
            }
          }
        }
      else
        scheme = null;
      if (isSimple) {
        if (start > 0 || end < uri.length) {
          uri = J.substring$2$s(uri, start, end);
          schemeEnd -= start;
          hostStart -= start;
          portStart -= start;
          pathStart -= start;
          queryStart -= start;
          fragmentStart -= start;
        }
        return P._SimpleUri$(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
      }
      return P._Uri__Uri$notSimple(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
    }, null, null, 4, 4, null, 16, 0, 65, 5, 7],
    Uri_encodeQueryComponent: [function(component, encoding) {
      return P._Uri__uriEncode(C.List_nxB, H.stringTypeCheck(component), H.interceptedTypeCheck(encoding, "$isEncoding"), true);
    }, null, null, 4, 3, null, 323, 324, 131],
    Uri_decodeComponent: [function(encodedComponent) {
      H.stringTypeCheck(encodedComponent);
      return P._Uri__uriDecode(encodedComponent, 0, encodedComponent.length, C.Utf8Codec_false, false);
    }, "call$1", "core_Uri_decodeComponent$closure", 4, 0, 7, 360],
    Uri_decodeQueryComponent: [function(encodedComponent, encoding) {
      H.stringTypeCheck(encodedComponent);
      H.interceptedTypeCheck(encoding, "$isEncoding");
      return P._Uri__uriDecode(encodedComponent, 0, encodedComponent.length, encoding, true);
    }, null, null, 4, 3, null, 323, 360, 131],
    Uri_splitQueryString: [function(query, encoding) {
      var t1;
      H.stringTypeCheck(query);
      H.interceptedTypeCheck(encoding, "$isEncoding");
      t1 = P.String;
      return C.JSArray_methods.fold$1$2(H.setRuntimeTypeInfo(query.split("&"), [t1]), P.LinkedHashMap_LinkedHashMap$_empty(t1, t1), new P.Uri_splitQueryString_closure(encoding), [P.Map, P.String, P.String]);
    }, null, null, 4, 3, null, 323, 210, 131],
    Uri__parseIPv4Address: [function(host, start, end) {
      var error, result, t1, i, partStart, partIndex, char, part, partIndex0;
      H.stringTypeCheck(host);
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      error = new P.Uri__parseIPv4Address_error(host);
      result = H.NativeUint8List_NativeUint8List(4);
      t1 = J.getInterceptor$s(host);
      i = start;
      partStart = i;
      partIndex = 0;
      while (true) {
        if (typeof i !== "number")
          return i.$lt();
        if (typeof end !== "number")
          return H.iae(end);
        if (!(i < end))
          break;
        char = t1.codeUnitAt$1(host, i);
        if (char !== 46) {
          if (typeof char !== "number")
            return char.$xor();
          if ((char ^ 48) >>> 0 > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2("IPv4 address should contain exactly 4 parts", i);
          part = P.int_parse(C.JSString_methods.substring$2(host, partStart, i), null, null);
          if (typeof part !== "number")
            return part.$gt();
          if (part > 255)
            error.call$2("each part must be in the range 0..255", partStart);
          partIndex0 = partIndex + 1;
          if (partIndex >= result.length)
            return H.ioore(result, partIndex);
          result[partIndex] = part;
          partStart = i + 1;
          partIndex = partIndex0;
        }
        ++i;
      }
      if (partIndex !== 3)
        error.call$2("IPv4 address should contain exactly 4 parts", end);
      part = P.int_parse(t1.substring$2(host, partStart, end), null, null);
      if (typeof part !== "number")
        return part.$gt();
      if (part > 255)
        error.call$2("each part must be in the range 0..255", partStart);
      if (partIndex >= result.length)
        return H.ioore(result, partIndex);
      result[partIndex] = part;
      return result;
    }, null, null, 12, 0, null, 170, 5, 7],
    Uri_parseIPv6Address: [function(host, start, end) {
      var error, parseHex, parts, t1, i, partStart, wildcardSeen, seenDot, char, atEnd, isLastWildcard, last, bytes, index, t2, value, wildCardLength, j;
      H.stringTypeCheck(host);
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      if (end == null)
        end = host.length;
      error = new P.Uri_parseIPv6Address_error(host);
      parseHex = new P.Uri_parseIPv6Address_parseHex(error, host);
      if (host.length < 2)
        error.call$1("address is too short");
      parts = H.setRuntimeTypeInfo([], [P.int]);
      t1 = J.getInterceptor$s(host);
      i = start;
      partStart = i;
      wildcardSeen = false;
      seenDot = false;
      while (true) {
        if (typeof i !== "number")
          return i.$lt();
        if (!(i < end))
          break;
        char = t1.codeUnitAt$1(host, i);
        if (char === 58) {
          if (i === start) {
            ++i;
            if (!J.$eq$(C.JSString_methods.codeUnitAt$1(host, i), 58))
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          if (i === partStart) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            C.JSArray_methods.add$1(parts, -1);
            wildcardSeen = true;
          } else
            C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, i));
          partStart = i + 1;
        } else if (char === 46)
          seenDot = true;
        ++i;
      }
      if (parts.length === 0)
        error.call$1("too few parts");
      atEnd = partStart === end;
      isLastWildcard = J.$eq$(C.JSArray_methods.get$last(parts), -1);
      if (atEnd && !isLastWildcard)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, end));
        else {
          last = P.Uri__parseIPv4Address(host, partStart, end);
          t1 = J.getInterceptor$asx(last);
          C.JSArray_methods.add$1(parts, J.$or$n(J.$shl$n(t1.$index(last, 0), 8), t1.$index(last, 1)));
          C.JSArray_methods.add$1(parts, J.$or$n(J.$shl$n(t1.$index(last, 2), 8), t1.$index(last, 3)));
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$1("an address with a wildcard must have less than 7 parts");
      } else if (parts.length !== 8)
        error.call$1("an address without a wildcard must contain exactly 8 parts");
      bytes = H.NativeUint8List_NativeUint8List(16);
      for (t1 = J.getInterceptor$ax(bytes), i = 0, index = 0; t2 = parts.length, i < t2; ++i) {
        value = parts[i];
        if (value === -1) {
          wildCardLength = 9 - t2;
          for (j = 0; j < wildCardLength; ++j) {
            t1.$indexSet(bytes, index, 0);
            t1.$indexSet(bytes, index + 1, 0);
            index += 2;
          }
        } else {
          if (typeof value !== "number")
            return value.$shr();
          t1.$indexSet(bytes, index, C.JSInt_methods._shrOtherPositive$1(value, 8));
          t1.$indexSet(bytes, index + 1, value & 255);
          index += 2;
        }
      }
      return bytes;
    }, null, null, 4, 4, null, 16, 0, 170, 5, 7],
    _createTables: [function() {
      var tables, t1, t2, t3, b;
      tables = P.List_List$generate(22, new P._createTables_closure(), true, P.Uint8List);
      t1 = new P._createTables_build(tables);
      t2 = new P._createTables_setChars();
      t3 = new P._createTables_setRange();
      b = H.interceptedTypeCheck(t1.call$2(0, 225), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 14);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 3);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(14, 225), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 15);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(15, 225), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(1, 225), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(2, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 139);
      t2.call$3(b, "/", 131);
      t2.call$3(b, ".", 146);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(3, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 68);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(4, 229), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(5, 229), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(6, 231), "$isUint8List");
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(7, 231), "$isUint8List");
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      t2.call$3(H.interceptedTypeCheck(t1.call$2(8, 8), "$isUint8List"), "]", 5);
      b = H.interceptedTypeCheck(t1.call$2(9, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 16);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(16, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 17);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(17, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(10, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(18, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 19);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(19, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(11, 235), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(12, 236), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 12);
      t2.call$3(b, "?", 12);
      t2.call$3(b, "#", 205);
      b = H.interceptedTypeCheck(t1.call$2(13, 237), "$isUint8List");
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 13);
      t2.call$3(b, "?", 13);
      t3.call$3(H.interceptedTypeCheck(t1.call$2(20, 245), "$isUint8List"), "az", 21);
      b = H.interceptedTypeCheck(t1.call$2(21, 245), "$isUint8List");
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    }, null, null, 0, 0, null],
    _scan: [function(uri, start, end, state, indices) {
      var tables, t1, t2, t3, i, table, char, transition;
      H.stringTypeCheck(uri);
      H.intTypeCheck(start);
      H.intTypeCheck(end);
      H.intTypeCheck(state);
      H.assertSubtype(indices, "$isList", [P.int], "$asList");
      tables = $.$get$_scannerTables();
      t1 = J.getInterceptor$ax(indices);
      t2 = J.getInterceptor$asx(tables);
      t3 = J.getInterceptor$s(uri);
      i = start;
      while (true) {
        if (typeof i !== "number")
          return i.$lt();
        if (typeof end !== "number")
          return H.iae(end);
        if (!(i < end))
          break;
        table = t2.$index(tables, state);
        char = J.$xor$n(t3.codeUnitAt$1(uri, i), 96);
        if (typeof char !== "number")
          return char.$gt();
        if (char > 95)
          char = 31;
        if (char < 0 || char >= table.length)
          return H.ioore(table, char);
        transition = table[char];
        if (typeof transition !== "number")
          return transition.$and();
        state = transition & 31;
        t1.$indexSet(indices, C.JSInt_methods._shrOtherPositive$1(transition, 5), i);
        ++i;
      }
      return state;
    }, null, null, 20, 0, null, 65, 5, 7, 78, 708],
    _startsWithData: [function(text, start) {
      var delta, t1, t2, t3, t4;
      H.stringTypeCheck(text);
      H.intTypeCheck(start);
      if (typeof start !== "number")
        return start.$add();
      delta = J.$mul$ns(J.$xor$n(J.getInterceptor$s(text).codeUnitAt$1(text, start + 4), 58), 3);
      t1 = J.$xor$n(C.JSString_methods.codeUnitAt$1(text, start), 100);
      if (typeof delta !== "number")
        return delta.$or();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.$xor$n(C.JSString_methods.codeUnitAt$1(text, start + 1), 97);
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.$xor$n(C.JSString_methods.codeUnitAt$1(text, start + 2), 116);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = J.$xor$n(C.JSString_methods.codeUnitAt$1(text, start + 3), 97);
      if (typeof t4 !== "number")
        return H.iae(t4);
      return (delta | t1 | t2 | t3 | t4) >>> 0;
    }, null, null, 8, 0, null, 17, 5],
    _stringOrNullLength: [function(s) {
      H.stringTypeCheck(s);
      return s == null ? 0 : s.length;
    }, null, null, 4, 0, null, 50],
    _symbolMapToStringMap_closure: {
      "^": "Closure:52;result,$ti",
      call$2: [function(key, value) {
        J.$indexSet$ax(this.result, P._symbolToString(H.interceptedTypeCheck(key, "$isSymbol0")), value);
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    NoSuchMethodError_toString_closure: {
      "^": "Closure:52;_box_0,sb,$ti",
      call$2: [function(key, value) {
        var t1, t2;
        H.interceptedTypeCheck(key, "$isSymbol0");
        t1 = this.sb;
        t2 = this._box_0;
        t1.write$1(t2.comma);
        t1.write$1(P._symbolToString(key));
        t1.write$1(": ");
        t1.write$1(P.Error_safeToString(value));
        t2.comma = ", ";
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    _CompileTimeError: {
      "^": "Error;$ti"
    },
    _DuplicatedFieldInitializerError: {
      "^": "Error;$ti"
    },
    _BigIntImpl: {
      "^": "Object;$ti",
      $isBigInt: 1,
      $isComparable: 1,
      $asComparable: function() {
        return [P.BigInt];
      }
    },
    _BigIntReduction: {
      "^": "Object;$ti"
    },
    _BigIntClassic: {
      "^": "Object;$ti",
      $is_BigIntReduction: 1
    },
    Deprecated: {
      "^": "Object;$ti"
    },
    _Override: {
      "^": "Object;$ti"
    },
    Provisional: {
      "^": "Object;$ti"
    },
    _Proxy0: {
      "^": "Object;$ti"
    },
    pragma: {
      "^": "Object;$ti"
    },
    BigInt: {
      "^": "Object;$ti",
      $isComparable: 1,
      $asComparable: function() {
        return [P.BigInt];
      }
    },
    bool: {
      "^": "Object;$ti"
    },
    "+bool": 0,
    Comparable: {
      "^": "Object;$ti"
    },
    DateTime: {
      "^": "Object;_core$_value,isUtc,$ti",
      difference$1: [function(other) {
        return P.Duration$(0, 0, 0, J.$sub$n(this._core$_value, H.interceptedTypeCheck(other, "$isDateTime")._core$_value), 0, 0);
      }, null, "get$difference", 4, 0, null, 3],
      get$millisecondsSinceEpoch: [function() {
        return this._core$_value;
      }, null, null, 2, 0, null],
      get$year: [function() {
        return H.intTypeCheck(H.Primitives_getYear(this));
      }, null, null, 2, 0, null],
      get$month: [function() {
        return H.intTypeCheck(H.Primitives_getMonth(this));
      }, null, null, 2, 0, null],
      get$day: [function() {
        return H.intTypeCheck(H.Primitives_getDay(this));
      }, null, null, 2, 0, null],
      get$hour: [function() {
        return H.intTypeCheck(H.Primitives_getHours(this));
      }, null, null, 2, 0, null],
      get$minute: [function() {
        return H.intTypeCheck(H.Primitives_getMinutes(this));
      }, null, null, 2, 0, null],
      get$second: [function() {
        return H.intTypeCheck(H.Primitives_getSeconds(this));
      }, null, null, 2, 0, null],
      get$millisecond: [function() {
        return H.intTypeCheck(H.Primitives_getMilliseconds(this));
      }, null, null, 2, 0, null],
      get$microsecond: [function() {
        return 0;
      }, null, null, 2, 0, null],
      get$weekday: [function() {
        return H.intTypeCheck(H.Primitives_getWeekday(this));
      }, null, null, 2, 0, null],
      DateTime$_withValue$2$isUtc: [function(_value, isUtc) {
        var t1;
        if (!J.$gt$n(J.abs$0$in(this.get$millisecondsSinceEpoch()), 864e13))
          t1 = J.$eq$(J.abs$0$in(this.get$millisecondsSinceEpoch()), 864e13) && !J.$eq$(this.get$microsecond(), 0);
        else
          t1 = true;
        if (t1)
          throw H.wrapException(P.ArgumentError$("DateTime is outside valid range: " + H.S(this.get$millisecondsSinceEpoch())));
        if (this.isUtc == null)
          throw H.wrapException(P.ArgumentError$("'isUtc' flag may not be 'null'"));
      }, null, null, 4, 3, null, 0, 372, 317],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.DateTime))
          return false;
        return J.$eq$(this._core$_value, other._core$_value) && J.$eq$(this.isUtc, other.isUtc);
      }, null, "get$==", 5, 0, null, 3],
      compareTo$1: [function(_, other) {
        return J.compareTo$1$ns(this._core$_value, H.interceptedTypeCheck(other, "$isDateTime")._core$_value);
      }, null, "get$compareTo", 5, 0, null, 3],
      get$hashCode: [function(_) {
        var t1, t2;
        t1 = this._core$_value;
        t2 = J.getInterceptor$n(t1);
        return J.$and$bn(t2.$xor(t1, t2.$shr(t1, 30)), 1073741823);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        var y, m, d, h, min, sec, ms, us;
        y = P.DateTime__fourDigits(this.get$year());
        m = P.DateTime__twoDigits(this.get$month());
        d = P.DateTime__twoDigits(this.get$day());
        h = P.DateTime__twoDigits(this.get$hour());
        min = P.DateTime__twoDigits(this.get$minute());
        sec = P.DateTime__twoDigits(this.get$second());
        ms = P.DateTime__threeDigits(this.get$millisecond());
        us = J.$eq$(this.get$microsecond(), 0) ? "" : P.DateTime__threeDigits(this.get$microsecond());
        if (this.isUtc)
          return H.S(y) + "-" + H.S(m) + "-" + H.S(d) + " " + H.S(h) + ":" + H.S(min) + ":" + H.S(sec) + "." + H.S(ms) + H.S(us) + "Z";
        else
          return H.S(y) + "-" + H.S(m) + "-" + H.S(d) + " " + H.S(h) + ":" + H.S(min) + ":" + H.S(sec) + "." + H.S(ms) + H.S(us);
      }, null, "get$toString", 1, 0, null],
      $isComparable: 1,
      $asComparable: function() {
        return [P.DateTime];
      },
      static: {
        DateTime$fromMillisecondsSinceEpoch: [function(millisecondsSinceEpoch, isUtc) {
          var t1;
          if (typeof millisecondsSinceEpoch !== "number")
            return H.iae(millisecondsSinceEpoch);
          t1 = new P.DateTime(millisecondsSinceEpoch, isUtc, []);
          t1.DateTime$_withValue$2$isUtc(millisecondsSinceEpoch, isUtc);
          return t1;
        }, null, null, 4, 3, null, 18, 886, 317],
        DateTime__microsecondInRoundedMilliseconds: [function(microsecond) {
          H.intTypeCheck(microsecond);
          if (typeof microsecond !== "number")
            return microsecond.$div();
          return C.JSDouble_methods.round$0(microsecond / 1000);
        }, null, null, 4, 0, null, 352],
        DateTime$: [function(year, month, day, hour, minute, second, millisecond, microsecond) {
          var t1 = P.DateTime__microsecondInRoundedMilliseconds(microsecond);
          if (typeof millisecond !== "number")
            return millisecond.$add();
          if (typeof t1 !== "number")
            return H.iae(t1);
          return new P.DateTime(H.intTypeCheck(H.checkInt(H.Primitives_valueFromDecomposedDate(year, month, day, hour, minute, second, millisecond + t1, false))), false, []);
        }, null, null, 4, 14, null, 205, 205, 16, 16, 16, 16, 16, 555, 238, 237, 560, 561, 562, 564, 352],
        DateTime$now: [function() {
          return new P.DateTime(H.intTypeCheck(H.Primitives_dateNow()), false, []);
        }, null, null, 0, 0, null],
        DateTime__fourDigits: [function(n) {
          var absN, sign;
          H.intTypeCheck(n);
          if (typeof n !== "number")
            return n.abs$0();
          absN = Math.abs(n);
          sign = n < 0 ? "-" : "";
          if (absN >= 1000)
            return "" + n;
          if (absN >= 100)
            return sign + "0" + absN;
          if (absN >= 10)
            return sign + "00" + absN;
          return sign + "000" + absN;
        }, null, null, 4, 0, null, 72],
        DateTime__threeDigits: [function(n) {
          H.intTypeCheck(n);
          if (typeof n !== "number")
            return n.$ge();
          if (n >= 100)
            return "" + n;
          if (n >= 10)
            return "0" + n;
          return "00" + n;
        }, null, null, 4, 0, null, 72],
        DateTime__twoDigits: [function(n) {
          H.intTypeCheck(n);
          if (typeof n !== "number")
            return n.$ge();
          if (n >= 10)
            return "" + n;
          return "0" + n;
        }, null, null, 4, 0, null, 72]
      }
    },
    double: {
      "^": "num;$ti"
    },
    "+double": 0,
    Duration: {
      "^": "Object;_duration,$ti",
      $add: [function(_, other) {
        return P.Duration$_microseconds(J.$add$ansx(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration));
      }, null, "get$+", 5, 0, null, 3],
      $sub: [function(_, other) {
        return P.Duration$_microseconds(J.$sub$n(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration));
      }, null, "get$-", 5, 0, null, 3],
      $mul: [function(_, factor) {
        return P.Duration$_microseconds(J.round$0$n(J.$mul$ns(this._duration, H.numTypeCheck(factor))));
      }, null, "get$*", 5, 0, null, 373],
      $tdiv: [function(_, quotient) {
        H.intTypeCheck(quotient);
        if (quotient === 0)
          throw H.wrapException(P.IntegerDivisionByZeroException$());
        return P.Duration$_microseconds(J.$tdiv$n(this._duration, quotient));
      }, null, "get$~/", 5, 0, null, 750],
      $lt: [function(_, other) {
        return J.$lt$n(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
      }, null, "get$<", 5, 0, null, 3],
      $gt: [function(_, other) {
        return J.$gt$n(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
      }, null, "get$>", 5, 0, null, 3],
      $le: [function(_, other) {
        return J.$le$n(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
      }, null, "get$<=", 5, 0, null, 3],
      $ge: [function(_, other) {
        return J.$ge$n(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
      }, null, "get$>=", 5, 0, null, 3],
      get$inHours: [function() {
        return J.$tdiv$n(this._duration, 3600000000);
      }, null, null, 2, 0, null],
      get$inMinutes: [function() {
        return J.$tdiv$n(this._duration, 60000000);
      }, null, null, 2, 0, null],
      get$inSeconds: [function() {
        return J.$tdiv$n(this._duration, 1000000);
      }, null, null, 2, 0, null],
      get$inMilliseconds: [function() {
        return J.$tdiv$n(this._duration, 1000);
      }, null, null, 2, 0, null],
      get$inMicroseconds: [function() {
        return this._duration;
      }, null, null, 2, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.Duration))
          return false;
        return J.$eq$(this._duration, other._duration);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this._duration);
      }, null, null, 3, 0, null],
      compareTo$1: [function(_, other) {
        return J.compareTo$1$ns(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
      }, null, "get$compareTo", 5, 0, null, 3],
      toString$0: [function(_) {
        var t1, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
        t1 = new P.Duration_toString_twoDigits();
        if (J.$lt$n(this.get$inMicroseconds(), 0))
          return "-" + H.S(this.$negate(0));
        twoDigitMinutes = t1.call$1(H.intTypeCheck(J.remainder$1$n(this.get$inMinutes(), 60)));
        twoDigitSeconds = t1.call$1(H.intTypeCheck(J.remainder$1$n(this.get$inSeconds(), 60)));
        sixDigitUs = new P.Duration_toString_sixDigits().call$1(H.intTypeCheck(J.remainder$1$n(this.get$inMicroseconds(), 1000000)));
        return H.S(this.get$inHours()) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
      }, null, "get$toString", 1, 0, null],
      get$isNegative: [function(_) {
        return J.$lt$n(this._duration, 0);
      }, null, null, 3, 0, null],
      abs$0: [function(_) {
        return P.Duration$_microseconds(J.abs$0$in(this._duration));
      }, null, "get$abs", 1, 0, null],
      $negate: [function(_) {
        var t1 = this._duration;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return P.Duration$_microseconds(0 - t1);
      }, null, "get$unary-", 1, 0, null],
      $isComparable: 1,
      $asComparable: function() {
        return [P.Duration];
      },
      static: {
        Duration$: [function(days, hours, microseconds, milliseconds, minutes, seconds) {
          if (typeof days !== "number")
            return H.iae(days);
          if (typeof hours !== "number")
            return H.iae(hours);
          if (typeof minutes !== "number")
            return H.iae(minutes);
          if (typeof seconds !== "number")
            return H.iae(seconds);
          if (typeof milliseconds !== "number")
            return H.iae(milliseconds);
          if (typeof microseconds !== "number")
            return H.iae(microseconds);
          return new P.Duration(864e8 * days + 3600000000 * hours + 60000000 * minutes + 1000000 * seconds + 1000 * milliseconds + microseconds, []);
        }, null, null, 0, 13, null, 16, 16, 16, 16, 16, 16, 567, 358, 570, 236, 359, 361],
        Duration$_microseconds: [function(_duration) {
          return new P.Duration(_duration, []);
        }, null, null, 4, 0, null, 572]
      }
    },
    Duration_toString_sixDigits: {
      "^": "Closure:29;$ti",
      call$1: [function(n) {
        H.intTypeCheck(n);
        if (typeof n !== "number")
          return n.$ge();
        if (n >= 100000)
          return "" + n;
        if (n >= 10000)
          return "0" + n;
        if (n >= 1000)
          return "00" + n;
        if (n >= 100)
          return "000" + n;
        if (n >= 10)
          return "0000" + n;
        return "00000" + n;
      }, null, null, 4, 0, null, 72, "call"]
    },
    Duration_toString_twoDigits: {
      "^": "Closure:29;$ti",
      call$1: [function(n) {
        H.intTypeCheck(n);
        if (typeof n !== "number")
          return n.$ge();
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }, null, null, 4, 0, null, 72, "call"]
    },
    Error: {
      "^": "Object;$ti"
    },
    AssertionError: {
      "^": "Error;$ti"
    },
    TypeError: {
      "^": "AssertionError;$ti"
    },
    CastError: {
      "^": "Error;$ti"
    },
    NullThrownError: {
      "^": "Error;$ti",
      toString$0: [function(_) {
        return "Throw of null.";
      }, null, "get$toString", 1, 0, null],
      static: {
        NullThrownError$: [function() {
          return new P.NullThrownError([]);
        }, null, null, 0, 0, null]
      }
    },
    ArgumentError: {
      "^": "Error;_hasValue,invalidValue,name>,message>,$ti",
      get$_errorName: [function() {
        return "Invalid argument" + (!this._hasValue ? "(s)" : "");
      }, null, null, 2, 0, null],
      get$_errorExplanation: [function() {
        return "";
      }, null, null, 2, 0, null],
      toString$0: [function(_) {
        var t1, nameString, message, prefix, explanation, errorValue;
        t1 = this.name;
        nameString = t1 != null ? " (" + H.S(t1) + ")" : "";
        t1 = this.message;
        message = t1 == null ? "" : ": " + H.S(t1);
        prefix = H.S(this.get$_errorName()) + nameString + message;
        if (!this._hasValue)
          return prefix;
        explanation = this.get$_errorExplanation();
        errorValue = P.Error_safeToString(this.invalidValue);
        return prefix + H.S(explanation) + ": " + H.S(errorValue);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        ArgumentError$: [function(message) {
          return new P.ArgumentError(false, null, null, message, []);
        }, null, null, 0, 2, null, 0, 21],
        ArgumentError$value: [function(value, $name, message) {
          return new P.ArgumentError(true, value, $name, message, []);
        }, null, null, 4, 4, null, 0, 0, 1, 8, 21],
        ArgumentError$notNull: [function($name) {
          return new P.ArgumentError(false, null, $name, "Must not be null", []);
        }, null, null, 0, 2, null, 0, 8]
      }
    },
    RangeError: {
      "^": "ArgumentError;start>,end<,_hasValue,invalidValue,name,message,$ti",
      get$_errorName: [function() {
        return "RangeError";
      }, null, null, 2, 0, null],
      get$_errorExplanation: [function() {
        var t1, explanation, t2, t3;
        t1 = this.start;
        if (t1 == null) {
          t1 = this.end;
          explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
        } else {
          t2 = this.end;
          if (t2 == null)
            explanation = ": Not greater than or equal to " + H.S(t1);
          else {
            t3 = J.getInterceptor$n(t2);
            if (t3.$gt(t2, t1))
              explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
            else
              explanation = t3.$lt(t2, t1) ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
          }
        }
        return explanation;
      }, null, null, 2, 0, null],
      static: {
        RangeError$: [function(message) {
          return new P.RangeError(null, null, false, null, null, message, []);
        }, null, null, 4, 0, null, 21],
        RangeError$value: [function(value, $name, message) {
          var t1 = message != null ? message : "Value not in range";
          return new P.RangeError(null, null, true, value, $name, t1, []);
        }, null, null, 4, 4, null, 0, 0, 1, 8, 21],
        RangeError$range: [function(invalidValue, minValue, maxValue, $name, message) {
          var t1 = message != null ? message : "Invalid value";
          return new P.RangeError(minValue, maxValue, true, invalidValue, $name, t1, []);
        }, null, null, 12, 4, null, 0, 0, 355, 356, 357, 8, 21],
        RangeError_checkValueInInterval: [function(value, minValue, maxValue, $name, message) {
          var t1;
          H.intTypeCheck(value);
          H.intTypeCheck(minValue);
          H.intTypeCheck(maxValue);
          H.stringTypeCheck($name);
          H.stringTypeCheck(message);
          if (typeof value !== "number")
            return value.$lt();
          if (typeof minValue !== "number")
            return H.iae(minValue);
          if (value >= minValue) {
            if (typeof maxValue !== "number")
              return H.iae(maxValue);
            t1 = value > maxValue;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, message));
        }, null, null, 12, 4, null, 0, 0, 1, 356, 357, 8, 21],
        RangeError_checkValidRange: [function(start, end, $length, startName, endName, message) {
          var t1;
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.intTypeCheck($length);
          H.stringTypeCheck(startName);
          H.stringTypeCheck(endName);
          H.stringTypeCheck(message);
          if (typeof start !== "number")
            return H.iae(start);
          if (0 <= start) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = start > $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.RangeError$range(start, 0, $length, startName == null ? "start" : startName, message));
          if (end != null) {
            if (!(start > end)) {
              if (typeof $length !== "number")
                return H.iae($length);
              t1 = end > $length;
            } else
              t1 = true;
            if (t1)
              throw H.wrapException(P.RangeError$range(end, start, $length, endName == null ? "end" : endName, message));
            return end;
          }
          return $length;
        }, null, null, 12, 6, null, 0, 0, 0, 5, 7, 35, 581, 582, 21],
        RangeError_checkNotNegative: [function(value, $name, message) {
          H.intTypeCheck(value);
          H.stringTypeCheck($name);
          H.stringTypeCheck(message);
          if (typeof value !== "number")
            return value.$lt();
          if (value < 0)
            throw H.wrapException(P.RangeError$range(value, 0, null, $name, message));
        }, null, null, 4, 4, null, 0, 0, 1, 8, 21]
      }
    },
    IndexError: {
      "^": "ArgumentError;indexable,length>,_hasValue,invalidValue,name,message,$ti",
      get$start: [function(_) {
        return 0;
      }, null, null, 3, 0, null],
      get$end: [function() {
        return J.$sub$n(this.length, 1);
      }, null, null, 2, 0, null],
      get$_errorName: [function() {
        return "RangeError";
      }, null, null, 2, 0, null],
      get$_errorExplanation: [function() {
        if (H.boolTypeCheck(J.$lt$n(this.invalidValue, 0)))
          return ": index must not be negative";
        var t1 = this.length;
        if (J.$eq$(t1, 0))
          return ": no indices are valid";
        return ": index should be less than " + H.S(t1);
      }, null, null, 2, 0, null],
      $isRangeError: 1,
      static: {
        IndexError$: [function(invalidValue, indexable, $name, message, $length) {
          var t1, t2;
          t1 = H.intTypeCheck($length != null ? $length : J.get$length$asx(indexable));
          t2 = message != null ? message : "Index out of range";
          return new P.IndexError(indexable, t1, true, invalidValue, $name, t2, []);
        }, null, null, 8, 6, null, 0, 0, 0, 355, 389, 8, 21, 35]
      }
    },
    FallThroughError: {
      "^": "Error;$ti"
    },
    AbstractClassInstantiationError: {
      "^": "Error;$ti"
    },
    NoSuchMethodError: {
      "^": "Error;_core$_receiver,_memberName,_core$_arguments,_namedArguments,_existingArgumentNames,$ti",
      toString$0: [function(_) {
        var _box_0, sb, t1, argument, memberName, receiverText, actualParameters, formalParameters;
        _box_0 = {};
        sb = P.StringBuffer$("");
        _box_0.comma = "";
        t1 = this._core$_arguments;
        if (t1 != null)
          for (t1 = J.get$iterator$ax(t1); t1.moveNext$0();) {
            argument = t1.get$current();
            sb.write$1(_box_0.comma);
            sb.write$1(P.Error_safeToString(argument));
            _box_0.comma = ", ";
          }
        t1 = this._namedArguments;
        if (t1 != null)
          J.forEach$1$ax(t1, new P.NoSuchMethodError_toString_closure(_box_0, sb));
        memberName = P._symbolToString(this._memberName);
        receiverText = P.Error_safeToString(this._core$_receiver);
        actualParameters = H.S(sb);
        t1 = this._existingArgumentNames;
        if (t1 == null)
          return "NoSuchMethodError: method not found: '" + H.S(memberName) + "'\nReceiver: " + H.S(receiverText) + "\nArguments: [" + actualParameters + "]";
        else {
          formalParameters = J.join$1$ax(t1, ", ");
          return "NoSuchMethodError: incorrect number of arguments passed to method named '" + H.S(memberName) + "'\nReceiver: " + H.S(receiverText) + "\nTried calling: " + H.S(memberName) + "(" + actualParameters + ")\nFound: " + H.S(memberName) + "(" + H.S(formalParameters) + ")";
        }
      }, null, "get$toString", 1, 0, null],
      static: {
        NoSuchMethodError$: [function(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
          return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames, []);
        }, null, null, 16, 2, null, 0, 38, 142, 153, 157, 966]
      }
    },
    UnsupportedError: {
      "^": "Error;message>,$ti",
      toString$0: [function(_) {
        return "Unsupported operation: " + H.S(this.message);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        UnsupportedError$: [function(message) {
          return new P.UnsupportedError(message, []);
        }, null, null, 4, 0, null, 21]
      }
    },
    UnimplementedError: {
      "^": "Error;message>,$ti",
      toString$0: [function(_) {
        var t1 = this.message;
        return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isUnsupportedError: 1,
      static: {
        UnimplementedError$: [function(message) {
          return new P.UnimplementedError(message, []);
        }, null, null, 0, 2, null, 0, 21]
      }
    },
    StateError: {
      "^": "Error;message>,$ti",
      toString$0: [function(_) {
        return "Bad state: " + H.S(this.message);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        StateError$: [function(message) {
          return new P.StateError(message, []);
        }, null, null, 4, 0, null, 21]
      }
    },
    ConcurrentModificationError: {
      "^": "Error;modifiedObject,$ti",
      toString$0: [function(_) {
        var t1 = this.modifiedObject;
        if (t1 == null)
          return "Concurrent modification during iteration.";
        return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
      }, null, "get$toString", 1, 0, null],
      static: {
        ConcurrentModificationError$: [function(modifiedObject) {
          return new P.ConcurrentModificationError(modifiedObject, []);
        }, null, null, 0, 2, null, 0, 587]
      }
    },
    OutOfMemoryError: {
      "^": "Object;$ti",
      toString$0: [function(_) {
        return "Out of Memory";
      }, null, "get$toString", 1, 0, null],
      $isError: 1
    },
    StackOverflowError: {
      "^": "Object;$ti",
      toString$0: [function(_) {
        return "Stack Overflow";
      }, null, "get$toString", 1, 0, null],
      $isError: 1,
      static: {
        StackOverflowError$: [function() {
          return new P.StackOverflowError([]);
        }, null, null, 0, 0, null]
      }
    },
    CyclicInitializationError: {
      "^": "Error;variableName,$ti",
      toString$0: [function(_) {
        var t1 = this.variableName;
        return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + H.S(t1) + "' during its initialization";
      }, null, "get$toString", 1, 0, null],
      static: {
        CyclicInitializationError$: [function(variableName) {
          return new P.CyclicInitializationError(variableName, []);
        }, null, null, 0, 2, null, 0, 589]
      }
    },
    _ConstantHelper: {
      "^": "Object;$ti"
    },
    Exception: {
      "^": "Object;$ti"
    },
    _Exception: {
      "^": "Object;message>,$ti",
      toString$0: [function(_) {
        var t1 = this.message;
        if (t1 == null)
          return "Exception";
        return "Exception: " + H.S(t1);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isException: 1,
      static: {
        _Exception$: [function(message) {
          return new P._Exception(message, []);
        }, null, null, 0, 2, null, 0, 21]
      }
    },
    FormatException: {
      "^": "Object;message>,source>,offset>,$ti",
      toString$0: [function(_) {
        var t1, report, offset, source, lineNum, lineStart, previousCharWasCR, i, char, lineEnd, end, start, prefix, postfix, slice;
        t1 = this.message;
        report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
        offset = this.offset;
        source = this.source;
        if (typeof source !== "string")
          return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
        if (offset != null)
          t1 = offset < 0 || offset > source.length;
        else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          if (source.length > 78)
            source = J.$add$ansx(C.JSString_methods.substring$2(source, 0, 75), "...");
          return report + "\n" + H.S(source);
        }
        for (lineNum = 1, lineStart = 0, previousCharWasCR = false, i = 0; i < offset; ++i) {
          char = H.intTypeCheck(C.JSString_methods._codeUnitAt$1(source, i));
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
        lineEnd = source.length;
        for (i = offset; i < source.length; ++i) {
          char = H.intTypeCheck(C.JSString_methods.codeUnitAt$1(source, i));
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = H.stringTypeCheck(C.JSString_methods.substring$2(source, start, end));
        return H.S(report) + prefix + H.S(slice) + postfix + "\n" + H.S(C.JSString_methods.$mul(" ", offset - start + prefix.length)) + "^\n";
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isException: 1,
      static: {
        FormatException$: [function(message, source, offset) {
          return new P.FormatException(message, source, offset, []);
        }, null, null, 0, 6, null, 39, 0, 0, 21, 11, 52]
      }
    },
    IntegerDivisionByZeroException: {
      "^": "Object;$ti",
      toString$0: [function(_) {
        return "IntegerDivisionByZeroException";
      }, null, "get$toString", 1, 0, null],
      $isException: 1,
      static: {
        IntegerDivisionByZeroException$: [function() {
          return new P.IntegerDivisionByZeroException([]);
        }, null, null, 0, 0, null]
      }
    },
    Expando: {
      "^": "Object;_jsWeakMapOrKey,name>,$ti",
      $index: [function(_, object) {
        var t1 = this._jsWeakMapOrKey;
        if (typeof t1 !== "string") {
          P.Expando__checkType(object);
          return t1.get(object);
        }
        return H.assertSubtypeOfRuntimeType(P.Expando__getFromObject(t1, object), H.getTypeArgumentByIndex(this, 0));
      }, null, "get$[]", 5, 0, null, 9],
      $indexSet: [function(_, object, value) {
        var t1;
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
        t1 = this._jsWeakMapOrKey;
        if (typeof t1 !== "string")
          t1.set(object, value);
        else
          P.Expando__setOnObject(t1, object, value);
      }, null, "get$[]=", 9, 0, null, 9, 1],
      toString$0: [function(_) {
        return "Expando:" + H.S(this.name);
      }, null, "get$toString", 1, 0, null],
      static: {
        Expando$: [function($name, $T) {
          var t1 = typeof WeakMap == "function" ? new WeakMap() : P.Expando__createKey();
          return new P.Expando(t1, $name, [$T]);
        }, null, null, 0, 2, null, 0, 8],
        Expando__getFromObject: [function(key, object) {
          var values;
          H.stringTypeCheck(key);
          values = H.Primitives_getProperty(object, "expando$values");
          return values == null ? null : H.Primitives_getProperty(values, key);
        }, null, null, 8, 0, null, 4, 9],
        Expando__setOnObject: [function(key, object, value) {
          var values;
          H.stringTypeCheck(key);
          values = H.Primitives_getProperty(object, "expando$values");
          if (values == null) {
            values = P.Object$();
            H.Primitives_setProperty(object, "expando$values", values);
          }
          H.Primitives_setProperty(values, key, value);
        }, null, null, 12, 0, null, 4, 9, 1],
        Expando__createKey: [function() {
          var t1 = $.Expando__keyCount;
          $.Expando__keyCount = J.$add$ansx(t1, 1);
          return "expando$key$" + H.S(t1);
        }, null, null, 0, 0, null],
        Expando__checkType: [function(object) {
          if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
            throw H.wrapException(P.ArgumentError$value(object, "Expandos are not allowed on strings, numbers, booleans or null", null));
        }, null, null, 4, 0, null, 9]
      }
    },
    Function: {
      "^": "Object;$ti"
    },
    int: {
      "^": "num;$ti"
    },
    "+int": 0,
    Invocation: {
      "^": "Object;$ti"
    },
    _Invocation: {
      "^": "Object;$ti",
      $isInvocation: 1
    },
    Iterable: {
      "^": "Object;$ti",
      cast$1$0: [1, function(_, $R) {
        return P.Iterable_castFrom(this, H.getRuntimeTypeArgument(this, "Iterable", 0), $R);
      }, function($receiver) {
        return this.cast$1$0($receiver, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      map$1$1: [1, function(_, f, $T) {
        var t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
        return H.MappedIterable_MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      where$1: ["super$Iterable$where", function(_, test) {
        var t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
        return H.WhereIterable$(this, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]}), t1);
      }, null, "get$where", 5, 0, null, 41],
      contains$1: [function(_, element) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (J.$eq$(t1.get$current(), element))
            return true;
        return false;
      }, null, "get$contains", 5, 0, null, 10],
      forEach$1: [function(_, f) {
        var t1;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "Iterable", 0)]});
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          f.call$1(t1.get$current());
      }, null, "get$forEach", 5, 0, null, 15],
      join$1: [function(_, separator) {
        var iterator, buffer;
        H.stringTypeCheck(separator);
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          return "";
        buffer = P.StringBuffer$("");
        if (separator == null || separator === "") {
          do
            buffer.write$1(H.S(iterator.get$current()));
          while (iterator.moveNext$0());
        } else {
          buffer.write$1(H.S(iterator.get$current()));
          for (; iterator.moveNext$0();) {
            buffer.write$1(separator);
            buffer.write$1(H.S(iterator.get$current()));
          }
        }
        return buffer.toString$0(0);
      }, null, "get$join", 1, 2, null, 39, 90],
      any$1: [function(_, test) {
        var t1;
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "Iterable", 0)]});
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (test.call$1(t1.get$current()))
            return true;
        return false;
      }, null, "get$any", 5, 0, null, 41],
      toList$1$growable: [function(_, growable) {
        return P.List_List$from(this, H.boolTypeCheck(growable), H.getRuntimeTypeArgument(this, "Iterable", 0));
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95],
      get$length: [function(_) {
        var it, count;
        it = this.get$iterator(this);
        for (count = 0; it.moveNext$0();)
          ++count;
        return count;
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return !this.get$iterator(this).moveNext$0();
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 3, 0, null],
      take$1: [function(_, count) {
        return H.TakeIterable_TakeIterable(this, H.intTypeCheck(count), H.getRuntimeTypeArgument(this, "Iterable", 0));
      }, null, "get$take", 5, 0, null, 42],
      skip$1: [function(_, count) {
        return H.SkipIterable_SkipIterable(this, H.intTypeCheck(count), H.getRuntimeTypeArgument(this, "Iterable", 0));
      }, null, "get$skip", 5, 0, null, 42],
      get$first: [function(_) {
        var it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current();
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        do
          result = it.get$current();
        while (it.moveNext$0());
        return result;
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        result = it.get$current();
        if (it.moveNext$0())
          throw H.wrapException(H.IterableElementError_tooMany());
        return result;
      }, null, null, 3, 0, null],
      firstWhere$2$orElse: [function(_, test, orElse) {
        var t1, element;
        t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        for (t1 = this.get$iterator(this); t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element))
            return element;
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$firstWhere", 5, 3, null, 0, 41, 98],
      lastWhere$2$orElse: [function(_, test, orElse) {
        var t1, result, foundMatching, element;
        t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
        H.functionTypeCheck(orElse, {func: 1, ret: t1});
        for (t1 = this.get$iterator(this), result = null, foundMatching = false; t1.moveNext$0();) {
          element = t1.get$current();
          if (test.call$1(element)) {
            result = element;
            foundMatching = true;
          }
        }
        if (foundMatching)
          return result;
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      elementAt$1: [function(_, index) {
        var t1, elementIndex, element;
        H.intTypeCheck(index);
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        P.RangeError_checkNotNegative(index, "index", null);
        for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
          element = t1.get$current();
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      }, null, "get$elementAt", 5, 0, null, 6],
      toString$0: [function(_) {
        return P.IterableBase_iterableToShortString(this, "(", ")");
      }, null, "get$toString", 1, 0, null]
    },
    _GeneratorIterable: {
      "^": "ListIterable;$ti"
    },
    BidirectionalIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    Iterator: {
      "^": "Object;$ti"
    },
    List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    "+List": 0,
    Map: {
      "^": "Object;$ti"
    },
    MapEntry: {
      "^": "Object;key,value>,$ti",
      toString$0: [function(_) {
        return "MapEntry(" + H.S(this.key) + ": " + H.S(this.value) + ")";
      }, null, "get$toString", 1, 0, null],
      static: {
        MapEntry$_: [function(key, value, $K, $V) {
          return new P.MapEntry(key, value, [$K, $V]);
        }, null, null, 8, 0, null, 4, 1]
      }
    },
    Null: {
      "^": "Object;$ti",
      get$hashCode: [function(_) {
        return P.Object.prototype.get$hashCode.call(this, this);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return "null";
      }, null, "get$toString", 1, 0, null]
    },
    "+Null": 0,
    num: {
      "^": "Object;$ti",
      $isComparable: 1,
      $asComparable: function() {
        return [P.num];
      }
    },
    "+num": 0,
    Object: {
      "^": ";$ti",
      $eq: [function(_, other) {
        return this === other;
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return H.Primitives_objectHashCode(this);
      }, null, null, 3, 0, null],
      toString$0: ["super$Object$toString", function(_) {
        return H.Primitives_objectToHumanReadableString(this);
      }, null, "get$toString", 1, 0, null],
      noSuchMethod$1: [function(_, invocation) {
        H.interceptedTypeCheck(invocation, "$isInvocation");
        throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      }, null, "get$noSuchMethod", 5, 0, null, 306],
      get$runtimeType: [function(_) {
        return H.getRuntimeType(this);
      }, null, null, 3, 0, null],
      toString: function() {
        return this.toString$0(this);
      },
      static: {
        Object$: [function() {
          return new P.Object([]);
        }, null, null, 0, 0, null]
      }
    },
    Pattern: {
      "^": "Object;$ti"
    },
    Match: {
      "^": "Object;$ti"
    },
    RegExp: {
      "^": "Object;$ti",
      $isPattern: 1
    },
    Set: {
      "^": "EfficientLengthIterable;$ti"
    },
    Sink: {
      "^": "Object;$ti"
    },
    StackTrace: {
      "^": "Object;$ti"
    },
    _StringStackTrace: {
      "^": "Object;$ti",
      $isStackTrace: 1
    },
    Stopwatch: {
      "^": "Object;_core$_start,_stop,$ti",
      Stopwatch$0: [function() {
        if ($.Stopwatch__frequency == null)
          P.Stopwatch__initTicker();
      }, null, null, 0, 0, null],
      get$frequency: [function() {
        return $.Stopwatch__frequency;
      }, null, null, 2, 0, null],
      start$0: [function(_) {
        if (this._stop != null) {
          this._core$_start = H.intTypeCheck(J.$add$ansx(this._core$_start, J.$sub$n(P.Stopwatch__now(), this._stop)));
          this._stop = null;
        }
      }, "call$0", "get$start", 1, 0, 0],
      stop$0: [function(_) {
        if (this._stop == null)
          this._stop = H.intTypeCheck(P.Stopwatch__now());
      }, null, "get$stop", 1, 0, null],
      get$elapsedTicks: [function() {
        var t1 = this._stop;
        if (t1 == null)
          t1 = P.Stopwatch__now();
        return J.$sub$n(t1, this._core$_start);
      }, null, null, 2, 0, null],
      get$elapsed: [function() {
        return P.Duration$(0, 0, this.get$elapsedMicroseconds(), 0, 0, 0);
      }, null, null, 2, 0, null],
      get$elapsedMicroseconds: [function() {
        return J.$tdiv$n(J.$mul$ns(this.get$elapsedTicks(), 1000000), this.get$frequency());
      }, null, null, 2, 0, null],
      static: {
        Stopwatch__initTicker: [function() {
          H.Primitives_initTicker();
          $.Stopwatch__frequency = $.Primitives_timerFrequency;
        }, null, null, 0, 0, null],
        Stopwatch__now: [function() {
          return H.intTypeCheck($.Primitives_timerTicks.call$0());
        }, null, null, 0, 0, null],
        Stopwatch$: [function() {
          var t1 = new P.Stopwatch(0, 0, []);
          t1.Stopwatch$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    String: {
      "^": "Object;$ti",
      $isComparable: 1,
      $asComparable: function() {
        return [P.String];
      },
      $isPattern: 1
    },
    "+String": 0,
    Runes: {
      "^": "Iterable;$ti",
      $asIterable: function() {
        return [P.int];
      }
    },
    RuneIterator: {
      "^": "Object;$ti",
      $isBidirectionalIterator: 1,
      $asBidirectionalIterator: function() {
        return [P.int];
      },
      $isIterator: 1,
      $asIterator: function() {
        return [P.int];
      }
    },
    StringBuffer: {
      "^": "Object;_contents,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this._contents);
      }, null, null, 3, 0, null],
      write$1: [function(obj) {
        this._writeString$1(H.S(obj));
      }, null, "get$write", 4, 0, null, 85],
      writeCharCode$1: [function(charCode) {
        this._writeString$1(P.String_String$fromCharCode(H.intTypeCheck(charCode)));
      }, null, "get$writeCharCode", 4, 0, null, 93],
      writeAll$2: [function(objects, separator) {
        H.listSuperNativeTypeCheck(objects, "$isIterable");
        H.stringTypeCheck(separator);
        this._contents = H.stringTypeCheck(P.StringBuffer__writeAll(this._contents, objects, separator));
      }, null, "get$writeAll", 4, 2, null, 39, 354, 90],
      writeln$1: [function(obj) {
        this._writeString$1(H.S(obj) + "\n");
      }, function() {
        return this.writeln$1("");
      }, "writeln$0", null, null, "get$writeln", 0, 2, null, 39, 85],
      clear$0: [function(_) {
        this._contents = "";
      }, null, "get$clear", 1, 0, null],
      toString$0: [function(_) {
        return H.Primitives_flattenString(this._contents);
      }, null, "get$toString", 1, 0, null],
      _writeString$1: [function(str) {
        this._contents = H.stringTypeCheck(H.Primitives_stringConcatUnchecked(this._contents, H.stringTypeCheck(str)));
      }, null, "get$_writeString", 4, 0, null, 82],
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 3, 0, null],
      $isStringSink: 1,
      static: {
        StringBuffer$: [function($content) {
          return new P.StringBuffer(H.S($content), []);
        }, null, null, 0, 2, null, 39, 906],
        StringBuffer__writeAll: [function(string, objects, separator) {
          var iterator;
          H.stringTypeCheck(string);
          H.listSuperNativeTypeCheck(objects, "$isIterable");
          H.stringTypeCheck(separator);
          iterator = J.get$iterator$ax(objects);
          if (!iterator.moveNext$0())
            return string;
          if (J.get$isEmpty$asx(separator)) {
            do
              string = P.StringBuffer__writeOne(string, iterator.get$current());
            while (iterator.moveNext$0());
          } else {
            string = P.StringBuffer__writeOne(string, iterator.get$current());
            for (; iterator.moveNext$0();)
              string = P.StringBuffer__writeOne(P.StringBuffer__writeOne(string, separator), iterator.get$current());
          }
          return string;
        }, null, null, 12, 0, null, 30, 354, 90],
        StringBuffer__writeOne: [function(string, obj) {
          return H.Primitives_stringConcatUnchecked(H.stringTypeCheck(string), H.S(obj));
        }, null, null, 8, 0, null, 30, 85]
      }
    },
    StringSink: {
      "^": "Object;$ti"
    },
    Symbol0: {
      "^": "Object;$ti"
    },
    Type: {
      "^": "Object;$ti"
    },
    Uri: {
      "^": "Object;$ti"
    },
    Uri_splitQueryString_closure: {
      "^": "Closure:209;encoding,$ti",
      call$2: [function(map, element) {
        var t1, index, key, value;
        t1 = P.String;
        H.assertSubtype(map, "$isMap", [t1, t1], "$asMap");
        H.stringTypeCheck(element);
        index = J.getInterceptor$asx(element).indexOf$1(element, "=");
        if (index === -1) {
          if (element !== "")
            map.$indexSet(0, P.Uri_decodeQueryComponent(element, this.encoding), "");
        } else if (index !== 0) {
          key = C.JSString_methods.substring$2(element, 0, index);
          if (typeof index !== "number")
            return index.$add();
          value = C.JSString_methods.substring$1(element, index + 1);
          t1 = this.encoding;
          map.$indexSet(0, P.Uri_decodeQueryComponent(key, t1), P.Uri_decodeQueryComponent(value, t1));
        }
        return map;
      }, null, null, 8, 0, null, 111, 10, "call"]
    },
    Uri__parseIPv4Address_error: {
      "^": "Closure:55;host,$ti",
      call$2: [function(msg, position) {
        H.stringTypeCheck(msg);
        H.intTypeCheck(position);
        throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + H.S(msg), this.host, position));
      }, null, null, 8, 0, null, 374, 69, "call"]
    },
    Uri_parseIPv6Address_error: {
      "^": "Closure:74;host,$ti",
      call$2: [function(msg, position) {
        throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + H.S(H.stringTypeCheck(msg)), this.host, H.intTypeCheck(position)));
      }, function(msg) {
        return this.call$2(msg, null);
      }, "call$1", null, null, null, 4, 2, null, 0, 374, 69, "call"]
    },
    Uri_parseIPv6Address_parseHex: {
      "^": "Closure:76;error,host,$ti",
      call$2: [function(start, end) {
        var value;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        if (end - start > 4)
          this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
        value = P.int_parse(J.substring$2$s(this.host, start, end), null, 16);
        if (typeof value !== "number")
          return value.$lt();
        if (value < 0 || value > 65535)
          this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
        return value;
      }, null, null, 8, 0, null, 5, 7, "call"]
    },
    _Uri: {
      "^": "Object;scheme<,_userInfo,_host,_port,path>,_query,_fragment,0_pathSegments,0_text,0_hashCodeCache,0_queryParameters,0_queryParameterLists,$ti",
      set$_pathSegments: function(_pathSegments) {
        this._pathSegments = H.assertSubtype(_pathSegments, "$isList", [P.String], "$asList");
      },
      set$_queryParameters: function(_queryParameters) {
        var t1 = P.String;
        this._queryParameters = H.assertSubtype(_queryParameters, "$isMap", [t1, t1], "$asMap");
      },
      get$userInfo: [function() {
        return this._userInfo;
      }, null, null, 2, 0, null],
      get$host: [function(_) {
        var t1, t2;
        t1 = this._host;
        if (t1 == null)
          return "";
        t2 = J.getInterceptor$s(t1);
        if (t2.startsWith$1(t1, "["))
          return t2.substring$2(t1, 1, J.$sub$n(t2.get$length(t1), 1));
        return t1;
      }, null, null, 3, 0, null],
      get$port: [function(_) {
        var t1 = this._port;
        if (t1 == null)
          return P._Uri__defaultPort(this.scheme);
        return t1;
      }, null, null, 3, 0, null],
      get$query: [function() {
        var t1 = this._query;
        return t1 == null ? "" : t1;
      }, null, null, 2, 0, null],
      get$fragment: [function() {
        var t1 = this._fragment;
        return t1 == null ? "" : t1;
      }, null, null, 2, 0, null],
      get$pathSegments: [function() {
        var result, pathToSplit, t1;
        result = this._pathSegments;
        if (result != null)
          return result;
        pathToSplit = this.path;
        if (J.getInterceptor$asx(pathToSplit).get$isNotEmpty(pathToSplit) && J.$eq$(C.JSString_methods._codeUnitAt$1(pathToSplit, 0), 47))
          pathToSplit = C.JSString_methods.substring$1(pathToSplit, 1);
        if (pathToSplit === "")
          result = C.List_empty1;
        else {
          t1 = P.String;
          result = P.List_List$unmodifiable(C.JSArray_methods.map$1$1(H.setRuntimeTypeInfo(pathToSplit.split("/"), [t1]), P.core_Uri_decodeComponent$closure(), null), t1);
        }
        this.set$_pathSegments(result);
        return result;
      }, null, null, 2, 0, null],
      get$queryParameters: [function() {
        if (this._queryParameters == null) {
          var t1 = P.String;
          this.set$_queryParameters(P.UnmodifiableMapView$(P.Uri_splitQueryString(this.get$query(), C.Utf8Codec_false), t1, t1));
        }
        return this._queryParameters;
      }, null, null, 2, 0, null],
      _mergePaths$2: [function(base, reference) {
        var t1, backCount, refStart, baseEnd, newEnd, delta;
        H.stringTypeCheck(base);
        H.stringTypeCheck(reference);
        for (t1 = J.getInterceptor$s(reference), backCount = 0, refStart = 0; t1.startsWith$2(reference, "../", refStart);) {
          refStart += 3;
          ++backCount;
        }
        baseEnd = J.getInterceptor$s(base).lastIndexOf$1(base, "/");
        while (true) {
          if (typeof baseEnd !== "number")
            return baseEnd.$gt();
          if (!(baseEnd > 0 && backCount > 0))
            break;
          newEnd = C.JSString_methods.lastIndexOf$2(base, "/", baseEnd - 1);
          if (typeof newEnd !== "number")
            return newEnd.$lt();
          if (newEnd < 0)
            break;
          delta = baseEnd - newEnd;
          t1 = delta !== 2;
          if (!t1 || delta === 3)
            if (J.$eq$(C.JSString_methods.codeUnitAt$1(base, newEnd + 1), 46))
              t1 = !t1 || J.$eq$(C.JSString_methods.codeUnitAt$1(base, newEnd + 2), 46);
            else
              t1 = false;
          else
            t1 = false;
          if (t1)
            break;
          --backCount;
          baseEnd = newEnd;
        }
        return C.JSString_methods.replaceRange$3(base, baseEnd + 1, null, C.JSString_methods.substring$1(reference, refStart - 3 * backCount));
      }, null, "get$_mergePaths", 8, 0, null, 280, 219],
      resolve$1: [function(reference) {
        return this.resolveUri$1(P.Uri_parse(H.stringTypeCheck(reference), 0, null));
      }, null, "get$resolve", 4, 0, null, 219],
      resolveUri$1: [function(reference) {
        var targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, mergedPath;
        H.interceptedTypeCheck(reference, "$isUri");
        if (J.get$isNotEmpty$asx(reference.get$scheme())) {
          targetScheme = reference.get$scheme();
          if (reference.get$hasAuthority()) {
            targetUserInfo = reference.get$userInfo();
            targetHost = reference.get$host(reference);
            targetPort = reference.get$hasPort() ? reference.get$port(reference) : null;
          } else {
            targetUserInfo = "";
            targetHost = null;
            targetPort = null;
          }
          targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
          targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
        } else {
          targetScheme = this.scheme;
          if (reference.get$hasAuthority()) {
            targetUserInfo = reference.get$userInfo();
            targetHost = reference.get$host(reference);
            targetPort = P._Uri__makePort(reference.get$hasPort() ? reference.get$port(reference) : null, targetScheme);
            targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
            targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
          } else {
            targetUserInfo = this._userInfo;
            targetHost = this._host;
            targetPort = this._port;
            if (J.$eq$(reference.get$path(reference), "")) {
              targetPath = this.path;
              targetQuery = reference.get$hasQuery() ? reference.get$query() : this._query;
            } else {
              if (reference.get$hasAbsolutePath())
                targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
              else if (this.get$hasEmptyPath())
                if (!this.get$hasAuthority())
                  targetPath = !this.get$hasScheme() ? reference.get$path(reference) : P._Uri__removeDotSegments(reference.get$path(reference));
                else
                  targetPath = P._Uri__removeDotSegments(C.JSString_methods.$add("/", reference.get$path(reference)));
              else {
                mergedPath = this._mergePaths$2(this.path, reference.get$path(reference));
                if (this.get$hasScheme() || this.get$hasAuthority() || this.get$hasAbsolutePath())
                  targetPath = P._Uri__removeDotSegments(mergedPath);
                else
                  targetPath = P._Uri__normalizeRelativePath(mergedPath, this.get$hasScheme() || this.get$hasAuthority());
              }
              targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
            }
          }
        }
        return P._Uri$_internal(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, reference.get$hasFragment() ? reference.get$fragment() : null);
      }, null, "get$resolveUri", 4, 0, null, 219],
      get$hasScheme: [function() {
        return J.get$isNotEmpty$asx(this.scheme);
      }, null, null, 2, 0, null],
      get$hasAuthority: [function() {
        return this._host != null;
      }, null, null, 2, 0, null],
      get$hasPort: [function() {
        return this._port != null;
      }, null, null, 2, 0, null],
      get$hasQuery: [function() {
        return this._query != null;
      }, null, null, 2, 0, null],
      get$hasFragment: [function() {
        return this._fragment != null;
      }, null, null, 2, 0, null],
      get$hasEmptyPath: [function() {
        return J.get$isEmpty$asx(this.path);
      }, null, null, 2, 0, null],
      get$hasAbsolutePath: [function() {
        return J.startsWith$1$s(this.path, "/");
      }, null, null, 2, 0, null],
      toFilePath$1$windows: [function(windows) {
        var t1, t2;
        H.boolTypeCheck(windows);
        t1 = this.scheme;
        t2 = J.getInterceptor$(t1);
        if (!t2.$eq(t1, "") && !t2.$eq(t1, "file"))
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(t1) + " URI"));
        if (!J.$eq$(this.get$query(), ""))
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
        if (!J.$eq$(this.get$fragment(), ""))
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
        return (windows == null ? P._Uri__isWindows() : windows) ? P._Uri__toWindowsFilePath(this) : this._toFilePath$0();
      }, function() {
        return this.toFilePath$1$windows(null);
      }, "toFilePath$0", null, null, "get$toFilePath", 0, 3, null, 0, 376],
      _toFilePath$0: [function() {
        var pathSegments, result;
        if (this.get$hasAuthority() && !J.$eq$(this.get$host(this), ""))
          throw H.wrapException(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
        pathSegments = this.get$pathSegments();
        P._Uri__checkNonWindowsPathReservedCharacters(pathSegments, false);
        result = P.StringBuffer$("");
        if (this.get$hasAbsolutePath())
          result.write$1("/");
        result.writeAll$2(pathSegments, "/");
        return result.toString$0(0);
      }, null, "get$_toFilePath", 0, 0, null],
      _writeAuthority$1: [function(ss) {
        var t1;
        H.interceptedTypeCheck(ss, "$isStringSink");
        t1 = this._userInfo;
        if (J.get$isNotEmpty$asx(t1)) {
          ss.write$1(t1);
          ss.write$1("@");
        }
        t1 = this._host;
        if (t1 != null)
          ss.write$1(t1);
        t1 = this._port;
        if (t1 != null) {
          ss.write$1(":");
          ss.write$1(t1);
        }
      }, null, "get$_writeAuthority", 4, 0, null, 770],
      toString$0: [function(_) {
        var t1 = this._text;
        if (t1 == null) {
          t1 = H.stringTypeCheck(this._initializeText$0());
          this._text = t1;
        }
        return t1;
      }, null, "get$toString", 1, 0, null],
      _initializeText$0: [function() {
        var sb, t1, t2;
        sb = P.StringBuffer$("");
        t1 = this.scheme;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isNotEmpty(t1)) {
          sb.write$1(t1);
          sb.write$1(":");
        }
        if (this.get$hasAuthority() || t2.$eq(t1, "file")) {
          sb.write$1("//");
          this._writeAuthority$1(sb);
        }
        sb.write$1(this.path);
        t1 = this._query;
        if (t1 != null) {
          sb.write$1("?");
          sb.write$1(t1);
        }
        t1 = this._fragment;
        if (t1 != null) {
          sb.write$1("#");
          sb.write$1(t1);
        }
        return sb.toString$0(0);
      }, null, "get$_initializeText", 0, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!!J.getInterceptor$(other).$isUri)
          return J.$eq$(this.scheme, other.get$scheme()) && J.$eq$(this.get$hasAuthority(), other.get$hasAuthority()) && J.$eq$(this.get$userInfo(), other.get$userInfo()) && J.$eq$(this.get$host(this), other.get$host(other)) && J.$eq$(this.get$port(this), other.get$port(other)) && J.$eq$(this.path, other.get$path(other)) && J.$eq$(this.get$hasQuery(), other.get$hasQuery()) && J.$eq$(this.get$query(), other.get$query()) && J.$eq$(this.get$hasFragment(), other.get$hasFragment()) && J.$eq$(this.get$fragment(), other.get$fragment());
        return false;
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = H.intTypeCheck(J.get$hashCode$(this.toString$0(0)));
          this._hashCodeCache = t1;
        }
        return t1;
      }, null, null, 3, 0, null],
      $isUri: 1,
      static: {
        _Uri__isWindows: [function() {
          return $.$get$_Uri__isWindowsCached();
        }, null, null, 2, 0, null],
        _Uri__uriEncode: [function(canonicalTable, text, encoding, spaceToPlus) {
          var result, bytes, t1, t2, i, t3, byte;
          H.assertSubtype(canonicalTable, "$isList", [P.int], "$asList");
          H.stringTypeCheck(text);
          H.interceptedTypeCheck(encoding, "$isEncoding");
          H.boolTypeCheck(spaceToPlus);
          if (encoding === C.Utf8Codec_false && $.$get$_Uri__needsNoEncoding().hasMatch$1(text))
            return text;
          result = P.StringBuffer$("");
          bytes = encoding.encode$1(text);
          t1 = J.getInterceptor$asx(bytes);
          t2 = J.getInterceptor$asx(canonicalTable);
          i = 0;
          while (true) {
            t3 = t1.get$length(bytes);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            byte = t1.$index(bytes, i);
            if (typeof byte !== "number")
              return byte.$lt();
            if (byte < 128 && !J.$eq$(J.$and$bn(t2.$index(canonicalTable, C.JSInt_methods._shrOtherPositive$1(byte, 4)), 1 << (byte & 15) >>> 0), 0))
              result.writeCharCode$1(byte);
            else if (spaceToPlus && byte === 32)
              result.write$1("+");
            else {
              result.write$1("%");
              result.write$1("0123456789ABCDEF"[C.JSInt_methods._shrOtherPositive$1(byte, 4) & 15]);
              result.write$1("0123456789ABCDEF"[byte & 15]);
            }
            ++i;
          }
          return result.toString$0(0);
        }, null, null, 16, 0, null, 969, 17, 131, 1008],
        _Uri$_internal: [function(scheme, _userInfo, _host, _port, path, _query, _fragment) {
          return new P._Uri(scheme, _userInfo, _host, _port, path, _query, _fragment, []);
        }, null, null, 28, 0, null, 107, 623, 625, 627, 26, 632, 633],
        _Uri__Uri$notSimple: [function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
          var userInfoStart, userInfo, host, t1, port, path, query;
          H.stringTypeCheck(uri);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.intTypeCheck(schemeEnd);
          H.intTypeCheck(hostStart);
          H.intTypeCheck(portStart);
          H.intTypeCheck(pathStart);
          H.intTypeCheck(queryStart);
          H.intTypeCheck(fragmentStart);
          H.stringTypeCheck(scheme);
          if (scheme == null) {
            if (typeof schemeEnd !== "number")
              return schemeEnd.$gt();
            if (typeof start !== "number")
              return H.iae(start);
            if (schemeEnd > start)
              scheme = P._Uri__makeScheme(uri, start, schemeEnd);
            else {
              if (schemeEnd === start)
                P._Uri__fail(uri, start, "Invalid empty scheme");
              scheme = "";
            }
          }
          if (typeof hostStart !== "number")
            return hostStart.$gt();
          if (typeof start !== "number")
            return H.iae(start);
          if (hostStart > start) {
            if (typeof schemeEnd !== "number")
              return schemeEnd.$add();
            userInfoStart = schemeEnd + 3;
            userInfo = userInfoStart < hostStart ? P._Uri__makeUserInfo(uri, userInfoStart, hostStart - 1) : "";
            host = P._Uri__makeHost(uri, hostStart, portStart, false);
            if (typeof portStart !== "number")
              return portStart.$add();
            t1 = portStart + 1;
            if (typeof pathStart !== "number")
              return H.iae(pathStart);
            port = t1 < pathStart ? P._Uri__makePort(P.int_parse(J.substring$2$s(uri, t1, pathStart), new P._Uri__Uri$notSimple_closure(uri, portStart), null), scheme) : null;
          } else {
            userInfo = "";
            host = null;
            port = null;
          }
          path = P._Uri__makePath(uri, pathStart, queryStart, null, scheme, host != null);
          if (typeof queryStart !== "number")
            return queryStart.$lt();
          if (typeof fragmentStart !== "number")
            return H.iae(fragmentStart);
          query = queryStart < fragmentStart ? P._Uri__makeQuery(uri, queryStart + 1, fragmentStart, null) : null;
          if (typeof end !== "number")
            return H.iae(end);
          return P._Uri$_internal(scheme, userInfo, host, port, path, query, fragmentStart < end ? P._Uri__makeFragment(uri, fragmentStart + 1, end) : null);
        }, null, null, 40, 0, null, 65, 5, 7, 636, 638, 643, 645, 646, 651, 107],
        _Uri__Uri: [function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
          var t1, isFile, hasAuthority;
          H.stringTypeCheck(scheme);
          H.stringTypeCheck(userInfo);
          H.stringTypeCheck(host);
          H.intTypeCheck(port);
          H.stringTypeCheck(path);
          t1 = P.String;
          H.assertSubtype(pathSegments, "$isIterable", [t1], "$asIterable");
          H.stringTypeCheck(query);
          H.assertSubtype(queryParameters, "$isMap", [t1, null], "$asMap");
          H.stringTypeCheck(fragment);
          scheme = P._Uri__makeScheme(scheme, 0, P._stringOrNullLength(scheme));
          userInfo = P._Uri__makeUserInfo(userInfo, 0, P._stringOrNullLength(userInfo));
          host = P._Uri__makeHost(host, 0, P._stringOrNullLength(host), false);
          if (query === "")
            query = null;
          query = P._Uri__makeQuery(query, 0, P._stringOrNullLength(query), queryParameters);
          fragment = P._Uri__makeFragment(fragment, 0, P._stringOrNullLength(fragment));
          port = P._Uri__makePort(port, scheme);
          isFile = scheme === "file";
          if (host == null)
            t1 = J.get$isNotEmpty$asx(userInfo) || port != null || isFile;
          else
            t1 = false;
          if (t1)
            host = "";
          t1 = host == null;
          hasAuthority = !t1;
          path = P._Uri__makePath(path, 0, P._stringOrNullLength(path), pathSegments, scheme, hasAuthority);
          if (J.getInterceptor$asx(scheme).get$isEmpty(scheme) && t1 && !J.startsWith$1$s(path, "/"))
            path = P._Uri__normalizeRelativePath(path, C.JSString_methods.get$isNotEmpty(scheme) || hasAuthority);
          else
            path = P._Uri__removeDotSegments(path);
          return P._Uri$_internal(scheme, userInfo, t1 && J.startsWith$1$s(path, "//") ? "" : host, port, path, query, fragment);
        }, null, null, 0, 19, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 325, 170, 26, 363, 224, 210, 364, 107, 365],
        _Uri__defaultPort: [function(scheme) {
          H.stringTypeCheck(scheme);
          if (scheme === "http")
            return 80;
          if (scheme === "https")
            return 443;
          return 0;
        }, null, null, 4, 0, null, 107],
        _Uri__fail: [function(uri, index, message) {
          H.stringTypeCheck(uri);
          H.intTypeCheck(index);
          throw H.wrapException(P.FormatException$(H.stringTypeCheck(message), uri, index));
        }, null, null, 12, 0, null, 65, 6, 21],
        _Uri__checkNonWindowsPathReservedCharacters: [function(segments, argumentError) {
          J.forEach$1$ax(H.assertSubtype(segments, "$isList", [P.String], "$asList"), new P._Uri__checkNonWindowsPathReservedCharacters_closure(H.boolTypeCheck(argumentError)));
        }, null, null, 8, 0, null, 366, 338],
        _Uri__checkWindowsPathReservedCharacters: [function(segments, argumentError, firstSegment) {
          var t1, t2;
          H.assertSubtype(segments, "$isList", [P.String], "$asList");
          H.boolTypeCheck(argumentError);
          for (t1 = J.get$iterator$ax(J.skip$1$ax(segments, H.intTypeCheck(firstSegment))); t1.moveNext$0();) {
            t2 = t1.get$current();
            if (J.contains$1$asx(t2, P.RegExp_RegExp('["*/:<>?\\\\|]', true, false)))
              if (argumentError)
                throw H.wrapException(P.ArgumentError$("Illegal character in path"));
              else
                throw H.wrapException(P.UnsupportedError$("Illegal character in path: " + t2));
          }
        }, null, null, 8, 2, null, 16, 366, 338, 673],
        _Uri__checkWindowsDriveLetter: [function(charCode, argumentError) {
          var t1;
          H.intTypeCheck(charCode);
          H.boolTypeCheck(argumentError);
          if (typeof charCode !== "number")
            return H.iae(charCode);
          if (!(65 <= charCode && charCode <= 90))
            t1 = 97 <= charCode && charCode <= 122;
          else
            t1 = true;
          if (t1)
            return;
          if (argumentError)
            throw H.wrapException(P.ArgumentError$(C.JSString_methods.$add("Illegal drive letter ", P.String_String$fromCharCode(charCode))));
          else
            throw H.wrapException(P.UnsupportedError$(C.JSString_methods.$add("Illegal drive letter ", P.String_String$fromCharCode(charCode))));
        }, null, null, 8, 0, null, 93, 338],
        _Uri__makePort: [function(port, scheme) {
          H.intTypeCheck(port);
          H.stringTypeCheck(scheme);
          if (port != null && port === P._Uri__defaultPort(scheme))
            return;
          return port;
        }, null, null, 8, 0, null, 224, 107],
        _Uri__makeHost: [function(host, start, end, strictIPv6) {
          var t1, i;
          H.stringTypeCheck(host);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.boolTypeCheck(strictIPv6);
          if (host == null)
            return;
          if (start == end)
            return "";
          if (J.$eq$(C.JSString_methods.codeUnitAt$1(host, start), 91)) {
            if (typeof end !== "number")
              return end.$sub();
            t1 = end - 1;
            if (!J.$eq$(C.JSString_methods.codeUnitAt$1(host, t1), 93))
              P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
            if (typeof start !== "number")
              return start.$add();
            P.Uri_parseIPv6Address(host, start + 1, t1);
            return J.toLowerCase$0$s(C.JSString_methods.substring$2(host, start, end));
          }
          if (!strictIPv6) {
            i = start;
            while (true) {
              if (typeof i !== "number")
                return i.$lt();
              if (typeof end !== "number")
                return H.iae(end);
              if (!(i < end))
                break;
              if (J.$eq$(C.JSString_methods.codeUnitAt$1(host, i), 58)) {
                P.Uri_parseIPv6Address(host, start, end);
                return "[" + host + "]";
              }
              ++i;
            }
          }
          return P._Uri__normalizeRegName(host, start, end);
        }, null, null, 16, 0, null, 170, 5, 7, 674],
        _Uri__isRegNameChar: [function(char) {
          var t1;
          H.intTypeCheck(char);
          if (typeof char !== "number")
            return char.$lt();
          if (char < 127) {
            t1 = C.JSInt_methods._shrOtherPositive$1(char, 4);
            if (t1 >= 8)
              return H.ioore(C.List_qNA, t1);
            t1 = !J.$eq$(J.$and$bn(C.List_qNA[t1], 1 << (char & 15) >>> 0), 0);
          } else
            t1 = false;
          return t1;
        }, null, null, 4, 0, null, 164],
        _Uri__normalizeRegName: [function(host, start, end) {
          var t1, index, sectionStart, buffer, isNormalized, char, replacement, t2, slice, sourceLength, tail;
          H.stringTypeCheck(host);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          t1 = J.getInterceptor$s(host);
          index = start;
          sectionStart = index;
          buffer = null;
          isNormalized = true;
          while (true) {
            if (typeof index !== "number")
              return index.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(index < end))
              break;
            c$0: {
              char = t1.codeUnitAt$1(host, index);
              if (char === 37) {
                replacement = P._Uri__normalizeEscape(host, index, true);
                t2 = replacement == null;
                if (t2 && isNormalized) {
                  index += 3;
                  break c$0;
                }
                if (buffer == null)
                  buffer = P.StringBuffer$("");
                slice = C.JSString_methods.substring$2(host, sectionStart, index);
                buffer.write$1(!isNormalized ? J.toLowerCase$0$s(slice) : slice);
                if (t2) {
                  replacement = C.JSString_methods.substring$2(host, index, index + 3);
                  sourceLength = 3;
                } else if (replacement === "%") {
                  replacement = "%25";
                  sourceLength = 1;
                } else
                  sourceLength = 3;
                buffer.write$1(replacement);
                index += sourceLength;
                sectionStart = index;
                isNormalized = true;
              } else if (P._Uri__isRegNameChar(char)) {
                if (isNormalized) {
                  if (typeof char !== "number")
                    return H.iae(char);
                  t2 = 65 <= char && 90 >= char;
                } else
                  t2 = false;
                if (t2) {
                  if (buffer == null)
                    buffer = P.StringBuffer$("");
                  if (typeof sectionStart !== "number")
                    return sectionStart.$lt();
                  if (sectionStart < index) {
                    buffer.write$1(C.JSString_methods.substring$2(host, sectionStart, index));
                    sectionStart = index;
                  }
                  isNormalized = false;
                }
                ++index;
              } else if (P._Uri__isGeneralDelimiter(char))
                P._Uri__fail(host, index, "Invalid character");
              else {
                if (typeof char !== "number")
                  return char.$and();
                if ((char & 64512) === 55296 && index + 1 < end) {
                  tail = C.JSString_methods.codeUnitAt$1(host, index + 1);
                  if (typeof tail !== "number")
                    return tail.$and();
                  if ((tail & 64512) === 56320) {
                    char = 65536 | (char & 1023) << 10 | tail & 1023;
                    sourceLength = 2;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                if (buffer == null)
                  buffer = P.StringBuffer$("");
                slice = C.JSString_methods.substring$2(host, sectionStart, index);
                buffer.write$1(!isNormalized ? J.toLowerCase$0$s(slice) : slice);
                buffer.write$1(P._Uri__escapeChar(char));
                index += sourceLength;
                sectionStart = index;
              }
            }
          }
          if (buffer == null)
            return t1.substring$2(host, start, end);
          if (typeof sectionStart !== "number")
            return sectionStart.$lt();
          if (sectionStart < end) {
            slice = t1.substring$2(host, sectionStart, end);
            buffer.write$1(!isNormalized ? J.toLowerCase$0$s(slice) : slice);
          }
          return buffer.toString$0(0);
        }, null, null, 12, 0, null, 170, 5, 7],
        _Uri__makeScheme: [function(scheme, start, end) {
          var i, containsUpperCase, codeUnit;
          H.stringTypeCheck(scheme);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          if (start == end)
            return "";
          if (!P._Uri__isAlphabeticCharacter(J.getInterceptor$s(scheme).codeUnitAt$1(scheme, start)))
            P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
          i = start;
          containsUpperCase = false;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(i < end))
              break;
            codeUnit = C.JSString_methods.codeUnitAt$1(scheme, i);
            if (!P._Uri__isSchemeCharacter(codeUnit))
              P._Uri__fail(scheme, i, "Illegal scheme character");
            if (typeof codeUnit !== "number")
              return H.iae(codeUnit);
            if (65 <= codeUnit && codeUnit <= 90)
              containsUpperCase = true;
            ++i;
          }
          scheme = C.JSString_methods.substring$2(scheme, start, end);
          return P._Uri__canonicalizeScheme(containsUpperCase ? J.toLowerCase$0$s(scheme) : scheme);
        }, null, null, 12, 0, null, 107, 5, 7],
        _Uri__canonicalizeScheme: [function(scheme) {
          H.stringTypeCheck(scheme);
          if (scheme === "http")
            return "http";
          if (scheme === "file")
            return "file";
          if (scheme === "https")
            return "https";
          if (scheme === "package")
            return "package";
          return scheme;
        }, null, null, 4, 0, null, 107],
        _Uri__makeUserInfo: [function(userInfo, start, end) {
          H.stringTypeCheck(userInfo);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          if (userInfo == null)
            return "";
          return P._Uri__normalizeOrSubstring(userInfo, start, end, C.List_gRj, false);
        }, null, null, 12, 0, null, 365, 5, 7],
        _Uri__makePath: [function(path, start, end, pathSegments, scheme, hasAuthority) {
          var t1, isFile, ensureLeadingSlash, t2, result;
          H.stringTypeCheck(path);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          t1 = P.String;
          H.assertSubtype(pathSegments, "$isIterable", [t1], "$asIterable");
          H.stringTypeCheck(scheme);
          H.boolTypeCheck(hasAuthority);
          isFile = scheme === "file";
          ensureLeadingSlash = isFile || hasAuthority;
          t2 = path == null;
          if (t2 && pathSegments == null)
            return isFile ? "/" : "";
          t2 = !t2;
          if (t2 && pathSegments != null)
            throw H.wrapException(P.ArgumentError$("Both path and pathSegments specified"));
          result = t2 ? P._Uri__normalizeOrSubstring(path, start, end, C.List_qg4, true) : J.join$1$ax(J.map$1$1$ax(pathSegments, new P._Uri__makePath_closure(), t1), "/");
          t1 = J.getInterceptor$asx(result);
          if (H.boolTypeCheck(t1.get$isEmpty(result))) {
            if (isFile)
              return "/";
          } else if (ensureLeadingSlash && !H.boolTypeCheck(t1.startsWith$1(result, "/")))
            result = C.JSString_methods.$add("/", H.stringTypeCheck(result));
          return H.stringTypeCheck(P._Uri__normalizePath(H.stringTypeCheck(result), scheme, hasAuthority));
        }, null, null, 24, 0, null, 26, 5, 7, 363, 107, 367],
        _Uri__normalizePath: [function(path, scheme, hasAuthority) {
          H.stringTypeCheck(path);
          H.stringTypeCheck(scheme);
          H.boolTypeCheck(hasAuthority);
          if (J.getInterceptor$asx(scheme).get$isEmpty(scheme) && !hasAuthority && !J.startsWith$1$s(path, "/"))
            return P._Uri__normalizeRelativePath(path, C.JSString_methods.get$isNotEmpty(scheme) || hasAuthority);
          return P._Uri__removeDotSegments(path);
        }, null, null, 12, 0, null, 26, 107, 367],
        _Uri__makeQuery: [function(query, start, end, queryParameters) {
          var t1, result;
          t1 = {};
          H.stringTypeCheck(query);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.assertSubtype(queryParameters, "$isMap", [P.String, null], "$asMap");
          if (query != null) {
            if (queryParameters != null)
              throw H.wrapException(P.ArgumentError$("Both query and queryParameters specified"));
            return P._Uri__normalizeOrSubstring(query, start, end, C.List_CVk, true);
          }
          if (queryParameters == null)
            return;
          result = P.StringBuffer$("");
          t1.separator = "";
          queryParameters.forEach$1(0, new P._Uri__makeQuery_closure(new P._Uri__makeQuery_writeParameter(t1, result)));
          return result.toString$0(0);
        }, null, null, 16, 0, null, 210, 5, 7, 364],
        _Uri__makeFragment: [function(fragment, start, end) {
          H.stringTypeCheck(fragment);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          if (fragment == null)
            return;
          return P._Uri__normalizeOrSubstring(fragment, start, end, C.List_CVk, true);
        }, null, null, 12, 0, null, 325, 5, 7],
        _Uri__normalizeEscape: [function(source, index, lowerCase) {
          var t1, firstDigit, secondDigit, firstDigitValue, secondDigitValue, value;
          H.stringTypeCheck(source);
          H.intTypeCheck(index);
          H.boolTypeCheck(lowerCase);
          if (typeof index !== "number")
            return index.$add();
          t1 = index + 2;
          if (t1 >= source.length)
            return "%";
          firstDigit = J.getInterceptor$s(source).codeUnitAt$1(source, index + 1);
          secondDigit = C.JSString_methods.codeUnitAt$1(source, t1);
          firstDigitValue = H.hexDigitValue(firstDigit);
          secondDigitValue = H.hexDigitValue(secondDigit);
          if (typeof firstDigitValue !== "number")
            return firstDigitValue.$lt();
          if (firstDigitValue >= 0) {
            if (typeof secondDigitValue !== "number")
              return secondDigitValue.$lt();
            t1 = secondDigitValue < 0;
          } else
            t1 = true;
          if (t1)
            return "%";
          if (typeof secondDigitValue !== "number")
            return H.iae(secondDigitValue);
          value = firstDigitValue * 16 + secondDigitValue;
          if (P._Uri__isUnreservedChar(value))
            return P.String_String$fromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
          if (typeof firstDigit !== "number")
            return firstDigit.$ge();
          if (firstDigit < 97) {
            if (typeof secondDigit !== "number")
              return secondDigit.$ge();
            t1 = secondDigit >= 97;
          } else
            t1 = true;
          if (t1)
            return J.toUpperCase$0$s(C.JSString_methods.substring$2(source, index, index + 3));
          return;
        }, null, null, 12, 0, null, 11, 6, 679],
        _Uri__escapeChar: [function(char) {
          var t1, codeUnits, flag, encodedBytes, index, byte;
          H.intTypeCheck(char);
          if (typeof char !== "number")
            return char.$lt();
          if (char < 128) {
            t1 = new Array(3);
            t1.fixed$length = Array;
            codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
            C.JSArray_methods.$indexSet(codeUnits, 0, 37);
            C.JSArray_methods.$indexSet(codeUnits, 1, C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", C.JSInt_methods._shrOtherPositive$1(char, 4)));
            C.JSArray_methods.$indexSet(codeUnits, 2, C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", char & 15));
          } else {
            if (char > 2047)
              if (char > 65535) {
                flag = 240;
                encodedBytes = 4;
              } else {
                flag = 224;
                encodedBytes = 3;
              }
            else {
              flag = 192;
              encodedBytes = 2;
            }
            t1 = new Array(3 * encodedBytes);
            t1.fixed$length = Array;
            codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
            for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
              byte = C.JSInt_methods.$shr(char, 6 * encodedBytes) & 63 | flag;
              C.JSArray_methods.$indexSet(codeUnits, index, 37);
              C.JSArray_methods.$indexSet(codeUnits, index + 1, C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte >>> 4));
              C.JSArray_methods.$indexSet(codeUnits, index + 2, C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte & 15));
              index += 3;
            }
          }
          return P.String_String$fromCharCodes(codeUnits, 0, null);
        }, null, null, 4, 0, null, 164],
        _Uri__normalizeOrSubstring: [function(component, start, end, charTable, escapeDelimiters) {
          var t1;
          H.stringTypeCheck(component);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          t1 = P._Uri__normalize(component, start, end, H.assertSubtype(charTable, "$isList", [P.int], "$asList"), H.boolTypeCheck(escapeDelimiters));
          return t1 == null ? J.substring$2$s(component, start, end) : t1;
        }, null, null, 16, 3, null, 18, 324, 5, 7, 368, 369],
        _Uri__normalize: [function(component, start, end, charTable, escapeDelimiters) {
          var t1, t2, t3, index, sectionStart, buffer, char, replacement, sourceLength, t4, tail;
          H.stringTypeCheck(component);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.assertSubtype(charTable, "$isList", [P.int], "$asList");
          t1 = !H.boolTypeCheck(escapeDelimiters);
          t2 = J.getInterceptor$s(component);
          t3 = J.getInterceptor$asx(charTable);
          index = start;
          sectionStart = index;
          buffer = null;
          while (true) {
            if (typeof index !== "number")
              return index.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(index < end))
              break;
            c$0: {
              char = t2.codeUnitAt$1(component, index);
              if (typeof char !== "number")
                return char.$lt();
              if (char < 127 && !J.$eq$(J.$and$bn(t3.$index(charTable, C.JSInt_methods._shrOtherPositive$1(char, 4)), 1 << (char & 15) >>> 0), 0))
                ++index;
              else {
                if (char === 37) {
                  replacement = P._Uri__normalizeEscape(component, index, false);
                  if (replacement == null) {
                    index += 3;
                    break c$0;
                  }
                  if ("%" === replacement) {
                    replacement = "%25";
                    sourceLength = 1;
                  } else
                    sourceLength = 3;
                } else if (t1 && P._Uri__isGeneralDelimiter(char)) {
                  P._Uri__fail(component, index, "Invalid character");
                  replacement = null;
                  sourceLength = null;
                } else {
                  if ((char & 64512) === 55296) {
                    t4 = index + 1;
                    if (t4 < end) {
                      tail = C.JSString_methods.codeUnitAt$1(component, t4);
                      if (typeof tail !== "number")
                        return tail.$and();
                      if ((tail & 64512) === 56320) {
                        char = 65536 | (char & 1023) << 10 | tail & 1023;
                        sourceLength = 2;
                      } else
                        sourceLength = 1;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                  replacement = P._Uri__escapeChar(char);
                }
                if (buffer == null)
                  buffer = P.StringBuffer$("");
                buffer.write$1(C.JSString_methods.substring$2(component, sectionStart, index));
                buffer.write$1(replacement);
                if (typeof sourceLength !== "number")
                  return H.iae(sourceLength);
                index += sourceLength;
                sectionStart = index;
              }
            }
          }
          if (buffer == null)
            return;
          if (typeof sectionStart !== "number")
            return sectionStart.$lt();
          if (sectionStart < end)
            buffer.write$1(t2.substring$2(component, sectionStart, end));
          return buffer.toString$0(0);
        }, null, null, 16, 3, null, 18, 324, 5, 7, 368, 369],
        _Uri__isSchemeCharacter: [function(ch) {
          var t1;
          H.intTypeCheck(ch);
          if (typeof ch !== "number")
            return ch.$lt();
          if (ch < 128) {
            t1 = C.JSInt_methods._shrOtherPositive$1(ch, 4);
            if (t1 >= 8)
              return H.ioore(C.List_JYB, t1);
            t1 = !J.$eq$(J.$and$bn(C.List_JYB[t1], 1 << (ch & 15) >>> 0), 0);
          } else
            t1 = false;
          return t1;
        }, null, null, 4, 0, null, 262],
        _Uri__isGeneralDelimiter: [function(ch) {
          var t1;
          H.intTypeCheck(ch);
          if (typeof ch !== "number")
            return ch.$le();
          if (ch <= 93) {
            t1 = C.JSInt_methods._shrOtherPositive$1(ch, 4);
            if (t1 >= 8)
              return H.ioore(C.List_2Vk, t1);
            t1 = !J.$eq$(J.$and$bn(C.List_2Vk[t1], 1 << (ch & 15) >>> 0), 0);
          } else
            t1 = false;
          return t1;
        }, null, null, 4, 0, null, 262],
        _Uri__mayContainDotSegments: [function(path) {
          H.stringTypeCheck(path);
          if (J.getInterceptor$s(path).startsWith$1(path, "."))
            return true;
          return C.JSString_methods.indexOf$1(path, "/.") !== -1;
        }, null, null, 4, 0, null, 26],
        _Uri__removeDotSegments: [function(path) {
          var t1, output, appendSlash, t2;
          H.stringTypeCheck(path);
          if (!P._Uri__mayContainDotSegments(path))
            return path;
          t1 = P.String;
          output = H.setRuntimeTypeInfo([], [t1]);
          for (t1 = C.JSArray_methods.get$iterator(H.setRuntimeTypeInfo(path.split("/"), [t1])), appendSlash = false; t1.moveNext$0();) {
            t2 = t1.get$current();
            if (t2 === "..") {
              if (C.JSArray_methods.get$isNotEmpty(output)) {
                if (0 >= output.length)
                  return H.ioore(output, -1);
                output.pop();
                if (C.JSArray_methods.get$isEmpty(output))
                  C.JSArray_methods.add$1(output, "");
              }
              appendSlash = true;
            } else if ("." === t2)
              appendSlash = true;
            else {
              C.JSArray_methods.add$1(output, t2);
              appendSlash = false;
            }
          }
          if (appendSlash)
            C.JSArray_methods.add$1(output, "");
          return C.JSArray_methods.join$1(output, "/");
        }, null, null, 4, 0, null, 26],
        _Uri__normalizeRelativePath: [function(path, allowScheme) {
          var t1, output, appendSlash, t2;
          H.stringTypeCheck(path);
          H.boolTypeCheck(allowScheme);
          if (!P._Uri__mayContainDotSegments(path))
            return !allowScheme ? P._Uri__escapeScheme(path) : path;
          t1 = P.String;
          output = H.setRuntimeTypeInfo([], [t1]);
          for (t1 = C.JSArray_methods.get$iterator(H.setRuntimeTypeInfo(path.split("/"), [t1])), appendSlash = false; t1.moveNext$0();) {
            t2 = t1.get$current();
            if (".." === t2)
              if (!C.JSArray_methods.get$isEmpty(output) && !J.$eq$(C.JSArray_methods.get$last(output), "..")) {
                if (0 >= output.length)
                  return H.ioore(output, -1);
                output.pop();
                appendSlash = true;
              } else {
                C.JSArray_methods.add$1(output, "..");
                appendSlash = false;
              }
            else if ("." === t2)
              appendSlash = true;
            else {
              C.JSArray_methods.add$1(output, t2);
              appendSlash = false;
            }
          }
          if (!C.JSArray_methods.get$isEmpty(output)) {
            t1 = output.length;
            if (t1 === 1) {
              if (0 >= t1)
                return H.ioore(output, 0);
              t1 = J.get$isEmpty$asx(output[0]);
            } else
              t1 = false;
          } else
            t1 = true;
          if (t1)
            return "./";
          if (appendSlash || J.$eq$(C.JSArray_methods.get$last(output), ".."))
            C.JSArray_methods.add$1(output, "");
          if (!allowScheme) {
            if (0 >= output.length)
              return H.ioore(output, 0);
            C.JSArray_methods.$indexSet(output, 0, P._Uri__escapeScheme(output[0]));
          }
          return C.JSArray_methods.join$1(output, "/");
        }, null, null, 8, 0, null, 26, 692],
        _Uri__escapeScheme: [function(path) {
          var t1, i, char, t2;
          H.stringTypeCheck(path);
          t1 = path.length;
          if (t1 >= 2 && P._Uri__isAlphabeticCharacter(J._codeUnitAt$1$s(path, 0)))
            for (i = 1; i < t1; ++i) {
              char = C.JSString_methods._codeUnitAt$1(path, i);
              if (char === 58)
                return H.S(C.JSString_methods.substring$2(path, 0, i)) + "%3A" + H.S(C.JSString_methods.substring$1(path, i + 1));
              if (typeof char !== "number")
                return char.$gt();
              if (char <= 127) {
                t2 = C.JSInt_methods._shrOtherPositive$1(char, 4);
                if (t2 >= 8)
                  return H.ioore(C.List_JYB, t2);
                t2 = J.$eq$(J.$and$bn(C.List_JYB[t2], 1 << (char & 15) >>> 0), 0);
              } else
                t2 = true;
              if (t2)
                break;
            }
          return path;
        }, null, null, 4, 0, null, 26],
        _Uri__toWindowsFilePath: [function(uri) {
          var segments, t1, hasDriveLetter, result, host;
          H.interceptedTypeCheck(uri, "$isUri");
          segments = uri.get$pathSegments();
          t1 = J.getInterceptor$asx(segments);
          if (J.$gt$n(t1.get$length(segments), 0) && J.$eq$(J.get$length$asx(t1.$index(segments, 0)), 2) && J.$eq$(J.codeUnitAt$1$s(t1.$index(segments, 0), 1), 58)) {
            P._Uri__checkWindowsDriveLetter(J.codeUnitAt$1$s(t1.$index(segments, 0), 0), false);
            P._Uri__checkWindowsPathReservedCharacters(segments, false, 1);
            hasDriveLetter = true;
          } else {
            P._Uri__checkWindowsPathReservedCharacters(segments, false, 0);
            hasDriveLetter = false;
          }
          result = P.StringBuffer$("");
          if (uri.get$hasAbsolutePath() && !hasDriveLetter)
            result.write$1("\\");
          if (uri.get$hasAuthority()) {
            host = uri.get$host(uri);
            if (J.get$isNotEmpty$asx(host)) {
              result.write$1("\\");
              result.write$1(host);
              result.write$1("\\");
            }
          }
          result.writeAll$2(segments, "\\");
          if (hasDriveLetter && J.$eq$(t1.get$length(segments), 1))
            result.write$1("\\");
          return result.toString$0(0);
        }, null, null, 4, 0, null, 65],
        _Uri__hexCharPairToByte: [function(s, pos) {
          var t1, byte, i, charCode;
          H.stringTypeCheck(s);
          H.intTypeCheck(pos);
          for (t1 = J.getInterceptor$s(s), byte = 0, i = 0; i < 2; ++i) {
            if (typeof pos !== "number")
              return pos.$add();
            charCode = t1.codeUnitAt$1(s, pos + i);
            if (typeof charCode !== "number")
              return H.iae(charCode);
            if (48 <= charCode && charCode <= 57)
              byte = byte * 16 + charCode - 48;
            else {
              charCode = (charCode | 32) >>> 0;
              if (97 <= charCode && charCode <= 102)
                byte = byte * 16 + charCode - 87;
              else
                throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
            }
          }
          return byte;
        }, null, null, 8, 0, null, 50, 302],
        _Uri__uriDecode: [function(text, start, end, encoding, plusToSpace) {
          var simple, t1, i, codeUnit, t2, bytes;
          H.stringTypeCheck(text);
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.interceptedTypeCheck(encoding, "$isEncoding");
          H.boolTypeCheck(plusToSpace);
          t1 = J.getInterceptor$s(text);
          i = start;
          while (true) {
            if (typeof i !== "number")
              return i.$lt();
            if (typeof end !== "number")
              return H.iae(end);
            if (!(i < end)) {
              simple = true;
              break;
            }
            codeUnit = t1.codeUnitAt$1(text, i);
            if (typeof codeUnit !== "number")
              return codeUnit.$gt();
            if (codeUnit <= 127)
              if (codeUnit !== 37)
                t2 = plusToSpace && codeUnit === 43;
              else
                t2 = true;
            else
              t2 = true;
            if (t2) {
              simple = false;
              break;
            }
            ++i;
          }
          if (simple)
            if (C.Utf8Codec_false === encoding || C.Latin1Codec_false === encoding || C.AsciiCodec_false === encoding)
              return t1.substring$2(text, start, end);
            else
              bytes = J.get$codeUnits$s(t1.substring$2(text, start, end));
          else {
            bytes = H.setRuntimeTypeInfo([], [P.int]);
            i = start;
            while (true) {
              if (typeof i !== "number")
                return i.$lt();
              if (!(i < end))
                break;
              codeUnit = t1.codeUnitAt$1(text, i);
              if (typeof codeUnit !== "number")
                return codeUnit.$gt();
              if (codeUnit > 127)
                throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
              if (codeUnit === 37) {
                if (i + 3 > text.length)
                  throw H.wrapException(P.ArgumentError$("Truncated URI"));
                C.JSArray_methods.add$1(bytes, P._Uri__hexCharPairToByte(text, i + 1));
                i += 2;
              } else if (plusToSpace && codeUnit === 43)
                C.JSArray_methods.add$1(bytes, 32);
              else
                C.JSArray_methods.add$1(bytes, codeUnit);
              ++i;
            }
          }
          return encoding.decode$1(0, bytes);
        }, null, null, 20, 0, null, 17, 5, 7, 131, 700],
        _Uri__isAlphabeticCharacter: [function(codeUnit) {
          var lowerCase;
          H.intTypeCheck(codeUnit);
          if (typeof codeUnit !== "number")
            return codeUnit.$or();
          lowerCase = (codeUnit | 32) >>> 0;
          return 97 <= lowerCase && lowerCase <= 122;
        }, null, null, 4, 0, null, 125],
        _Uri__isUnreservedChar: [function(char) {
          var t1;
          H.intTypeCheck(char);
          if (typeof char !== "number")
            return char.$lt();
          if (char < 127) {
            t1 = C.JSInt_methods._shrOtherPositive$1(char, 4);
            if (t1 >= 8)
              return H.ioore(C.List_nxB, t1);
            t1 = !J.$eq$(J.$and$bn(C.List_nxB[t1], 1 << (char & 15) >>> 0), 0);
          } else
            t1 = false;
          return t1;
        }, null, null, 4, 0, null, 164]
      }
    },
    _Uri__Uri$notSimple_closure: {
      "^": "Closure:15;uri,portStart,$ti",
      call$1: [function(_) {
        H.stringTypeCheck(_);
        throw H.wrapException(P.FormatException$("Invalid port", this.uri, J.$add$ansx(this.portStart, 1)));
      }, null, null, 4, 0, null, 12, "call"]
    },
    _Uri__checkNonWindowsPathReservedCharacters_closure: {
      "^": "Closure:15;argumentError,$ti",
      call$1: [function(segment) {
        H.stringTypeCheck(segment);
        if (J.contains$1$asx(segment, "/"))
          if (this.argumentError)
            throw H.wrapException(P.ArgumentError$("Illegal path character " + segment));
          else
            throw H.wrapException(P.UnsupportedError$("Illegal path character " + segment));
      }, null, null, 4, 0, null, 771, "call"]
    },
    _Uri__makePath_closure: {
      "^": "Closure:7;$ti",
      call$1: [function(s) {
        return P._Uri__uriEncode(C.List_qg40, H.stringTypeCheck(s), C.Utf8Codec_false, false);
      }, null, null, 4, 0, null, 50, "call"]
    },
    _Uri__makeQuery_writeParameter: {
      "^": "Closure:41;_box_0,result,$ti",
      call$2: [function(key, value) {
        var t1, t2;
        H.stringTypeCheck(key);
        H.stringTypeCheck(value);
        t1 = this.result;
        t2 = this._box_0;
        t1.write$1(t2.separator);
        t2.separator = "&";
        t1.write$1(P.Uri_encodeQueryComponent(key, C.Utf8Codec_false));
        if (value != null && C.JSString_methods.get$isNotEmpty(value)) {
          t1.write$1("=");
          t1.write$1(P.Uri_encodeQueryComponent(value, C.Utf8Codec_false));
        }
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    _Uri__makeQuery_closure: {
      "^": "Closure:22;writeParameter,$ti",
      call$2: [function(key, value) {
        var t1, t2;
        H.stringTypeCheck(key);
        if (value == null || typeof value === "string")
          this.writeParameter.call$2(key, H.stringTypeCheck(value));
        else
          for (t1 = J.get$iterator$ax(H.listSuperNativeTypeCheck(value, "$isIterable")), t2 = this.writeParameter; t1.moveNext$0();)
            t2.call$2(key, H.stringTypeCheck(t1.get$current()));
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    UriData: {
      "^": "Object;_text,_separatorIndices,_uriCache,$ti",
      get$uri: [function() {
        var t1, colonIndex, t2, t3, queryIndex, end, query;
        t1 = this._uriCache;
        if (t1 != null)
          return t1;
        colonIndex = J.$index$asx(this._separatorIndices, 0);
        t1 = this._text;
        if (typeof colonIndex !== "number")
          return colonIndex.$add();
        t2 = colonIndex + 1;
        t3 = J.getInterceptor$asx(t1);
        queryIndex = t3.indexOf$2(t1, "?", t2);
        end = t3.get$length(t1);
        if (typeof queryIndex !== "number")
          return queryIndex.$ge();
        if (queryIndex >= 0) {
          query = P._Uri__normalizeOrSubstring(t1, queryIndex + 1, end, C.List_CVk, false);
          end = queryIndex;
        } else
          query = null;
        t1 = P._DataUri$(this, P._Uri__normalizeOrSubstring(t1, t2, end, C.List_qg4, false), query);
        this._uriCache = t1;
        return t1;
      }, null, null, 2, 0, null],
      toString$0: [function(_) {
        var t1 = this._text;
        return J.$eq$(J.$index$asx(this._separatorIndices, 0), -1) ? "data:" + H.S(t1) : t1;
      }, null, "get$toString", 1, 0, null],
      static: {
        UriData$_: [function(_text, _separatorIndices, _uriCache) {
          return new P.UriData(_text, _separatorIndices, _uriCache, []);
        }, null, null, 12, 0, null, 701, 703, 704],
        UriData__parse: [function(text, start, sourceUri) {
          var indices, t1, i, slashIndex, char, t2, equalsIndex, lastSeparator, data;
          H.stringTypeCheck(text);
          H.intTypeCheck(start);
          H.interceptedTypeCheck(sourceUri, "$isUri");
          if (typeof start !== "number")
            return start.$sub();
          indices = H.setRuntimeTypeInfo([start - 1], [P.int]);
          for (t1 = text.length, i = start, slashIndex = -1, char = null; i < t1; ++i) {
            char = C.JSString_methods.codeUnitAt$1(text, i);
            t2 = J.getInterceptor$(char);
            if (t2.$eq(char, 44) || t2.$eq(char, 59))
              break;
            if (t2.$eq(char, 47)) {
              if (slashIndex < 0) {
                slashIndex = i;
                continue;
              }
              throw H.wrapException(P.FormatException$("Invalid MIME type", text, i));
            }
          }
          if (slashIndex < 0 && i > start)
            throw H.wrapException(P.FormatException$("Invalid MIME type", text, i));
          for (; !J.$eq$(char, 44);) {
            C.JSArray_methods.add$1(indices, i);
            ++i;
            for (equalsIndex = -1; i < t1; ++i) {
              char = C.JSString_methods.codeUnitAt$1(text, i);
              t2 = J.getInterceptor$(char);
              if (t2.$eq(char, 61)) {
                if (equalsIndex < 0)
                  equalsIndex = i;
              } else if (t2.$eq(char, 59) || t2.$eq(char, 44))
                break;
            }
            if (equalsIndex >= 0)
              C.JSArray_methods.add$1(indices, equalsIndex);
            else {
              lastSeparator = C.JSArray_methods.get$last(indices);
              if (J.$eq$(char, 44)) {
                if (typeof lastSeparator !== "number")
                  return lastSeparator.$add();
                t2 = i !== lastSeparator + 7 || !C.JSString_methods.startsWith$2(text, "base64", lastSeparator + 1);
              } else
                t2 = true;
              if (t2)
                throw H.wrapException(P.FormatException$("Expecting '='", text, i));
              break;
            }
          }
          C.JSArray_methods.add$1(indices, i);
          t2 = i + 1;
          if (C.JSInt_methods.get$isOdd(indices.length))
            text = C.Base64Codec_Base64Encoder_false.normalize$3(text, t2, t1);
          else {
            data = P._Uri__normalize(text, t2, t1, C.List_CVk, true);
            if (data != null)
              text = C.JSString_methods.replaceRange$3(text, t2, t1, data);
          }
          return P.UriData$_(text, indices, sourceUri);
        }, null, null, 12, 0, null, 17, 5, 706]
      }
    },
    _createTables_closure: {
      "^": "Closure:83;$ti",
      call$1: [function(_) {
        H.intTypeCheck(_);
        return H.NativeUint8List_NativeUint8List(96);
      }, null, null, 4, 0, null, 12, "call"]
    },
    _createTables_build: {
      "^": "Closure:85;tables,$ti",
      call$2: [function(state, defaultTransition) {
        var t1 = J.$index$asx(this.tables, H.intTypeCheck(state));
        J.fillRange$3$x(t1, 0, 96, H.intTypeCheck(defaultTransition));
        return t1;
      }, null, null, 8, 0, null, 78, 772, "call"]
    },
    _createTables_setChars: {
      "^": "Closure:44;$ti",
      call$3: [function(target, chars, transition) {
        var t1, t2, i, char;
        H.interceptedTypeCheck(target, "$isUint8List");
        H.stringTypeCheck(chars);
        H.intTypeCheck(transition);
        for (t1 = chars.length, t2 = target && C.NativeUint8List_methods, i = 0; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(chars, i);
          if (typeof char !== "number")
            return char.$xor();
          t2.$indexSet(target, (char ^ 96) >>> 0, transition);
        }
      }, null, null, 12, 0, null, 89, 773, 377, "call"]
    },
    _createTables_setRange: {
      "^": "Closure:44;$ti",
      call$3: [function(target, range, transition) {
        var i, n, t1;
        H.interceptedTypeCheck(target, "$isUint8List");
        H.stringTypeCheck(range);
        H.intTypeCheck(transition);
        i = J.getInterceptor$s(range)._codeUnitAt$1(range, 0);
        n = C.JSString_methods._codeUnitAt$1(range, 1);
        t1 = target && C.NativeUint8List_methods;
        while (true) {
          if (typeof i !== "number")
            return i.$le();
          if (typeof n !== "number")
            return H.iae(n);
          if (!(i <= n))
            break;
          t1.$indexSet(target, (i ^ 96) >>> 0, transition);
          ++i;
        }
      }, null, null, 12, 0, null, 89, 778, 377, "call"]
    },
    _SimpleUri: {
      "^": "Object;_uri,_schemeEnd,_hostStart,_portStart,_pathStart,_queryStart,_fragmentStart,_schemeCache,0_hashCodeCache,$ti",
      get$hasScheme: [function() {
        return J.$gt$n(this._schemeEnd, 0);
      }, null, null, 2, 0, null],
      get$hasAuthority: [function() {
        return J.$gt$n(this._hostStart, 0);
      }, null, null, 2, 0, null],
      get$hasPort: [function() {
        return J.$gt$n(this._hostStart, 0) && J.$lt$n(J.$add$ansx(this._portStart, 1), this._pathStart);
      }, null, null, 2, 0, null],
      get$hasQuery: [function() {
        return J.$lt$n(this._queryStart, this._fragmentStart);
      }, null, null, 2, 0, null],
      get$hasFragment: [function() {
        return J.$lt$n(this._fragmentStart, J.get$length$asx(this._uri));
      }, null, null, 2, 0, null],
      get$_isFile: [function() {
        return J.$eq$(this._schemeEnd, 4) && J.startsWith$1$s(this._uri, "file");
      }, null, null, 2, 0, null],
      get$_isHttp: [function() {
        return J.$eq$(this._schemeEnd, 4) && J.startsWith$1$s(this._uri, "http");
      }, null, null, 2, 0, null],
      get$_isHttps: [function() {
        return J.$eq$(this._schemeEnd, 5) && J.startsWith$1$s(this._uri, "https");
      }, null, null, 2, 0, null],
      get$_isPackage: [function() {
        return J.$eq$(this._schemeEnd, 7) && J.startsWith$1$s(this._uri, "package");
      }, null, null, 2, 0, null],
      get$hasAbsolutePath: [function() {
        return J.startsWith$2$s(this._uri, "/", this._pathStart);
      }, null, null, 2, 0, null],
      get$hasEmptyPath: [function() {
        return J.$eq$(this._pathStart, this._queryStart);
      }, null, null, 2, 0, null],
      get$scheme: [function() {
        var t1, t2;
        t1 = this._schemeEnd;
        if (J.$le$n(t1, 0))
          return "";
        t2 = this._schemeCache;
        if (t2 != null)
          return t2;
        if (this.get$_isHttp()) {
          this._schemeCache = "http";
          t1 = "http";
        } else if (this.get$_isHttps()) {
          this._schemeCache = "https";
          t1 = "https";
        } else if (this.get$_isFile()) {
          this._schemeCache = "file";
          t1 = "file";
        } else if (this.get$_isPackage()) {
          this._schemeCache = "package";
          t1 = "package";
        } else {
          t1 = H.stringTypeCheck(J.substring$2$s(this._uri, 0, t1));
          this._schemeCache = t1;
        }
        return t1;
      }, null, null, 2, 0, null],
      get$userInfo: [function() {
        var t1, t2, t3, t4;
        t1 = this._hostStart;
        t2 = this._schemeEnd;
        t3 = J.getInterceptor$ansx(t2);
        t4 = J.getInterceptor$n(t1);
        return t4.$gt(t1, t3.$add(t2, 3)) ? J.substring$2$s(this._uri, t3.$add(t2, 3), t4.$sub(t1, 1)) : "";
      }, null, null, 2, 0, null],
      get$host: [function(_) {
        var t1 = this._hostStart;
        return J.$gt$n(t1, 0) ? J.substring$2$s(this._uri, t1, this._portStart) : "";
      }, null, null, 3, 0, null],
      get$port: [function(_) {
        if (this.get$hasPort())
          return P.int_parse(J.substring$2$s(this._uri, J.$add$ansx(this._portStart, 1), this._pathStart), null, null);
        if (this.get$_isHttp())
          return 80;
        if (this.get$_isHttps())
          return 443;
        return 0;
      }, null, null, 3, 0, null],
      get$path: [function(_) {
        return J.substring$2$s(this._uri, this._pathStart, this._queryStart);
      }, null, null, 3, 0, null],
      get$query: [function() {
        var t1, t2, t3;
        t1 = this._queryStart;
        t2 = this._fragmentStart;
        t3 = J.getInterceptor$n(t1);
        return t3.$lt(t1, t2) ? J.substring$2$s(this._uri, t3.$add(t1, 1), t2) : "";
      }, null, null, 2, 0, null],
      get$fragment: [function() {
        var t1, t2, t3, t4;
        t1 = this._fragmentStart;
        t2 = this._uri;
        t3 = J.getInterceptor$asx(t2);
        t4 = J.getInterceptor$n(t1);
        return t4.$lt(t1, t3.get$length(t2)) ? t3.substring$1(t2, t4.$add(t1, 1)) : "";
      }, null, null, 2, 0, null],
      get$pathSegments: [function() {
        var start, end, t1, t2, t3, parts, i;
        start = this._pathStart;
        end = this._queryStart;
        t1 = this._uri;
        t2 = J.getInterceptor$s(t1);
        if (t2.startsWith$2(t1, "/", start)) {
          if (typeof start !== "number")
            return start.$add();
          ++start;
        }
        if (start == end)
          return C.List_empty1;
        t3 = P.String;
        parts = H.setRuntimeTypeInfo([], [t3]);
        i = start;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof end !== "number")
            return H.iae(end);
          if (!(i < end))
            break;
          if (t2.codeUnitAt$1(t1, i) === 47) {
            C.JSArray_methods.add$1(parts, t2.substring$2(t1, start, i));
            start = i + 1;
          }
          ++i;
        }
        C.JSArray_methods.add$1(parts, t2.substring$2(t1, start, end));
        return P.List_List$unmodifiable(parts, t3);
      }, null, null, 2, 0, null],
      get$queryParameters: [function() {
        if (!this.get$hasQuery())
          return C.Map_empty;
        var t1 = P.String;
        return P.UnmodifiableMapView$(P.Uri_splitQueryString(this.get$query(), C.Utf8Codec_false), t1, t1);
      }, null, null, 2, 0, null],
      _isPort$1: [function(port) {
        var portDigitStart, t1;
        H.stringTypeCheck(port);
        portDigitStart = J.$add$ansx(this._portStart, 1);
        t1 = port.length;
        if (typeof portDigitStart !== "number")
          return portDigitStart.$add();
        return portDigitStart + t1 === this._pathStart && J.startsWith$2$s(this._uri, port, portDigitStart);
      }, null, "get$_isPort", 4, 0, null, 224],
      removeFragment$0: [function() {
        if (!this.get$hasFragment())
          return this;
        var t1 = this._fragmentStart;
        return P._SimpleUri$(J.substring$2$s(this._uri, 0, t1), this._schemeEnd, this._hostStart, this._portStart, this._pathStart, this._queryStart, t1, this._schemeCache);
      }, null, "get$removeFragment", 0, 0, null],
      resolve$1: [function(reference) {
        return this.resolveUri$1(P.Uri_parse(H.stringTypeCheck(reference), 0, null));
      }, null, "get$resolve", 4, 0, null, 219],
      resolveUri$1: [function(reference) {
        H.interceptedTypeCheck(reference, "$isUri");
        if (reference instanceof P._SimpleUri)
          return this._simpleMerge$2(this, reference);
        return this._toNonSimple$0().resolveUri$1(reference);
      }, null, "get$resolveUri", 4, 0, null, 219],
      _simpleMerge$2: [function(base, ref) {
        var isSimple, t1, t2, delta, refStart, t3, baseUri, refUri, baseStart, baseEnd, baseStart0, refEnd, backCount, refStart0, insert;
        H.interceptedTypeCheck(base, "$is_SimpleUri");
        H.interceptedTypeCheck(ref, "$is_SimpleUri");
        if (ref.get$hasScheme())
          return ref;
        if (ref.get$hasAuthority()) {
          if (!base.get$hasScheme())
            return ref;
          if (base.get$_isFile())
            isSimple = !ref.get$hasEmptyPath();
          else if (base.get$_isHttp())
            isSimple = !ref._isPort$1("80");
          else
            isSimple = !base.get$_isHttps() || !ref._isPort$1("443");
          if (isSimple) {
            t1 = base._schemeEnd;
            t2 = J.getInterceptor$ansx(t1);
            delta = t2.$add(t1, 1);
            return P._SimpleUri$(J.$add$ansx(J.substring$2$s(base._uri, 0, t2.$add(t1, 1)), J.substring$1$s(ref._uri, J.$add$ansx(ref._schemeEnd, 1))), t1, J.$add$ansx(ref._hostStart, delta), J.$add$ansx(ref._portStart, delta), J.$add$ansx(ref._pathStart, delta), J.$add$ansx(ref._queryStart, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache);
          } else
            return this._toNonSimple$0().resolveUri$1(ref);
        }
        if (ref.get$hasEmptyPath()) {
          if (ref.get$hasQuery()) {
            t1 = base._queryStart;
            t2 = ref._queryStart;
            delta = J.$sub$n(t1, t2);
            return P._SimpleUri$(J.$add$ansx(J.substring$2$s(base._uri, 0, t1), J.substring$1$s(ref._uri, t2)), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, J.$add$ansx(t2, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache);
          }
          if (ref.get$hasFragment()) {
            t1 = base._fragmentStart;
            t2 = ref._fragmentStart;
            delta = J.$sub$n(t1, t2);
            return P._SimpleUri$(J.$add$ansx(J.substring$2$s(base._uri, 0, t1), J.substring$1$s(ref._uri, t2)), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, base._queryStart, J.$add$ansx(t2, delta), base._schemeCache);
          }
          return base.removeFragment$0();
        }
        if (ref.get$hasAbsolutePath()) {
          t1 = base._pathStart;
          t2 = ref._pathStart;
          delta = J.$sub$n(t1, t2);
          return P._SimpleUri$(J.$add$ansx(J.substring$2$s(base._uri, 0, t1), J.substring$1$s(ref._uri, t2)), base._schemeEnd, base._hostStart, base._portStart, t1, J.$add$ansx(ref._queryStart, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache);
        }
        if (base.get$hasEmptyPath() && base.get$hasAuthority()) {
          refStart = ref._pathStart;
          for (t1 = ref._uri, t2 = J.getInterceptor$s(t1); t2.startsWith$2(t1, "../", refStart);) {
            if (typeof refStart !== "number")
              return refStart.$add();
            refStart += 3;
          }
          t3 = base._pathStart;
          delta = J.$add$ansx(J.$sub$n(t3, refStart), 1);
          return P._SimpleUri$(H.S(J.substring$2$s(base._uri, 0, t3)) + "/" + H.S(t2.substring$1(t1, refStart)), base._schemeEnd, base._hostStart, base._portStart, t3, J.$add$ansx(ref._queryStart, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache);
        }
        baseUri = base._uri;
        refUri = ref._uri;
        baseStart = base._pathStart;
        baseEnd = base._queryStart;
        for (t1 = J.getInterceptor$s(baseUri), baseStart0 = baseStart; t1.startsWith$2(baseUri, "../", baseStart0);) {
          if (typeof baseStart0 !== "number")
            return baseStart0.$add();
          baseStart0 += 3;
        }
        refStart = ref._pathStart;
        refEnd = ref._queryStart;
        t1 = J.getInterceptor$s(refUri);
        backCount = 0;
        while (true) {
          if (typeof refStart !== "number")
            return refStart.$add();
          refStart0 = refStart + 3;
          if (typeof refEnd !== "number")
            return H.iae(refEnd);
          if (!(refStart0 <= refEnd && t1.startsWith$2(refUri, "../", refStart)))
            break;
          ++backCount;
          refStart = refStart0;
        }
        insert = "";
        while (true) {
          if (typeof baseEnd !== "number")
            return baseEnd.$gt();
          if (typeof baseStart0 !== "number")
            return H.iae(baseStart0);
          if (!(baseEnd > baseStart0))
            break;
          --baseEnd;
          if (C.JSString_methods.codeUnitAt$1(baseUri, baseEnd) === 47) {
            if (backCount === 0) {
              insert = "/";
              break;
            }
            --backCount;
            insert = "/";
          }
        }
        if (baseEnd === baseStart0 && !base.get$hasScheme() && !base.get$hasAbsolutePath()) {
          refStart -= backCount * 3;
          insert = "";
        }
        delta = baseEnd - refStart + insert.length;
        return P._SimpleUri$(H.S(C.JSString_methods.substring$2(baseUri, 0, baseEnd)) + insert + H.S(t1.substring$1(refUri, refStart)), base._schemeEnd, base._hostStart, base._portStart, baseStart, refEnd + delta, J.$add$ansx(ref._fragmentStart, delta), base._schemeCache);
      }, null, "get$_simpleMerge", 8, 0, null, 280, 81],
      toFilePath$1$windows: [function(windows) {
        var t1, t2;
        H.boolTypeCheck(windows);
        if (J.$ge$n(this._schemeEnd, 0) && !this.get$_isFile())
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(this.get$scheme()) + " URI"));
        t1 = this._queryStart;
        t2 = J.getInterceptor$n(t1);
        if (t2.$lt(t1, J.get$length$asx(this._uri))) {
          if (t2.$lt(t1, this._fragmentStart))
            throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
        }
        return (windows == null ? P._Uri__isWindows() : windows) ? P._Uri__toWindowsFilePath(this) : this._toFilePath$0();
      }, function() {
        return this.toFilePath$1$windows(null);
      }, "toFilePath$0", null, null, "get$toFilePath", 0, 3, null, 0, 376],
      _toFilePath$0: [function() {
        if (J.$lt$n(this._hostStart, this._portStart))
          throw H.wrapException(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
        return this.get$path(this);
      }, null, "get$_toFilePath", 0, 0, null],
      get$hashCode: [function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = H.intTypeCheck(J.get$hashCode$(this._uri));
          this._hashCodeCache = t1;
        }
        return t1;
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!!J.getInterceptor$(other).$isUri)
          return J.$eq$(this._uri, other.toString$0(0));
        return false;
      }, null, "get$==", 5, 0, null, 3],
      _toNonSimple$0: [function() {
        var t1, t2, t3, t4, t5, t6;
        t1 = this.get$scheme();
        t2 = this.get$userInfo();
        t3 = this.get$hasAuthority() ? this.get$host(this) : null;
        t4 = this.get$hasPort() ? this.get$port(this) : null;
        t5 = this.get$path(this);
        t6 = this.get$hasQuery() ? this.get$query() : null;
        return P._Uri$_internal(t1, t2, t3, t4, t5, t6, this.get$hasFragment() ? this.get$fragment() : null);
      }, null, "get$_toNonSimple", 0, 0, null],
      toString$0: [function(_) {
        return this._uri;
      }, null, "get$toString", 1, 0, null],
      $isUri: 1,
      static: {
        _SimpleUri$: [function(_uri, _schemeEnd, _hostStart, _portStart, _pathStart, _queryStart, _fragmentStart, _schemeCache) {
          return new P._SimpleUri(_uri, _schemeEnd, _hostStart, _portStart, _pathStart, _queryStart, _fragmentStart, _schemeCache, []);
        }, null, null, 32, 0, null, 711, 714, 716, 695, 725, 734, 739, 740]
      }
    },
    _DataUri: {
      "^": "_Uri;_core$_data,scheme,_userInfo,_host,_port,path,_query,_fragment,0_pathSegments,0_text,0_hashCodeCache,0_queryParameters,0_queryParameterLists,$ti",
      static: {
        _DataUri$: [function(_data, path, query) {
          return new P._DataUri(_data, "data", null, null, null, path, query, null, []);
        }, null, null, 12, 0, null, 741, 26, 210]
      }
    }
  }], ["dart.developer", "dart:developer",, P, {
    "^": "",
    log0: [function(message, error, level, $name, sequenceNumber, stackTrace, time, zone) {
      H.stringTypeCheck(message);
      H.interceptedTypeCheck(time, "$isDateTime");
      H.intTypeCheck(sequenceNumber);
      H.intTypeCheck(level);
      H.stringTypeCheck($name);
      H.interceptedTypeCheck(zone, "$isZone");
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
    }, null, null, 4, 15, null, 0, 16, 39, 0, 0, 0, 0, 21, 14, 218, 8, 830, 20, 379, 122],
    _FakeUserTag: {
      "^": "Object;$ti",
      $isUserTag: 1
    },
    ServiceExtensionResponse: {
      "^": "Object;$ti"
    },
    UserTag: {
      "^": "Object;$ti"
    },
    Metric: {
      "^": "Object;$ti"
    },
    Gauge: {
      "^": "Metric;$ti"
    },
    Counter: {
      "^": "Metric;$ti"
    },
    Metrics: {
      "^": "Object;$ti"
    },
    ServiceProtocolInfo: {
      "^": "Object;$ti"
    },
    Service: {
      "^": "Object;$ti"
    },
    Flow: {
      "^": "Object;$ti"
    },
    Timeline: {
      "^": "Object;$ti"
    },
    TimelineTask: {
      "^": "Object;$ti"
    },
    _AsyncBlock: {
      "^": "Object;$ti"
    },
    _SyncBlock: {
      "^": "Object;$ti"
    }
  }], ["dart.dom.html", "dart:html",, W, {
    "^": "",
    window: [function() {
      return window;
    }, null, null, 2, 0, null],
    document: [function() {
      return document;
    }, null, null, 2, 0, null],
    promiseToFuture: [1, function(jsPromise, $T) {
      var completer = P.Completer_Completer($T);
      jsPromise.then(H.convertDartClosureToJS(new W.promiseToFuture_closure(completer, $T), 1), H.convertDartClosureToJS(new W.promiseToFuture_closure0(completer), 1));
      return completer.get$future();
    }, function(jsPromise) {
      return W.promiseToFuture(jsPromise, null);
    }, null, "call$1", null, 4, 0, null, 854],
    AnchorElement_AnchorElement: [function(href) {
      var e;
      H.stringTypeCheck(href);
      e = W.document().createElement("a");
      if (href != null)
        e.href = href;
      return e;
    }, null, null, 0, 3, null, 0, 855],
    Blob_Blob: [function(blobParts, type, endings) {
      var t1, bag;
      H.listTypeCheck(blobParts);
      H.stringTypeCheck(type);
      H.stringTypeCheck(endings);
      t1 = type == null;
      if (t1 && endings == null)
        return H.interceptedTypeCheck(W.Blob__create_1(blobParts), "$isBlob");
      bag = W.Blob__create_bag();
      if (!t1)
        W.Blob__bag_set(bag, "type", type);
      if (endings != null)
        W.Blob__bag_set(bag, "endings", endings);
      return H.interceptedTypeCheck(W.Blob__create_2(blobParts, bag), "$isBlob");
    }, null, null, 4, 4, null, 0, 0, 856, 29, 857],
    Blob__create_1: [function(parts) {
      return new self.Blob(parts);
    }, null, null, 4, 0, null, 154],
    Blob__create_2: [function(parts, bag) {
      return new self.Blob(parts, bag);
    }, null, null, 8, 0, null, 154, 380],
    Blob__create_bag: [function() {
      return {};
    }, null, null, 0, 0, null],
    Blob__bag_set: [function(bag, key, value) {
      bag[key] = value;
    }, null, null, 12, 0, null, 380, 4, 1],
    CanvasElement_CanvasElement: [function(height, width) {
      var e;
      H.intTypeCheck(width);
      H.intTypeCheck(height);
      e = W.document().createElement("canvas");
      if (width != null)
        e.width = width;
      if (height != null)
        e.height = height;
      return e;
    }, null, null, 0, 5, null, 0, 0, 96, 56],
    CssStyleDeclaration__readCache: [function(key) {
      H.stringTypeCheck(key);
      return $.$get$CssStyleDeclaration__propertyCache()[key];
    }, null, null, 4, 0, null, 4],
    CssStyleDeclaration__writeCache: [function(key, value) {
      H.stringTypeCheck(key);
      H.stringTypeCheck(value);
      $.$get$CssStyleDeclaration__propertyCache()[key] = value;
    }, null, null, 8, 0, null, 4, 1],
    CssStyleDeclaration__camelCase: [function(hyphenated) {
      return H.stringTypeCheck(hyphenated).replace(/^-ms-/, "ms-").replace(/-([\da-z])/ig, function(_, letter) {
        return letter.toUpperCase();
      });
    }, null, null, 4, 0, null, 860],
    DivElement_DivElement: [function() {
      return W.document().createElement("div");
    }, null, null, 0, 0, null],
    DocumentFragment_DocumentFragment: [function() {
      return J.createDocumentFragment$0$x(W.document());
    }, null, null, 0, 0, null],
    Element_Element$html: [function(html, treeSanitizer, validator) {
      H.stringTypeCheck(html);
      H.interceptedTypeCheck(validator, "$isNodeValidator");
      H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
      return H.interceptedTypeCheck(J.get$single$ax(J.where$1$ax(J.get$nodes$x(J.createFragment$3$treeSanitizer$validator$x(J.get$body$x(W.document()), html, treeSanitizer, validator)), new W.Element_Element$html_closure())), "$isElement");
    }, null, null, 4, 5, null, 0, 0, 149, 117, 97],
    Element_Element$tag: [function(tag, typeExtention) {
      return H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(H.stringTypeCheck(tag), H.stringTypeCheck(typeExtention)), "$isElement");
    }, null, null, 4, 2, null, 0, 109, 867],
    Element_Element$div: [function() {
      return W.DivElement_DivElement();
    }, null, null, 0, 0, null],
    Element_Element$span: [function() {
      return W.Element_Element$tag("span", null);
    }, null, null, 0, 0, null],
    Element__hasCorruptedAttributes: [function(element) {
      return function(element) {
        if (!(element.attributes instanceof NamedNodeMap))
          return true;
        var childNodes = element.childNodes;
        if (element.lastChild && element.lastChild !== childNodes[childNodes.length - 1])
          return true;
        if (element.children)
          if (!(element.children instanceof HTMLCollection || element.children instanceof NodeList))
            return true;
        var length = 0;
        if (element.children)
          length = element.children.length;
        for (var i = 0; i < length; i++) {
          var child = element.children[i];
          if (child.id == 'attributes' || child.name == 'attributes' || child.id == 'lastChild' || child.name == 'lastChild' || child.id == 'children' || child.name == 'children')
            return true;
        }
        return false;
      }(H.interceptedTypeCheck(element, "$isElement"));
    }, null, null, 4, 0, null, 10],
    Element__hasCorruptedAttributesAdditionalCheck: [function(element) {
      return !(H.interceptedTypeCheck(element, "$isElement").attributes instanceof NamedNodeMap);
    }, null, null, 4, 0, null, 10],
    Element__safeTagName: [function(element) {
      var result, t1, t2, exception;
      result = "element tag unavailable";
      try {
        t1 = J.getInterceptor$x(element);
        t2 = t1.get$tagName(element);
        if (typeof t2 === "string")
          result = H.stringTypeCheck(t1.get$tagName(element));
      } catch (exception) {
        H.unwrapException(exception);
      }
      return result;
    }, null, null, 4, 0, null, 10],
    _ElementFactoryProvider_createElement_tag: [function(tag, typeExtension) {
      H.stringTypeCheck(tag);
      H.stringTypeCheck(typeExtension);
      if (typeExtension != null)
        return document.createElement(tag, typeExtension);
      return document.createElement(tag);
    }, null, null, 8, 0, null, 109, 384],
    FileReader_FileReader: [function() {
      return W.FileReader__create_1();
    }, null, null, 0, 0, null],
    FileReader__create_1: [function() {
      return new FileReader();
    }, null, null, 0, 0, null],
    FontFace_FontFace: [function(family, source, descriptors) {
      H.stringTypeCheck(family);
      H.interceptedTypeCheck(descriptors, "$isMap");
      if (descriptors != null)
        return W.FontFace__create_1(family, source, P.convertDartToNative_Dictionary(descriptors, null));
      return W.FontFace__create_2(family, source);
    }, null, null, 8, 2, null, 0, 326, 11, 385],
    FontFace__create_1: [function(family, source, descriptors) {
      return new FontFace(family, source, descriptors);
    }, null, null, 12, 0, null, 326, 11, 385],
    FontFace__create_2: [function(family, source) {
      return new FontFace(family, source);
    }, null, null, 8, 0, null, 326, 11],
    HttpRequest_HttpRequest: [function() {
      return W.HttpRequest__create_1();
    }, null, null, 0, 0, null],
    HttpRequest__create_1: [function() {
      return new XMLHttpRequest();
    }, null, null, 0, 0, null],
    ImageElement_ImageElement: [function(height, src, width) {
      var e;
      H.stringTypeCheck(src);
      H.intTypeCheck(width);
      H.intTypeCheck(height);
      e = W.document().createElement("img");
      if (src != null)
        e.src = src;
      if (width != null)
        e.width = width;
      if (height != null)
        e.height = height;
      return e;
    }, null, null, 0, 7, null, 0, 0, 0, 96, 386, 56],
    IntersectionObserver_IntersectionObserver: [function(callback, options) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [[P.List,,], W.IntersectionObserver]});
      H.interceptedTypeCheck(options, "$isMap");
      if (options != null)
        return W.IntersectionObserver__create_1(callback, P.convertDartToNative_Dictionary(options, null));
      return W.IntersectionObserver__create_2(callback);
    }, null, null, 4, 2, null, 0, 43, 118],
    IntersectionObserver__create_1: [function(callback, options) {
      return new IntersectionObserver(callback, options);
    }, null, null, 8, 0, null, 43, 118],
    IntersectionObserver__create_2: [function(callback) {
      return new IntersectionObserver(callback);
    }, null, null, 4, 0, null, 43],
    Range_supportsCreateContextualFragment: [function() {
      return "createContextualFragment" in window.Range.prototype;
    }, null, null, 2, 0, null],
    SpanElement_SpanElement: [function() {
      return W.document().createElement("span");
    }, null, null, 0, 0, null],
    TableElement_TableElement: [function() {
      return W.document().createElement("table");
    }, null, null, 0, 0, null],
    WebSocket_WebSocket: [function(url, protocols) {
      H.stringTypeCheck(url);
      if (protocols != null)
        return W.WebSocket__create_1(url, protocols);
      return W.WebSocket__create_2(url);
    }, null, null, 4, 2, null, 0, 62, 387],
    WebSocket__create_1: [function(url, protocols) {
      return new WebSocket(url, protocols);
    }, null, null, 8, 0, null, 62, 387],
    WebSocket__create_2: [function(url) {
      return new WebSocket(url);
    }, null, null, 4, 0, null, 62],
    _JenkinsSmiHash_combine: [function(hash, value) {
      H.intTypeCheck(hash);
      H.intTypeCheck(value);
      if (typeof hash !== "number")
        return hash.$add();
      if (typeof value !== "number")
        return H.iae(value);
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    }, null, null, 8, 0, null, 155, 1],
    _JenkinsSmiHash_finish: [function(hash) {
      H.intTypeCheck(hash);
      if (typeof hash !== "number")
        return H.iae(hash);
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }, null, null, 4, 0, null, 155],
    _JenkinsSmiHash_hash4: [function(a, b, c, d) {
      return W._JenkinsSmiHash_finish(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, H.intTypeCheck(a)), H.intTypeCheck(b)), H.intTypeCheck(c)), H.intTypeCheck(d)));
    }, null, null, 16, 0, null, 33, 54, 70, 887],
    _convertNativeToDart_Window: [function(win) {
      if (win == null)
        return;
      return W._DOMWindowCrossFrame__createSafe(win);
    }, null, null, 4, 0, null, 899],
    _convertNativeToDart_EventTarget: [function(e) {
      var $window;
      if (e == null)
        return;
      if ("postMessage" in e) {
        $window = W._DOMWindowCrossFrame__createSafe(e);
        if (!!J.getInterceptor$($window).$isEventTarget)
          return $window;
        return;
      } else
        return H.interceptedTypeCheck(e, "$isEventTarget");
    }, null, null, 4, 0, null, 19],
    _convertNativeToDart_XHR_Response: [function(o) {
      if (!!J.getInterceptor$(o).$isDocument)
        return o;
      return P.convertNativeToDart_SerializedScriptValue(o);
    }, null, null, 4, 0, null, 25],
    _wrapZone: [1, function(callback, $T) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [$T]});
      if (J.$eq$(P.Zone_current(), C.C__RootZone))
        return callback;
      if (callback == null)
        return;
      return P.Zone_current().bindUnaryCallbackGuarded$1$1(callback, $T);
    }, function(callback) {
      return W._wrapZone(callback, null);
    }, null, "call$1", null, 4, 0, null, 43],
    querySelector: [function(selectors) {
      H.stringTypeCheck(selectors);
      return J.querySelector$1$x(W.document(), selectors);
    }, null, null, 4, 0, null, 145],
    querySelectorAll: [1, function(selectors, $T) {
      H.assertIsSubtype($T, W.Element, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'querySelectorAll'.");
      H.stringTypeCheck(selectors);
      return J.querySelectorAll$1$1$x(W.document(), selectors, $T);
    }, function(selectors) {
      return W.querySelectorAll(selectors, W.Element);
    }, null, "call$1", null, 4, 0, null, 145],
    NodeTreeSanitizer_NodeTreeSanitizer: [function(validator) {
      return W._ValidatingTreeSanitizer$(H.interceptedTypeCheck(validator, "$isNodeValidator"));
    }, null, null, 4, 0, null, 97],
    UriPolicy_UriPolicy: [function() {
      return W._SameOriginUriPolicy$();
    }, null, null, 0, 0, null],
    promiseToFuture_closure: {
      "^": "Closure:6;completer,T,$ti",
      call$1: [function(promiseValue) {
        return J.complete$1$z(this.completer, H.futureOrCheck(promiseValue, {futureOr: 1, type: this.T}));
      }, null, null, 4, 0, null, 904, "call"]
    },
    promiseToFuture_closure0: {
      "^": "Closure:6;completer,$ti",
      call$1: [function(promiseError) {
        return this.completer.completeError$1(promiseError);
      }, null, null, 4, 0, null, 905, "call"]
    },
    HtmlElement: {
      "^": "Element;$ti",
      $isHtmlElement: 1,
      $isNoncedElement: 1,
      "%": ";HTMLElement"
    },
    AbortPaymentEvent: {
      "^": "ExtendableEvent;$ti",
      $isAbortPaymentEvent: 1,
      "%": "AbortPaymentEvent"
    },
    AbsoluteOrientationSensor: {
      "^": "OrientationSensor;$ti",
      $isAbsoluteOrientationSensor: 1,
      "%": ""
    },
    AbstractWorker: {
      "^": "Interceptor;$ti",
      $isEventTarget: 1
    },
    Accelerometer: {
      "^": "Sensor;$ti",
      $isAccelerometer: 1,
      "%": ""
    },
    AccessibleNode: {
      "^": "EventTarget;$ti",
      $isAccessibleNode: 1,
      "%": ""
    },
    AccessibleNodeList: {
      "^": "Interceptor;$ti",
      $isAccessibleNodeList: 1,
      "%": ""
    },
    AmbientLightSensor: {
      "^": "Sensor;$ti",
      $isAmbientLightSensor: 1,
      "%": ""
    },
    AnchorElement: {
      "^": "HtmlElement;0hostname=,0href,0port=,0protocol=,$ti",
      set$href: function(receiver, href) {
        receiver.href = H.stringTypeCheck(href);
      },
      toString$0: [function(receiver) {
        return String(receiver);
      }, null, "get$toString", 1, 0, null],
      $isAnchorElement: 1,
      $isHtmlHyperlinkElementUtils: 1,
      "%": "HTMLAnchorElement"
    },
    Animation: {
      "^": "EventTarget;$ti",
      $isAnimation: 1,
      "%": ""
    },
    AnimationEffectReadOnly: {
      "^": "Interceptor;$ti",
      $isAnimationEffectReadOnly: 1,
      "%": ""
    },
    AnimationEffectTiming: {
      "^": "AnimationEffectTimingReadOnly;$ti",
      $isAnimationEffectTiming: 1,
      "%": ""
    },
    AnimationEffectTimingReadOnly: {
      "^": "Interceptor;$ti",
      $isAnimationEffectTimingReadOnly: 1,
      "%": ""
    },
    AnimationEvent: {
      "^": "Event;$ti",
      $isAnimationEvent: 1,
      "%": "AnimationEvent"
    },
    AnimationPlaybackEvent: {
      "^": "Event;$ti",
      $isAnimationPlaybackEvent: 1,
      "%": "AnimationPlaybackEvent"
    },
    AnimationTimeline: {
      "^": "Interceptor;$ti",
      $isAnimationTimeline: 1,
      "%": ""
    },
    AnimationWorkletGlobalScope: {
      "^": "WorkletGlobalScope;$ti",
      $isAnimationWorkletGlobalScope: 1,
      "%": ""
    },
    ApplicationCache: {
      "^": "EventTarget;$ti",
      $isApplicationCache: 1,
      "%": ""
    },
    ApplicationCacheErrorEvent: {
      "^": "Event;0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isApplicationCacheErrorEvent: 1,
      "%": "ApplicationCacheErrorEvent"
    },
    AreaElement: {
      "^": "HtmlElement;$ti",
      toString$0: [function(receiver) {
        return String(receiver);
      }, null, "get$toString", 1, 0, null],
      $isAreaElement: 1,
      $isHtmlHyperlinkElementUtils: 1,
      "%": "HTMLAreaElement"
    },
    AudioElement: {
      "^": "MediaElement;$ti",
      $isAudioElement: 1,
      "%": "HTMLAudioElement"
    },
    AuthenticatorAssertionResponse: {
      "^": "AuthenticatorResponse;$ti",
      $isAuthenticatorAssertionResponse: 1,
      "%": ""
    },
    AuthenticatorAttestationResponse: {
      "^": "AuthenticatorResponse;$ti",
      $isAuthenticatorAttestationResponse: 1,
      "%": ""
    },
    AuthenticatorResponse: {
      "^": "Interceptor;$ti",
      $isAuthenticatorResponse: 1,
      "%": ""
    },
    BRElement: {
      "^": "HtmlElement;$ti",
      $isBRElement: 1,
      "%": "HTMLBRElement"
    },
    BackgroundFetchClickEvent: {
      "^": "BackgroundFetchEvent;$ti",
      $isBackgroundFetchClickEvent: 1,
      "%": "BackgroundFetchClickEvent"
    },
    BackgroundFetchEvent: {
      "^": "ExtendableEvent;$ti",
      $isBackgroundFetchEvent: 1,
      "%": ";BackgroundFetchEvent"
    },
    BackgroundFetchFailEvent: {
      "^": "BackgroundFetchEvent;$ti",
      $isBackgroundFetchFailEvent: 1,
      "%": "BackgroundFetchFailEvent"
    },
    BackgroundFetchFetch: {
      "^": "Interceptor;$ti",
      $isBackgroundFetchFetch: 1,
      "%": ""
    },
    BackgroundFetchManager: {
      "^": "Interceptor;$ti",
      $isBackgroundFetchManager: 1,
      "%": ""
    },
    BackgroundFetchRegistration: {
      "^": "EventTarget;$ti",
      $isBackgroundFetchRegistration: 1,
      "%": ""
    },
    BackgroundFetchSettledFetch: {
      "^": "BackgroundFetchFetch;$ti",
      $isBackgroundFetchSettledFetch: 1,
      "%": ""
    },
    BackgroundFetchedEvent: {
      "^": "BackgroundFetchEvent;$ti",
      $isBackgroundFetchedEvent: 1,
      "%": "BackgroundFetchedEvent"
    },
    BarProp: {
      "^": "Interceptor;$ti",
      $isBarProp: 1,
      "%": ""
    },
    BarcodeDetector: {
      "^": "Interceptor;$ti",
      $isBarcodeDetector: 1,
      "%": ""
    },
    BaseElement: {
      "^": "HtmlElement;0href,$ti",
      set$href: function(receiver, href) {
        receiver.href = H.stringTypeCheck(href);
      },
      $isBaseElement: 1,
      "%": "HTMLBaseElement"
    },
    BatteryManager: {
      "^": "EventTarget;$ti",
      $isBatteryManager: 1,
      "%": ""
    },
    BeforeInstallPromptEvent: {
      "^": "Event;$ti",
      $isBeforeInstallPromptEvent: 1,
      "%": "BeforeInstallPromptEvent"
    },
    BeforeUnloadEvent: {
      "^": "Event;$ti",
      $isBeforeUnloadEvent: 1,
      "%": "BeforeUnloadEvent"
    },
    Blob: {
      "^": "Interceptor;$ti",
      $isBlob: 1,
      "%": ";Blob"
    },
    BlobEvent: {
      "^": "Event;$ti",
      $isBlobEvent: 1,
      "%": "BlobEvent"
    },
    BluetoothRemoteGattDescriptor: {
      "^": "Interceptor;$ti",
      $isBluetoothRemoteGattDescriptor: 1,
      "%": ""
    },
    Body: {
      "^": "Interceptor;$ti",
      $isBody: 1,
      "%": ""
    },
    BodyElement: {
      "^": "HtmlElement;$ti",
      get$onScroll: [function(receiver) {
        return C.EventStreamProvider_scroll.forElement$1(receiver);
      }, null, null, 3, 0, null],
      $isBodyElement: 1,
      $isWindowEventHandlers: 1,
      "%": "HTMLBodyElement"
    },
    BroadcastChannel: {
      "^": "EventTarget;$ti",
      $isBroadcastChannel: 1,
      "%": ""
    },
    BudgetState: {
      "^": "Interceptor;$ti",
      $isBudgetState: 1,
      "%": ""
    },
    ButtonElement: {
      "^": "HtmlElement;0name=,$ti",
      $isButtonElement: 1,
      "%": "HTMLButtonElement"
    },
    CDataSection: {
      "^": "Text;$ti",
      $isCDataSection: 1,
      "%": "CDATASection"
    },
    CacheStorage: {
      "^": "Interceptor;$ti",
      $isCacheStorage: 1,
      "%": ""
    },
    CanMakePaymentEvent: {
      "^": "ExtendableEvent;$ti",
      $isCanMakePaymentEvent: 1,
      "%": "CanMakePaymentEvent"
    },
    CanvasCaptureMediaStreamTrack: {
      "^": "MediaStreamTrack;$ti",
      $isCanvasCaptureMediaStreamTrack: 1,
      "%": ""
    },
    CanvasElement: {
      "^": "HtmlElement;0height=,0width=,$ti",
      set$height: function(receiver, height) {
        receiver.height = H.intTypeCheck(height);
      },
      set$width: function(receiver, width) {
        receiver.width = H.intTypeCheck(width);
      },
      get$context2D: [function(receiver) {
        return receiver.getContext("2d");
      }, null, null, 3, 0, null],
      $isCanvasElement: 1,
      $isCanvasImageSource: 1,
      "%": "HTMLCanvasElement"
    },
    CanvasGradient: {
      "^": "Interceptor;$ti",
      $isCanvasGradient: 1,
      "%": "CanvasGradient"
    },
    CanvasPattern: {
      "^": "Interceptor;$ti",
      $isCanvasPattern: 1,
      "%": "CanvasPattern"
    },
    CanvasRenderingContext: {
      "^": "Object;$ti"
    },
    CanvasRenderingContext2D: {
      "^": "Interceptor;0fillStyle},0font,0lineWidth,0strokeStyle},0textAlign,0textBaseline,$ti",
      set$font: function(receiver, font) {
        receiver.font = H.stringTypeCheck(font);
      },
      set$lineWidth: function(receiver, lineWidth) {
        receiver.lineWidth = H.numTypeCheck(lineWidth);
      },
      set$textAlign: function(receiver, textAlign) {
        receiver.textAlign = H.stringTypeCheck(textAlign);
      },
      set$textBaseline: function(receiver, textBaseline) {
        receiver.textBaseline = H.stringTypeCheck(textBaseline);
      },
      beginPath$0: [function(receiver) {
        return receiver.beginPath();
      }, null, "get$beginPath", 1, 0, null],
      clearRect$4: [function(receiver, x, y, width, height) {
        return receiver.clearRect(H.numTypeCheck(x), H.numTypeCheck(y), H.numTypeCheck(width), H.numTypeCheck(height));
      }, null, "get$clearRect", 17, 0, null, 37, 77, 56, 96],
      fillRect$4: [function(receiver, x, y, width, height) {
        return receiver.fillRect(H.numTypeCheck(x), H.numTypeCheck(y), H.numTypeCheck(width), H.numTypeCheck(height));
      }, null, "get$fillRect", 17, 0, null, 37, 77, 56, 96],
      measureText$1: [function(receiver, text) {
        return receiver.measureText(H.stringTypeCheck(text));
      }, null, "get$measureText", 5, 0, null, 17],
      restore$0: [function(receiver) {
        return receiver.restore();
      }, null, "get$restore", 1, 0, null],
      rotate$1: [function(receiver, angle) {
        return receiver.rotate(H.numTypeCheck(angle));
      }, null, "get$rotate", 5, 0, null, 393],
      save$0: [function(receiver) {
        return receiver.save();
      }, null, "get$save", 1, 0, null],
      scale$2: [function(receiver, x, y) {
        return receiver.scale(H.numTypeCheck(x), H.numTypeCheck(y));
      }, null, "get$scale", 9, 0, null, 37, 77],
      stroke$1: [function(receiver, path) {
        return receiver.stroke(H.interceptedTypeCheck(path, "$isPath2D"));
      }, function($receiver) {
        return $receiver.stroke();
      }, "stroke$0", null, null, "get$stroke", 1, 2, null, 0, 26],
      translate$2: [function(receiver, x, y) {
        return receiver.translate(H.numTypeCheck(x), H.numTypeCheck(y));
      }, null, "get$translate", 9, 0, null, 37, 77],
      lineTo$2: [function(receiver, x, y) {
        return receiver.lineTo(H.numTypeCheck(x), H.numTypeCheck(y));
      }, null, "get$lineTo", 9, 0, null, 37, 77],
      moveTo$2: [function(receiver, x, y) {
        return receiver.moveTo(H.numTypeCheck(x), H.numTypeCheck(y));
      }, null, "get$moveTo", 9, 0, null, 37, 77],
      rect$4: [function(receiver, x, y, width, height) {
        return receiver.rect(H.numTypeCheck(x), H.numTypeCheck(y), H.numTypeCheck(width), H.numTypeCheck(height));
      }, "call$4", "get$rect", 17, 0, 92, 37, 77, 56, 96],
      drawImageScaled$5: [function(receiver, source, destX, destY, destWidth, destHeight) {
        return receiver.drawImage(H.interceptedTypeCheck(source, "$isCanvasImageSource"), H.numTypeCheck(destX), H.numTypeCheck(destY), H.numTypeCheck(destWidth), H.numTypeCheck(destHeight));
      }, null, "get$drawImageScaled", 21, 0, null, 11, 908, 909, 1046, 915],
      fillText$4: [function(receiver, text, x, y, maxWidth) {
        H.stringTypeCheck(text);
        H.numTypeCheck(x);
        H.numTypeCheck(y);
        H.numTypeCheck(maxWidth);
        if (maxWidth != null)
          receiver.fillText(text, x, y, maxWidth);
        else
          receiver.fillText(text, x, y);
      }, function($receiver, text, x, y) {
        return this.fillText$4($receiver, text, x, y, null);
      }, "fillText$3", null, null, "get$fillText", 13, 2, null, 0, 17, 37, 77, 918],
      $isCanvasRenderingContext: 1,
      $isCanvasRenderingContext2D: 1,
      "%": "CanvasRenderingContext2D"
    },
    CharacterData: {
      "^": "Node;0length=,$ti",
      $isCharacterData: 1,
      $isChildNode: 1,
      $isNonDocumentTypeChildNode: 1,
      "%": ";CharacterData"
    },
    ChildNode: {
      "^": "Interceptor;$ti"
    },
    Client0: {
      "^": "Interceptor;$ti",
      $isClient0: 1,
      "%": ""
    },
    Clients: {
      "^": "Interceptor;$ti",
      $isClients: 1,
      "%": ""
    },
    ClipboardEvent: {
      "^": "Event;$ti",
      $isClipboardEvent: 1,
      "%": "ClipboardEvent"
    },
    CloseEvent: {
      "^": "Event;0code=,$ti",
      $isCloseEvent: 1,
      "%": "CloseEvent"
    },
    Comment: {
      "^": "CharacterData;$ti",
      $isComment: 1,
      "%": "Comment"
    },
    CompositionEvent: {
      "^": "UIEvent;$ti",
      $isCompositionEvent: 1,
      "%": "CompositionEvent"
    },
    ContentElement: {
      "^": "HtmlElement;$ti",
      $isContentElement: 1,
      "%": "HTMLContentElement"
    },
    CookieStore: {
      "^": "Interceptor;$ti",
      $isCookieStore: 1,
      "%": ""
    },
    Coordinates: {
      "^": "Interceptor;$ti",
      $isCoordinates: 1,
      "%": ""
    },
    Credential: {
      "^": "Interceptor;$ti",
      $isCredential: 1,
      "%": ""
    },
    CredentialUserData: {
      "^": "Interceptor;$ti",
      $isCredentialUserData: 1,
      "%": ""
    },
    CredentialsContainer: {
      "^": "Interceptor;$ti",
      $isCredentialsContainer: 1,
      "%": ""
    },
    Crypto: {
      "^": "Interceptor;$ti",
      $isCrypto: 1,
      "%": ""
    },
    CryptoKey: {
      "^": "Interceptor;$ti",
      $isCryptoKey: 1,
      "%": ""
    },
    Css: {
      "^": "Interceptor;$ti",
      $isCss: 1,
      "%": ""
    },
    CssCharsetRule: {
      "^": "CssRule;$ti",
      $isCssCharsetRule: 1,
      "%": ""
    },
    CssConditionRule: {
      "^": "CssGroupingRule;$ti",
      $isCssConditionRule: 1,
      "%": ""
    },
    CssFontFaceRule: {
      "^": "CssRule;$ti",
      $isCssFontFaceRule: 1,
      "%": ""
    },
    CssGroupingRule: {
      "^": "CssRule;$ti",
      $isCssGroupingRule: 1,
      "%": ""
    },
    CssImageValue: {
      "^": "CssResourceValue;$ti",
      $isCssImageValue: 1,
      "%": ""
    },
    CssImportRule: {
      "^": "CssRule;$ti",
      $isCssImportRule: 1,
      "%": ""
    },
    CssKeyframeRule: {
      "^": "CssRule;$ti",
      $isCssKeyframeRule: 1,
      "%": ""
    },
    CssKeyframesRule: {
      "^": "CssRule;$ti",
      $isCssKeyframesRule: 1,
      "%": ""
    },
    CssKeywordValue: {
      "^": "CssStyleValue;$ti",
      $isCssKeywordValue: 1,
      "%": ""
    },
    CssMatrixComponent: {
      "^": "CssTransformComponent;$ti",
      $isCssMatrixComponent: 1,
      "%": ""
    },
    CssMediaRule: {
      "^": "CssConditionRule;$ti",
      $isCssMediaRule: 1,
      "%": ""
    },
    CssNamespaceRule: {
      "^": "CssRule;$ti",
      $isCssNamespaceRule: 1,
      "%": ""
    },
    CssNumericValue: {
      "^": "CssStyleValue;$ti",
      $isCssNumericValue: 1,
      "%": ""
    },
    CssPageRule: {
      "^": "CssRule;$ti",
      $isCssPageRule: 1,
      "%": ""
    },
    CssPerspective: {
      "^": "CssTransformComponent;$ti",
      $isCssPerspective: 1,
      "%": ""
    },
    CssPositionValue: {
      "^": "CssStyleValue;$ti",
      $isCssPositionValue: 1,
      "%": ""
    },
    CssResourceValue: {
      "^": "CssStyleValue;$ti",
      $isCssResourceValue: 1,
      "%": ""
    },
    CssRotation: {
      "^": "CssTransformComponent;$ti",
      $isCssRotation: 1,
      "%": ""
    },
    CssRule: {
      "^": "Interceptor;$ti",
      $isCssRule: 1,
      "%": ""
    },
    CssScale: {
      "^": "CssTransformComponent;$ti",
      $isCssScale: 1,
      "%": ""
    },
    CssSkew: {
      "^": "CssTransformComponent;$ti",
      $isCssSkew: 1,
      "%": ""
    },
    CssStyleDeclaration: {
      "^": "_CssStyleDeclaration_Interceptor_CssStyleDeclarationBase;0length=,$ti",
      getPropertyValue$1: [function(receiver, propertyName) {
        var propValue = this._getPropertyValueHelper$1(receiver, H.stringTypeCheck(propertyName));
        return propValue == null ? "" : propValue;
      }, null, "get$getPropertyValue", 5, 0, null, 105],
      _getPropertyValueHelper$1: [function(receiver, propertyName) {
        return this._getPropertyValue$1(receiver, this._browserPropertyName$1(receiver, H.stringTypeCheck(propertyName)));
      }, null, "get$_getPropertyValueHelper", 5, 0, null, 105],
      _supportsProperty$1: [function(receiver, propertyName) {
        return H.stringTypeCheck(propertyName) in receiver;
      }, null, "get$_supportsProperty", 5, 0, null, 105],
      setProperty$3: [function(receiver, propertyName, value, priority) {
        H.stringTypeCheck(propertyName);
        H.stringTypeCheck(value);
        H.stringTypeCheck(priority);
        return this._setPropertyHelper$3(receiver, this._browserPropertyName$1(receiver, propertyName), value, priority);
      }, null, "get$setProperty", 9, 2, null, 0, 105, 1, 394],
      _browserPropertyName$1: [function(receiver, propertyName) {
        var $name;
        H.stringTypeCheck(propertyName);
        $name = W.CssStyleDeclaration__readCache(propertyName);
        if (typeof $name === "string")
          return $name;
        $name = this._supportedBrowserPropertyName$1(receiver, propertyName);
        W.CssStyleDeclaration__writeCache(propertyName, $name);
        return $name;
      }, null, "get$_browserPropertyName", 5, 0, null, 105],
      _supportedBrowserPropertyName$1: [function(receiver, propertyName) {
        var prefixed;
        H.stringTypeCheck(propertyName);
        if (this._supportsProperty$1(receiver, W.CssStyleDeclaration__camelCase(propertyName)))
          return propertyName;
        prefixed = H.S(P.Device_cssPrefix()) + H.S(propertyName);
        if (this._supportsProperty$1(receiver, prefixed))
          return prefixed;
        return propertyName;
      }, null, "get$_supportedBrowserPropertyName", 5, 0, null, 105],
      _setPropertyHelper$3: [function(receiver, propertyName, value, priority) {
        H.stringTypeCheck(propertyName);
        H.stringTypeCheck(value);
        H.stringTypeCheck(priority);
        if (value == null)
          value = "";
        if (priority == null)
          priority = "";
        receiver.setProperty(propertyName, value, priority);
      }, null, "get$_setPropertyHelper", 9, 2, null, 0, 105, 1, 394],
      _getPropertyValue$1: [function(receiver, property) {
        return receiver.getPropertyValue(H.stringTypeCheck(property));
      }, null, "get$_getPropertyValue", 5, 0, null, 67],
      set$backgroundImage: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.backgroundImage = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      set$bottom: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.bottom = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      get$clear: [function(receiver) {
        return receiver.clear;
      }, null, null, 3, 0, null],
      set$color: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.color = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      set$display: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.display = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      set$font: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.font = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      get$height: [function(receiver) {
        return receiver.height;
      }, null, null, 3, 0, null],
      set$height: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.height = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      get$left: [function(receiver) {
        return receiver.left;
      }, null, null, 3, 0, null],
      set$left: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.left = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      set$overflow: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.overflow = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      set$paddingLeft: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.paddingLeft = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      set$position: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.position = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      set$right: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.right = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      get$top: [function(receiver) {
        return receiver.top;
      }, null, null, 3, 0, null],
      set$top: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.top = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      get$width: [function(receiver) {
        return receiver.width;
      }, null, null, 3, 0, null],
      set$width: [function(receiver, value) {
        H.stringTypeCheck(value);
        receiver.width = value == null ? "" : value;
      }, null, null, 7, 0, null, 1],
      clear$0: function($receiver) {
        return this.get$clear($receiver).call$0();
      },
      clear$1: function($receiver, arg0) {
        return this.get$clear($receiver).call$1(arg0);
      },
      $isCssStyleDeclaration: 1,
      $isCssStyleDeclarationBase: 1,
      "%": "CSS2Properties|CSSStyleDeclaration|MSStyleCSSProperties"
    },
    _CssStyleDeclarationSet: {
      "^": "__CssStyleDeclarationSet_Object_CssStyleDeclarationBase;$ti",
      $isCssStyleDeclarationBase: 1
    },
    CssStyleDeclarationBase: {
      "^": "Object;$ti",
      set$backgroundImage: [function(receiver, value) {
        this.setProperty$3(receiver, "background-image", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$bottom: [function(receiver, value) {
        this.setProperty$3(receiver, "bottom", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      get$clear: [function(receiver) {
        return this.getPropertyValue$1(receiver, "clear");
      }, null, null, 3, 0, null],
      set$display: [function(receiver, value) {
        this.setProperty$3(receiver, "display", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$font: [function(receiver, value) {
        this.setProperty$3(receiver, "font", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      get$height: [function(receiver) {
        return this.getPropertyValue$1(receiver, "height");
      }, null, null, 3, 0, null],
      set$height: [function(receiver, value) {
        this.setProperty$3(receiver, "height", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      get$left: [function(receiver) {
        return this.getPropertyValue$1(receiver, "left");
      }, null, null, 3, 0, null],
      set$left: [function(receiver, value) {
        this.setProperty$3(receiver, "left", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$overflow: [function(receiver, value) {
        this.setProperty$3(receiver, "overflow", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$overflowX: [function(receiver, value) {
        this.setProperty$3(receiver, "overflow-x", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$paddingLeft: [function(receiver, value) {
        this.setProperty$3(receiver, "padding-left", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$position: [function(receiver, value) {
        this.setProperty$3(receiver, "position", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$right: [function(receiver, value) {
        this.setProperty$3(receiver, "right", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      get$top: [function(receiver) {
        return this.getPropertyValue$1(receiver, "top");
      }, null, null, 3, 0, null],
      set$top: [function(receiver, value) {
        this.setProperty$3(receiver, "top", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      set$transform: [function(receiver, value) {
        this.setProperty$3(receiver, "transform", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      get$width: [function(receiver) {
        return this.getPropertyValue$1(receiver, "width");
      }, null, null, 3, 0, null],
      set$width: [function(receiver, value) {
        this.setProperty$3(receiver, "width", H.stringTypeCheck(value), "");
      }, null, null, 7, 0, null, 1],
      clear$0: function($receiver) {
        return this.get$clear($receiver).call$0();
      },
      clear$1: function($receiver, arg0) {
        return this.get$clear($receiver).call$1(arg0);
      }
    },
    CssStyleRule: {
      "^": "CssRule;$ti",
      $isCssStyleRule: 1,
      "%": ""
    },
    CssStyleSheet: {
      "^": "StyleSheet;$ti",
      $isCssStyleSheet: 1,
      "%": ""
    },
    CssStyleValue: {
      "^": "Interceptor;$ti",
      $isCssStyleValue: 1,
      "%": ""
    },
    CssSupportsRule: {
      "^": "CssConditionRule;$ti",
      $isCssSupportsRule: 1,
      "%": ""
    },
    CssTransformComponent: {
      "^": "Interceptor;$ti",
      $isCssTransformComponent: 1,
      "%": ""
    },
    CssTransformValue: {
      "^": "CssStyleValue;$ti",
      $isCssTransformValue: 1,
      "%": ""
    },
    CssTranslation: {
      "^": "CssTransformComponent;$ti",
      $isCssTranslation: 1,
      "%": ""
    },
    CssUnitValue: {
      "^": "CssNumericValue;$ti",
      $isCssUnitValue: 1,
      "%": ""
    },
    CssUnparsedValue: {
      "^": "CssStyleValue;$ti",
      $isCssUnparsedValue: 1,
      "%": ""
    },
    CssVariableReferenceValue: {
      "^": "Interceptor;$ti",
      $isCssVariableReferenceValue: 1,
      "%": ""
    },
    CssViewportRule: {
      "^": "CssRule;$ti",
      $isCssViewportRule: 1,
      "%": ""
    },
    CssurlImageValue: {
      "^": "CssImageValue;$ti",
      $isCssurlImageValue: 1,
      "%": ""
    },
    CustomElementRegistry: {
      "^": "Interceptor;$ti",
      $isCustomElementRegistry: 1,
      "%": ""
    },
    CustomEvent: {
      "^": "Event;$ti",
      $isCustomEvent: 1,
      "%": "CustomEvent"
    },
    DListElement: {
      "^": "HtmlElement;$ti",
      $isDListElement: 1,
      "%": "HTMLDListElement"
    },
    DataElement: {
      "^": "HtmlElement;$ti",
      $isDataElement: 1,
      "%": "HTMLDataElement"
    },
    DataListElement: {
      "^": "HtmlElement;$ti",
      $isDataListElement: 1,
      "%": "HTMLDataListElement"
    },
    DataTransfer: {
      "^": "Interceptor;$ti",
      $isDataTransfer: 1,
      "%": ""
    },
    DataTransferItem: {
      "^": "Interceptor;$ti",
      $isDataTransferItem: 1,
      "%": ""
    },
    DataTransferItemList: {
      "^": "Interceptor;$ti",
      $isDataTransferItemList: 1,
      "%": ""
    },
    DedicatedWorkerGlobalScope: {
      "^": "WorkerGlobalScope;$ti",
      $isDedicatedWorkerGlobalScope: 1,
      "%": "DedicatedWorkerGlobalScope"
    },
    DeprecatedStorageInfo: {
      "^": "Interceptor;$ti",
      $isDeprecatedStorageInfo: 1,
      "%": ""
    },
    DeprecatedStorageQuota: {
      "^": "Interceptor;$ti",
      $isDeprecatedStorageQuota: 1,
      "%": ""
    },
    DeprecationReport: {
      "^": "ReportBody;$ti",
      $isDeprecationReport: 1,
      "%": ""
    },
    DetailsElement: {
      "^": "HtmlElement;$ti",
      $isDetailsElement: 1,
      "%": "HTMLDetailsElement"
    },
    DetectedBarcode: {
      "^": "Interceptor;$ti",
      $isDetectedBarcode: 1,
      "%": ""
    },
    DetectedFace: {
      "^": "Interceptor;$ti",
      $isDetectedFace: 1,
      "%": ""
    },
    DetectedText: {
      "^": "Interceptor;$ti",
      $isDetectedText: 1,
      "%": ""
    },
    DeviceAcceleration: {
      "^": "Interceptor;$ti",
      $isDeviceAcceleration: 1,
      "%": ""
    },
    DeviceMotionEvent: {
      "^": "Event;$ti",
      $isDeviceMotionEvent: 1,
      "%": "DeviceMotionEvent"
    },
    DeviceOrientationEvent: {
      "^": "Event;$ti",
      $isDeviceOrientationEvent: 1,
      "%": "DeviceOrientationEvent"
    },
    DeviceRotationRate: {
      "^": "Interceptor;$ti",
      $isDeviceRotationRate: 1,
      "%": ""
    },
    DialogElement: {
      "^": "HtmlElement;$ti",
      $isDialogElement: 1,
      "%": "HTMLDialogElement"
    },
    DirectoryEntry: {
      "^": "Entry;$ti",
      $isDirectoryEntry: 1,
      "%": ""
    },
    DirectoryReader: {
      "^": "Interceptor;$ti",
      $isDirectoryReader: 1,
      "%": ""
    },
    DivElement: {
      "^": "HtmlElement;$ti",
      $isDivElement: 1,
      "%": "HTMLDivElement"
    },
    Document: {
      "^": "Node;0implementation=,0fonts=,$ti",
      adoptNode$1: [function(receiver, node) {
        return receiver.adoptNode(H.interceptedTypeCheck(node, "$isNode"));
      }, null, "get$adoptNode", 5, 0, null, 23],
      createDocumentFragment$0: [function(receiver) {
        return receiver.createDocumentFragment();
      }, null, "get$createDocumentFragment", 1, 0, null],
      _createElement$2: [function(receiver, localName_OR_tagName, options_OR_typeExtension) {
        return receiver.createElement(H.stringTypeCheck(localName_OR_tagName), options_OR_typeExtension);
      }, null, "get$_createElement", 5, 2, null, 0, 957, 962],
      querySelector$1: [function(receiver, selectors) {
        return receiver.querySelector(H.stringTypeCheck(selectors));
      }, null, "get$querySelector", 5, 0, null, 145],
      _querySelectorAll$1: [function(receiver, selectors) {
        return receiver.querySelectorAll(H.stringTypeCheck(selectors));
      }, null, "get$_querySelectorAll", 5, 0, null, 145],
      querySelectorAll$1$1: [1, function(receiver, selectors, $T) {
        H.assertIsSubtype($T, W.Element, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'querySelectorAll'.");
        return W._FrozenElementList$_wrap(this._querySelectorAll$1(receiver, H.stringTypeCheck(selectors)), $T);
      }, function($receiver, selectors) {
        return this.querySelectorAll$1$1($receiver, selectors, W.Element);
      }, "querySelectorAll$1", null, "call$1", "get$querySelectorAll", 5, 0, null, 145],
      createElement$2: [function(receiver, tagName, typeExtension) {
        H.stringTypeCheck(tagName);
        H.stringTypeCheck(typeExtension);
        return H.interceptedTypeCheck(typeExtension == null ? this._createElement_2$1(receiver, tagName) : this._createElement$2(receiver, tagName, typeExtension), "$isElement");
      }, function($receiver, tagName) {
        return this.createElement$2($receiver, tagName, null);
      }, "createElement$1", null, null, "get$createElement", 5, 2, null, 0, 395, 384],
      _createElement_2$1: [function(receiver, tagName) {
        return receiver.createElement(H.stringTypeCheck(tagName));
      }, null, "get$_createElement_2", 5, 0, null, 395],
      $isDocument: 1,
      "%": ";Document"
    },
    DocumentFragment: {
      "^": "Node;$ti",
      $isDocumentFragment: 1,
      $isNonElementParentNode: 1,
      $isParentNode: 1,
      "%": ";DocumentFragment"
    },
    DocumentOrShadowRoot: {
      "^": "Interceptor;$ti",
      $isDocumentOrShadowRoot: 1,
      "%": ""
    },
    DocumentTimeline: {
      "^": "AnimationTimeline;$ti",
      $isDocumentTimeline: 1,
      "%": ""
    },
    DomError: {
      "^": "Interceptor;0message=,0name=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isDomError: 1,
      "%": "DOMError"
    },
    DomException: {
      "^": "Interceptor;0message=,$ti",
      get$name: [function(receiver) {
        var errorName = receiver.name;
        if (P.Device_isWebKit() && errorName === "SECURITY_ERR")
          return "SecurityError";
        if (P.Device_isWebKit() && errorName === "SYNTAX_ERR")
          return "SyntaxError";
        return errorName;
      }, null, null, 3, 0, null],
      toString$0: [function(receiver) {
        return String(receiver);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isDomException: 1,
      "%": "DOMException"
    },
    DomImplementation: {
      "^": "Interceptor;$ti",
      createHtmlDocument$1: [function(receiver, title) {
        return receiver.createHTMLDocument(H.stringTypeCheck(title));
      }, null, "get$createHtmlDocument", 1, 2, null, 0, 86],
      $isDomImplementation: 1,
      "%": "DOMImplementation"
    },
    DomIterator: {
      "^": "Interceptor;$ti",
      $isDomIterator: 1,
      "%": ""
    },
    DomMatrix: {
      "^": "DomMatrixReadOnly;$ti",
      $isDomMatrix: 1,
      "%": ""
    },
    DomMatrixReadOnly: {
      "^": "Interceptor;$ti",
      $isDomMatrixReadOnly: 1,
      "%": ""
    },
    DomParser: {
      "^": "Interceptor;$ti",
      $isDomParser: 1,
      "%": ""
    },
    DomPoint: {
      "^": "DomPointReadOnly;$ti",
      $isDomPoint: 1,
      "%": ""
    },
    DomPointReadOnly: {
      "^": "Interceptor;$ti",
      $isDomPointReadOnly: 1,
      "%": ""
    },
    DomQuad: {
      "^": "Interceptor;$ti",
      $isDomQuad: 1,
      "%": ""
    },
    DomRectList: {
      "^": "_DomRectList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [[P.Rectangle, P.num]];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [[P.Rectangle, P.num]];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isList: 1,
      $asList: function() {
        return [[P.Rectangle, P.num]];
      },
      $isDomRectList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [[P.Rectangle, P.num]];
      },
      "%": ""
    },
    DomRectReadOnly: {
      "^": "Interceptor;$ti",
      toString$0: [function(receiver) {
        return "Rectangle (" + H.S(this.get$left(receiver)) + ", " + H.S(this.get$top(receiver)) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
      }, null, "get$toString", 1, 0, null],
      $eq: [function(receiver, other) {
        var t1;
        if (other == null)
          return false;
        if (!H.checkSubtype(other, "$isRectangle", [P.num], "$asRectangle"))
          return false;
        t1 = J.getInterceptor$x(other);
        return J.$eq$(this.get$left(receiver), t1.get$left(other)) && J.$eq$(this.get$top(receiver), t1.get$top(other)) && J.$eq$(this.get$width(receiver), t1.get$width(other)) && J.$eq$(this.get$height(receiver), t1.get$height(other));
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(receiver) {
        return W._JenkinsSmiHash_hash4(J.get$hashCode$(this.get$left(receiver)), J.get$hashCode$(this.get$top(receiver)), J.get$hashCode$(this.get$width(receiver)), J.get$hashCode$(this.get$height(receiver)));
      }, null, null, 3, 0, null],
      get$height: [function(receiver) {
        return receiver.height;
      }, null, null, 3, 0, null],
      get$left: [function(receiver) {
        return receiver.left;
      }, null, null, 3, 0, null],
      get$top: [function(receiver) {
        return receiver.top;
      }, null, null, 3, 0, null],
      get$width: [function(receiver) {
        return receiver.width;
      }, null, null, 3, 0, null],
      get$x: [function(receiver) {
        return receiver.x;
      }, null, null, 3, 0, null],
      get$y: [function(receiver) {
        return receiver.y;
      }, null, null, 3, 0, null],
      $isDomRectReadOnly: 1,
      $is_RectangleBase: 1,
      $as_RectangleBase: function() {
        return [P.num];
      },
      $isRectangle: 1,
      $asRectangle: function() {
        return [P.num];
      },
      "%": ";DOMRectReadOnly"
    },
    DomStringList: {
      "^": "_DomStringList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [P.String];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [P.String];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [P.String];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.String];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      },
      $isDomStringList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.String];
      },
      "%": ""
    },
    DomStringMap: {
      "^": "Interceptor;$ti",
      $isDomStringMap: 1,
      "%": ""
    },
    DomTokenList: {
      "^": "Interceptor;0length=,$ti",
      $isDomTokenList: 1,
      "%": "DOMTokenList"
    },
    _ChildrenElementList: {
      "^": "ListBase;_element,_childElements,$ti",
      contains$1: [function(_, element) {
        return J.contains$1$asx(this._childElements, element);
      }, null, "get$contains", 5, 0, null, 10],
      get$isEmpty: [function(_) {
        return J.get$_firstElementChild$x(this._element) == null;
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this._childElements);
      }, null, null, 3, 0, null],
      $index: [function(_, index) {
        return H.interceptedTypeCheck(J.$index$asx(this._childElements, H.intTypeCheck(index)), "$isElement");
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(_, index, value) {
        H.intTypeCheck(index);
        J._replaceChild$2$x(this._element, H.interceptedTypeCheck(value, "$isElement"), J.$index$asx(this._childElements, index));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(_, newLength) {
        H.intTypeCheck(newLength);
        throw H.wrapException(P.UnsupportedError$("Cannot resize element lists"));
      }, null, null, 7, 0, null, 162],
      add$1: [function(_, value) {
        H.interceptedTypeCheck(value, "$isElement");
        J.append$1$x(this._element, value);
        return value;
      }, "call$1", "get$add", 5, 0, 94, 1],
      get$iterator: [function(_) {
        return J.get$iterator$ax(this.toList$0(this));
      }, null, null, 3, 0, null],
      addAll$1: [function(_, iterable) {
        var t1, t2, t3;
        t1 = W.Element;
        H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
        for (t1 = J.get$iterator$ax(iterable instanceof W._ChildNodeListLazy ? P.List_List$from(iterable, true, t1) : iterable), t2 = this._element, t3 = J.getInterceptor$x(t2); t1.moveNext$0();)
          t3.append$1(t2, t1.get$current());
      }, null, "get$addAll", 5, 0, null, 13],
      sort$1: [function(_, compare) {
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Element, W.Element]});
        throw H.wrapException(P.UnsupportedError$("Cannot sort element lists"));
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      replaceRange$3: [function(_, start, end, iterable) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
        throw H.wrapException(P.UnimplementedError$(null));
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 13],
      setRange$4: [function(_, start, end, iterable, skipCount) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
        H.intTypeCheck(skipCount);
        throw H.wrapException(P.UnimplementedError$(null));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      remove$1: [function(_, object) {
        var t1, t2;
        if (!!J.getInterceptor$(object).$isElement) {
          t1 = object.parentNode;
          t2 = this._element;
          if (t1 == null ? t2 == null : t1 === t2) {
            J._removeChild$1$x(t2, object);
            return true;
          }
        }
        return false;
      }, null, "get$remove", 5, 0, null, 9],
      insert$2: [function(_, index, element) {
        var t1;
        H.intTypeCheck(index);
        H.interceptedTypeCheck(element, "$isElement");
        if (typeof index !== "number")
          return index.$lt();
        if (index >= 0) {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = index > t1;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
        t1 = this._element;
        if (index === this.get$length(this))
          J.append$1$x(t1, element);
        else
          J.insertBefore$2$x(t1, element, this.$index(0, index));
      }, null, "get$insert", 9, 0, null, 6, 10],
      setAll$2: [function(_, index, iterable) {
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
        throw H.wrapException(P.UnimplementedError$(null));
      }, null, "get$setAll", 9, 0, null, 6, 13],
      clear$0: [function(_) {
        J._clearChildren$0$x(this._element);
      }, null, "get$clear", 1, 0, null],
      removeAt$1: [function(_, index) {
        var result = this.$index(0, H.intTypeCheck(index));
        if (result != null)
          J._removeChild$1$x(this._element, result);
        return result;
      }, null, "get$removeAt", 5, 0, null, 6],
      removeLast$0: [function(_) {
        var result = this.get$last(this);
        if (result != null)
          J._removeChild$1$x(this._element, result);
        return result;
      }, null, "get$removeLast", 1, 0, null],
      get$first: [function(_) {
        var result = J.get$_firstElementChild$x(this._element);
        if (result == null)
          throw H.wrapException(P.StateError$("No elements"));
        return result;
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        var result = J.get$_lastElementChild$x(this._element);
        if (result == null)
          throw H.wrapException(P.StateError$("No elements"));
        return result;
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        if (J.$gt$n(this.get$length(this), 1))
          throw H.wrapException(P.StateError$("More than one element"));
        return this.get$first(this);
      }, null, null, 3, 0, null],
      $asEfficientLengthIterable: function() {
        return [W.Element];
      },
      $asListBase: function() {
        return [W.Element];
      },
      $asListMixin: function() {
        return [W.Element];
      },
      $asIterable: function() {
        return [W.Element];
      },
      $asList: function() {
        return [W.Element];
      },
      $isNodeListWrapper: 1,
      $as_ListBase_Object_ListMixin: function() {
        return [W.Element];
      },
      static: {
        _ChildrenElementList$_wrap: [function(element) {
          return new W._ChildrenElementList(element, element.children, []);
        }, null, null, 4, 0, null, 10]
      }
    },
    _ChildrenElementList__filter_closure: {
      "^": "Closure:276;$ti"
    },
    ElementList: {
      "^": "ListBase;$ti"
    },
    _FrozenElementList: {
      "^": "ListBase;_nodeList,$ti",
      _FrozenElementList$_wrap$1: [function(_nodeList, $E) {
      }, null, null, 4, 0, null, 381],
      get$length: [function(_) {
        return J.get$length$asx(this._nodeList);
      }, null, null, 3, 0, null],
      $index: [function(_, index) {
        return H.assertSubtypeOfRuntimeType(J.$index$asx(this._nodeList, H.intTypeCheck(index)), H.getTypeArgumentByIndex(this, 0));
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(_, index, value) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
        throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(_, newLength) {
        H.intTypeCheck(newLength);
        throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
      }, null, null, 7, 0, null, 162],
      sort$1: [function(_, compare) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
        throw H.wrapException(P.UnsupportedError$("Cannot sort list"));
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      get$first: [function(_) {
        return H.assertSubtypeOfRuntimeType(J.get$first$ax(this._nodeList), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        return H.assertSubtypeOfRuntimeType(J.get$last$ax(this._nodeList), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        return H.assertSubtypeOfRuntimeType(J.get$single$ax(this._nodeList), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      $isElementList: 1,
      $isNodeListWrapper: 1,
      static: {
        _FrozenElementList$_wrap: [function(_nodeList, $E) {
          var t1 = new W._FrozenElementList(_nodeList, [$E]);
          t1._FrozenElementList$_wrap$1(_nodeList, $E);
          return t1;
        }, null, null, 4, 0, null, 381]
      }
    },
    _FrozenElementList$_wrap_closure: {
      "^": "Closure:25;$ti"
    },
    _FrozenElementList$_wrap_closure0: {
      "^": "Closure:25;$ti"
    },
    Element: {
      "^": "Node;0style=,0title,0_attributes:attributes=,0className=,0innerHTML,0tagName=,0_firstElementChild:firstElementChild=,0_lastElementChild:lastElementChild=,$ti",
      set$title: function(receiver, title) {
        receiver.title = H.stringTypeCheck(title);
      },
      set$className: function(receiver, className) {
        receiver.className = H.stringTypeCheck(className);
      },
      set$_innerHtml: function(receiver, _innerHtml) {
        receiver.innerHTML = H.stringTypeCheck(_innerHtml);
      },
      get$attributes: [function(receiver) {
        return W._ElementAttributeMap$(receiver);
      }, null, null, 3, 0, null],
      get$children: [function(receiver) {
        return W._ChildrenElementList$_wrap(receiver);
      }, null, null, 3, 0, null],
      querySelectorAll$1$1: [1, function(receiver, selectors, $T) {
        H.assertIsSubtype($T, W.Element, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'querySelectorAll'.");
        return W._FrozenElementList$_wrap(this._querySelectorAll$1(receiver, H.stringTypeCheck(selectors)), $T);
      }, function($receiver, selectors) {
        return this.querySelectorAll$1$1($receiver, selectors, W.Element);
      }, "querySelectorAll$1", null, "call$1", "get$querySelectorAll", 5, 0, null, 145],
      get$classes: [function(receiver) {
        return W._ElementCssClassSet$(receiver);
      }, null, null, 3, 0, null],
      get$localName: [function(receiver) {
        return receiver.localName;
      }, null, null, 3, 0, null],
      toString$0: [function(receiver) {
        return this.get$localName(receiver);
      }, null, "get$toString", 1, 0, null],
      scrollIntoView$1: [function(receiver, alignment) {
        var hasScrollIntoViewIfNeeded;
        H.interceptedTypeCheck(alignment, "$isScrollAlignment");
        hasScrollIntoViewIfNeeded = !!receiver.scrollIntoViewIfNeeded;
        if (alignment === C.ScrollAlignment_TOP)
          this._scrollIntoView$1(receiver, true);
        else if (alignment === C.ScrollAlignment_BOTTOM)
          this._scrollIntoView$1(receiver, false);
        else if (hasScrollIntoViewIfNeeded)
          if (alignment === C.ScrollAlignment_CENTER)
            this._scrollIntoViewIfNeeded$1(receiver, true);
          else
            receiver.scrollIntoViewIfNeeded();
        else
          receiver.scrollIntoView();
      }, function($receiver) {
        return this.scrollIntoView$1($receiver, null);
      }, "scrollIntoView$0", null, null, "get$scrollIntoView", 1, 2, null, 0, 982],
      createFragment$3$treeSanitizer$validator: ["super$Element$createFragment", function(receiver, html, treeSanitizer, validator) {
        var t1, base, t2, contextElement, fragment;
        H.stringTypeCheck(html);
        H.interceptedTypeCheck(validator, "$isNodeValidator");
        H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
        if (treeSanitizer == null) {
          if (validator == null) {
            t1 = $.Element__defaultValidator;
            if (t1 == null) {
              t1 = W.NodeValidatorBuilder$common();
              $.Element__defaultValidator = t1;
              validator = t1;
            } else
              validator = t1;
          }
          t1 = $.Element__defaultSanitizer;
          if (t1 == null)
            $.Element__defaultSanitizer = W._ValidatingTreeSanitizer$(validator);
          else
            t1.set$validator(validator);
          treeSanitizer = $.Element__defaultSanitizer;
        } else if (validator != null)
          throw H.wrapException(P.ArgumentError$("validator can only be passed if treeSanitizer is null"));
        if ($.Element__parseDocument == null) {
          t1 = J.createHtmlDocument$1$x(J.get$implementation$x(W.document()), "");
          $.Element__parseDocument = t1;
          $.Element__parseRange = t1.createRange();
          base = H.interceptedTypeCheck(J.createElement$1$x($.Element__parseDocument, "base"), "$isBaseElement");
          base.href = H.stringTypeCheck(J.get$baseUri$x(W.document()));
          J.append$1$x(J.get$head$x($.Element__parseDocument), base);
        }
        if (J.get$body$x($.Element__parseDocument) == null) {
          t1 = $.Element__parseDocument;
          t2 = J.getInterceptor$x(t1);
          t2.set$body(t1, H.interceptedTypeCheck(t2.createElement$1(t1, "body"), "$isBodyElement"));
        }
        t1 = $.Element__parseDocument;
        if (!!this.$isBodyElement)
          contextElement = J.get$body$x(t1);
        else {
          contextElement = J.createElement$1$x(t1, receiver.tagName);
          t1 = J.get$body$x($.Element__parseDocument);
          H.interceptedTypeCheck(contextElement, "$isNode");
          J.append$1$x(t1, contextElement);
        }
        if (W.Range_supportsCreateContextualFragment() && this.get$_canBeUsedToCreateContextualFragment(receiver)) {
          J.selectNodeContents$1$x($.Element__parseRange, H.interceptedTypeCheck(contextElement, "$isNode"));
          fragment = J.createContextualFragment$1$x($.Element__parseRange, html);
        } else {
          t1 = J.getInterceptor$x(contextElement);
          t1.set$_innerHtml(contextElement, html);
          fragment = J.createDocumentFragment$0$x($.Element__parseDocument);
          for (t2 = J.getInterceptor$x(fragment); t1.get$firstChild(contextElement) != null;)
            t2.append$1(fragment, t1.get$firstChild(contextElement));
        }
        t1 = J.getInterceptor$(contextElement);
        if (!t1.$eq(contextElement, J.get$body$x($.Element__parseDocument)))
          t1.remove$0(contextElement);
        H.interceptedTypeCheck(fragment, "$isNode");
        treeSanitizer.sanitizeTree$1(fragment);
        J.adoptNode$1$x(W.document(), fragment);
        return H.interceptedTypeCheck(fragment, "$isDocumentFragment");
      }, function($receiver, html, treeSanitizer) {
        return this.createFragment$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
      }, "createFragment$2$treeSanitizer", null, null, "get$createFragment", 5, 5, null, 0, 0, 149, 117, 97],
      get$_canBeUsedToCreateContextualFragment: [function(receiver) {
        return !this.get$_cannotBeUsedToCreateContextualFragment(receiver);
      }, null, null, 3, 0, null],
      get$_cannotBeUsedToCreateContextualFragment: [function(receiver) {
        return C.JSArray_methods.contains$1(C.List_ego, receiver.tagName);
      }, null, null, 3, 0, null],
      setInnerHtml$3$treeSanitizer$validator: [function(receiver, html, treeSanitizer, validator) {
        H.stringTypeCheck(html);
        H.interceptedTypeCheck(validator, "$isNodeValidator");
        H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
        receiver.textContent = null;
        this.append$1(receiver, this.createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, validator));
      }, function($receiver, html, treeSanitizer) {
        return this.setInnerHtml$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
      }, "setInnerHtml$2$treeSanitizer", function($receiver, html) {
        return this.setInnerHtml$3$treeSanitizer$validator($receiver, html, null, null);
      }, "setInnerHtml$1", null, null, null, "get$setInnerHtml", 5, 5, null, 0, 0, 149, 117, 97],
      get$offsetHeight: [function(receiver) {
        return H.intTypeCheck(C.JSNumber_methods.round$0(receiver.offsetHeight));
      }, null, null, 3, 0, null],
      get$offsetWidth: [function(receiver) {
        return H.intTypeCheck(C.JSNumber_methods.round$0(receiver.offsetWidth));
      }, null, null, 3, 0, null],
      get$scrollHeight: [function(receiver) {
        return H.intTypeCheck(C.JSNumber_methods.round$0(receiver.scrollHeight));
      }, null, null, 3, 0, null],
      get$scrollLeft: [function(receiver) {
        return H.intTypeCheck(C.JSNumber_methods.round$0(receiver.scrollLeft));
      }, null, null, 3, 0, null],
      get$scrollTop: [function(receiver) {
        return H.intTypeCheck(C.JSNumber_methods.round$0(receiver.scrollTop));
      }, null, null, 3, 0, null],
      set$scrollTop: [function(receiver, value) {
        receiver.scrollTop = J.round$0$n(H.intTypeCheck(value));
      }, null, null, 7, 0, null, 1],
      getAttribute$1: [function(receiver, $name) {
        return receiver.getAttribute(H.stringTypeCheck($name));
      }, null, "get$getAttribute", 5, 0, null, 8],
      getBoundingClientRect$0: [function(receiver) {
        return receiver.getBoundingClientRect();
      }, null, "get$getBoundingClientRect", 1, 0, null],
      _hasAttribute$1: [function(receiver, $name) {
        return receiver.hasAttribute(H.stringTypeCheck($name));
      }, null, "get$_hasAttribute", 5, 0, null, 8],
      _removeAttribute$1: [function(receiver, $name) {
        return receiver.removeAttribute(H.stringTypeCheck($name));
      }, null, "get$_removeAttribute", 5, 0, null, 8],
      _scrollIntoView$1: [function(receiver, arg) {
        return receiver.scrollIntoView(arg);
      }, null, "get$_scrollIntoView", 1, 2, null, 0, 44],
      _scrollIntoViewIfNeeded$1: [function(receiver, centerIfNeeded) {
        return receiver.scrollIntoViewIfNeeded(H.boolTypeCheck(centerIfNeeded));
      }, null, "get$_scrollIntoViewIfNeeded", 1, 2, null, 0, 983],
      scrollTo$2: [function(receiver, options_OR_x, y) {
        H.numTypeCheck(y);
        if (options_OR_x == null && y == null) {
          receiver.scrollTo();
          return;
        }
        if (!!J.getInterceptor$(options_OR_x).$isMap && y == null) {
          this._scrollTo_2$1(receiver, P.convertDartToNative_Dictionary(options_OR_x, null));
          return;
        }
        if (y != null && typeof options_OR_x === "number") {
          this._scrollTo_3$2(receiver, options_OR_x, y);
          return;
        }
        throw H.wrapException(P.ArgumentError$("Incorrect number or type of arguments"));
      }, function($receiver, options_OR_x) {
        return this.scrollTo$2($receiver, options_OR_x, null);
      }, "scrollTo$1", null, null, "get$scrollTo", 1, 4, null, 0, 0, 1003, 77],
      _scrollTo_2$1: [function(receiver, options) {
        return receiver.scrollTo(options);
      }, null, "get$_scrollTo_2", 5, 0, null, 118],
      _scrollTo_3$2: [function(receiver, x, y) {
        return receiver.scrollTo(H.numTypeCheck(x), y);
      }, null, "get$_scrollTo_3", 9, 0, null, 37, 77],
      setAttribute$2: [function(receiver, $name, value) {
        return receiver.setAttribute(H.stringTypeCheck($name), H.stringTypeCheck(value));
      }, null, "get$setAttribute", 9, 0, null, 8, 1],
      _querySelectorAll$1: [function(receiver, selectors) {
        return receiver.querySelectorAll(H.stringTypeCheck(selectors));
      }, null, "get$_querySelectorAll", 5, 0, null, 145],
      get$onChange: [function(receiver) {
        return C.EventStreamProvider_change.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onClick: [function(receiver) {
        return C.EventStreamProvider_click.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onDoubleClick: [function(receiver) {
        return C.EventStreamProvider_dblclick.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onKeyDown: [function(receiver) {
        return C.EventStreamProvider_keydown.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onLoad: [function(receiver) {
        return C.EventStreamProvider_load.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onMouseLeave: [function(receiver) {
        return C.EventStreamProvider_mouseleave.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onMouseMove: [function(receiver) {
        return C.EventStreamProvider_mousemove.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onMouseOver: [function(receiver) {
        return C.EventStreamProvider_mouseover.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onScroll: [function(receiver) {
        return C.EventStreamProvider_scroll.forElement$1(receiver);
      }, null, null, 3, 0, null],
      $isChildNode: 1,
      $isElement: 1,
      $isGlobalEventHandlers: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1,
      "%": ";Element"
    },
    Element_Element$html_closure: {
      "^": "Closure:25;$ti",
      call$1: [function(e) {
        return !!J.getInterceptor$(H.interceptedTypeCheck(e, "$isNode")).$isElement;
      }, null, null, 4, 0, null, 19, "call"]
    },
    _ElementFactoryProvider: {
      "^": "Object;$ti"
    },
    ScrollAlignment: {
      "^": "Object;_html$_value,$ti",
      toString$0: [function(_) {
        return "ScrollAlignment." + H.S(this._html$_value);
      }, null, "get$toString", 1, 0, null]
    },
    EmbedElement: {
      "^": "HtmlElement;0height=,0name=,0width=,$ti",
      set$height: function(receiver, height) {
        receiver.height = H.stringTypeCheck(height);
      },
      set$width: function(receiver, width) {
        receiver.width = H.stringTypeCheck(width);
      },
      $isEmbedElement: 1,
      "%": "HTMLEmbedElement"
    },
    Entry: {
      "^": "Interceptor;$ti",
      $isEntry: 1,
      "%": ""
    },
    ErrorEvent: {
      "^": "Event;0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isErrorEvent: 1,
      "%": "ErrorEvent"
    },
    Event: {
      "^": "Interceptor;$ti",
      get$target: [function(receiver) {
        return W._convertNativeToDart_EventTarget(receiver.target);
      }, null, null, 3, 0, null],
      $isEvent: 1,
      "%": ";Event|InputEvent"
    },
    EventSource: {
      "^": "EventTarget;$ti",
      $isEventSource: 1,
      "%": ""
    },
    Events: {
      "^": "Object;$ti"
    },
    ElementEvents: {
      "^": "Events;$ti"
    },
    EventTarget: {
      "^": "Interceptor;$ti",
      addEventListener$3: [function(receiver, type, listener, useCapture) {
        H.stringTypeCheck(type);
        H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
        H.boolTypeCheck(useCapture);
        if (listener != null)
          this._addEventListener$3(receiver, type, listener, useCapture);
      }, null, "get$addEventListener", 9, 2, null, 0, 29, 133, 143],
      removeEventListener$3: [function(receiver, type, listener, useCapture) {
        H.stringTypeCheck(type);
        H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
        H.boolTypeCheck(useCapture);
        if (listener != null)
          this._removeEventListener$3(receiver, type, listener, useCapture);
      }, null, "get$removeEventListener", 9, 2, null, 0, 29, 133, 143],
      _addEventListener$3: [function(receiver, type, listener, options) {
        H.stringTypeCheck(type);
        H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
        H.boolTypeCheck(options);
        return receiver.addEventListener(type, H.convertDartClosureToJS(listener, 1), options);
      }, null, "get$_addEventListener", 9, 2, null, 0, 29, 133, 118],
      _removeEventListener$3: [function(receiver, type, listener, options) {
        H.stringTypeCheck(type);
        H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
        H.boolTypeCheck(options);
        return receiver.removeEventListener(type, H.convertDartClosureToJS(listener, 1), options);
      }, null, "get$_removeEventListener", 9, 2, null, 0, 29, 133, 118],
      $isEventTarget: 1,
      "%": ";EventTarget"
    },
    ExtendableEvent: {
      "^": "Event;$ti",
      $isExtendableEvent: 1,
      "%": ";ExtendableEvent"
    },
    ExtendableMessageEvent: {
      "^": "ExtendableEvent;$ti",
      $isExtendableMessageEvent: 1,
      "%": "ExtendableMessageEvent"
    },
    External: {
      "^": "Interceptor;$ti",
      $isExternal: 1,
      "%": ""
    },
    FaceDetector: {
      "^": "Interceptor;$ti",
      $isFaceDetector: 1,
      "%": ""
    },
    FederatedCredential: {
      "^": "Credential;$ti",
      $isCredentialUserData: 1,
      $isFederatedCredential: 1,
      "%": ""
    },
    FetchEvent: {
      "^": "ExtendableEvent;$ti",
      $isFetchEvent: 1,
      "%": "FetchEvent"
    },
    FieldSetElement: {
      "^": "HtmlElement;0name=,$ti",
      $isFieldSetElement: 1,
      "%": "HTMLFieldSetElement"
    },
    File: {
      "^": "Blob;0name=,$ti",
      $isFile: 1,
      "%": "File"
    },
    FileEntry: {
      "^": "Entry;$ti",
      $isFileEntry: 1,
      "%": ""
    },
    FileList: {
      "^": "_FileList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.File];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.File];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.File];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.File];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.File];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.File];
      },
      $isList: 1,
      $asList: function() {
        return [W.File];
      },
      $isFileList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.File];
      },
      "%": ""
    },
    FileReader: {
      "^": "EventTarget;$ti",
      get$result: [function(receiver) {
        var res = receiver.result;
        if (!!J.getInterceptor$(res).$isByteBuffer)
          return P.Uint8List_Uint8List$view(res, 0, null);
        return res;
      }, null, null, 3, 0, null],
      readAsArrayBuffer$1: [function(receiver, blob) {
        return receiver.readAsArrayBuffer(H.interceptedTypeCheck(blob, "$isBlob"));
      }, null, "get$readAsArrayBuffer", 5, 0, null, 1004],
      get$onError: [function(receiver) {
        return C.EventStreamProvider_error0.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      get$onLoad: [function(receiver) {
        return C.EventStreamProvider_load0.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      get$onLoadEnd: [function(receiver) {
        return C.EventStreamProvider_loadend.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      $isFileReader: 1,
      "%": "FileReader"
    },
    FileSystem: {
      "^": "Interceptor;$ti",
      $isFileSystem: 1,
      "%": ""
    },
    FileWriter: {
      "^": "EventTarget;$ti",
      $isFileWriter: 1,
      "%": ""
    },
    FocusEvent: {
      "^": "UIEvent;$ti",
      $isFocusEvent: 1,
      "%": "FocusEvent"
    },
    FontFace: {
      "^": "Interceptor;$ti",
      load$0: [function(receiver) {
        return W.promiseToFuture(receiver.load(), W.FontFace);
      }, null, "get$load", 1, 0, null],
      $isFontFace: 1,
      "%": "FontFace"
    },
    FontFaceSet: {
      "^": "EventTarget;$ti",
      add$1: [function(receiver, arg) {
        return receiver.add(H.interceptedTypeCheck(arg, "$isFontFace"));
      }, "call$1", "get$add", 5, 0, 101, 44],
      clear$0: [function(receiver) {
        return receiver.clear();
      }, null, "get$clear", 1, 0, null],
      $isFontFaceSet: 1,
      "%": "FontFaceSet"
    },
    FontFaceSetLoadEvent: {
      "^": "Event;$ti",
      $isFontFaceSetLoadEvent: 1,
      "%": "FontFaceSetLoadEvent"
    },
    FontFaceSource: {
      "^": "Interceptor;$ti",
      $isFontFaceSource: 1,
      "%": ""
    },
    ForeignFetchEvent: {
      "^": "ExtendableEvent;$ti",
      $isForeignFetchEvent: 1,
      "%": "ForeignFetchEvent"
    },
    FormData: {
      "^": "Interceptor;$ti",
      $isFormData: 1,
      "%": ""
    },
    FormElement: {
      "^": "HtmlElement;0length=,0name=,$ti",
      $isFormElement: 1,
      "%": "HTMLFormElement"
    },
    Gamepad: {
      "^": "Interceptor;$ti",
      $isGamepad: 1,
      "%": ""
    },
    GamepadButton: {
      "^": "Interceptor;$ti",
      $isGamepadButton: 1,
      "%": ""
    },
    GamepadEvent: {
      "^": "Event;$ti",
      $isGamepadEvent: 1,
      "%": "GamepadEvent"
    },
    GamepadPose: {
      "^": "Interceptor;$ti",
      $isGamepadPose: 1,
      "%": ""
    },
    Geolocation: {
      "^": "Interceptor;$ti",
      $isGeolocation: 1,
      "%": ""
    },
    _GeopositionWrapper: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isGeoposition: 1
    },
    Geoposition: {
      "^": "Interceptor;$ti",
      $isGeoposition: 1,
      "%": ""
    },
    GlobalEventHandlers: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isEventTarget: 1
    },
    Gyroscope: {
      "^": "Sensor;$ti",
      $isGyroscope: 1,
      "%": ""
    },
    HRElement: {
      "^": "HtmlElement;$ti",
      $isHRElement: 1,
      "%": "HTMLHRElement"
    },
    HashChangeEvent: {
      "^": "Event;$ti",
      $isHashChangeEvent: 1,
      "%": "HashChangeEvent"
    },
    HeadElement: {
      "^": "HtmlElement;$ti",
      $isHeadElement: 1,
      "%": "HTMLHeadElement"
    },
    Headers: {
      "^": "Interceptor;$ti",
      $isHeaders: 1,
      "%": ""
    },
    HeadingElement: {
      "^": "HtmlElement;$ti",
      $isHeadingElement: 1,
      "%": "HTMLHeadingElement"
    },
    History: {
      "^": "Interceptor;0length=,$ti",
      pushState$3: [function(receiver, data, title, url) {
        H.stringTypeCheck(title);
        H.stringTypeCheck(url);
        this._pushState_1$3(receiver, P.convertDartToNative_SerializedScriptValue(data), title, url);
        return;
      }, null, "get$pushState", 13, 0, null, 34, 86, 62],
      _pushState_1$3: [function(receiver, data, title, url) {
        return receiver.pushState(data, title, url);
      }, null, "get$_pushState_1", 13, 0, null, 34, 86, 62],
      $isHistory: 1,
      $isHistoryBase: 1,
      "%": "History"
    },
    HtmlCollection: {
      "^": "_HtmlCollection_Interceptor_ListMixin_ImmutableListMixin;$ti",
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.interceptedTypeCheck(value, "$isNode");
        throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(receiver, value) {
        H.intTypeCheck(value);
        throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
      }, null, null, 7, 0, null, 1],
      get$first: [function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(P.StateError$("No elements"));
      }, null, null, 3, 0, null],
      get$last: [function(receiver) {
        var len = receiver.length;
        if (len > 0)
          return receiver[len - 1];
        throw H.wrapException(P.StateError$("No elements"));
      }, null, null, 3, 0, null],
      get$single: [function(receiver) {
        var len = receiver.length;
        if (len === 1)
          return receiver[0];
        if (len === 0)
          throw H.wrapException(P.StateError$("No elements"));
        throw H.wrapException(P.StateError$("More than one element"));
      }, null, null, 3, 0, null],
      elementAt$1: [function(receiver, index) {
        return this.$index(receiver, H.intTypeCheck(index));
      }, null, "get$elementAt", 5, 0, null, 6],
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Node];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.Node];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isHtmlCollection: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Node];
      },
      "%": ";HTMLCollection"
    },
    HtmlDocument: {
      "^": "Document;0body=,$ti",
      set$body: function(receiver, body) {
        receiver.body = H.interceptedTypeCheck(body, "$isBodyElement");
      },
      get$head: [function(receiver) {
        return receiver.head;
      }, null, null, 3, 0, null],
      $isHtmlDocument: 1,
      "%": "HTMLDocument"
    },
    HtmlFormControlsCollection: {
      "^": "HtmlCollection;$ti",
      $isHtmlFormControlsCollection: 1,
      "%": "HTMLFormControlsCollection"
    },
    HtmlHtmlElement: {
      "^": "HtmlElement;$ti",
      $isHtmlHtmlElement: 1,
      "%": "HTMLHtmlElement"
    },
    HtmlHyperlinkElementUtils: {
      "^": "Interceptor;$ti",
      $isHtmlHyperlinkElementUtils: 1,
      "%": ""
    },
    HtmlOptionsCollection: {
      "^": "HtmlCollection;$ti",
      $isHtmlOptionsCollection: 1,
      "%": "HTMLOptionsCollection"
    },
    HttpRequest: {
      "^": "HttpRequestEventTarget;0responseType,0status=,0statusText=,0withCredentials,$ti",
      set$responseType: function(receiver, responseType) {
        receiver.responseType = H.stringTypeCheck(responseType);
      },
      set$withCredentials: function(receiver, withCredentials) {
        receiver.withCredentials = H.boolTypeCheck(withCredentials);
      },
      get$responseHeaders: [function(receiver) {
        var t1, headers, headersString, t2, splitIdx, key, value;
        t1 = P.String;
        headers = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
        headersString = receiver.getAllResponseHeaders();
        if (headersString == null)
          return headers;
        for (t1 = C.JSArray_methods.get$iterator(H.setRuntimeTypeInfo(headersString.split("\r\n"), [t1])); t1.moveNext$0();) {
          t2 = t1.get$current();
          if (J.getInterceptor$asx(t2).get$isEmpty(t2))
            continue;
          splitIdx = C.JSString_methods.indexOf$1(t2, ": ");
          if (splitIdx === -1)
            continue;
          key = J.toLowerCase$0$s(C.JSString_methods.substring$2(t2, 0, splitIdx));
          if (typeof splitIdx !== "number")
            return splitIdx.$add();
          value = C.JSString_methods.substring$1(t2, splitIdx + 2);
          if (headers.containsKey$1(key))
            headers.$indexSet(0, key, H.S(headers.$index(0, key)) + ", " + H.S(value));
          else
            headers.$indexSet(0, key, value);
        }
        return headers;
      }, null, null, 3, 0, null],
      open$5$async$password$user: [function(receiver, method, url, async, password, user) {
        H.stringTypeCheck(method);
        H.stringTypeCheck(url);
        H.boolTypeCheck(async);
        H.stringTypeCheck(user);
        H.stringTypeCheck(password);
        return receiver.open(method, url);
      }, null, "get$open", 9, 7, null, 0, 0, 0, 61, 62, 1006, 397, 398],
      get$response: [function(receiver) {
        return W._convertNativeToDart_XHR_Response(receiver.response);
      }, null, null, 3, 0, null],
      send$1: [function(receiver, body_OR_data) {
        return receiver.send(body_OR_data);
      }, null, "get$send", 1, 2, null, 0, 1009],
      setRequestHeader$2: [function(receiver, $name, value) {
        return receiver.setRequestHeader(H.stringTypeCheck($name), H.stringTypeCheck(value));
      }, "call$2", "get$setRequestHeader", 9, 0, 41, 8, 1],
      $isHttpRequest: 1,
      "%": "XMLHttpRequest"
    },
    HttpRequestEventTarget: {
      "^": "EventTarget;$ti",
      get$onError: [function(receiver) {
        return C.EventStreamProvider_error0.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      get$onLoad: [function(receiver) {
        return C.EventStreamProvider_load0.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      $isHttpRequestEventTarget: 1,
      "%": ";XMLHttpRequestEventTarget"
    },
    HttpRequestUpload: {
      "^": "HttpRequestEventTarget;$ti",
      $isHttpRequestUpload: 1,
      "%": ""
    },
    IFrameElement: {
      "^": "HtmlElement;0height=,0name=,0width=,$ti",
      set$height: function(receiver, height) {
        receiver.height = H.stringTypeCheck(height);
      },
      set$width: function(receiver, width) {
        receiver.width = H.stringTypeCheck(width);
      },
      $isIFrameElement: 1,
      "%": "HTMLIFrameElement"
    },
    IdleDeadline: {
      "^": "Interceptor;$ti",
      $isIdleDeadline: 1,
      "%": ""
    },
    ImageBitmap: {
      "^": "Interceptor;$ti",
      $isImageBitmap: 1,
      "%": ""
    },
    ImageBitmapRenderingContext: {
      "^": "Interceptor;$ti",
      $isImageBitmapRenderingContext: 1,
      "%": ""
    },
    ImageCapture: {
      "^": "Interceptor;$ti",
      $isImageCapture: 1,
      "%": ""
    },
    ImageData: {
      "^": "Interceptor;0height=,0width=,$ti",
      $isImageData: 1,
      "%": "ImageData"
    },
    ImageElement: {
      "^": "HtmlElement;0height=,0width=,$ti",
      set$height: function(receiver, height) {
        receiver.height = H.intTypeCheck(height);
      },
      set$width: function(receiver, width) {
        receiver.width = H.intTypeCheck(width);
      },
      $isImageElement: 1,
      $isCanvasImageSource: 1,
      "%": "HTMLImageElement"
    },
    InputDeviceCapabilities: {
      "^": "Interceptor;$ti",
      $isInputDeviceCapabilities: 1,
      "%": ""
    },
    InputElement: {
      "^": "HtmlElement;0checked=,0height=,0name=,0width=,$ti",
      set$checked: function(receiver, checked) {
        receiver.checked = H.boolTypeCheck(checked);
      },
      set$height: function(receiver, height) {
        receiver.height = H.intTypeCheck(height);
      },
      set$width: function(receiver, width) {
        receiver.width = H.intTypeCheck(width);
      },
      $isInputElement: 1,
      $isInputElementBase: 1,
      $isHiddenInputElement: 1,
      $isTextInputElementBase: 1,
      $isSearchInputElement: 1,
      $isTextInputElement: 1,
      $isUrlInputElement: 1,
      $isTelephoneInputElement: 1,
      $isEmailInputElement: 1,
      $isPasswordInputElement: 1,
      $isRangeInputElementBase: 1,
      $isDateInputElement: 1,
      $isMonthInputElement: 1,
      $isWeekInputElement: 1,
      $isTimeInputElement: 1,
      $isLocalDateTimeInputElement: 1,
      $isNumberInputElement: 1,
      $isRangeInputElement: 1,
      $isCheckboxInputElement: 1,
      $isRadioButtonInputElement: 1,
      $isFileUploadInputElement: 1,
      $isSubmitButtonInputElement: 1,
      $isImageButtonInputElement: 1,
      $isResetButtonInputElement: 1,
      $isButtonInputElement: 1,
      "%": "HTMLInputElement"
    },
    InputElementBase: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    HiddenInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    TextInputElementBase: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    SearchInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isTextInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    TextInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isTextInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    UrlInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isTextInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    TelephoneInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isTextInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    EmailInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isTextInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    PasswordInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isTextInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    RangeInputElementBase: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    DateInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isRangeInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    MonthInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isRangeInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    WeekInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isRangeInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    TimeInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isRangeInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    LocalDateTimeInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isRangeInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    NumberInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isRangeInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    RangeInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isRangeInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    CheckboxInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    RadioButtonInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    FileUploadInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    SubmitButtonInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    ImageButtonInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    ResetButtonInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    ButtonInputElement: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isChildNode: 1,
      $isElement: 1,
      $isEventTarget: 1,
      $isGlobalEventHandlers: 1,
      $isInputElementBase: 1,
      $isNode: 1,
      $isNonDocumentTypeChildNode: 1,
      $isParentNode: 1
    },
    InstallEvent: {
      "^": "ExtendableEvent;$ti",
      $isInstallEvent: 1,
      "%": "InstallEvent"
    },
    IntersectionObserver: {
      "^": "Interceptor;$ti",
      disconnect$0: [function(receiver) {
        return receiver.disconnect();
      }, null, "get$disconnect", 1, 0, null],
      observe$1: [function(receiver, target) {
        return receiver.observe(H.interceptedTypeCheck(target, "$isElement"));
      }, null, "get$observe", 5, 0, null, 89],
      $isIntersectionObserver: 1,
      "%": "IntersectionObserver"
    },
    IntersectionObserverEntry: {
      "^": "Interceptor;$ti",
      $isIntersectionObserverEntry: 1,
      "%": ""
    },
    InterventionReport: {
      "^": "ReportBody;$ti",
      $isInterventionReport: 1,
      "%": ""
    },
    KeyboardEvent: {
      "^": "UIEvent;0code=,$ti",
      $isKeyboardEvent: 1,
      "%": "KeyboardEvent"
    },
    KeyframeEffect: {
      "^": "KeyframeEffectReadOnly;$ti",
      $isKeyframeEffect: 1,
      "%": ""
    },
    KeyframeEffectReadOnly: {
      "^": "AnimationEffectReadOnly;$ti",
      $isKeyframeEffectReadOnly: 1,
      "%": ""
    },
    LIElement: {
      "^": "HtmlElement;$ti",
      $isLIElement: 1,
      "%": "HTMLLIElement"
    },
    LabelElement: {
      "^": "HtmlElement;$ti",
      $isLabelElement: 1,
      "%": "HTMLLabelElement"
    },
    LegendElement: {
      "^": "HtmlElement;$ti",
      $isLegendElement: 1,
      "%": "HTMLLegendElement"
    },
    LinearAccelerationSensor: {
      "^": "Accelerometer;$ti",
      $isLinearAccelerationSensor: 1,
      "%": ""
    },
    LinkElement: {
      "^": "HtmlElement;$ti",
      $isLinkElement: 1,
      "%": "HTMLLinkElement"
    },
    Location: {
      "^": "Interceptor;0hash=,0hostname=,0pathname=,0port=,0protocol=,0search=,$ti",
      toString$0: [function(receiver) {
        return String(receiver);
      }, null, "get$toString", 1, 0, null],
      $isLocation: 1,
      $isLocationBase: 1,
      "%": "Location"
    },
    Magnetometer: {
      "^": "Sensor;$ti",
      $isMagnetometer: 1,
      "%": ""
    },
    MapElement: {
      "^": "HtmlElement;0name=,$ti",
      $isMapElement: 1,
      "%": "HTMLMapElement"
    },
    MediaCapabilities: {
      "^": "Interceptor;$ti",
      $isMediaCapabilities: 1,
      "%": ""
    },
    MediaCapabilitiesInfo: {
      "^": "Interceptor;$ti",
      $isMediaCapabilitiesInfo: 1,
      "%": ""
    },
    MediaDeviceInfo: {
      "^": "Interceptor;$ti",
      $isMediaDeviceInfo: 1,
      "%": ""
    },
    MediaDevices: {
      "^": "EventTarget;$ti",
      $isMediaDevices: 1,
      "%": ""
    },
    MediaElement: {
      "^": "HtmlElement;$ti",
      $isMediaElement: 1,
      "%": ";HTMLMediaElement"
    },
    MediaEncryptedEvent: {
      "^": "Event;$ti",
      $isMediaEncryptedEvent: 1,
      "%": "MediaEncryptedEvent"
    },
    MediaError: {
      "^": "Interceptor;0code=,0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isMediaError: 1,
      "%": "MediaError"
    },
    MediaKeyMessageEvent: {
      "^": "Event;0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isMediaKeyMessageEvent: 1,
      "%": "MediaKeyMessageEvent"
    },
    MediaKeySession: {
      "^": "EventTarget;$ti",
      $isMediaKeySession: 1,
      "%": ""
    },
    MediaKeyStatusMap: {
      "^": "Interceptor;$ti",
      $isMediaKeyStatusMap: 1,
      "%": ""
    },
    MediaKeySystemAccess: {
      "^": "Interceptor;$ti",
      $isMediaKeySystemAccess: 1,
      "%": ""
    },
    MediaKeys: {
      "^": "Interceptor;$ti",
      $isMediaKeys: 1,
      "%": ""
    },
    MediaKeysPolicy: {
      "^": "Interceptor;$ti",
      $isMediaKeysPolicy: 1,
      "%": ""
    },
    MediaList: {
      "^": "Interceptor;$ti",
      $isMediaList: 1,
      "%": ""
    },
    MediaMetadata: {
      "^": "Interceptor;$ti",
      $isMediaMetadata: 1,
      "%": ""
    },
    MediaQueryList: {
      "^": "EventTarget;0matches=,$ti",
      get$onChange: [function(receiver) {
        return C.EventStreamProvider_change.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      matches$1: function($receiver, arg0) {
        return $receiver.matches.call$1(arg0);
      },
      $isMediaQueryList: 1,
      "%": "MediaQueryList"
    },
    MediaQueryListEvent: {
      "^": "Event;$ti",
      $isMediaQueryListEvent: 1,
      "%": "MediaQueryListEvent"
    },
    MediaRecorder: {
      "^": "EventTarget;$ti",
      $isMediaRecorder: 1,
      "%": ""
    },
    MediaSession: {
      "^": "Interceptor;$ti",
      $isMediaSession: 1,
      "%": ""
    },
    MediaSettingsRange: {
      "^": "Interceptor;$ti",
      $isMediaSettingsRange: 1,
      "%": ""
    },
    MediaSource: {
      "^": "EventTarget;$ti",
      $isMediaSource: 1,
      "%": ""
    },
    MediaStream: {
      "^": "EventTarget;$ti",
      $isMediaStream: 1,
      "%": ""
    },
    MediaStreamEvent: {
      "^": "Event;$ti",
      $isMediaStreamEvent: 1,
      "%": "MediaStreamEvent"
    },
    MediaStreamTrack: {
      "^": "EventTarget;$ti",
      $isMediaStreamTrack: 1,
      "%": ""
    },
    MediaStreamTrackEvent: {
      "^": "Event;$ti",
      $isMediaStreamTrackEvent: 1,
      "%": "MediaStreamTrackEvent"
    },
    MemoryInfo: {
      "^": "Interceptor;$ti",
      $isMemoryInfo: 1,
      "%": ""
    },
    MenuElement: {
      "^": "HtmlElement;$ti",
      $isMenuElement: 1,
      "%": "HTMLMenuElement"
    },
    MessageChannel: {
      "^": "Interceptor;$ti",
      $isMessageChannel: 1,
      "%": ""
    },
    MessageEvent: {
      "^": "Event;$ti",
      get$data: [function(receiver) {
        return P.convertNativeToDart_SerializedScriptValue(receiver.data);
      }, null, null, 3, 0, null],
      $isMessageEvent: 1,
      "%": "MessageEvent"
    },
    MessagePort: {
      "^": "EventTarget;$ti",
      $isMessagePort: 1,
      "%": ""
    },
    MetaElement: {
      "^": "HtmlElement;0name=,$ti",
      $isMetaElement: 1,
      "%": "HTMLMetaElement"
    },
    Metadata: {
      "^": "Interceptor;$ti",
      $isMetadata: 1,
      "%": ""
    },
    MeterElement: {
      "^": "HtmlElement;$ti",
      $isMeterElement: 1,
      "%": "HTMLMeterElement"
    },
    MidiAccess: {
      "^": "EventTarget;$ti",
      $isMidiAccess: 1,
      "%": ""
    },
    MidiConnectionEvent: {
      "^": "Event;$ti",
      $isMidiConnectionEvent: 1,
      "%": "MIDIConnectionEvent"
    },
    MidiInput: {
      "^": "MidiPort;$ti",
      $isMidiInput: 1,
      "%": ""
    },
    MidiInputMap: {
      "^": "_MidiInputMap_Interceptor_MapMixin;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      },
      $isMidiInputMap: 1,
      "%": ""
    },
    MidiMessageEvent: {
      "^": "Event;$ti",
      $isMidiMessageEvent: 1,
      "%": "MIDIMessageEvent"
    },
    MidiOutput: {
      "^": "MidiPort;$ti",
      $isMidiOutput: 1,
      "%": ""
    },
    MidiOutputMap: {
      "^": "_MidiOutputMap_Interceptor_MapMixin;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      },
      $isMidiOutputMap: 1,
      "%": ""
    },
    MidiPort: {
      "^": "EventTarget;$ti",
      $isMidiPort: 1,
      "%": ""
    },
    MimeType: {
      "^": "Interceptor;$ti",
      $isMimeType: 1,
      "%": ""
    },
    MimeTypeArray: {
      "^": "_MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.MimeType];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.MimeType];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.MimeType];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.MimeType];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.MimeType];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.MimeType];
      },
      $isList: 1,
      $asList: function() {
        return [W.MimeType];
      },
      $isMimeTypeArray: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.MimeType];
      },
      "%": ""
    },
    ModElement: {
      "^": "HtmlElement;$ti",
      $isModElement: 1,
      "%": "HTMLModElement"
    },
    MouseEvent: {
      "^": "UIEvent;$ti",
      get$client: [function(receiver) {
        return P.Point$(receiver.clientX, receiver.clientY, P.num);
      }, null, null, 3, 0, null],
      $isMouseEvent: 1,
      "%": ";DragEvent|MouseEvent"
    },
    MutationEvent: {
      "^": "Event;$ti",
      $isMutationEvent: 1,
      "%": "MutationEvent"
    },
    MutationObserver: {
      "^": "Interceptor;$ti",
      $isMutationObserver: 1,
      "%": ""
    },
    MutationRecord: {
      "^": "Interceptor;$ti",
      $isMutationRecord: 1,
      "%": ""
    },
    NavigationPreloadManager: {
      "^": "Interceptor;$ti",
      $isNavigationPreloadManager: 1,
      "%": ""
    },
    Navigator: {
      "^": "NavigatorConcurrentHardware;0userAgent=,$ti",
      $isNavigator: 1,
      $isNavigatorAutomationInformation: 1,
      $isNavigatorCookies: 1,
      $isNavigatorID: 1,
      $isNavigatorLanguage: 1,
      $isNavigatorOnLine: 1,
      "%": "Navigator"
    },
    NavigatorAutomationInformation: {
      "^": "Interceptor;$ti",
      $isNavigatorAutomationInformation: 1,
      "%": ""
    },
    NavigatorConcurrentHardware: {
      "^": "Interceptor;$ti",
      $isNavigatorConcurrentHardware: 1,
      "%": ";NavigatorConcurrentHardware"
    },
    NavigatorCookies: {
      "^": "Interceptor;$ti",
      $isNavigatorCookies: 1,
      "%": ""
    },
    NavigatorID: {
      "^": "Interceptor;$ti"
    },
    NavigatorLanguage: {
      "^": "Interceptor;$ti"
    },
    NavigatorOnLine: {
      "^": "Interceptor;$ti"
    },
    NavigatorUserMediaError: {
      "^": "Interceptor;0message=,0name=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isNavigatorUserMediaError: 1,
      "%": "NavigatorUserMediaError"
    },
    NetworkInformation: {
      "^": "EventTarget;$ti",
      $isNetworkInformation: 1,
      "%": ""
    },
    _ChildNodeListLazy: {
      "^": "ListBase;_this,$ti",
      get$first: [function(_) {
        var result = this._this.firstChild;
        if (result == null)
          throw H.wrapException(P.StateError$("No elements"));
        return result;
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        var result = this._this.lastChild;
        if (result == null)
          throw H.wrapException(P.StateError$("No elements"));
        return result;
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        var l = this.get$length(this);
        if (l === 0)
          throw H.wrapException(P.StateError$("No elements"));
        if (typeof l !== "number")
          return l.$gt();
        if (l > 1)
          throw H.wrapException(P.StateError$("More than one element"));
        return this._this.firstChild;
      }, null, null, 3, 0, null],
      add$1: [function(_, value) {
        J.append$1$x(this._this, H.interceptedTypeCheck(value, "$isNode"));
      }, "call$1", "get$add", 5, 0, 2, 1],
      addAll$1: [function(_, iterable) {
        var t1, t2, len, t3, t4, i;
        H.assertSubtype(iterable, "$isIterable", [W.Node], "$asIterable");
        t1 = J.getInterceptor$(iterable);
        if (!!t1.$is_ChildNodeListLazy) {
          t1 = iterable._this;
          t2 = this._this;
          if (t1 == null ? t2 != null : t1 !== t2) {
            len = iterable.get$length(iterable);
            if (typeof len !== "number")
              return H.iae(len);
            t3 = J.getInterceptor$x(t1);
            t4 = J.getInterceptor$x(t2);
            i = 0;
            for (; i < len; ++i)
              t4.append$1(t2, t3.get$firstChild(t1));
          }
          return;
        }
        for (t1 = t1.get$iterator(iterable), t2 = this._this, t3 = J.getInterceptor$x(t2); t1.moveNext$0();)
          t3.append$1(t2, t1.get$current());
      }, null, "get$addAll", 5, 0, null, 13],
      insert$2: [function(_, index, node) {
        var t1;
        H.intTypeCheck(index);
        H.interceptedTypeCheck(node, "$isNode");
        if (typeof index !== "number")
          return index.$lt();
        if (index >= 0) {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = index > t1;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
        t1 = this._this;
        if (index === this.get$length(this))
          J.append$1$x(t1, node);
        else
          J.insertBefore$2$x(t1, node, this.$index(0, index));
      }, null, "get$insert", 9, 0, null, 6, 23],
      insertAll$2: [function(_, index, iterable) {
        var t1;
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [W.Node], "$asIterable");
        t1 = this.get$length(this);
        if (index == null ? t1 == null : index === t1)
          this.addAll$1(0, iterable);
        else
          J.insertAllBefore$2$x(this._this, iterable, this.$index(0, index));
      }, null, "get$insertAll", 9, 0, null, 6, 13],
      setAll$2: [function(_, index, iterable) {
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [W.Node], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot setAll on Node list"));
      }, null, "get$setAll", 9, 0, null, 6, 13],
      removeLast$0: [function(_) {
        var result = this.get$last(this);
        if (result != null)
          J._removeChild$1$x(this._this, result);
        return result;
      }, null, "get$removeLast", 1, 0, null],
      removeAt$1: [function(_, index) {
        var result = this.$index(0, H.intTypeCheck(index));
        if (result != null)
          J._removeChild$1$x(this._this, result);
        return result;
      }, null, "get$removeAt", 5, 0, null, 6],
      remove$1: [function(_, object) {
        var t1, t2;
        if (!J.getInterceptor$(object).$isNode)
          return false;
        t1 = this._this;
        t2 = object.parentNode;
        if (t1 == null ? t2 != null : t1 !== t2)
          return false;
        J._removeChild$1$x(t1, object);
        return true;
      }, null, "get$remove", 5, 0, null, 9],
      clear$0: [function(_) {
        J._clearChildren$0$x(this._this);
      }, null, "get$clear", 1, 0, null],
      $indexSet: [function(_, index, value) {
        H.intTypeCheck(index);
        J._replaceChild$2$x(this._this, H.interceptedTypeCheck(value, "$isNode"), this.$index(0, index));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      get$iterator: [function(_) {
        return J.get$iterator$ax(J.get$childNodes$x(this._this));
      }, null, null, 3, 0, null],
      sort$1: [function(_, compare) {
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Node, W.Node]});
        throw H.wrapException(P.UnsupportedError$("Cannot sort Node list"));
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      setRange$4: [function(_, start, end, iterable, skipCount) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [W.Node], "$asIterable");
        H.intTypeCheck(skipCount);
        throw H.wrapException(P.UnsupportedError$("Cannot setRange on Node list"));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      get$length: [function(_) {
        return J.get$length$asx(J.get$childNodes$x(this._this));
      }, null, null, 3, 0, null],
      set$length: [function(_, value) {
        H.intTypeCheck(value);
        throw H.wrapException(P.UnsupportedError$("Cannot set length on immutable List."));
      }, null, null, 7, 0, null, 1],
      $index: [function(_, index) {
        H.intTypeCheck(index);
        return J.$index$asx(J.get$childNodes$x(this._this), index);
      }, null, "get$[]", 5, 0, null, 6],
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $asListBase: function() {
        return [W.Node];
      },
      $asListMixin: function() {
        return [W.Node];
      },
      $asIterable: function() {
        return [W.Node];
      },
      $asList: function() {
        return [W.Node];
      },
      $isNodeListWrapper: 1,
      $as_ListBase_Object_ListMixin: function() {
        return [W.Node];
      },
      static: {
        _ChildNodeListLazy$: [function(_this) {
          return new W._ChildNodeListLazy(_this, []);
        }, null, null, 4, 0, null, 877]
      }
    },
    Node: {
      "^": "EventTarget;0childNodes=,0baseUri:baseURI=,0firstChild=,0lastChild=,0parent:parentElement=,0previousNode:previousSibling=,0text:textContent=,$ti",
      set$text: function(receiver, text) {
        receiver.textContent = H.stringTypeCheck(text);
      },
      get$nodes: [function(receiver) {
        return W._ChildNodeListLazy$(receiver);
      }, null, null, 3, 0, null],
      remove$0: [function(receiver) {
        var t1 = receiver.parentNode;
        if (t1 != null)
          J._removeChild$1$x(t1, receiver);
      }, null, "get$remove", 1, 0, null],
      replaceWith$1: [function(receiver, otherNode) {
        var $parent, exception;
        H.interceptedTypeCheck(otherNode, "$isNode");
        try {
          $parent = receiver.parentNode;
          J._replaceChild$2$x($parent, otherNode, receiver);
        } catch (exception) {
          H.unwrapException(exception);
        }
        return receiver;
      }, null, "get$replaceWith", 5, 0, null, 1012],
      insertAllBefore$2: [function(receiver, newNodes, refChild) {
        var t1, len, t2, i;
        H.assertSubtype(newNodes, "$isIterable", [W.Node], "$asIterable");
        H.interceptedTypeCheck(refChild, "$isNode");
        t1 = J.getInterceptor$(newNodes);
        if (!!t1.$is_ChildNodeListLazy) {
          t1 = newNodes._this;
          if (t1 === receiver)
            throw H.wrapException(P.ArgumentError$(newNodes));
          len = newNodes.get$length(newNodes);
          if (typeof len !== "number")
            return H.iae(len);
          t2 = J.getInterceptor$x(t1);
          i = 0;
          for (; i < len; ++i)
            this.insertBefore$2(receiver, t2.get$firstChild(t1), refChild);
        } else
          for (t1 = t1.get$iterator(newNodes); t1.moveNext$0();)
            this.insertBefore$2(receiver, t1.get$current(), refChild);
      }, null, "get$insertAllBefore", 9, 0, null, 1013, 1023],
      _clearChildren$0: [function(receiver) {
        var t1;
        for (; t1 = receiver.firstChild, t1 != null;)
          this._removeChild$1(receiver, t1);
      }, null, "get$_clearChildren", 1, 0, null],
      toString$0: [function(receiver) {
        var value = receiver.nodeValue;
        return value == null ? this.super$Interceptor$toString(receiver) : value;
      }, null, "get$toString", 1, 0, null],
      append$1: [function(receiver, node) {
        return receiver.appendChild(H.interceptedTypeCheck(node, "$isNode"));
      }, null, "get$append", 5, 0, null, 23],
      insertBefore$2: [function(receiver, node, child) {
        return receiver.insertBefore(H.interceptedTypeCheck(node, "$isNode"), H.interceptedTypeCheck(child, "$isNode"));
      }, null, "get$insertBefore", 9, 0, null, 23, 130],
      _removeChild$1: [function(receiver, child) {
        return receiver.removeChild(H.interceptedTypeCheck(child, "$isNode"));
      }, null, "get$_removeChild", 5, 0, null, 130],
      _replaceChild$2: [function(receiver, node, child) {
        return receiver.replaceChild(H.interceptedTypeCheck(node, "$isNode"), H.interceptedTypeCheck(child, "$isNode"));
      }, null, "get$_replaceChild", 9, 0, null, 23, 130],
      $isNode: 1,
      "%": ";Node"
    },
    NodeFilter: {
      "^": "Interceptor;$ti",
      $isNodeFilter: 1,
      "%": ""
    },
    NodeIterator: {
      "^": "Interceptor;$ti",
      $isNodeIterator: 1,
      "%": ""
    },
    NodeList: {
      "^": "_NodeList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.interceptedTypeCheck(value, "$isNode");
        throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(receiver, value) {
        H.intTypeCheck(value);
        throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
      }, null, null, 7, 0, null, 1],
      get$first: [function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(P.StateError$("No elements"));
      }, null, null, 3, 0, null],
      get$last: [function(receiver) {
        var len = receiver.length;
        if (len > 0)
          return receiver[len - 1];
        throw H.wrapException(P.StateError$("No elements"));
      }, null, null, 3, 0, null],
      get$single: [function(receiver) {
        var len = receiver.length;
        if (len === 1)
          return receiver[0];
        if (len === 0)
          throw H.wrapException(P.StateError$("No elements"));
        throw H.wrapException(P.StateError$("More than one element"));
      }, null, null, 3, 0, null],
      elementAt$1: [function(receiver, index) {
        return this.$index(receiver, H.intTypeCheck(index));
      }, null, "get$elementAt", 5, 0, null, 6],
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Node];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.Node];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isNodeList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Node];
      },
      "%": "NodeList|RadioNodeList"
    },
    NonDocumentTypeChildNode: {
      "^": "Interceptor;$ti",
      $isNonDocumentTypeChildNode: 1,
      "%": ""
    },
    NonElementParentNode: {
      "^": "Interceptor;$ti",
      $isNonElementParentNode: 1,
      "%": ""
    },
    NoncedElement: {
      "^": "Interceptor;$ti",
      $isNoncedElement: 1,
      "%": ""
    },
    Notification: {
      "^": "EventTarget;$ti",
      $isNotification: 1,
      "%": ""
    },
    NotificationEvent: {
      "^": "ExtendableEvent;$ti",
      $isNotificationEvent: 1,
      "%": "NotificationEvent"
    },
    OListElement: {
      "^": "HtmlElement;0start=,$ti",
      $isOListElement: 1,
      "%": "HTMLOListElement"
    },
    ObjectElement: {
      "^": "HtmlElement;0height=,0name=,0width=,$ti",
      set$height: function(receiver, height) {
        receiver.height = H.stringTypeCheck(height);
      },
      set$width: function(receiver, width) {
        receiver.width = H.stringTypeCheck(width);
      },
      $isObjectElement: 1,
      "%": "HTMLObjectElement"
    },
    OffscreenCanvas: {
      "^": "EventTarget;$ti",
      $isOffscreenCanvas: 1,
      "%": ""
    },
    OffscreenCanvasRenderingContext2D: {
      "^": "Interceptor;$ti",
      $isOffscreenCanvasRenderingContext2D: 1,
      $is_CanvasPath: 1,
      "%": ""
    },
    OptGroupElement: {
      "^": "HtmlElement;$ti",
      $isOptGroupElement: 1,
      "%": "HTMLOptGroupElement"
    },
    OptionElement: {
      "^": "HtmlElement;0value=,$ti",
      set$value: function(receiver, value) {
        receiver.value = H.stringTypeCheck(value);
      },
      $isOptionElement: 1,
      "%": "HTMLOptionElement"
    },
    OrientationSensor: {
      "^": "Sensor;$ti",
      $isOrientationSensor: 1,
      "%": ""
    },
    OutputElement: {
      "^": "HtmlElement;0name=,$ti",
      $isOutputElement: 1,
      "%": "HTMLOutputElement"
    },
    OverconstrainedError: {
      "^": "Interceptor;0message=,0name=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isOverconstrainedError: 1,
      "%": "OverconstrainedError"
    },
    PageTransitionEvent: {
      "^": "Event;$ti",
      $isPageTransitionEvent: 1,
      "%": "PageTransitionEvent"
    },
    PaintRenderingContext2D: {
      "^": "Interceptor;$ti",
      $isPaintRenderingContext2D: 1,
      $is_CanvasPath: 1,
      "%": ""
    },
    PaintSize: {
      "^": "Interceptor;$ti",
      $isPaintSize: 1,
      "%": ""
    },
    PaintWorkletGlobalScope: {
      "^": "WorkletGlobalScope;$ti",
      $isPaintWorkletGlobalScope: 1,
      "%": ""
    },
    ParagraphElement: {
      "^": "HtmlElement;$ti",
      $isParagraphElement: 1,
      "%": "HTMLParagraphElement"
    },
    ParamElement: {
      "^": "HtmlElement;0name=,$ti",
      $isParamElement: 1,
      "%": "HTMLParamElement"
    },
    ParentNode: {
      "^": "Interceptor;$ti"
    },
    PasswordCredential: {
      "^": "Credential;$ti",
      $isCredentialUserData: 1,
      $isPasswordCredential: 1,
      "%": ""
    },
    Path2D: {
      "^": "Interceptor;$ti",
      $isPath2D: 1,
      $is_CanvasPath: 1,
      "%": ""
    },
    PaymentAddress: {
      "^": "Interceptor;$ti",
      $isPaymentAddress: 1,
      "%": ""
    },
    PaymentInstruments: {
      "^": "Interceptor;$ti",
      $isPaymentInstruments: 1,
      "%": ""
    },
    PaymentManager: {
      "^": "Interceptor;$ti",
      $isPaymentManager: 1,
      "%": ""
    },
    PaymentRequest: {
      "^": "EventTarget;$ti",
      $isPaymentRequest: 1,
      "%": ""
    },
    PaymentRequestEvent: {
      "^": "ExtendableEvent;$ti",
      $isPaymentRequestEvent: 1,
      "%": "PaymentRequestEvent"
    },
    PaymentRequestUpdateEvent: {
      "^": "Event;$ti",
      $isPaymentRequestUpdateEvent: 1,
      "%": "PaymentRequestUpdateEvent"
    },
    PaymentResponse: {
      "^": "Interceptor;$ti",
      $isPaymentResponse: 1,
      "%": ""
    },
    Performance: {
      "^": "EventTarget;$ti",
      $isPerformance: 1,
      "%": ""
    },
    PerformanceEntry: {
      "^": "Interceptor;$ti",
      $isPerformanceEntry: 1,
      "%": ""
    },
    PerformanceLongTaskTiming: {
      "^": "PerformanceEntry;$ti",
      $isPerformanceLongTaskTiming: 1,
      "%": ""
    },
    PerformanceMark: {
      "^": "PerformanceEntry;$ti",
      $isPerformanceMark: 1,
      "%": ""
    },
    PerformanceMeasure: {
      "^": "PerformanceEntry;$ti",
      $isPerformanceMeasure: 1,
      "%": ""
    },
    PerformanceNavigation: {
      "^": "Interceptor;$ti",
      $isPerformanceNavigation: 1,
      "%": ""
    },
    PerformanceNavigationTiming: {
      "^": "PerformanceResourceTiming;$ti",
      $isPerformanceNavigationTiming: 1,
      "%": ""
    },
    PerformanceObserver: {
      "^": "Interceptor;$ti",
      $isPerformanceObserver: 1,
      "%": ""
    },
    PerformanceObserverEntryList: {
      "^": "Interceptor;$ti",
      $isPerformanceObserverEntryList: 1,
      "%": ""
    },
    PerformancePaintTiming: {
      "^": "PerformanceEntry;$ti",
      $isPerformancePaintTiming: 1,
      "%": ""
    },
    PerformanceResourceTiming: {
      "^": "PerformanceEntry;$ti",
      $isPerformanceResourceTiming: 1,
      "%": ""
    },
    PerformanceServerTiming: {
      "^": "Interceptor;$ti",
      $isPerformanceServerTiming: 1,
      "%": ""
    },
    PerformanceTiming: {
      "^": "Interceptor;$ti",
      $isPerformanceTiming: 1,
      "%": ""
    },
    PermissionStatus: {
      "^": "EventTarget;$ti",
      $isPermissionStatus: 1,
      "%": ""
    },
    Permissions: {
      "^": "Interceptor;$ti",
      $isPermissions: 1,
      "%": ""
    },
    PhotoCapabilities: {
      "^": "Interceptor;$ti",
      $isPhotoCapabilities: 1,
      "%": ""
    },
    PictureElement: {
      "^": "HtmlElement;$ti",
      $isPictureElement: 1,
      "%": "HTMLPictureElement"
    },
    Plugin: {
      "^": "Interceptor;$ti",
      $isPlugin: 1,
      "%": ""
    },
    PluginArray: {
      "^": "_PluginArray_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Plugin];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.Plugin];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Plugin];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Plugin];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Plugin];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Plugin];
      },
      $isList: 1,
      $asList: function() {
        return [W.Plugin];
      },
      $isPluginArray: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Plugin];
      },
      "%": ""
    },
    PointerEvent: {
      "^": "MouseEvent;0height=,0width=,$ti",
      $isPointerEvent: 1,
      "%": "PointerEvent"
    },
    PopStateEvent: {
      "^": "Event;$ti",
      $isPopStateEvent: 1,
      "%": "PopStateEvent"
    },
    PositionError: {
      "^": "Interceptor;0code=,0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isPositionError: 1,
      "%": "PositionError"
    },
    PreElement: {
      "^": "HtmlElement;$ti",
      $isPreElement: 1,
      "%": "HTMLPreElement"
    },
    Presentation: {
      "^": "Interceptor;$ti",
      $isPresentation: 1,
      "%": ""
    },
    PresentationAvailability: {
      "^": "EventTarget;$ti",
      $isPresentationAvailability: 1,
      "%": ""
    },
    PresentationConnection: {
      "^": "EventTarget;$ti",
      $isPresentationConnection: 1,
      "%": ""
    },
    PresentationConnectionAvailableEvent: {
      "^": "Event;$ti",
      $isPresentationConnectionAvailableEvent: 1,
      "%": "PresentationConnectionAvailableEvent"
    },
    PresentationConnectionCloseEvent: {
      "^": "Event;0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isPresentationConnectionCloseEvent: 1,
      "%": "PresentationConnectionCloseEvent"
    },
    PresentationConnectionList: {
      "^": "EventTarget;$ti",
      $isPresentationConnectionList: 1,
      "%": ""
    },
    PresentationReceiver: {
      "^": "Interceptor;$ti",
      $isPresentationReceiver: 1,
      "%": ""
    },
    PresentationRequest: {
      "^": "EventTarget;$ti",
      $isPresentationRequest: 1,
      "%": ""
    },
    ProcessingInstruction: {
      "^": "CharacterData;$ti",
      $isProcessingInstruction: 1,
      "%": "ProcessingInstruction"
    },
    ProgressElement0: {
      "^": "HtmlElement;$ti",
      $isProgressElement0: 1,
      "%": "HTMLProgressElement"
    },
    ProgressEvent: {
      "^": "Event;$ti",
      $isProgressEvent: 1,
      "%": ";ProgressEvent"
    },
    PromiseRejectionEvent: {
      "^": "Event;$ti",
      $isPromiseRejectionEvent: 1,
      "%": "PromiseRejectionEvent"
    },
    PublicKeyCredential: {
      "^": "Credential;$ti",
      $isPublicKeyCredential: 1,
      "%": ""
    },
    PushEvent: {
      "^": "ExtendableEvent;$ti",
      $isPushEvent: 1,
      "%": "PushEvent"
    },
    PushManager: {
      "^": "Interceptor;$ti",
      $isPushManager: 1,
      "%": ""
    },
    PushMessageData: {
      "^": "Interceptor;$ti",
      $isPushMessageData: 1,
      "%": ""
    },
    PushSubscription: {
      "^": "Interceptor;$ti",
      $isPushSubscription: 1,
      "%": ""
    },
    PushSubscriptionOptions: {
      "^": "Interceptor;$ti",
      $isPushSubscriptionOptions: 1,
      "%": ""
    },
    QuoteElement: {
      "^": "HtmlElement;$ti",
      $isQuoteElement: 1,
      "%": "HTMLQuoteElement"
    },
    Range: {
      "^": "Interceptor;$ti",
      createContextualFragment$1: [function(receiver, fragment) {
        return receiver.createContextualFragment(H.stringTypeCheck(fragment));
      }, null, "get$createContextualFragment", 5, 0, null, 325],
      selectNodeContents$1: [function(receiver, node) {
        return receiver.selectNodeContents(H.interceptedTypeCheck(node, "$isNode"));
      }, null, "get$selectNodeContents", 5, 0, null, 23],
      $isRange: 1,
      "%": "Range"
    },
    RelatedApplication: {
      "^": "Interceptor;$ti",
      $isRelatedApplication: 1,
      "%": ""
    },
    RelativeOrientationSensor: {
      "^": "OrientationSensor;$ti",
      $isRelativeOrientationSensor: 1,
      "%": ""
    },
    RemotePlayback: {
      "^": "EventTarget;$ti",
      $isRemotePlayback: 1,
      "%": ""
    },
    ReportBody: {
      "^": "Interceptor;$ti",
      $isReportBody: 1,
      "%": ""
    },
    ReportingObserver: {
      "^": "Interceptor;$ti",
      $isReportingObserver: 1,
      "%": ""
    },
    ResizeObserver: {
      "^": "Interceptor;$ti",
      $isResizeObserver: 1,
      "%": ""
    },
    ResizeObserverEntry: {
      "^": "Interceptor;$ti",
      $isResizeObserverEntry: 1,
      "%": ""
    },
    RtcCertificate: {
      "^": "Interceptor;$ti",
      $isRtcCertificate: 1,
      "%": ""
    },
    RtcDataChannel: {
      "^": "EventTarget;$ti",
      $isRtcDataChannel: 1,
      "%": ""
    },
    RtcDataChannelEvent: {
      "^": "Event;$ti",
      $isRtcDataChannelEvent: 1,
      "%": "RTCDataChannelEvent"
    },
    RtcDtmfSender: {
      "^": "EventTarget;$ti",
      $isRtcDtmfSender: 1,
      "%": ""
    },
    RtcDtmfToneChangeEvent: {
      "^": "Event;$ti",
      $isRtcDtmfToneChangeEvent: 1,
      "%": "RTCDTMFToneChangeEvent"
    },
    RtcIceCandidate: {
      "^": "Interceptor;$ti",
      $isRtcIceCandidate: 1,
      "%": ""
    },
    RtcLegacyStatsReport: {
      "^": "Interceptor;$ti",
      $isRtcLegacyStatsReport: 1,
      "%": ""
    },
    RtcPeerConnection: {
      "^": "EventTarget;$ti",
      $isRtcPeerConnection: 1,
      "%": ""
    },
    RtcPeerConnectionIceEvent: {
      "^": "Event;$ti",
      $isRtcPeerConnectionIceEvent: 1,
      "%": "RTCPeerConnectionIceEvent"
    },
    RtcRtpContributingSource: {
      "^": "Interceptor;$ti",
      $isRtcRtpContributingSource: 1,
      "%": ""
    },
    RtcRtpReceiver: {
      "^": "Interceptor;$ti",
      $isRtcRtpReceiver: 1,
      "%": ""
    },
    RtcRtpSender: {
      "^": "Interceptor;$ti",
      $isRtcRtpSender: 1,
      "%": ""
    },
    RtcSessionDescription: {
      "^": "Interceptor;$ti",
      $isRtcSessionDescription: 1,
      "%": ""
    },
    RtcStatsReport: {
      "^": "_RtcStatsReport_Interceptor_MapMixin;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      },
      $isRtcStatsReport: 1,
      "%": ""
    },
    RtcStatsResponse: {
      "^": "Interceptor;$ti",
      $isRtcStatsResponse: 1,
      "%": ""
    },
    RtcTrackEvent: {
      "^": "Event;$ti",
      $isRtcTrackEvent: 1,
      "%": "RTCTrackEvent"
    },
    Screen0: {
      "^": "Interceptor;$ti",
      $isScreen0: 1,
      "%": ""
    },
    ScreenOrientation: {
      "^": "EventTarget;$ti",
      $isScreenOrientation: 1,
      "%": ""
    },
    ScriptElement0: {
      "^": "HtmlElement;$ti",
      $isScriptElement0: 1,
      "%": "HTMLScriptElement"
    },
    ScrollState: {
      "^": "Interceptor;$ti",
      $isScrollState: 1,
      "%": ""
    },
    ScrollTimeline: {
      "^": "AnimationTimeline;$ti",
      $isScrollTimeline: 1,
      "%": ""
    },
    SecurityPolicyViolationEvent: {
      "^": "Event;$ti",
      $isSecurityPolicyViolationEvent: 1,
      "%": "SecurityPolicyViolationEvent"
    },
    SelectElement: {
      "^": "HtmlElement;0length=,0name=,0selectedIndex,0value=,$ti",
      set$length: function(receiver, $length) {
        receiver.length = H.intTypeCheck($length);
      },
      set$selectedIndex: function(receiver, selectedIndex) {
        receiver.selectedIndex = H.intTypeCheck(selectedIndex);
      },
      set$value: function(receiver, value) {
        receiver.value = H.stringTypeCheck(value);
      },
      $isSelectElement: 1,
      "%": "HTMLSelectElement"
    },
    Selection: {
      "^": "Interceptor;$ti",
      $isSelection: 1,
      "%": ""
    },
    Sensor: {
      "^": "EventTarget;$ti",
      $isSensor: 1,
      "%": ""
    },
    SensorErrorEvent: {
      "^": "Event;$ti",
      $isSensorErrorEvent: 1,
      "%": "SensorErrorEvent"
    },
    ServiceWorker: {
      "^": "EventTarget;$ti",
      $isAbstractWorker: 1,
      $isServiceWorker: 1,
      "%": ""
    },
    ServiceWorkerContainer: {
      "^": "EventTarget;$ti",
      $isServiceWorkerContainer: 1,
      "%": ""
    },
    ServiceWorkerGlobalScope: {
      "^": "WorkerGlobalScope;$ti",
      $isServiceWorkerGlobalScope: 1,
      "%": "ServiceWorkerGlobalScope"
    },
    ServiceWorkerRegistration: {
      "^": "EventTarget;$ti",
      $isServiceWorkerRegistration: 1,
      "%": ""
    },
    ShadowElement: {
      "^": "HtmlElement;$ti",
      $isShadowElement: 1,
      "%": "HTMLShadowElement"
    },
    ShadowRoot: {
      "^": "DocumentFragment;$ti",
      $isDocumentOrShadowRoot: 1,
      $isShadowRoot: 1,
      "%": "ShadowRoot"
    },
    SharedArrayBuffer: {
      "^": "Interceptor;$ti",
      $isSharedArrayBuffer: 1,
      "%": ""
    },
    SharedWorker: {
      "^": "EventTarget;$ti",
      $isAbstractWorker: 1,
      $isSharedWorker: 1,
      "%": ""
    },
    SharedWorkerGlobalScope: {
      "^": "WorkerGlobalScope;0name=,$ti",
      $isSharedWorkerGlobalScope: 1,
      "%": "SharedWorkerGlobalScope"
    },
    SlotElement: {
      "^": "HtmlElement;0name=,$ti",
      $isSlotElement: 1,
      "%": "HTMLSlotElement"
    },
    SourceBuffer: {
      "^": "EventTarget;$ti",
      $isSourceBuffer: 1,
      "%": ""
    },
    SourceBufferList: {
      "^": "_SourceBufferList_EventTarget_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.SourceBuffer];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.SourceBuffer];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SourceBuffer];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.SourceBuffer];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SourceBuffer];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SourceBuffer];
      },
      $isList: 1,
      $asList: function() {
        return [W.SourceBuffer];
      },
      $isSourceBufferList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.SourceBuffer];
      },
      "%": ""
    },
    SourceElement: {
      "^": "HtmlElement;$ti",
      $isSourceElement: 1,
      "%": "HTMLSourceElement"
    },
    SpanElement: {
      "^": "HtmlElement;$ti",
      $isSpanElement: 1,
      "%": "HTMLSpanElement"
    },
    SpeechGrammar: {
      "^": "Interceptor;$ti",
      $isSpeechGrammar: 1,
      "%": ""
    },
    SpeechGrammarList: {
      "^": "_SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.SpeechGrammar];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.SpeechGrammar];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechGrammar];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.SpeechGrammar];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SpeechGrammar];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SpeechGrammar];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechGrammar];
      },
      $isSpeechGrammarList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.SpeechGrammar];
      },
      "%": ""
    },
    SpeechRecognition: {
      "^": "EventTarget;$ti",
      $isSpeechRecognition: 1,
      "%": ""
    },
    SpeechRecognitionAlternative: {
      "^": "Interceptor;$ti",
      $isSpeechRecognitionAlternative: 1,
      "%": ""
    },
    SpeechRecognitionError: {
      "^": "Event;0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isSpeechRecognitionError: 1,
      "%": "SpeechRecognitionError"
    },
    SpeechRecognitionEvent: {
      "^": "Event;$ti",
      $isSpeechRecognitionEvent: 1,
      "%": "SpeechRecognitionEvent"
    },
    SpeechRecognitionResult: {
      "^": "Interceptor;$ti",
      $isSpeechRecognitionResult: 1,
      "%": ""
    },
    SpeechSynthesis: {
      "^": "EventTarget;$ti",
      $isSpeechSynthesis: 1,
      "%": ""
    },
    SpeechSynthesisEvent: {
      "^": "Event;0name=,$ti",
      $isSpeechSynthesisEvent: 1,
      "%": "SpeechSynthesisEvent"
    },
    SpeechSynthesisUtterance: {
      "^": "EventTarget;$ti",
      $isSpeechSynthesisUtterance: 1,
      "%": ""
    },
    SpeechSynthesisVoice: {
      "^": "Interceptor;$ti",
      $isSpeechSynthesisVoice: 1,
      "%": ""
    },
    StaticRange: {
      "^": "Interceptor;$ti",
      $isStaticRange: 1,
      "%": ""
    },
    Storage: {
      "^": "_Storage_Interceptor_MapMixin;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, P.String];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, P.String];
      },
      $isStorage: 1,
      "%": ""
    },
    StorageEvent: {
      "^": "Event;$ti",
      $isStorageEvent: 1,
      "%": "StorageEvent"
    },
    StorageManager: {
      "^": "Interceptor;$ti",
      $isStorageManager: 1,
      "%": ""
    },
    StyleElement: {
      "^": "HtmlElement;$ti",
      $isStyleElement: 1,
      "%": "HTMLStyleElement"
    },
    StyleMedia: {
      "^": "Interceptor;$ti",
      $isStyleMedia: 1,
      "%": ""
    },
    StylePropertyMap: {
      "^": "StylePropertyMapReadonly;$ti",
      $isStylePropertyMap: 1,
      "%": ""
    },
    StylePropertyMapReadonly: {
      "^": "Interceptor;$ti",
      $isStylePropertyMapReadonly: 1,
      "%": ""
    },
    StyleSheet: {
      "^": "Interceptor;$ti",
      $isStyleSheet: 1,
      "%": ""
    },
    SyncEvent: {
      "^": "ExtendableEvent;$ti",
      $isSyncEvent: 1,
      "%": "SyncEvent"
    },
    SyncManager: {
      "^": "Interceptor;$ti",
      $isSyncManager: 1,
      "%": ""
    },
    TableCaptionElement: {
      "^": "HtmlElement;$ti",
      $isTableCaptionElement: 1,
      "%": "HTMLTableCaptionElement"
    },
    TableCellElement: {
      "^": "HtmlElement;$ti",
      $isTableCellElement: 1,
      "%": "HTMLTableCellElement|HTMLTableDataCellElement|HTMLTableHeaderCellElement"
    },
    TableColElement: {
      "^": "HtmlElement;$ti",
      $isTableColElement: 1,
      "%": "HTMLTableColElement"
    },
    TableElement: {
      "^": "HtmlElement;$ti",
      createFragment$3$treeSanitizer$validator: [function(receiver, html, treeSanitizer, validator) {
        var table, fragment;
        H.stringTypeCheck(html);
        H.interceptedTypeCheck(validator, "$isNodeValidator");
        H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
        if (W.Range_supportsCreateContextualFragment())
          return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
        table = W.Element_Element$html("<table>" + H.S(html) + "</table>", treeSanitizer, validator);
        fragment = W.DocumentFragment_DocumentFragment();
        J.addAll$1$ax(J.get$nodes$x(fragment), J.get$nodes$x(table));
        return fragment;
      }, function($receiver, html, treeSanitizer) {
        return this.createFragment$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
      }, "createFragment$2$treeSanitizer", null, null, "get$createFragment", 5, 5, null, 0, 0, 149, 117, 97],
      $isTableElement: 1,
      "%": "HTMLTableElement"
    },
    TableRowElement: {
      "^": "HtmlElement;$ti",
      createFragment$3$treeSanitizer$validator: [function(receiver, html, treeSanitizer, validator) {
        var fragment, row;
        H.stringTypeCheck(html);
        H.interceptedTypeCheck(validator, "$isNodeValidator");
        H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
        if (W.Range_supportsCreateContextualFragment())
          return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
        fragment = W.DocumentFragment_DocumentFragment();
        row = J.get$single$ax(J.get$nodes$x(J.get$single$ax(J.get$nodes$x(J.createFragment$3$treeSanitizer$validator$x(W.TableElement_TableElement(), html, treeSanitizer, validator)))));
        J.addAll$1$ax(J.get$nodes$x(fragment), J.get$nodes$x(row));
        return fragment;
      }, function($receiver, html, treeSanitizer) {
        return this.createFragment$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
      }, "createFragment$2$treeSanitizer", null, null, "get$createFragment", 5, 5, null, 0, 0, 149, 117, 97],
      $isTableRowElement: 1,
      "%": "HTMLTableRowElement"
    },
    TableSectionElement: {
      "^": "HtmlElement;$ti",
      createFragment$3$treeSanitizer$validator: [function(receiver, html, treeSanitizer, validator) {
        var fragment, section;
        H.stringTypeCheck(html);
        H.interceptedTypeCheck(validator, "$isNodeValidator");
        H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
        if (W.Range_supportsCreateContextualFragment())
          return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
        fragment = W.DocumentFragment_DocumentFragment();
        section = J.get$single$ax(J.get$nodes$x(J.createFragment$3$treeSanitizer$validator$x(W.TableElement_TableElement(), html, treeSanitizer, validator)));
        J.addAll$1$ax(J.get$nodes$x(fragment), J.get$nodes$x(section));
        return fragment;
      }, function($receiver, html, treeSanitizer) {
        return this.createFragment$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
      }, "createFragment$2$treeSanitizer", null, null, "get$createFragment", 5, 5, null, 0, 0, 149, 117, 97],
      $isTableSectionElement: 1,
      "%": "HTMLTableSectionElement"
    },
    TaskAttributionTiming: {
      "^": "PerformanceEntry;$ti",
      $isTaskAttributionTiming: 1,
      "%": ""
    },
    TemplateElement: {
      "^": "HtmlElement;$ti",
      setInnerHtml$3$treeSanitizer$validator: [function(receiver, html, treeSanitizer, validator) {
        var fragment;
        H.stringTypeCheck(html);
        H.interceptedTypeCheck(validator, "$isNodeValidator");
        H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
        receiver.textContent = null;
        fragment = this.createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, validator);
        J.append$1$x(receiver.content, fragment);
      }, function($receiver, html, treeSanitizer) {
        return this.setInnerHtml$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
      }, "setInnerHtml$2$treeSanitizer", function($receiver, html) {
        return this.setInnerHtml$3$treeSanitizer$validator($receiver, html, null, null);
      }, "setInnerHtml$1", null, null, null, "get$setInnerHtml", 5, 5, null, 0, 0, 149, 117, 97],
      $isTemplateElement: 1,
      "%": "HTMLTemplateElement"
    },
    Text: {
      "^": "CharacterData;$ti",
      $isText: 1,
      "%": ";Text"
    },
    TextAreaElement: {
      "^": "HtmlElement;0name=,$ti",
      $isTextAreaElement: 1,
      "%": "HTMLTextAreaElement"
    },
    TextDetector: {
      "^": "Interceptor;$ti",
      $isTextDetector: 1,
      "%": ""
    },
    TextEvent: {
      "^": "UIEvent;$ti",
      $isTextEvent: 1,
      "%": "TextEvent"
    },
    TextMetrics: {
      "^": "Interceptor;0width=,$ti",
      $isTextMetrics: 1,
      "%": "TextMetrics"
    },
    TextTrack: {
      "^": "EventTarget;$ti",
      $isTextTrack: 1,
      "%": ""
    },
    TextTrackCue: {
      "^": "EventTarget;$ti",
      $isTextTrackCue: 1,
      "%": ""
    },
    TextTrackCueList: {
      "^": "_TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.TextTrackCue];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.TextTrackCue];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrackCue];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.TextTrackCue];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.TextTrackCue];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.TextTrackCue];
      },
      $isList: 1,
      $asList: function() {
        return [W.TextTrackCue];
      },
      $isTextTrackCueList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.TextTrackCue];
      },
      "%": ""
    },
    TextTrackList: {
      "^": "_TextTrackList_EventTarget_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.TextTrack];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.TextTrack];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrack];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.TextTrack];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.TextTrack];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.TextTrack];
      },
      $isList: 1,
      $asList: function() {
        return [W.TextTrack];
      },
      $isTextTrackList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.TextTrack];
      },
      "%": ""
    },
    TimeElement: {
      "^": "HtmlElement;$ti",
      $isTimeElement: 1,
      "%": "HTMLTimeElement"
    },
    TimeRanges: {
      "^": "Interceptor;$ti",
      $isTimeRanges: 1,
      "%": ""
    },
    TitleElement: {
      "^": "HtmlElement;$ti",
      $isTitleElement: 1,
      "%": "HTMLTitleElement"
    },
    Touch: {
      "^": "Interceptor;$ti",
      $isTouch: 1,
      "%": ""
    },
    TouchEvent: {
      "^": "UIEvent;$ti",
      $isTouchEvent: 1,
      "%": "TouchEvent"
    },
    TouchList: {
      "^": "_TouchList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Touch];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.Touch];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Touch];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Touch];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Touch];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Touch];
      },
      $isList: 1,
      $asList: function() {
        return [W.Touch];
      },
      $isTouchList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Touch];
      },
      "%": ""
    },
    TrackDefault: {
      "^": "Interceptor;$ti",
      $isTrackDefault: 1,
      "%": ""
    },
    TrackDefaultList: {
      "^": "Interceptor;$ti",
      $isTrackDefaultList: 1,
      "%": ""
    },
    TrackElement: {
      "^": "HtmlElement;0kind=,$ti",
      $isTrackElement: 1,
      "%": "HTMLTrackElement"
    },
    TrackEvent: {
      "^": "Event;$ti",
      $isTrackEvent: 1,
      "%": "TrackEvent"
    },
    TransitionEvent: {
      "^": "Event;$ti",
      $isTransitionEvent: 1,
      "%": "TransitionEvent|WebKitTransitionEvent"
    },
    TreeWalker: {
      "^": "Interceptor;$ti",
      $isTreeWalker: 1,
      "%": ""
    },
    TrustedHtml: {
      "^": "Interceptor;$ti",
      $isTrustedHtml: 1,
      "%": ""
    },
    TrustedScriptUrl: {
      "^": "Interceptor;$ti",
      $isTrustedScriptUrl: 1,
      "%": ""
    },
    TrustedUrl: {
      "^": "Interceptor;$ti",
      $isTrustedUrl: 1,
      "%": ""
    },
    UIEvent: {
      "^": "Event;$ti",
      $isUIEvent: 1,
      "%": ";UIEvent"
    },
    UListElement: {
      "^": "HtmlElement;$ti",
      $isUListElement: 1,
      "%": "HTMLUListElement"
    },
    UnderlyingSourceBase: {
      "^": "Interceptor;$ti",
      $isUnderlyingSourceBase: 1,
      "%": ""
    },
    UnknownElement: {
      "^": "HtmlElement;$ti",
      $isUnknownElement: 1,
      "%": "HTMLUnknownElement"
    },
    Url: {
      "^": "Interceptor;$ti",
      $isUrl: 1,
      "%": ""
    },
    UrlSearchParams: {
      "^": "Interceptor;$ti",
      $isUrlSearchParams: 1,
      "%": ""
    },
    UrlUtilsReadOnly: {
      "^": "Interceptor;$ti"
    },
    VR: {
      "^": "EventTarget;$ti",
      $isVR: 1,
      "%": ""
    },
    VRCoordinateSystem: {
      "^": "Interceptor;$ti",
      $isVRCoordinateSystem: 1,
      "%": ""
    },
    VRDevice: {
      "^": "EventTarget;$ti",
      $isVRDevice: 1,
      "%": ""
    },
    VRDeviceEvent: {
      "^": "Event;$ti",
      $isVRDeviceEvent: 1,
      "%": "VRDeviceEvent"
    },
    VRDisplay: {
      "^": "EventTarget;$ti",
      $isVRDisplay: 1,
      "%": ""
    },
    VRDisplayCapabilities: {
      "^": "Interceptor;$ti",
      $isVRDisplayCapabilities: 1,
      "%": ""
    },
    VRDisplayEvent: {
      "^": "Event;$ti",
      $isVRDisplayEvent: 1,
      "%": "VRDisplayEvent"
    },
    VREyeParameters: {
      "^": "Interceptor;$ti",
      $isVREyeParameters: 1,
      "%": ""
    },
    VRFrameData: {
      "^": "Interceptor;$ti",
      $isVRFrameData: 1,
      "%": ""
    },
    VRFrameOfReference: {
      "^": "VRCoordinateSystem;$ti",
      $isVRFrameOfReference: 1,
      "%": ""
    },
    VRPose: {
      "^": "Interceptor;$ti",
      $isVRPose: 1,
      "%": ""
    },
    VRSession: {
      "^": "EventTarget;$ti",
      $isVRSession: 1,
      "%": ""
    },
    VRSessionEvent: {
      "^": "Event;$ti",
      $isVRSessionEvent: 1,
      "%": "VRSessionEvent"
    },
    VRStageBounds: {
      "^": "Interceptor;$ti",
      $isVRStageBounds: 1,
      "%": ""
    },
    VRStageBoundsPoint: {
      "^": "Interceptor;$ti",
      $isVRStageBoundsPoint: 1,
      "%": ""
    },
    VRStageParameters: {
      "^": "Interceptor;$ti",
      $isVRStageParameters: 1,
      "%": ""
    },
    ValidityState: {
      "^": "Interceptor;$ti",
      $isValidityState: 1,
      "%": ""
    },
    VideoElement: {
      "^": "MediaElement;0height=,0width=,$ti",
      set$height: function(receiver, height) {
        receiver.height = H.intTypeCheck(height);
      },
      set$width: function(receiver, width) {
        receiver.width = H.intTypeCheck(width);
      },
      $isVideoElement: 1,
      $isCanvasImageSource: 1,
      "%": "HTMLVideoElement"
    },
    VideoPlaybackQuality: {
      "^": "Interceptor;$ti",
      $isVideoPlaybackQuality: 1,
      "%": ""
    },
    VideoTrack: {
      "^": "Interceptor;$ti",
      $isVideoTrack: 1,
      "%": ""
    },
    VideoTrackList: {
      "^": "EventTarget;$ti",
      $isVideoTrackList: 1,
      "%": ""
    },
    VisualViewport: {
      "^": "EventTarget;$ti",
      $isVisualViewport: 1,
      "%": ""
    },
    VttCue: {
      "^": "TextTrackCue;$ti",
      $isVttCue: 1,
      "%": ""
    },
    VttRegion: {
      "^": "Interceptor;$ti",
      $isVttRegion: 1,
      "%": ""
    },
    WebSocket0: {
      "^": "EventTarget;$ti",
      send$1: [function(receiver, data) {
        return receiver.send(data);
      }, null, "get$send", 5, 0, null, 34],
      get$onClose: [function(receiver) {
        return C.EventStreamProvider_close.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      get$onError: [function(receiver) {
        return C.EventStreamProvider_error.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      get$onMessage: [function(receiver) {
        return C.EventStreamProvider_message.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      get$onOpen: [function(receiver) {
        return C.EventStreamProvider_open.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      $isWebSocket0: 1,
      "%": "WebSocket"
    },
    WheelEvent: {
      "^": "MouseEvent;$ti",
      $isWheelEvent: 1,
      "%": "WheelEvent"
    },
    Window: {
      "^": "EventTarget;0devicePixelRatio=,0history=,0name=,0navigator=,$ti",
      get$animationFrame: [function(receiver) {
        var completer = P.Completer_Completer$sync(P.num);
        this.requestAnimationFrame$1(receiver, new W.Window_animationFrame_closure(completer));
        return completer.get$future();
      }, null, null, 3, 0, null],
      get$location: [function(receiver) {
        return H.interceptedTypeCheck(this.get$_location(receiver), "$isLocation");
      }, null, null, 3, 0, null],
      get$_location: [function(receiver) {
        return receiver.location;
      }, null, null, 3, 0, null],
      requestAnimationFrame$1: [function(receiver, callback) {
        H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.num]});
        this._ensureRequestAnimationFrame$0(receiver);
        return this._requestAnimationFrame$1(receiver, W._wrapZone(callback, P.num));
      }, null, "get$requestAnimationFrame", 5, 0, null, 43],
      _requestAnimationFrame$1: [function(receiver, callback) {
        return receiver.requestAnimationFrame(H.convertDartClosureToJS(H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.num]}), 1));
      }, null, "get$_requestAnimationFrame", 5, 0, null, 43],
      _ensureRequestAnimationFrame$0: [function(receiver) {
        if (!!(receiver.requestAnimationFrame && receiver.cancelAnimationFrame))
          return;
        (function($this) {
          var vendors = ['ms', 'moz', 'webkit', 'o'];
          for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
            $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
            $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
          }
          if ($this.requestAnimationFrame && $this.cancelAnimationFrame)
            return;
          $this.requestAnimationFrame = function(callback) {
            return window.setTimeout(function() {
              callback(Date.now());
            }, 16);
          };
          $this.cancelAnimationFrame = function(id) {
            clearTimeout(id);
          };
        })(receiver);
      }, null, "get$_ensureRequestAnimationFrame", 1, 0, null],
      get$console: [function(receiver) {
        return C.C_Console;
      }, null, null, 3, 0, null],
      get$top: [function(receiver) {
        return W._convertNativeToDart_Window(receiver.top);
      }, null, null, 3, 0, null],
      matchMedia$1: [function(receiver, query) {
        return receiver.matchMedia(H.stringTypeCheck(query));
      }, null, "get$matchMedia", 5, 0, null, 210],
      get$onPopState: [function(receiver) {
        return C.EventStreamProvider_popstate.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      get$onResize: [function(receiver) {
        return C.EventStreamProvider_resize.forTarget$1(receiver);
      }, null, null, 3, 0, null],
      $isGlobalEventHandlers: 1,
      $isWindow: 1,
      $isWindowBase64: 1,
      $isWindowEventHandlers: 1,
      $is_WindowTimers: 1,
      $isWindowBase: 1,
      "%": "DOMWindow|Window"
    },
    Window_animationFrame_closure: {
      "^": "Closure:48;completer,$ti",
      call$1: [function(time) {
        J.complete$1$z(this.completer, H.numTypeCheck(time));
      }, null, null, 4, 0, null, 379, "call"]
    },
    _BeforeUnloadEvent: {
      "^": "_WrappedEvent;$ti",
      $isBeforeUnloadEvent: 1
    },
    _BeforeUnloadEventStreamProvider: {
      "^": "Object;$ti",
      $isEventStreamProvider: 1,
      $asEventStreamProvider: function() {
        return [W.BeforeUnloadEvent];
      }
    },
    WindowBase64: {
      "^": "Interceptor;$ti"
    },
    WindowClient: {
      "^": "Client0;$ti",
      $isWindowClient: 1,
      "%": ""
    },
    WindowEventHandlers: {
      "^": "EventTarget;$ti"
    },
    Worker: {
      "^": "EventTarget;$ti",
      $isAbstractWorker: 1,
      $isWorker: 1,
      "%": ""
    },
    WorkerGlobalScope: {
      "^": "EventTarget;$ti",
      $isWindowBase64: 1,
      $isWorkerGlobalScope: 1,
      $is_WindowTimers: 1,
      "%": ";WorkerGlobalScope"
    },
    WorkerPerformance: {
      "^": "EventTarget;$ti",
      $isWorkerPerformance: 1,
      "%": ""
    },
    WorkletAnimation: {
      "^": "Interceptor;$ti",
      $isWorkletAnimation: 1,
      "%": ""
    },
    WorkletGlobalScope: {
      "^": "Interceptor;$ti",
      $isWorkletGlobalScope: 1,
      "%": ""
    },
    XPathEvaluator: {
      "^": "Interceptor;$ti",
      $isXPathEvaluator: 1,
      "%": ""
    },
    XPathExpression: {
      "^": "Interceptor;$ti",
      $isXPathExpression: 1,
      "%": ""
    },
    XPathNSResolver: {
      "^": "Interceptor;$ti",
      $isXPathNSResolver: 1,
      "%": ""
    },
    XPathResult: {
      "^": "Interceptor;$ti",
      $isXPathResult: 1,
      "%": ""
    },
    XmlDocument: {
      "^": "Document;$ti",
      $isXmlDocument: 1,
      "%": "XMLDocument"
    },
    XmlSerializer: {
      "^": "Interceptor;$ti",
      $isXmlSerializer: 1,
      "%": ""
    },
    XsltProcessor: {
      "^": "Interceptor;$ti",
      $isXsltProcessor: 1,
      "%": ""
    },
    _Attr: {
      "^": "Node;0name=,0value=,$ti",
      set$value: function(receiver, value) {
        receiver.value = H.stringTypeCheck(value);
      },
      $is_Attr: 1,
      "%": "Attr"
    },
    _Bluetooth: {
      "^": "Interceptor;$ti",
      $is_Bluetooth: 1,
      "%": ""
    },
    _BluetoothCharacteristicProperties: {
      "^": "Interceptor;$ti",
      $is_BluetoothCharacteristicProperties: 1,
      "%": ""
    },
    _BluetoothDevice: {
      "^": "EventTarget;$ti",
      $is_BluetoothDevice: 1,
      "%": ""
    },
    _BluetoothRemoteGATTCharacteristic: {
      "^": "EventTarget;$ti",
      $is_BluetoothRemoteGATTCharacteristic: 1,
      "%": ""
    },
    _BluetoothRemoteGATTServer: {
      "^": "Interceptor;$ti",
      $is_BluetoothRemoteGATTServer: 1,
      "%": ""
    },
    _BluetoothRemoteGATTService: {
      "^": "Interceptor;$ti",
      $is_BluetoothRemoteGATTService: 1,
      "%": ""
    },
    _BluetoothUUID: {
      "^": "Interceptor;$ti",
      $is_BluetoothUUID: 1,
      "%": ""
    },
    _BudgetService: {
      "^": "Interceptor;$ti",
      $is_BudgetService: 1,
      "%": ""
    },
    _Cache: {
      "^": "Interceptor;$ti",
      $is_Cache: 1,
      "%": ""
    },
    _CanvasPath: {
      "^": "Interceptor;$ti"
    },
    _Clipboard: {
      "^": "EventTarget;$ti",
      $is_Clipboard: 1,
      "%": ""
    },
    _CssRuleList: {
      "^": "__CssRuleList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.CssRule];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.CssRule];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.CssRule];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.CssRule];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.CssRule];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.CssRule];
      },
      $isList: 1,
      $asList: function() {
        return [W.CssRule];
      },
      $is_CssRuleList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.CssRule];
      },
      "%": ""
    },
    _DOMFileSystemSync: {
      "^": "Interceptor;$ti",
      $is_DOMFileSystemSync: 1,
      "%": ""
    },
    _DirectoryEntrySync: {
      "^": "_EntrySync;$ti",
      $is_DirectoryEntrySync: 1,
      "%": ""
    },
    _DirectoryReaderSync: {
      "^": "Interceptor;$ti",
      $is_DirectoryReaderSync: 1,
      "%": ""
    },
    _DocumentType: {
      "^": "Node;$ti",
      $isChildNode: 1,
      $is_DocumentType: 1,
      "%": "DocumentType"
    },
    _DomRect: {
      "^": "DomRectReadOnly;$ti",
      toString$0: [function(receiver) {
        return "Rectangle (" + H.S(this.get$left(receiver)) + ", " + H.S(this.get$top(receiver)) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
      }, null, "get$toString", 1, 0, null],
      $eq: [function(receiver, other) {
        var t1;
        if (other == null)
          return false;
        if (!H.checkSubtype(other, "$isRectangle", [P.num], "$asRectangle"))
          return false;
        t1 = J.getInterceptor$x(other);
        return J.$eq$(this.get$left(receiver), t1.get$left(other)) && J.$eq$(this.get$top(receiver), t1.get$top(other)) && J.$eq$(this.get$width(receiver), t1.get$width(other)) && J.$eq$(this.get$height(receiver), t1.get$height(other));
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(receiver) {
        return W._JenkinsSmiHash_hash4(J.get$hashCode$(this.get$left(receiver)), J.get$hashCode$(this.get$top(receiver)), J.get$hashCode$(this.get$width(receiver)), J.get$hashCode$(this.get$height(receiver)));
      }, null, null, 3, 0, null],
      get$height: [function(receiver) {
        return receiver.height;
      }, null, null, 3, 0, null],
      get$width: [function(receiver) {
        return receiver.width;
      }, null, null, 3, 0, null],
      get$x: [function(receiver) {
        return receiver.x;
      }, null, null, 3, 0, null],
      get$y: [function(receiver) {
        return receiver.y;
      }, null, null, 3, 0, null],
      $is_DomRect: 1,
      "%": "ClientRect|DOMRect"
    },
    _JenkinsSmiHash: {
      "^": "Object;$ti"
    },
    _EntrySync: {
      "^": "Interceptor;$ti",
      $is_EntrySync: 1,
      "%": ""
    },
    _FileEntrySync: {
      "^": "_EntrySync;$ti",
      $is_FileEntrySync: 1,
      "%": ""
    },
    _FileReaderSync: {
      "^": "Interceptor;$ti",
      $is_FileReaderSync: 1,
      "%": ""
    },
    _FileWriterSync: {
      "^": "Interceptor;$ti",
      $is_FileWriterSync: 1,
      "%": ""
    },
    _GamepadList: {
      "^": "__GamepadList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Gamepad];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.Gamepad];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Gamepad];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Gamepad];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Gamepad];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Gamepad];
      },
      $isList: 1,
      $asList: function() {
        return [W.Gamepad];
      },
      $is_GamepadList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Gamepad];
      },
      "%": ""
    },
    _HTMLAllCollection: {
      "^": "Interceptor;$ti",
      $is_HTMLAllCollection: 1,
      "%": ""
    },
    _HTMLDirectoryElement: {
      "^": "HtmlElement;$ti",
      $is_HTMLDirectoryElement: 1,
      "%": "HTMLDirectoryElement"
    },
    _HTMLFontElement: {
      "^": "HtmlElement;$ti",
      $is_HTMLFontElement: 1,
      "%": "HTMLFontElement"
    },
    _HTMLFrameElement: {
      "^": "HtmlElement;$ti",
      $is_HTMLFrameElement: 1,
      "%": "HTMLFrameElement"
    },
    _HTMLFrameSetElement: {
      "^": "HtmlElement;$ti",
      $isWindowEventHandlers: 1,
      $is_HTMLFrameSetElement: 1,
      "%": "HTMLFrameSetElement"
    },
    _HTMLMarqueeElement: {
      "^": "HtmlElement;$ti",
      $is_HTMLMarqueeElement: 1,
      "%": "HTMLMarqueeElement"
    },
    _Mojo: {
      "^": "Interceptor;$ti",
      $is_Mojo: 1,
      "%": ""
    },
    _MojoHandle: {
      "^": "Interceptor;$ti",
      $is_MojoHandle: 1,
      "%": ""
    },
    _MojoInterfaceInterceptor: {
      "^": "EventTarget;$ti",
      $is_MojoInterfaceInterceptor: 1,
      "%": ""
    },
    _MojoInterfaceRequestEvent: {
      "^": "Event;$ti",
      $is_MojoInterfaceRequestEvent: 1,
      "%": "MojoInterfaceRequestEvent"
    },
    _MojoWatcher: {
      "^": "Interceptor;$ti",
      $is_MojoWatcher: 1,
      "%": ""
    },
    _NFC: {
      "^": "Interceptor;$ti",
      $is_NFC: 1,
      "%": ""
    },
    _NamedNodeMap: {
      "^": "__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin;$ti",
      get$length: [function(receiver) {
        return receiver.length;
      }, null, null, 3, 0, null],
      $index: [function(receiver, index) {
        H.intTypeCheck(index);
        if (index >>> 0 !== index || index >= receiver.length)
          throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
        return receiver[index];
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(receiver, index, value) {
        H.intTypeCheck(index);
        H.interceptedTypeCheck(value, "$isNode");
        throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(receiver, value) {
        H.intTypeCheck(value);
        throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
      }, null, null, 7, 0, null, 1],
      get$first: [function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(P.StateError$("No elements"));
      }, null, null, 3, 0, null],
      get$last: [function(receiver) {
        var len = receiver.length;
        if (len > 0)
          return receiver[len - 1];
        throw H.wrapException(P.StateError$("No elements"));
      }, null, null, 3, 0, null],
      get$single: [function(receiver) {
        var len = receiver.length;
        if (len === 1)
          return receiver[0];
        if (len === 0)
          throw H.wrapException(P.StateError$("No elements"));
        throw H.wrapException(P.StateError$("More than one element"));
      }, null, null, 3, 0, null],
      elementAt$1: [function(receiver, index) {
        return this.$index(receiver, H.intTypeCheck(index));
      }, null, "get$elementAt", 5, 0, null, 6],
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.Node];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.Node];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $is_NamedNodeMap: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Node];
      },
      "%": "MozNamedAttrMap|NamedNodeMap"
    },
    _PagePopupController: {
      "^": "Interceptor;$ti",
      $is_PagePopupController: 1,
      "%": ""
    },
    _Report: {
      "^": "Interceptor;$ti",
      $is_Report: 1,
      "%": ""
    },
    _Request: {
      "^": "Body;$ti",
      $is_Request: 1,
      "%": ""
    },
    _ResourceProgressEvent: {
      "^": "ProgressEvent;$ti",
      $is_ResourceProgressEvent: 1,
      "%": "ResourceProgressEvent"
    },
    _Response: {
      "^": "Body;$ti",
      $is_Response: 1,
      "%": ""
    },
    _SpeechRecognitionResultList: {
      "^": "__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.SpeechRecognitionResult];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SpeechRecognitionResult];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechRecognitionResult];
      },
      $is_SpeechRecognitionResultList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.SpeechRecognitionResult];
      },
      "%": ""
    },
    _StyleSheetList: {
      "^": "__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isJSIndexable: 1,
      $asJSIndexable: function() {
        return [W.StyleSheet];
      },
      $isJSMutableIndexable: 1,
      $asJSMutableIndexable: function() {
        return [W.StyleSheet];
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.StyleSheet];
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: function() {
        return [W.StyleSheet];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.StyleSheet];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.StyleSheet];
      },
      $isList: 1,
      $asList: function() {
        return [W.StyleSheet];
      },
      $is_StyleSheetList: 1,
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.StyleSheet];
      },
      "%": ""
    },
    _SubtleCrypto: {
      "^": "Interceptor;$ti",
      $is_SubtleCrypto: 1,
      "%": ""
    },
    _USB: {
      "^": "EventTarget;$ti",
      $is_USB: 1,
      "%": ""
    },
    _USBAlternateInterface: {
      "^": "Interceptor;$ti",
      $is_USBAlternateInterface: 1,
      "%": ""
    },
    _USBConfiguration: {
      "^": "Interceptor;$ti",
      $is_USBConfiguration: 1,
      "%": ""
    },
    _USBConnectionEvent: {
      "^": "Event;$ti",
      $is_USBConnectionEvent: 1,
      "%": "USBConnectionEvent"
    },
    _USBDevice: {
      "^": "Interceptor;$ti",
      $is_USBDevice: 1,
      "%": ""
    },
    _USBEndpoint: {
      "^": "Interceptor;$ti",
      $is_USBEndpoint: 1,
      "%": ""
    },
    _USBInTransferResult: {
      "^": "Interceptor;$ti",
      $is_USBInTransferResult: 1,
      "%": ""
    },
    _USBInterface: {
      "^": "Interceptor;$ti",
      $is_USBInterface: 1,
      "%": ""
    },
    _USBIsochronousInTransferPacket: {
      "^": "Interceptor;$ti",
      $is_USBIsochronousInTransferPacket: 1,
      "%": ""
    },
    _USBIsochronousInTransferResult: {
      "^": "Interceptor;$ti",
      $is_USBIsochronousInTransferResult: 1,
      "%": ""
    },
    _USBIsochronousOutTransferPacket: {
      "^": "Interceptor;$ti",
      $is_USBIsochronousOutTransferPacket: 1,
      "%": ""
    },
    _USBIsochronousOutTransferResult: {
      "^": "Interceptor;$ti",
      $is_USBIsochronousOutTransferResult: 1,
      "%": ""
    },
    _USBOutTransferResult: {
      "^": "Interceptor;$ti",
      $is_USBOutTransferResult: 1,
      "%": ""
    },
    _WindowTimers: {
      "^": "Interceptor;$ti"
    },
    _WorkerLocation: {
      "^": "Interceptor;$ti",
      $isUrlUtilsReadOnly: 1,
      $is_WorkerLocation: 1,
      "%": ""
    },
    _WorkerNavigator: {
      "^": "NavigatorConcurrentHardware;$ti",
      $isNavigatorID: 1,
      $isNavigatorOnLine: 1,
      $is_WorkerNavigator: 1,
      "%": ""
    },
    _Worklet: {
      "^": "Interceptor;$ti",
      $is_Worklet: 1,
      "%": ""
    },
    _AttributeMap: {
      "^": "MapBase;$ti",
      addAll$1: [function(_, other) {
        var t1 = P.String;
        H.assertSubtype(other, "$isMap", [t1, t1], "$asMap").forEach$1(0, new W._AttributeMap_addAll_closure(this));
      }, null, "get$addAll", 5, 0, null, 3],
      cast$2$0: [1, function(_, $K, $V) {
        var t1 = P.String;
        return P.Map_castFrom(this, t1, t1, $K, $V);
      }, function($receiver) {
        return this.cast$2$0($receiver, null, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      putIfAbsent$2: [function(key, ifAbsent) {
        H.stringTypeCheck(key);
        H.functionTypeCheck(ifAbsent, {func: 1, ret: P.String});
        if (!this.containsKey$1(key))
          this.$indexSet(0, key, ifAbsent.call$0());
        return this.$index(0, key);
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      clear$0: [function(_) {
        var t1;
        for (t1 = J.get$iterator$ax(this.get$keys()); t1.moveNext$0();)
          this.remove$1(0, t1.get$current());
      }, null, "get$clear", 1, 0, null],
      forEach$1: [function(_, f) {
        var t1, t2;
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String, P.String]});
        for (t1 = J.get$iterator$ax(this.get$keys()); t1.moveNext$0();) {
          t2 = t1.get$current();
          f.call$2(t2, this.$index(0, t2));
        }
      }, null, "get$forEach", 5, 0, null, 15],
      get$keys: [function() {
        var attributes, keys, len, i, attr;
        attributes = J.get$_attributes$x(this._element);
        keys = H.setRuntimeTypeInfo([], [P.String]);
        for (len = attributes.length, i = 0; i < len; ++i) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          attr = H.interceptedTypeCheck(attributes[i], "$is_Attr");
          if (this._matches$1(attr))
            C.JSArray_methods.add$1(keys, attr.name);
        }
        return keys;
      }, null, null, 2, 0, null],
      get$values: [function(_) {
        var attributes, values, len, i, attr;
        attributes = J.get$_attributes$x(this._element);
        values = H.setRuntimeTypeInfo([], [P.String]);
        for (len = attributes.length, i = 0; i < len; ++i) {
          if (i >= attributes.length)
            return H.ioore(attributes, i);
          attr = H.interceptedTypeCheck(attributes[i], "$is_Attr");
          if (this._matches$1(attr))
            C.JSArray_methods.add$1(values, attr.value);
        }
        return values;
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !this.get$isEmpty(this);
      }, null, null, 3, 0, null],
      $asMapBase: function() {
        return [P.String, P.String];
      },
      $asMapMixin: function() {
        return [P.String, P.String];
      },
      $asMap: function() {
        return [P.String, P.String];
      }
    },
    _AttributeMap_addAll_closure: {
      "^": "Closure:20;$this,$ti",
      call$2: [function(k, v) {
        J.$indexSet$ax(this.$this, H.stringTypeCheck(k), H.stringTypeCheck(v));
      }, null, null, 8, 0, null, 253, 112, "call"]
    },
    _ElementAttributeMap: {
      "^": "_AttributeMap;_element,$ti",
      containsKey$1: [function(key) {
        return J._hasAttribute$1$x(this._element, H.stringTypeCheck(key));
      }, null, "get$containsKey", 4, 0, null, 4],
      $index: [function(_, key) {
        return J.getAttribute$1$x(this._element, H.stringTypeCheck(key));
      }, null, "get$[]", 5, 0, null, 4],
      $indexSet: [function(_, key, value) {
        J.setAttribute$2$x(this._element, H.stringTypeCheck(key), H.stringTypeCheck(value));
      }, null, "get$[]=", 9, 0, null, 4, 1],
      remove$1: [function(_, key) {
        var t1, t2, value;
        t1 = this._element;
        H.stringTypeCheck(key);
        t2 = J.getInterceptor$x(t1);
        value = t2.getAttribute$1(t1, key);
        t2._removeAttribute$1(t1, key);
        return value;
      }, null, "get$remove", 5, 0, null, 4],
      get$length: [function(_) {
        return J.get$length$asx(this.get$keys());
      }, null, null, 3, 0, null],
      _matches$1: [function(node) {
        return H.interceptedTypeCheck(node, "$is_Attr").namespaceURI == null;
      }, null, "get$_matches", 4, 0, null, 23],
      static: {
        _ElementAttributeMap$: [function(element) {
          return new W._ElementAttributeMap(element, []);
        }, null, null, 4, 0, null, 10]
      }
    },
    _NamespacedAttributeMap: {
      "^": "_AttributeMap;$ti"
    },
    _DataAttributeMap: {
      "^": "MapBase;$ti",
      $asMapBase: function() {
        return [P.String, P.String];
      },
      $asMapMixin: function() {
        return [P.String, P.String];
      },
      $asMap: function() {
        return [P.String, P.String];
      }
    },
    _DataAttributeMap_addAll_closure: {
      "^": "Closure:20;$ti"
    },
    _DataAttributeMap_forEach_closure: {
      "^": "Closure:20;$ti"
    },
    _DataAttributeMap_keys_closure: {
      "^": "Closure:20;$ti"
    },
    _DataAttributeMap_values_closure: {
      "^": "Closure:20;$ti"
    },
    CanvasImageSource: {
      "^": "Object;$ti"
    },
    WindowBase: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isEventTarget: 1
    },
    LocationBase: {
      "^": "Object;$ti"
    },
    HistoryBase: {
      "^": "Object;$ti"
    },
    CssClassSet: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.String];
      },
      $isSet: 1,
      $asSet: function() {
        return [P.String];
      }
    },
    _ContentCssRect: {
      "^": "CssRect;$ti"
    },
    _ContentCssListRect: {
      "^": "_ContentCssRect;$ti"
    },
    _PaddingCssRect: {
      "^": "CssRect;$ti"
    },
    _BorderCssRect: {
      "^": "CssRect;$ti"
    },
    _MarginCssRect: {
      "^": "CssRect;$ti"
    },
    CssRect: {
      "^": "Object;$ti",
      $is_RectangleBase: 1,
      $as_RectangleBase: function() {
        return [P.num];
      },
      $isRectangle: 1,
      $asRectangle: function() {
        return [P.num];
      }
    },
    _MultiElementCssClassSet: {
      "^": "CssClassSetImpl;$ti"
    },
    _ElementCssClassSet: {
      "^": "CssClassSetImpl;_element,$ti",
      readClasses$0: [function() {
        var t1, s, trimmed;
        t1 = P.String;
        s = P.LinkedHashSet_LinkedHashSet(null, null, null, t1);
        for (t1 = C.JSArray_methods.get$iterator(H.setRuntimeTypeInfo(J.get$className$x(this._element).split(" "), [t1])); t1.moveNext$0();) {
          trimmed = J.trim$0$s(t1.get$current());
          if (!J.get$isEmpty$asx(trimmed))
            s.add$1(0, trimmed);
        }
        return s;
      }, null, "get$readClasses", 0, 0, null],
      writeClasses$1: [function(s) {
        J.set$className$x(this._element, H.assertSubtype(s, "$isSet", [P.String], "$asSet").join$1(0, " "));
      }, null, "get$writeClasses", 4, 0, null, 50],
      get$length: [function(_) {
        return W._ElementCssClassSet__classListLength(W._ElementCssClassSet__classListOf(this._element));
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return !J.$eq$(this.get$length(this), 0);
      }, null, null, 3, 0, null],
      clear$0: [function(_) {
        J.set$className$x(this._element, "");
      }, null, "get$clear", 1, 0, null],
      contains$1: [function(_, value) {
        return W._ElementCssClassSet__contains(this._element, value);
      }, null, "get$contains", 5, 0, null, 1],
      add$1: [function(_, value) {
        return W._ElementCssClassSet__add(this._element, H.stringTypeCheck(value));
      }, "call$1", "get$add", 5, 0, 18, 1],
      remove$1: [function(_, value) {
        return typeof value === "string" && W._ElementCssClassSet__remove(this._element, value);
      }, null, "get$remove", 5, 0, null, 1],
      toggle$2: [function(_, value, shouldAdd) {
        return W._ElementCssClassSet__toggle(this._element, H.stringTypeCheck(value), H.boolTypeCheck(shouldAdd));
      }, null, "get$toggle", 5, 2, null, 0, 1, 231],
      addAll$1: [function(_, iterable) {
        W._ElementCssClassSet__addAll(this._element, H.assertSubtype(iterable, "$isIterable", [P.String], "$asIterable"));
      }, null, "get$addAll", 5, 0, null, 13],
      removeAll$1: [function(iterable) {
        W._ElementCssClassSet__removeAll(this._element, H.assertSubtype(H.assertSubtype(iterable, "$isIterable", [P.Object], "$asIterable"), "$isIterable", [P.String], "$asIterable"));
      }, null, "get$removeAll", 4, 0, null, 13],
      static: {
        _ElementCssClassSet$: [function(_element) {
          return new W._ElementCssClassSet(_element, []);
        }, null, null, 4, 0, null, 92],
        _ElementCssClassSet__contains: [function(_element, value) {
          H.interceptedTypeCheck(_element, "$isElement");
          return typeof value === "string" && W._ElementCssClassSet__classListContains(W._ElementCssClassSet__classListOf(_element), value);
        }, null, null, 8, 0, null, 92, 1],
        _ElementCssClassSet__add: [function(_element, value) {
          var list, t1;
          H.interceptedTypeCheck(_element, "$isElement");
          H.stringTypeCheck(value);
          list = W._ElementCssClassSet__classListOf(_element);
          t1 = W._ElementCssClassSet__classListContainsBeforeAddOrRemove(list, value);
          W._ElementCssClassSet__classListAdd(list, value);
          return !t1;
        }, null, null, 8, 0, null, 92, 1],
        _ElementCssClassSet__remove: [function(_element, value) {
          var list, removed;
          H.interceptedTypeCheck(_element, "$isElement");
          H.stringTypeCheck(value);
          list = W._ElementCssClassSet__classListOf(_element);
          removed = W._ElementCssClassSet__classListContainsBeforeAddOrRemove(list, value);
          W._ElementCssClassSet__classListRemove(list, value);
          return removed;
        }, null, null, 8, 0, null, 92, 1],
        _ElementCssClassSet__toggle: [function(_element, value, shouldAdd) {
          H.interceptedTypeCheck(_element, "$isElement");
          H.stringTypeCheck(value);
          H.boolTypeCheck(shouldAdd);
          return shouldAdd == null ? W._ElementCssClassSet__toggleDefault(_element, value) : W._ElementCssClassSet__toggleOnOff(_element, value, shouldAdd);
        }, null, null, 12, 0, null, 92, 1, 231],
        _ElementCssClassSet__toggleDefault: [function(_element, value) {
          H.interceptedTypeCheck(_element, "$isElement");
          H.stringTypeCheck(value);
          return W._ElementCssClassSet__classListToggle1(W._ElementCssClassSet__classListOf(_element), value);
        }, null, null, 8, 0, null, 92, 1],
        _ElementCssClassSet__toggleOnOff: [function(_element, value, shouldAdd) {
          var list;
          H.interceptedTypeCheck(_element, "$isElement");
          H.stringTypeCheck(value);
          H.boolTypeCheck(shouldAdd);
          list = W._ElementCssClassSet__classListOf(_element);
          if (shouldAdd) {
            W._ElementCssClassSet__classListAdd(list, value);
            return true;
          } else {
            W._ElementCssClassSet__classListRemove(list, value);
            return false;
          }
        }, null, null, 12, 0, null, 92, 1, 231],
        _ElementCssClassSet__addAll: [function(_element, iterable) {
          var list, t1;
          H.interceptedTypeCheck(_element, "$isElement");
          H.assertSubtype(iterable, "$isIterable", [P.String], "$asIterable");
          list = W._ElementCssClassSet__classListOf(_element);
          for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();)
            W._ElementCssClassSet__classListAdd(list, t1.get$current());
        }, null, null, 8, 0, null, 92, 13],
        _ElementCssClassSet__removeAll: [function(_element, iterable) {
          var list, t1;
          H.interceptedTypeCheck(_element, "$isElement");
          H.assertSubtype(iterable, "$isIterable", [P.String], "$asIterable");
          list = W._ElementCssClassSet__classListOf(_element);
          for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();)
            W._ElementCssClassSet__classListRemove(list, t1.get$current());
        }, null, null, 8, 0, null, 92, 13],
        _ElementCssClassSet__classListOf: [function(e) {
          return H.interceptedTypeCheck(e, "$isElement").classList;
        }, null, null, 4, 0, null, 19],
        _ElementCssClassSet__classListLength: [function(list) {
          return H.interceptedTypeCheck(list, "$isDomTokenList").length;
        }, null, null, 4, 0, null, 68],
        _ElementCssClassSet__classListContains: [function(list, value) {
          return H.interceptedTypeCheck(list, "$isDomTokenList").contains(H.stringTypeCheck(value));
        }, null, null, 8, 0, null, 68, 1],
        _ElementCssClassSet__classListContainsBeforeAddOrRemove: [function(list, value) {
          return H.interceptedTypeCheck(list, "$isDomTokenList").contains(H.stringTypeCheck(value));
        }, null, null, 8, 0, null, 68, 1],
        _ElementCssClassSet__classListAdd: [function(list, value) {
          H.interceptedTypeCheck(list, "$isDomTokenList").add(H.stringTypeCheck(value));
        }, null, null, 8, 0, null, 68, 1],
        _ElementCssClassSet__classListRemove: [function(list, value) {
          H.interceptedTypeCheck(list, "$isDomTokenList").remove(H.stringTypeCheck(value));
        }, null, null, 8, 0, null, 68, 1],
        _ElementCssClassSet__classListToggle1: [function(list, value) {
          return H.interceptedTypeCheck(list, "$isDomTokenList").toggle(H.stringTypeCheck(value));
        }, null, null, 8, 0, null, 68, 1]
      }
    },
    Dimension: {
      "^": "Object;$ti"
    },
    EventStreamProvider: {
      "^": "Object;_eventType,$ti",
      forTarget$2$useCapture: [function(e, useCapture) {
        return W._EventStream$(H.interceptedTypeCheck(e, "$isEventTarget"), this._eventType, H.boolTypeCheck(useCapture), H.getTypeArgumentByIndex(this, 0));
      }, function(e) {
        return this.forTarget$2$useCapture(e, false);
      }, "forTarget$1", null, null, "get$forTarget", 4, 3, null, 18, 19, 143],
      forElement$2$useCapture: [function(e, useCapture) {
        return W._ElementEventStreamImpl$(H.interceptedTypeCheck(e, "$isElement"), this._eventType, H.boolTypeCheck(useCapture), H.getTypeArgumentByIndex(this, 0));
      }, function(e) {
        return this.forElement$2$useCapture(e, false);
      }, "forElement$1", null, null, "get$forElement", 4, 3, null, 18, 19, 143]
    },
    ElementStream: {
      "^": "Object;$ti",
      $isStream: 1
    },
    _EventStream: {
      "^": "Stream;_html$_target,_eventType,_useCapture,$ti",
      get$isBroadcast: [function() {
        return true;
      }, null, null, 2, 0, null],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        H.boolTypeCheck(cancelOnError);
        return W._EventStreamSubscription$(this._html$_target, this._eventType, onData, this._useCapture, t1);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      static: {
        _EventStream$: [function(_target, _eventType, _useCapture, $T) {
          return new W._EventStream(_target, _eventType, _useCapture, [$T]);
        }, null, null, 12, 0, null, 266, 319, 342]
      }
    },
    _ElementEventStreamImpl: {
      "^": "_EventStream;_html$_target,_eventType,_useCapture,$ti",
      $isElementStream: 1,
      static: {
        _ElementEventStreamImpl$: [function(target, eventType, useCapture, $T) {
          return new W._ElementEventStreamImpl(H.interceptedTypeCheck(target, "$isEventTarget"), H.stringTypeCheck(eventType), H.boolTypeCheck(useCapture), [$T]);
        }, null, null, 12, 0, null, 89, 891, 143]
      }
    },
    _ElementListEventStreamImpl: {
      "^": "Stream;$ti",
      $isElementStream: 1
    },
    _EventStreamSubscription: {
      "^": "StreamSubscription;_pauseCount,_html$_target,_eventType,_html$_onData,_useCapture,$ti",
      set$_html$_onData: function(_onData) {
        this._html$_onData = H.functionTypeCheck(_onData, {func: 1, args: [W.Event]});
      },
      _EventStreamSubscription$4: [function(_target, _eventType, onData, _useCapture, $T) {
        this._tryResume$0();
      }, null, null, 16, 0, null, 266, 319, 32, 342],
      cancel$0: [function() {
        if (this.get$_canceled())
          return;
        this._unlisten$0();
        this._html$_target = null;
        this.set$_html$_onData(null);
        return;
      }, null, "get$cancel", 0, 0, null],
      get$_canceled: [function() {
        return this._html$_target == null;
      }, null, null, 2, 0, null],
      onData$1: [function(handleData) {
        H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
        if (this.get$_canceled())
          throw H.wrapException(P.StateError$("Subscription has been canceled."));
        this._unlisten$0();
        this.set$_html$_onData(W._wrapZone(H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [W.Event]}), W.Event));
        this._tryResume$0();
      }, null, "get$onData", 4, 0, null, 283],
      onError$1: [function(_, handleError) {
        H.interceptedTypeCheck(handleError, "$isFunction");
      }, "call$1", "get$onError", 5, 0, 33, 322],
      onDone$1: [function(handleDone) {
        H.functionTypeCheck(handleDone, {func: 1, ret: -1});
      }, null, "get$onDone", 4, 0, null, 294],
      pause$1: [function(_, resumeSignal) {
        H.interceptedTypeCheck(resumeSignal, "$isFuture");
        if (this.get$_canceled())
          return;
        this._pauseCount = H.intTypeCheck(J.$add$ansx(this._pauseCount, 1));
        this._unlisten$0();
        if (resumeSignal != null)
          resumeSignal.whenComplete$1(this.get$resume());
      }, function($receiver) {
        return this.pause$1($receiver, null);
      }, "pause$0", null, null, "get$pause", 1, 2, null, 0, 175],
      get$isPaused: [function() {
        return J.$gt$n(this._pauseCount, 0);
      }, null, null, 2, 0, null],
      resume$0: [function() {
        if (this.get$_canceled() || !this.get$isPaused())
          return;
        this._pauseCount = H.intTypeCheck(J.$sub$n(this._pauseCount, 1));
        this._tryResume$0();
      }, "call$0", "get$resume", 0, 0, 0],
      _tryResume$0: [function() {
        if (this._html$_onData != null && !this.get$isPaused())
          J.addEventListener$3$x(this._html$_target, this._eventType, this._html$_onData, this._useCapture);
      }, null, "get$_tryResume", 0, 0, null],
      _unlisten$0: [function() {
        var t1 = this._html$_onData;
        if (t1 != null)
          J.removeEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
      }, null, "get$_unlisten", 0, 0, null],
      static: {
        _EventStreamSubscription$: [function(_target, _eventType, onData, _useCapture, $T) {
          var t1 = onData == null ? null : W._wrapZone(new W._EventStreamSubscription_closure(onData), W.Event);
          t1 = new W._EventStreamSubscription(0, _target, _eventType, t1, _useCapture, [$T]);
          t1._EventStreamSubscription$4(_target, _eventType, onData, _useCapture, $T);
          return t1;
        }, null, null, 16, 0, null, 266, 319, 32, 342]
      }
    },
    _EventStreamSubscription_closure: {
      "^": "Closure:117;onData,$ti",
      call$1: [function(e) {
        return this.onData.call$1(H.interceptedTypeCheck(e, "$isEvent"));
      }, null, null, 4, 0, null, 19, "call"]
    },
    CustomStream: {
      "^": "Object;$ti",
      $isStream: 1
    },
    _CustomEventStreamImpl: {
      "^": "Stream;$ti",
      $isCustomStream: 1
    },
    _CustomKeyEventStreamImpl: {
      "^": "_CustomEventStreamImpl;$ti",
      $asStream: function() {
        return [W.KeyEvent];
      },
      $asCustomStream: function() {
        return [W.KeyEvent];
      },
      $as_CustomEventStreamImpl: function() {
        return [W.KeyEvent];
      }
    },
    _StreamPool: {
      "^": "Object;$ti"
    },
    _CustomEventStreamProvider: {
      "^": "Object;$ti",
      $isEventStreamProvider: 1
    },
    _Html5NodeValidator: {
      "^": "Object;uriPolicy,$ti",
      _Html5NodeValidator$1$uriPolicy: [function(uriPolicy) {
        var t1, t2;
        t1 = $.$get$_Html5NodeValidator__attributeValidators();
        if (J.get$isEmpty$asx(t1)) {
          for (t2 = C.JSArray_methods.get$iterator(C.List_2Zi); t2.moveNext$0();)
            J.$indexSet$ax(t1, t2.get$current(), W.html__Html5NodeValidator__standardAttributeValidator$closure());
          for (t2 = C.JSArray_methods.get$iterator(C.List_yrN); t2.moveNext$0();)
            J.$indexSet$ax(t1, t2.get$current(), W.html__Html5NodeValidator__uriAttributeValidator$closure());
        }
      }, null, null, 0, 3, null, 0, 235],
      allowsElement$1: [function(element) {
        H.interceptedTypeCheck(element, "$isElement");
        return J.contains$1$asx($.$get$_Html5NodeValidator__allowedElements(), W.Element__safeTagName(element));
      }, null, "get$allowsElement", 4, 0, null, 10],
      allowsAttribute$3: [function(element, attributeName, value) {
        var tagName, t1, validator;
        H.interceptedTypeCheck(element, "$isElement");
        H.stringTypeCheck(attributeName);
        H.stringTypeCheck(value);
        tagName = W.Element__safeTagName(element);
        t1 = $.$get$_Html5NodeValidator__attributeValidators();
        validator = J.$index$asx(t1, H.S(tagName) + "::" + H.S(attributeName));
        if (validator == null)
          validator = J.$index$asx(t1, "*::" + H.S(attributeName));
        if (validator == null)
          return false;
        return H.boolTypeCheck(validator.call$4(element, attributeName, value, this));
      }, null, "get$allowsAttribute", 12, 0, null, 10, 144, 1],
      $isNodeValidator: 1,
      static: {
        _Html5NodeValidator$: [function(uriPolicy) {
          var t1 = uriPolicy != null ? uriPolicy : W.UriPolicy_UriPolicy();
          t1 = new W._Html5NodeValidator(t1, []);
          t1._Html5NodeValidator$1$uriPolicy(uriPolicy);
          return t1;
        }, null, null, 0, 3, null, 0, 235],
        _Html5NodeValidator__standardAttributeValidator: [function(element, attributeName, value, context) {
          H.interceptedTypeCheck(element, "$isElement");
          H.stringTypeCheck(attributeName);
          H.stringTypeCheck(value);
          H.interceptedTypeCheck(context, "$is_Html5NodeValidator");
          return true;
        }, "call$4", "html__Html5NodeValidator__standardAttributeValidator$closure", 16, 0, 45, 10, 144, 1, 202],
        _Html5NodeValidator__uriAttributeValidator: [function(element, attributeName, value, context) {
          H.interceptedTypeCheck(element, "$isElement");
          H.stringTypeCheck(attributeName);
          H.stringTypeCheck(value);
          return H.interceptedTypeCheck(context, "$is_Html5NodeValidator").uriPolicy.allowsUri$1(value);
        }, "call$4", "html__Html5NodeValidator__uriAttributeValidator$closure", 16, 0, 45, 10, 144, 1, 202]
      }
    },
    ImmutableListMixin: {
      "^": "Object;$ti",
      get$iterator: [function(receiver) {
        return W.FixedSizeListIterator$(receiver, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0));
      }, null, null, 3, 0, null],
      add$1: [function(receiver, value) {
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0));
        throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
      }, "call$1", "get$add", 5, 0, 2, 1],
      addAll$1: [function(receiver, iterable) {
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
      }, null, "get$addAll", 5, 0, null, 13],
      sort$1: [function(receiver, compare) {
        var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0);
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
        throw H.wrapException(P.UnsupportedError$("Cannot sort immutable List."));
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      insert$2: [function(receiver, index, element) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0));
        throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
      }, null, "get$insert", 9, 0, null, 6, 10],
      insertAll$2: [function(receiver, index, iterable) {
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
      }, null, "get$insertAll", 9, 0, null, 6, 13],
      setAll$2: [function(receiver, index, iterable) {
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot modify an immutable List."));
      }, null, "get$setAll", 9, 0, null, 6, 13],
      removeAt$1: [function(receiver, pos) {
        H.intTypeCheck(pos);
        throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
      }, null, "get$removeAt", 5, 0, null, 302],
      removeLast$0: [function(receiver) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
      }, null, "get$removeLast", 1, 0, null],
      remove$1: [function(receiver, object) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
      }, null, "get$remove", 5, 0, null, 9],
      setRange$4: [function(receiver, start, end, iterable, skipCount) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)], "$asIterable");
        H.intTypeCheck(skipCount);
        throw H.wrapException(P.UnsupportedError$("Cannot setRange on immutable List."));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      replaceRange$3: [function(receiver, start, end, iterable) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot modify an immutable List."));
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 13],
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1
    },
    KeyCode: {
      "^": "Object;$ti"
    },
    KeyLocation: {
      "^": "Object;$ti"
    },
    _KeyName: {
      "^": "Object;$ti"
    },
    _KeyboardEventHandler: {
      "^": "EventStreamProvider;$ti",
      $asEventStreamProvider: function() {
        return [W.KeyEvent];
      }
    },
    KeyboardEventStream: {
      "^": "Object;$ti"
    },
    NodeValidatorBuilder: {
      "^": "Object;_validators,$ti",
      NodeValidatorBuilder$common$0: [function() {
        this.allowHtml5$0();
        this.allowTemplating$0();
      }, null, null, 0, 0, null],
      allowHtml5$1$uriPolicy: [function(uriPolicy) {
        this.add$1(0, W._Html5NodeValidator$(H.interceptedTypeCheck(uriPolicy, "$isUriPolicy")));
      }, function() {
        return this.allowHtml5$1$uriPolicy(null);
      }, "allowHtml5$0", null, null, "get$allowHtml5", 0, 3, null, 0, 235],
      allowSvg$0: [function() {
        this.add$1(0, W._SvgNodeValidator$());
      }, null, "get$allowSvg", 0, 0, null],
      allowTemplating$0: [function() {
        this.add$1(0, W._TemplatingNodeValidator$());
      }, null, "get$allowTemplating", 0, 0, null],
      add$1: [function(_, validator) {
        J.add$1$ax(this._validators, H.interceptedTypeCheck(validator, "$isNodeValidator"));
      }, "call$1", "get$add", 5, 0, 120, 97],
      allowsElement$1: [function(element) {
        return J.any$1$ax(this._validators, new W.NodeValidatorBuilder_allowsElement_closure(H.interceptedTypeCheck(element, "$isElement")));
      }, null, "get$allowsElement", 4, 0, null, 10],
      allowsAttribute$3: [function(element, attributeName, value) {
        return J.any$1$ax(this._validators, new W.NodeValidatorBuilder_allowsAttribute_closure(H.interceptedTypeCheck(element, "$isElement"), H.stringTypeCheck(attributeName), H.stringTypeCheck(value)));
      }, null, "get$allowsAttribute", 12, 0, null, 10, 144, 1],
      $isNodeValidator: 1,
      static: {
        NodeValidatorBuilder$common: [function() {
          var t1 = new W.NodeValidatorBuilder(H.setRuntimeTypeInfo([], [W.NodeValidator]), []);
          t1.NodeValidatorBuilder$common$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    NodeValidatorBuilder_allowsElement_closure: {
      "^": "Closure:72;element,$ti",
      call$1: [function(v) {
        return H.interceptedTypeCheck(v, "$isNodeValidator").allowsElement$1(this.element);
      }, null, null, 4, 0, null, 112, "call"]
    },
    NodeValidatorBuilder_allowsAttribute_closure: {
      "^": "Closure:72;element,attributeName,value,$ti",
      call$1: [function(v) {
        return H.interceptedTypeCheck(v, "$isNodeValidator").allowsAttribute$3(this.element, this.attributeName, this.value);
      }, null, null, 4, 0, null, 112, "call"]
    },
    _SimpleNodeValidator: {
      "^": "Object;$ti",
      _SimpleNodeValidator$4$allowedAttributes$allowedElements$allowedUriAttributes: [function(uriPolicy, allowedAttributes, allowedElements, allowedUriAttributes) {
        var t1, legalAttributes, extraUriAttributes, t2;
        t1 = allowedElements == null ? C.List_empty1 : allowedElements;
        J.addAll$1$ax(this.allowedElements, t1);
        if (allowedAttributes == null)
          allowedAttributes = C.List_empty1;
        if (allowedUriAttributes == null)
          allowedUriAttributes = C.List_empty1;
        t1 = J.getInterceptor$ax(allowedAttributes);
        legalAttributes = t1.where$1(allowedAttributes, new W._SimpleNodeValidator_closure());
        extraUriAttributes = t1.where$1(allowedAttributes, new W._SimpleNodeValidator_closure0());
        J.addAll$1$ax(this.allowedAttributes, legalAttributes);
        t1 = this.allowedUriAttributes;
        t2 = J.getInterceptor$ax(t1);
        t2.addAll$1(t1, allowedUriAttributes);
        t2.addAll$1(t1, extraUriAttributes);
      }, null, null, 4, 7, null, 0, 0, 0, 235, 1033, 1038, 1040],
      allowsElement$1: [function(element) {
        return J.contains$1$asx(this.allowedElements, W.Element__safeTagName(H.interceptedTypeCheck(element, "$isElement")));
      }, null, "get$allowsElement", 4, 0, null, 10],
      allowsAttribute$3: ["super$_SimpleNodeValidator$allowsAttribute", function(element, attributeName, value) {
        var tagName, t1, t2;
        H.interceptedTypeCheck(element, "$isElement");
        H.stringTypeCheck(attributeName);
        H.stringTypeCheck(value);
        tagName = W.Element__safeTagName(element);
        t1 = this.allowedUriAttributes;
        t2 = J.getInterceptor$asx(t1);
        if (t2.contains$1(t1, H.S(tagName) + "::" + H.S(attributeName)))
          return this.uriPolicy.allowsUri$1(value);
        else if (t2.contains$1(t1, "*::" + H.S(attributeName)))
          return this.uriPolicy.allowsUri$1(value);
        else {
          t1 = this.allowedAttributes;
          t2 = J.getInterceptor$asx(t1);
          if (t2.contains$1(t1, H.S(tagName) + "::" + H.S(attributeName)))
            return true;
          else if (t2.contains$1(t1, "*::" + H.S(attributeName)))
            return true;
          else if (t2.contains$1(t1, H.S(tagName) + "::*"))
            return true;
          else if (t2.contains$1(t1, "*::*"))
            return true;
        }
        return false;
      }, null, "get$allowsAttribute", 12, 0, null, 10, 144, 1],
      $isNodeValidator: 1
    },
    _SimpleNodeValidator_closure: {
      "^": "Closure:14;$ti",
      call$1: [function(x) {
        return !C.JSArray_methods.contains$1(C.List_yrN, H.stringTypeCheck(x));
      }, null, null, 4, 0, null, 37, "call"]
    },
    _SimpleNodeValidator_closure0: {
      "^": "Closure:14;$ti",
      call$1: [function(x) {
        return C.JSArray_methods.contains$1(C.List_yrN, H.stringTypeCheck(x));
      }, null, null, 4, 0, null, 37, "call"]
    },
    _CustomElementNodeValidator: {
      "^": "_SimpleNodeValidator;$ti"
    },
    _TemplatingNodeValidator: {
      "^": "_SimpleNodeValidator;_templateAttrs,allowedElements,allowedAttributes,allowedUriAttributes,uriPolicy,$ti",
      allowsAttribute$3: [function(element, attributeName, value) {
        H.interceptedTypeCheck(element, "$isElement");
        H.stringTypeCheck(attributeName);
        H.stringTypeCheck(value);
        if (this.super$_SimpleNodeValidator$allowsAttribute(element, attributeName, value))
          return true;
        if (attributeName === "template" && value === "")
          return true;
        if (J.$eq$(J.$index$asx(J.get$attributes$x(element), "template"), ""))
          return J.contains$1$asx(this._templateAttrs, attributeName);
        return false;
      }, null, "get$allowsAttribute", 12, 0, null, 10, 144, 1],
      static: {
        _TemplatingNodeValidator$: [function() {
          var t1, t2, t3, t4;
          t1 = P.String;
          t2 = P.LinkedHashSet_LinkedHashSet$from(C.List_wSV, t1);
          t3 = C.JSArray_methods.map$1$1(C.List_wSV, new W._TemplatingNodeValidator_closure(), t1);
          t4 = H.setRuntimeTypeInfo(["TEMPLATE"], [t1]);
          t1 = new W._TemplatingNodeValidator(t2, P.LinkedHashSet_LinkedHashSet(null, null, null, t1), P.LinkedHashSet_LinkedHashSet(null, null, null, t1), P.LinkedHashSet_LinkedHashSet(null, null, null, t1), null, []);
          t1._SimpleNodeValidator$4$allowedAttributes$allowedElements$allowedUriAttributes(null, t3, t4, null);
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    _TemplatingNodeValidator_closure: {
      "^": "Closure:7;$ti",
      call$1: [function(attr) {
        return "TEMPLATE::" + H.S(H.stringTypeCheck(attr));
      }, null, null, 4, 0, null, 1041, "call"]
    },
    _SvgNodeValidator: {
      "^": "Object;$ti",
      allowsElement$1: [function(element) {
        var t1;
        H.interceptedTypeCheck(element, "$isElement");
        t1 = J.getInterceptor$(element);
        if (!!t1.$isScriptElement)
          return false;
        t1 = !!t1.$isSvgElement;
        if (t1 && J.$eq$(W.Element__safeTagName(element), "foreignObject"))
          return false;
        if (t1)
          return true;
        return false;
      }, null, "get$allowsElement", 4, 0, null, 10],
      allowsAttribute$3: [function(element, attributeName, value) {
        H.interceptedTypeCheck(element, "$isElement");
        H.stringTypeCheck(attributeName);
        H.stringTypeCheck(value);
        if (attributeName === "is" || J.startsWith$1$s(attributeName, "on"))
          return false;
        return this.allowsElement$1(element);
      }, null, "get$allowsAttribute", 12, 0, null, 10, 144, 1],
      $isNodeValidator: 1,
      static: {
        _SvgNodeValidator$: [function() {
          return new W._SvgNodeValidator([]);
        }, null, null, 0, 0, null]
      }
    },
    ReadyState: {
      "^": "Object;$ti"
    },
    _WrappedList: {
      "^": "ListBase;$ti",
      $isNodeListWrapper: 1
    },
    _WrappedIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    _HttpRequestUtils: {
      "^": "Object;$ti"
    },
    FixedSizeListIterator: {
      "^": "Object;_array,_html$_length,_position,0_html$_current,$ti",
      set$_html$_current: function(_current) {
        this._html$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
      },
      moveNext$0: [function() {
        var nextPosition, t1;
        nextPosition = J.$add$ansx(this._position, 1);
        t1 = this._html$_length;
        if (typeof nextPosition !== "number")
          return nextPosition.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (nextPosition < t1) {
          this.set$_html$_current(J.$index$asx(this._array, nextPosition));
          this._position = nextPosition;
          return true;
        }
        this.set$_html$_current(null);
        this._position = H.intTypeCheck(t1);
        return false;
      }, null, "get$moveNext", 0, 0, null],
      get$current: [function() {
        return this._html$_current;
      }, null, null, 2, 0, null],
      $isIterator: 1,
      static: {
        FixedSizeListIterator$: [function(array, $T) {
          return new W.FixedSizeListIterator(array, J.get$length$asx(array), -1, [$T]);
        }, null, null, 4, 0, null, 252]
      }
    },
    _VariableSizeListIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    },
    Console: {
      "^": "Object;$ti",
      get$_isConsoleDefined: [function() {
        return typeof console != "undefined";
      }, null, null, 2, 0, null],
      error$1: [function(_, arg) {
        return this.get$_isConsoleDefined() ? window.console.error(arg) : null;
      }, "call$1", "get$error", 5, 0, 2, 44],
      warn$1: [function(arg) {
        return this.get$_isConsoleDefined() ? window.console.warn(arg) : null;
      }, null, "get$warn", 4, 0, null, 44]
    },
    _JSElementUpgrader: {
      "^": "Object;$ti",
      $isElementUpgrader: 1
    },
    _DOMWindowCrossFrame: {
      "^": "Object;_window,$ti",
      get$top: [function(_) {
        return W._DOMWindowCrossFrame__createSafe(this._window.top);
      }, null, null, 3, 0, null],
      addEventListener$3: [function(_, type, listener, useCapture) {
        H.stringTypeCheck(type);
        H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
        H.boolTypeCheck(useCapture);
        return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
      }, null, "get$addEventListener", 9, 2, null, 0, 29, 133, 143],
      removeEventListener$3: [function(_, type, listener, useCapture) {
        H.stringTypeCheck(type);
        H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
        H.boolTypeCheck(useCapture);
        return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
      }, null, "get$removeEventListener", 9, 2, null, 0, 29, 133, 143],
      $isInterceptor: 1,
      $isEventTarget: 1,
      $isWindowBase: 1,
      static: {
        _DOMWindowCrossFrame$: [function(_window) {
          return new W._DOMWindowCrossFrame(_window, []);
        }, null, null, 4, 0, null, 901],
        _DOMWindowCrossFrame__createSafe: [function(w) {
          var t1 = W.window();
          if (w == null ? t1 == null : w === t1)
            return H.interceptedTypeCheck(w, "$isWindowBase");
          else {
            H.registerGlobalObject(w);
            return W._DOMWindowCrossFrame$(w);
          }
        }, null, null, 4, 0, null, 902]
      }
    },
    _LocationCrossFrame: {
      "^": "Object;$ti",
      $isLocationBase: 1
    },
    _HistoryCrossFrame: {
      "^": "Object;$ti",
      $isHistoryBase: 1
    },
    KeyEvent: {
      "^": "_WrappedEvent;$ti",
      $isKeyboardEvent: 1,
      $isUIEvent: 1
    },
    Platform: {
      "^": "Object;$ti"
    },
    _WrappedEvent: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isEvent: 1
    },
    ElementUpgrader: {
      "^": "Object;$ti"
    },
    NodeValidator: {
      "^": "Object;$ti"
    },
    NodeTreeSanitizer: {
      "^": "Object;$ti"
    },
    _TrustedHtmlTreeSanitizer: {
      "^": "Object;$ti",
      $isNodeTreeSanitizer: 1
    },
    UriPolicy: {
      "^": "Object;$ti"
    },
    _SameOriginUriPolicy: {
      "^": "Object;_hiddenAnchor,_loc,$ti",
      allowsUri$1: [function(uri) {
        var t1, t2, t3, t4;
        t1 = this._hiddenAnchor;
        t2 = J.getInterceptor$x(t1);
        t2.set$href(t1, H.stringTypeCheck(uri));
        t3 = this._loc;
        t4 = J.getInterceptor$x(t3);
        if (!(J.$eq$(t2.get$hostname(t1), t4.get$hostname(t3)) && J.$eq$(t2.get$port(t1), t4.get$port(t3)) && J.$eq$(t2.get$protocol(t1), t4.get$protocol(t3))))
          if (J.$eq$(t2.get$hostname(t1), ""))
            if (J.$eq$(t2.get$port(t1), ""))
              t1 = J.$eq$(t2.get$protocol(t1), ":") || J.$eq$(t2.get$protocol(t1), "");
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = true;
        return t1;
      }, null, "get$allowsUri", 4, 0, null, 65],
      $isUriPolicy: 1,
      static: {
        _SameOriginUriPolicy$: [function() {
          return new W._SameOriginUriPolicy(W.AnchorElement_AnchorElement(null), J.get$location$x(W.window()), []);
        }, null, null, 0, 0, null]
      }
    },
    _ThrowsNodeValidator: {
      "^": "Object;$ti",
      $isNodeValidator: 1
    },
    _ValidatingTreeSanitizer: {
      "^": "Object;validator,$ti",
      set$validator: function(validator) {
        this.validator = H.interceptedTypeCheck(validator, "$isNodeValidator");
      },
      sanitizeTree$1: [function(node) {
        new W._ValidatingTreeSanitizer_sanitizeTree_walk(this).call$2(H.interceptedTypeCheck(node, "$isNode"), null);
      }, null, "get$sanitizeTree", 4, 0, null, 23],
      _removeNode$2: [function(node, $parent) {
        H.interceptedTypeCheck(node, "$isNode");
        H.interceptedTypeCheck($parent, "$isNode");
        if ($parent == null)
          J.remove$0$ax(node);
        else
          J._removeChild$1$x($parent, node);
      }, null, "get$_removeNode", 8, 0, null, 23, 24],
      _sanitizeUntrustedElement$2: [function(element, $parent) {
        var corrupted, attrs, isAttr, corruptedTest1, elementText, elementTagName, exception;
        H.interceptedTypeCheck($parent, "$isNode");
        corrupted = true;
        attrs = null;
        isAttr = null;
        try {
          attrs = J.get$attributes$x(element);
          isAttr = J.$index$asx(attrs, "is");
          H.interceptedTypeCheck(element, "$isElement");
          corruptedTest1 = W.Element__hasCorruptedAttributes(element);
          corrupted = corruptedTest1 ? true : W.Element__hasCorruptedAttributesAdditionalCheck(element);
        } catch (exception) {
          H.unwrapException(exception);
        }
        elementText = "element unprintable";
        try {
          elementText = J.toString$0$(element);
        } catch (exception) {
          H.unwrapException(exception);
        }
        try {
          elementTagName = W.Element__safeTagName(element);
          this._sanitizeElement$7(H.interceptedTypeCheck(element, "$isElement"), $parent, corrupted, elementText, elementTagName, H.interceptedTypeCheck(attrs, "$isMap"), H.stringTypeCheck(isAttr));
        } catch (exception) {
          if (H.unwrapException(exception) instanceof P.ArgumentError)
            throw exception;
          else {
            this._removeNode$2(H.interceptedTypeCheck(element, "$isNode"), $parent);
            J.get$console$x(W.window()).warn$1("Removing corrupted element " + H.S(elementText));
          }
        }
      }, null, "get$_sanitizeUntrustedElement", 8, 0, null, 10, 24],
      _sanitizeElement$7: [function(element, $parent, corrupted, text, tag, attrs, isAttr) {
        var keys, i, t1, $name;
        H.interceptedTypeCheck(element, "$isElement");
        H.interceptedTypeCheck($parent, "$isNode");
        H.boolTypeCheck(corrupted);
        H.stringTypeCheck(text);
        H.stringTypeCheck(tag);
        H.interceptedTypeCheck(attrs, "$isMap");
        H.stringTypeCheck(isAttr);
        if (false !== corrupted) {
          this._removeNode$2(element, $parent);
          J.get$console$x(W.window()).warn$1("Removing element due to corrupted attributes on <" + H.S(text) + ">");
          return;
        }
        if (!this.validator.allowsElement$1(element)) {
          this._removeNode$2(element, $parent);
          J.get$console$x(W.window()).warn$1("Removing disallowed element <" + H.S(tag) + "> from " + H.S($parent));
          return;
        }
        if (isAttr != null)
          if (!this.validator.allowsAttribute$3(element, "is", isAttr)) {
            this._removeNode$2(element, $parent);
            J.get$console$x(W.window()).warn$1("Removing disallowed type extension <" + H.S(tag) + ' is="' + isAttr + '">');
            return;
          }
        keys = J.toList$0$ax(attrs.get$keys());
        i = J.$sub$n(attrs.get$length(attrs), 1);
        t1 = J.getInterceptor$asx(keys);
        while (true) {
          if (typeof i !== "number")
            return i.$ge();
          if (!(i >= 0))
            break;
          $name = t1.$index(keys, i);
          if (!this.validator.allowsAttribute$3(element, H.stringTypeCheck(J.toLowerCase$0$s($name)), H.stringTypeCheck(attrs.$index(0, $name)))) {
            J.get$console$x(W.window()).warn$1("Removing disallowed attribute <" + H.S(tag) + " " + H.S($name) + '="' + H.S(attrs.$index(0, $name)) + '">');
            attrs.remove$1(0, $name);
          }
          --i;
        }
        if (!!J.getInterceptor$(element).$isTemplateElement)
          this.sanitizeTree$1(element.content);
      }, null, "get$_sanitizeElement", 28, 0, null, 10, 24, 1042, 17, 109, 1044, 551],
      sanitizeNode$2: [function(node, $parent) {
        H.interceptedTypeCheck(node, "$isNode");
        H.interceptedTypeCheck($parent, "$isNode");
        switch (node.nodeType) {
          case 1:
            this._sanitizeUntrustedElement$2(node, $parent);
            break;
          case 8:
          case 11:
          case 3:
          case 4:
            break;
          default:
            this._removeNode$2(node, $parent);
        }
      }, null, "get$sanitizeNode", 8, 0, null, 23, 24],
      $isNodeTreeSanitizer: 1,
      static: {
        _ValidatingTreeSanitizer$: [function(validator) {
          return new W._ValidatingTreeSanitizer(validator, []);
        }, null, null, 4, 0, null, 97]
      }
    },
    _ValidatingTreeSanitizer_sanitizeTree_walk: {
      "^": "Closure:128;$this,$ti",
      call$2: [function(node, $parent) {
        var child, nextChild, t1, exception;
        H.interceptedTypeCheck(node, "$isNode");
        t1 = this.$this;
        t1.sanitizeNode$2(node, H.interceptedTypeCheck($parent, "$isNode"));
        child = J.get$lastChild$x(node);
        for (; null != child;) {
          nextChild = null;
          try {
            nextChild = J.get$previousNode$x(child);
          } catch (exception) {
            H.unwrapException(exception);
            t1._removeNode$2(child, node);
            child = null;
            nextChild = J.get$lastChild$x(node);
          }
          if (child != null)
            this.call$2(child, node);
          child = H.interceptedTypeCheck(nextChild, "$isNode");
        }
      }, null, null, 8, 0, null, 23, 24, "call"]
    },
    _CssStyleDeclaration_Interceptor_CssStyleDeclarationBase: {
      "^": "Interceptor+CssStyleDeclarationBase;$ti",
      $isCssStyleDeclarationBase: 1
    },
    _DomRectList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [[P.Rectangle, P.num]];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isList: 1,
      $asList: function() {
        return [[P.Rectangle, P.num]];
      }
    },
    _DomRectList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_DomRectList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [[P.Rectangle, P.num]];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [[P.Rectangle, P.num]];
      },
      $isList: 1,
      $asList: function() {
        return [[P.Rectangle, P.num]];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [[P.Rectangle, P.num]];
      }
    },
    _DomStringList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.String];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      }
    },
    _DomStringList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_DomStringList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.String];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.String];
      }
    },
    _FileList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.File];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.File];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.File];
      },
      $isList: 1,
      $asList: function() {
        return [W.File];
      }
    },
    _FileList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_FileList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.File];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.File];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.File];
      },
      $isList: 1,
      $asList: function() {
        return [W.File];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.File];
      }
    },
    _HtmlCollection_Interceptor_ListMixin: {
      "^": "Interceptor+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      }
    },
    _HtmlCollection_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_HtmlCollection_Interceptor_ListMixin+ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Node];
      }
    },
    _MidiInputMap_Interceptor_MapMixin: {
      "^": "Interceptor;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      }
    },
    _MidiOutputMap_Interceptor_MapMixin: {
      "^": "Interceptor;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      }
    },
    _MimeTypeArray_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.MimeType];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.MimeType];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.MimeType];
      },
      $isList: 1,
      $asList: function() {
        return [W.MimeType];
      }
    },
    _MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_MimeTypeArray_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.MimeType];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.MimeType];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.MimeType];
      },
      $isList: 1,
      $asList: function() {
        return [W.MimeType];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.MimeType];
      }
    },
    _NodeList_Interceptor_ListMixin: {
      "^": "Interceptor+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      }
    },
    _NodeList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_NodeList_Interceptor_ListMixin+ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Node];
      }
    },
    _PluginArray_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Plugin];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Plugin];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Plugin];
      },
      $isList: 1,
      $asList: function() {
        return [W.Plugin];
      }
    },
    _PluginArray_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_PluginArray_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Plugin];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Plugin];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Plugin];
      },
      $isList: 1,
      $asList: function() {
        return [W.Plugin];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Plugin];
      }
    },
    _RtcStatsReport_Interceptor_MapMixin: {
      "^": "Interceptor;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      }
    },
    _SourceBufferList_EventTarget_ListMixin: {
      "^": "EventTarget;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SourceBuffer];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SourceBuffer];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SourceBuffer];
      },
      $isList: 1,
      $asList: function() {
        return [W.SourceBuffer];
      }
    },
    _SourceBufferList_EventTarget_ListMixin_ImmutableListMixin: {
      "^": "_SourceBufferList_EventTarget_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SourceBuffer];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SourceBuffer];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SourceBuffer];
      },
      $isList: 1,
      $asList: function() {
        return [W.SourceBuffer];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.SourceBuffer];
      }
    },
    _SpeechGrammarList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechGrammar];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SpeechGrammar];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SpeechGrammar];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechGrammar];
      }
    },
    _SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_SpeechGrammarList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechGrammar];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SpeechGrammar];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SpeechGrammar];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechGrammar];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.SpeechGrammar];
      }
    },
    _Storage_Interceptor_MapMixin: {
      "^": "Interceptor;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, P.String];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, P.String];
      }
    },
    _TextTrackCueList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrackCue];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.TextTrackCue];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.TextTrackCue];
      },
      $isList: 1,
      $asList: function() {
        return [W.TextTrackCue];
      }
    },
    _TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_TextTrackCueList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrackCue];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.TextTrackCue];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.TextTrackCue];
      },
      $isList: 1,
      $asList: function() {
        return [W.TextTrackCue];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.TextTrackCue];
      }
    },
    _TextTrackList_EventTarget_ListMixin: {
      "^": "EventTarget;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrack];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.TextTrack];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.TextTrack];
      },
      $isList: 1,
      $asList: function() {
        return [W.TextTrack];
      }
    },
    _TextTrackList_EventTarget_ListMixin_ImmutableListMixin: {
      "^": "_TextTrackList_EventTarget_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.TextTrack];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.TextTrack];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.TextTrack];
      },
      $isList: 1,
      $asList: function() {
        return [W.TextTrack];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.TextTrack];
      }
    },
    _TouchList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Touch];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Touch];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Touch];
      },
      $isList: 1,
      $asList: function() {
        return [W.Touch];
      }
    },
    _TouchList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_TouchList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Touch];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Touch];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Touch];
      },
      $isList: 1,
      $asList: function() {
        return [W.Touch];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Touch];
      }
    },
    __CssRuleList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.CssRule];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.CssRule];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.CssRule];
      },
      $isList: 1,
      $asList: function() {
        return [W.CssRule];
      }
    },
    __CssRuleList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "__CssRuleList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.CssRule];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.CssRule];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.CssRule];
      },
      $isList: 1,
      $asList: function() {
        return [W.CssRule];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.CssRule];
      }
    },
    __CssStyleDeclarationSet_Object_CssStyleDeclarationBase: {
      "^": "Object;$ti",
      $isCssStyleDeclarationBase: 1
    },
    __GamepadList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Gamepad];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Gamepad];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Gamepad];
      },
      $isList: 1,
      $asList: function() {
        return [W.Gamepad];
      }
    },
    __GamepadList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "__GamepadList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Gamepad];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Gamepad];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Gamepad];
      },
      $isList: 1,
      $asList: function() {
        return [W.Gamepad];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Gamepad];
      }
    },
    __NamedNodeMap_Interceptor_ListMixin: {
      "^": "Interceptor+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      }
    },
    __NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "__NamedNodeMap_Interceptor_ListMixin+ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.Node];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.Node];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.Node];
      },
      $isList: 1,
      $asList: function() {
        return [W.Node];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.Node];
      }
    },
    __SpeechRecognitionResultList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SpeechRecognitionResult];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechRecognitionResult];
      }
    },
    __SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "__SpeechRecognitionResultList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.SpeechRecognitionResult];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.SpeechRecognitionResult];
      },
      $isList: 1,
      $asList: function() {
        return [W.SpeechRecognitionResult];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.SpeechRecognitionResult];
      }
    },
    __StyleSheetList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.StyleSheet];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.StyleSheet];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.StyleSheet];
      },
      $isList: 1,
      $asList: function() {
        return [W.StyleSheet];
      }
    },
    __StyleSheetList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "__StyleSheetList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [W.StyleSheet];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [W.StyleSheet];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [W.StyleSheet];
      },
      $isList: 1,
      $asList: function() {
        return [W.StyleSheet];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [W.StyleSheet];
      }
    }
  }], ["html_common", "dart:html_common",, P, {
    "^": "",
    convertDartToNative_SerializedScriptValue: [function(value) {
      return P.convertDartToNative_PrepareForStructuredClone(value);
    }, null, null, 4, 0, null, 1],
    convertNativeToDart_SerializedScriptValue: [function(object) {
      return P.convertNativeToDart_AcceptStructuredClone(object, true);
    }, null, null, 4, 0, null, 9],
    convertDartToNative_Dictionary: [function(dict, postCreate) {
      var object;
      H.interceptedTypeCheck(dict, "$isMap");
      H.functionTypeCheck(postCreate, {func: 1, ret: -1, args: [P.Object]});
      if (dict == null)
        return;
      object = {};
      if (postCreate != null)
        postCreate.call$1(object);
      dict.forEach$1(0, new P.convertDartToNative_Dictionary_closure(object));
      return object;
    }, null, null, 4, 2, null, 0, 552, 553],
    convertNativeToDart_DateTime: [function(date) {
      return P.DateTime$fromMillisecondsSinceEpoch(date.getTime(), true);
    }, null, null, 4, 0, null, 40],
    convertDartToNative_DateTime: [function(date) {
      return new Date(H.interceptedTypeCheck(date, "$isDateTime").get$millisecondsSinceEpoch());
    }, null, null, 4, 0, null, 40],
    convertDartToNative_PrepareForStructuredClone: [function(value) {
      return P._StructuredCloneDart2Js$().convertDartToNative_PrepareForStructuredClone$1(value);
    }, null, null, 4, 0, null, 1],
    convertNativeToDart_AcceptStructuredClone: [function(object, mustCopy) {
      return P._AcceptStructuredCloneDart2Js$().convertNativeToDart_AcceptStructuredClone$2$mustCopy(object, mustCopy);
    }, null, null, 4, 3, null, 18, 9, 400],
    isJavaScriptDate: [function(value) {
      return value instanceof Date;
    }, null, null, 4, 0, null, 1],
    isJavaScriptRegExp: [function(value) {
      return value instanceof RegExp;
    }, null, null, 4, 0, null, 1],
    isJavaScriptArray: [function(value) {
      return value instanceof Array;
    }, null, null, 4, 0, null, 1],
    isJavaScriptSimpleObject: [function(value) {
      var proto = Object.getPrototypeOf(value);
      return proto === Object.prototype || proto === null;
    }, null, null, 4, 0, null, 1],
    isJavaScriptPromise: [function(value) {
      return typeof Promise != "undefined" && value instanceof Promise;
    }, null, null, 4, 0, null, 1],
    convertNativePromiseToDartFuture: [function(promise) {
      var completer = P.Completer_Completer(null);
      promise.then(H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure(completer), 1))["catch"](H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure0(completer), 1));
      return completer.get$future();
    }, null, null, 4, 0, null, 556],
    Device_userAgent: [function() {
      return J.get$userAgent$x(J.get$navigator$x(W.window()));
    }, null, null, 2, 0, null],
    Device_isOpera: [function() {
      var t1 = $.Device__isOpera;
      if (t1 == null) {
        t1 = J.contains$2$asx(P.Device_userAgent(), "Opera", 0);
        $.Device__isOpera = t1;
      }
      return t1;
    }, null, null, 2, 0, null],
    Device_isIE: [function() {
      var t1 = $.Device__isIE;
      if (t1 == null) {
        t1 = !P.Device_isOpera() && J.contains$2$asx(P.Device_userAgent(), "Trident/", 0);
        $.Device__isIE = t1;
      }
      return t1;
    }, null, null, 2, 0, null],
    Device_isFirefox: [function() {
      var t1 = $.Device__isFirefox;
      if (t1 == null) {
        t1 = J.contains$2$asx(P.Device_userAgent(), "Firefox", 0);
        $.Device__isFirefox = t1;
      }
      return t1;
    }, null, null, 2, 0, null],
    Device_isWebKit: [function() {
      var t1 = $.Device__isWebKit;
      if (t1 == null) {
        t1 = !P.Device_isOpera() && J.contains$2$asx(P.Device_userAgent(), "WebKit", 0);
        $.Device__isWebKit = t1;
      }
      return t1;
    }, null, null, 2, 0, null],
    Device_cssPrefix: [function() {
      var prefix = $.Device__cachedCssPrefix;
      if (prefix != null)
        return prefix;
      if (P.Device_isFirefox())
        prefix = "-moz-";
      else if (P.Device_isIE())
        prefix = "-ms-";
      else
        prefix = P.Device_isOpera() ? "-o-" : "-webkit-";
      $.Device__cachedCssPrefix = prefix;
      return prefix;
    }, null, null, 2, 0, null],
    _StructuredClone: {
      "^": "Object;values>,$ti",
      findSlot$1: [function(value) {
        var t1, t2, $length, i, t3;
        t1 = this.values;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          t3 = t2.$index(t1, i);
          if (t3 == null ? value == null : t3 === value)
            return i;
        }
        t2.add$1(t1, value);
        J.add$1$ax(this.copies, null);
        return $length;
      }, null, "get$findSlot", 4, 0, null, 1],
      readSlot$1: [function(i) {
        return J.$index$asx(this.copies, H.intTypeCheck(i));
      }, null, "get$readSlot", 4, 0, null, 198],
      writeSlot$2: [function(i, x) {
        J.$indexSet$ax(this.copies, H.intTypeCheck(i), x);
      }, null, "get$writeSlot", 8, 0, null, 198, 37],
      cleanupSlots$0: [function() {
      }, null, "get$cleanupSlots", 0, 0, null],
      walk$1: [function(e) {
        var t1, t2, slot, copy;
        t1 = {};
        if (e == null)
          return e;
        if (typeof e === "boolean")
          return e;
        if (typeof e === "number")
          return e;
        if (typeof e === "string")
          return e;
        t2 = J.getInterceptor$(e);
        if (!!t2.$isDateTime)
          return P.convertDartToNative_DateTime(e);
        if (!!t2.$isRegExp)
          throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
        if (!!t2.$isFile)
          return e;
        if (!!t2.$isBlob)
          return e;
        if (!!t2.$isImageData)
          return e;
        if (this.cloneNotRequired$1(e))
          return e;
        if (!!t2.$isMap) {
          slot = this.findSlot$1(e);
          copy = this.readSlot$1(slot);
          t1.copy = copy;
          if (copy != null)
            return copy;
          copy = this.newJsMap$0();
          t1.copy = copy;
          this.writeSlot$2(slot, copy);
          e.forEach$1(0, new P._StructuredClone_walk_closure(t1, this));
          return t1.copy;
        }
        if (!!t2.$isList) {
          slot = this.findSlot$1(e);
          copy = this.readSlot$1(slot);
          if (copy != null)
            return copy;
          return this.copyList$2(e, slot);
        }
        throw H.wrapException(P.UnimplementedError$("structured clone of other type"));
      }, null, "get$walk", 4, 0, null, 19],
      copyList$2: [function(e, slot) {
        var t1, $length, copy, t2, i;
        H.listTypeCheck(e);
        H.intTypeCheck(slot);
        t1 = J.getInterceptor$asx(e);
        $length = t1.get$length(e);
        copy = this.newJsList$1($length);
        this.writeSlot$2(slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = J.getInterceptor$ax(copy);
        i = 0;
        for (; i < $length; ++i)
          t2.$indexSet(copy, i, this.walk$1(t1.$index(e, i)));
        return copy;
      }, null, "get$copyList", 8, 0, null, 19, 557],
      convertDartToNative_PrepareForStructuredClone$1: [function(value) {
        var copy = this.walk$1(value);
        this.cleanupSlots$0();
        return copy;
      }, null, "get$convertDartToNative_PrepareForStructuredClone", 4, 0, null, 1]
    },
    _StructuredClone_walk_closure: {
      "^": "Closure:9;_box_0,$this,$ti",
      call$2: [function(key, value) {
        var t1 = this.$this;
        t1.putIntoMap$3(this._box_0.copy, key, t1.walk$1(value));
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    _AcceptStructuredClone: {
      "^": "Object;values>,$ti",
      findSlot$1: [function(value) {
        var t1, t2, $length, i;
        t1 = this.values;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i)
          if (this.identicalInJs$2(t2.$index(t1, i), value))
            return i;
        t2.add$1(t1, value);
        J.add$1$ax(this.copies, null);
        return $length;
      }, null, "get$findSlot", 4, 0, null, 1],
      readSlot$1: [function(i) {
        return J.$index$asx(this.copies, H.intTypeCheck(i));
      }, null, "get$readSlot", 4, 0, null, 198],
      writeSlot$2: [function(i, x) {
        J.$indexSet$ax(this.copies, H.intTypeCheck(i), x);
      }, null, "get$writeSlot", 8, 0, null, 198, 37],
      walk$1: [function(e) {
        var _box_0, slot, copy, l, t1, $length, t2, i;
        _box_0 = {};
        if (e == null)
          return e;
        if (typeof e === "boolean")
          return e;
        if (typeof e === "number")
          return e;
        if (typeof e === "string")
          return e;
        if (P.isJavaScriptDate(e))
          return P.convertNativeToDart_DateTime(e);
        if (P.isJavaScriptRegExp(e))
          throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
        if (P.isJavaScriptPromise(e))
          return P.convertNativePromiseToDartFuture(e);
        if (P.isJavaScriptSimpleObject(e)) {
          slot = this.findSlot$1(e);
          copy = this.readSlot$1(slot);
          _box_0.copy = copy;
          if (copy != null)
            return copy;
          copy = P.LinkedHashMap__makeEmpty();
          _box_0.copy = copy;
          this.writeSlot$2(slot, copy);
          this.forEachJsField$2(e, new P._AcceptStructuredClone_walk_closure(_box_0, this));
          return _box_0.copy;
        }
        if (P.isJavaScriptArray(e)) {
          l = e;
          slot = this.findSlot$1(l);
          copy = this.readSlot$1(slot);
          if (copy != null)
            return copy;
          t1 = J.getInterceptor$asx(l);
          $length = H.intTypeCheck(t1.get$length(l));
          copy = this.mustCopy ? this.newDartList$1($length) : l;
          this.writeSlot$2(slot, copy);
          if (typeof $length !== "number")
            return H.iae($length);
          t2 = J.getInterceptor$ax(copy);
          i = 0;
          for (; i < $length; ++i)
            t2.$indexSet(copy, i, this.walk$1(t1.$index(l, i)));
          return copy;
        }
        return e;
      }, null, "get$walk", 4, 0, null, 19],
      convertNativeToDart_AcceptStructuredClone$2$mustCopy: [function(object, mustCopy) {
        this.mustCopy = H.boolTypeCheck(mustCopy);
        return this.walk$1(object);
      }, null, "get$convertNativeToDart_AcceptStructuredClone", 4, 3, null, 18, 9, 400]
    },
    _AcceptStructuredClone_walk_closure: {
      "^": "Closure:67;_box_0,$this,$ti",
      call$2: [function(key, value) {
        var t1, t2;
        t1 = this._box_0.copy;
        t2 = this.$this.walk$1(value);
        J.$indexSet$ax(t1, key, t2);
        return t2;
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    ContextAttributes: {
      "^": "Object;$ti"
    },
    _TypedImageData: {
      "^": "Object;$ti",
      $isInterceptor: 1,
      $isImageData: 1
    },
    convertDartToNative_Dictionary_closure: {
      "^": "Closure:9;object,$ti",
      call$2: [function(key, value) {
        this.object[key] = value;
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    _StructuredCloneDart2Js: {
      "^": "_StructuredClone;values,copies,$ti",
      newJsMap$0: [function() {
        return {};
      }, null, "get$newJsMap", 0, 0, null],
      putIntoMap$3: [function(map, key, value) {
        return map[key] = value;
      }, null, "get$putIntoMap", 12, 0, null, 111, 4, 1],
      newJsList$1: [function($length) {
        return new Array($length);
      }, null, "get$newJsList", 4, 0, null, 35],
      cloneNotRequired$1: [function(e) {
        var t1 = J.getInterceptor$(e);
        return !!t1.$isNativeByteBuffer || !!t1.$isNativeTypedData;
      }, null, "get$cloneNotRequired", 4, 0, null, 19],
      static: {
        _StructuredCloneDart2Js$: [function() {
          return new P._StructuredCloneDart2Js([], [], []);
        }, null, null, 0, 0, null]
      }
    },
    _AcceptStructuredCloneDart2Js: {
      "^": "_AcceptStructuredClone;values,copies,mustCopy,$ti",
      newJsList$1: [function($length) {
        return new Array($length);
      }, null, "get$newJsList", 4, 0, null, 35],
      newDartList$1: [function($length) {
        return this.newJsList$1($length);
      }, null, "get$newDartList", 4, 0, null, 35],
      identicalInJs$2: [function(a, b) {
        return a == null ? b == null : a === b;
      }, null, "get$identicalInJs", 8, 0, null, 33, 54],
      forEachJsField$2: [function(object, action) {
        var t1, key;
        H.functionTypeCheck(action, {func: 1, args: [,,]});
        for (t1 = C.JSArray_methods.get$iterator(Object.keys(object)); t1.moveNext$0();) {
          key = t1.get$current();
          action.call$2(key, object[key]);
        }
      }, null, "get$forEachJsField", 8, 0, null, 9, 63],
      static: {
        _AcceptStructuredCloneDart2Js$: [function() {
          return new P._AcceptStructuredCloneDart2Js([], [], false, []);
        }, null, null, 0, 0, null]
      }
    },
    convertNativePromiseToDartFuture_closure: {
      "^": "Closure:6;completer,$ti",
      call$1: [function(result) {
        return J.complete$1$z(this.completer, result);
      }, null, null, 4, 0, null, 59, "call"]
    },
    convertNativePromiseToDartFuture_closure0: {
      "^": "Closure:6;completer,$ti",
      call$1: [function(result) {
        return this.completer.completeError$1(result);
      }, null, null, 4, 0, null, 59, "call"]
    },
    CssClassSetImpl: {
      "^": "SetBase;$ti",
      _validateToken$1: [function(value) {
        H.stringTypeCheck(value);
        if ($.$get$CssClassSetImpl__validTokenRE().hasMatch$1(value))
          return value;
        throw H.wrapException(P.ArgumentError$value(value, "value", "Not a valid class token"));
      }, "call$1", "get$_validateToken", 4, 0, 7, 1],
      toString$0: [function(_) {
        return J.join$1$ax(this.readClasses$0(), " ");
      }, null, "get$toString", 1, 0, null],
      toggle$2: [function(_, value, shouldAdd) {
        var s, result;
        H.stringTypeCheck(value);
        H.boolTypeCheck(shouldAdd);
        this._validateToken$1(value);
        s = this.readClasses$0();
        if (shouldAdd == null ? !s.contains$1(0, value) : shouldAdd) {
          s.add$1(0, value);
          result = true;
        } else {
          s.remove$1(0, value);
          result = false;
        }
        this.writeClasses$1(s);
        return result;
      }, null, "get$toggle", 5, 2, null, 0, 1, 231],
      get$iterator: [function(_) {
        return J.get$iterator$ax(this.readClasses$0());
      }, null, null, 3, 0, null],
      forEach$1: [function(_, f) {
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String]});
        J.forEach$1$ax(this.readClasses$0(), f);
      }, null, "get$forEach", 5, 0, null, 15],
      join$1: [function(_, separator) {
        H.stringTypeCheck(separator);
        return J.join$1$ax(this.readClasses$0(), separator);
      }, null, "get$join", 1, 2, null, 39, 90],
      map$1$1: [1, function(_, f, $T) {
        H.functionTypeCheck(f, {func: 1, ret: $T, args: [P.String]});
        return J.map$1$1$ax(this.readClasses$0(), f, $T);
      }, function($receiver, f) {
        return this.map$1$1($receiver, f, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 15],
      where$1: [function(_, f) {
        H.functionTypeCheck(f, {func: 1, ret: P.bool, args: [P.String]});
        return J.where$1$ax(this.readClasses$0(), f);
      }, null, "get$where", 5, 0, null, 15],
      any$1: [function(_, f) {
        H.functionTypeCheck(f, {func: 1, ret: P.bool, args: [P.String]});
        return J.any$1$ax(this.readClasses$0(), f);
      }, null, "get$any", 5, 0, null, 15],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this.readClasses$0());
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this.readClasses$0());
      }, null, null, 3, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this.readClasses$0());
      }, null, null, 3, 0, null],
      contains$1: [function(_, value) {
        if (typeof value !== "string")
          return false;
        this._validateToken$1(value);
        return J.contains$1$asx(this.readClasses$0(), value);
      }, null, "get$contains", 5, 0, null, 1],
      add$1: [function(_, value) {
        H.stringTypeCheck(value);
        this._validateToken$1(value);
        return H.boolTypeCheck(this.modify$1(new P.CssClassSetImpl_add_closure(value)));
      }, "call$1", "get$add", 5, 0, 18, 1],
      remove$1: [function(_, value) {
        var s, result;
        H.stringTypeCheck(value);
        this._validateToken$1(value);
        if (typeof value !== "string")
          return false;
        s = this.readClasses$0();
        result = s.remove$1(0, value);
        this.writeClasses$1(s);
        return result;
      }, null, "get$remove", 5, 0, null, 1],
      addAll$1: [function(_, iterable) {
        this.modify$1(new P.CssClassSetImpl_addAll_closure(this, H.assertSubtype(iterable, "$isIterable", [P.String], "$asIterable")));
      }, null, "get$addAll", 5, 0, null, 13],
      removeAll$1: [function(iterable) {
        this.modify$1(new P.CssClassSetImpl_removeAll_closure(H.assertSubtype(iterable, "$isIterable", [P.Object], "$asIterable")));
      }, null, "get$removeAll", 4, 0, null, 13],
      get$first: [function(_) {
        return J.get$first$ax(this.readClasses$0());
      }, null, null, 3, 0, null],
      get$last: [function(_) {
        return J.get$last$ax(this.readClasses$0());
      }, null, null, 3, 0, null],
      get$single: [function(_) {
        return J.get$single$ax(this.readClasses$0());
      }, null, null, 3, 0, null],
      toList$1$growable: [function(_, growable) {
        H.boolTypeCheck(growable);
        return J.toList$1$growable$ax(this.readClasses$0(), growable);
      }, function($receiver) {
        return this.toList$1$growable($receiver, true);
      }, "toList$0", null, null, "get$toList", 1, 3, null, 27, 95],
      take$1: [function(_, n) {
        H.intTypeCheck(n);
        return J.take$1$ax(this.readClasses$0(), n);
      }, null, "get$take", 5, 0, null, 72],
      skip$1: [function(_, n) {
        H.intTypeCheck(n);
        return J.skip$1$ax(this.readClasses$0(), n);
      }, null, "get$skip", 5, 0, null, 72],
      lastWhere$2$orElse: [function(_, test, orElse) {
        H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [P.String]});
        H.functionTypeCheck(orElse, {func: 1, ret: P.String});
        return J.lastWhere$2$orElse$ax(this.readClasses$0(), test, orElse);
      }, null, "get$lastWhere", 5, 3, null, 0, 41, 98],
      elementAt$1: [function(_, index) {
        H.intTypeCheck(index);
        return J.elementAt$1$ax(this.readClasses$0(), index);
      }, null, "get$elementAt", 5, 0, null, 6],
      clear$0: [function(_) {
        this.modify$1(new P.CssClassSetImpl_clear_closure());
      }, null, "get$clear", 1, 0, null],
      modify$1: [function(f) {
        var s, ret;
        H.functionTypeCheck(f, {func: 1, args: [[P.Set, P.String]]});
        s = this.readClasses$0();
        ret = f.call$1(s);
        this.writeClasses$1(s);
        return ret;
      }, null, "get$modify", 4, 0, null, 15],
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $asSetMixin: function() {
        return [P.String];
      },
      $asSetBase: function() {
        return [P.String];
      },
      $asIterable: function() {
        return [P.String];
      },
      $asSet: function() {
        return [P.String];
      },
      $isCssClassSet: 1
    },
    CssClassSetImpl_add_closure: {
      "^": "Closure:135;value,$ti",
      call$1: [function(s) {
        return H.assertSubtype(s, "$isSet", [P.String], "$asSet").add$1(0, this.value);
      }, null, null, 4, 0, null, 50, "call"]
    },
    CssClassSetImpl_addAll_closure: {
      "^": "Closure:34;$this,iterable,$ti",
      call$1: [function(s) {
        var t1 = P.String;
        return H.assertSubtype(s, "$isSet", [t1], "$asSet").addAll$1(0, J.map$1$1$ax(this.iterable, this.$this.get$_validateToken(), t1));
      }, null, null, 4, 0, null, 50, "call"]
    },
    CssClassSetImpl_removeAll_closure: {
      "^": "Closure:34;iterable,$ti",
      call$1: [function(s) {
        return H.assertSubtype(s, "$isSet", [P.String], "$asSet").removeAll$1(this.iterable);
      }, null, null, 4, 0, null, 50, "call"]
    },
    CssClassSetImpl_clear_closure: {
      "^": "Closure:34;$ti",
      call$1: [function(s) {
        return H.assertSubtype(s, "$isSet", [P.String], "$asSet").clear$0(0);
      }, null, null, 4, 0, null, 50, "call"]
    },
    Device: {
      "^": "Object;$ti"
    },
    FilteredElementList: {
      "^": "ListBase;_node,_childNodes,$ti",
      get$_html_common$_iterable: [function() {
        return J.map$1$1$ax(J.where$1$ax(this._childNodes, new P.FilteredElementList__iterable_closure()), new P.FilteredElementList__iterable_closure0(), W.Element);
      }, null, null, 2, 0, null],
      get$_filtered: [function() {
        return P.List_List$from(this.get$_html_common$_iterable(), false, W.Element);
      }, null, null, 2, 0, null],
      forEach$1: [function(_, f) {
        H.functionTypeCheck(f, {func: 1, ret: -1, args: [W.Element]});
        J.forEach$1$ax(this.get$_filtered(), f);
      }, null, "get$forEach", 5, 0, null, 15],
      $indexSet: [function(_, index, value) {
        H.intTypeCheck(index);
        H.interceptedTypeCheck(value, "$isElement");
        J.replaceWith$1$x(this.$index(0, index), value);
      }, null, "get$[]=", 9, 0, null, 6, 1],
      set$length: [function(_, newLength) {
        var len;
        H.intTypeCheck(newLength);
        len = this.get$length(this);
        if (typeof newLength !== "number")
          return newLength.$ge();
        if (typeof len !== "number")
          return H.iae(len);
        if (newLength >= len)
          return;
        else if (newLength < 0)
          throw H.wrapException(P.ArgumentError$("Invalid list length"));
        this.removeRange$2(0, newLength, len);
      }, null, null, 7, 0, null, 162],
      add$1: [function(_, value) {
        J.add$1$ax(this._childNodes, H.interceptedTypeCheck(value, "$isElement"));
      }, "call$1", "get$add", 5, 0, 2, 1],
      addAll$1: [function(_, iterable) {
        var t1;
        for (t1 = J.get$iterator$ax(H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable")); t1.moveNext$0();)
          this.add$1(0, t1.get$current());
      }, null, "get$addAll", 5, 0, null, 13],
      contains$1: [function(_, needle) {
        var t1, t2;
        if (!J.getInterceptor$(needle).$isElement)
          return false;
        t1 = needle.parentNode;
        t2 = this._node;
        return t1 == null ? t2 == null : t1 === t2;
      }, null, "get$contains", 5, 0, null, 558],
      get$reversed: [function(_) {
        return J.get$reversed$ax(this.get$_filtered());
      }, null, null, 3, 0, null],
      sort$1: [function(_, compare) {
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Element, W.Element]});
        throw H.wrapException(P.UnsupportedError$("Cannot sort filtered list"));
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      setRange$4: [function(_, start, end, iterable, skipCount) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
        H.intTypeCheck(skipCount);
        throw H.wrapException(P.UnsupportedError$("Cannot setRange on filtered list"));
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      replaceRange$3: [function(_, start, end, iterable) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
        throw H.wrapException(P.UnsupportedError$("Cannot replaceRange on filtered list"));
      }, null, "get$replaceRange", 13, 0, null, 5, 7, 13],
      removeRange$2: [function(_, start, end) {
        var t1;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        t1 = J.skip$1$ax(this.get$_html_common$_iterable(), start);
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        J.forEach$1$ax(P.List_List$from(J.take$1$ax(t1, end - start), true, null), new P.FilteredElementList_removeRange_closure());
      }, null, "get$removeRange", 9, 0, null, 5, 7],
      clear$0: [function(_) {
        J.clear$0$ax(this._childNodes);
      }, null, "get$clear", 1, 0, null],
      removeLast$0: [function(_) {
        var result = J.get$last$ax(this.get$_html_common$_iterable());
        if (result != null)
          J.remove$0$ax(result);
        return result;
      }, null, "get$removeLast", 1, 0, null],
      insert$2: [function(_, index, value) {
        var t1, element;
        H.intTypeCheck(index);
        H.interceptedTypeCheck(value, "$isElement");
        t1 = this.get$length(this);
        if (index == null ? t1 == null : index === t1)
          this.add$1(0, value);
        else {
          element = J.elementAt$1$ax(this.get$_html_common$_iterable(), index);
          J.insertBefore$2$x(element.parentNode, value, element);
        }
      }, null, "get$insert", 9, 0, null, 6, 1],
      insertAll$2: [function(_, index, iterable) {
        var t1, element;
        H.intTypeCheck(index);
        H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
        t1 = this.get$length(this);
        if (index == null ? t1 == null : index === t1)
          this.addAll$1(0, iterable);
        else {
          element = J.elementAt$1$ax(this.get$_html_common$_iterable(), index);
          J.insertAllBefore$2$x(element.parentNode, iterable, element);
        }
      }, null, "get$insertAll", 9, 0, null, 6, 13],
      removeAt$1: [function(_, index) {
        var result = this.$index(0, H.intTypeCheck(index));
        J.remove$0$ax(result);
        return result;
      }, null, "get$removeAt", 5, 0, null, 6],
      remove$1: [function(_, element) {
        var t1 = J.getInterceptor$(element);
        if (!t1.$isElement)
          return false;
        if (this.contains$1(0, element)) {
          t1.remove$0(element);
          return true;
        } else
          return false;
      }, null, "get$remove", 5, 0, null, 10],
      get$length: [function(_) {
        return J.get$length$asx(this.get$_html_common$_iterable());
      }, null, null, 3, 0, null],
      $index: [function(_, index) {
        H.intTypeCheck(index);
        return J.elementAt$1$ax(this.get$_html_common$_iterable(), index);
      }, null, "get$[]", 5, 0, null, 6],
      get$iterator: [function(_) {
        return J.get$iterator$ax(this.get$_filtered());
      }, null, null, 3, 0, null],
      $asEfficientLengthIterable: function() {
        return [W.Element];
      },
      $asListBase: function() {
        return [W.Element];
      },
      $asListMixin: function() {
        return [W.Element];
      },
      $asIterable: function() {
        return [W.Element];
      },
      $asList: function() {
        return [W.Element];
      },
      $isNodeListWrapper: 1,
      $as_ListBase_Object_ListMixin: function() {
        return [W.Element];
      },
      static: {
        FilteredElementList$: [function(node) {
          return new P.FilteredElementList(node, J.get$nodes$x(node), []);
        }, null, null, 4, 0, null, 23]
      }
    },
    FilteredElementList__iterable_closure: {
      "^": "Closure:25;$ti",
      call$1: [function(n) {
        return !!J.getInterceptor$(H.interceptedTypeCheck(n, "$isNode")).$isElement;
      }, null, null, 4, 0, null, 72, "call"]
    },
    FilteredElementList__iterable_closure0: {
      "^": "Closure:137;$ti",
      call$1: [function(n) {
        return H.interceptedTypeCast(H.interceptedTypeCheck(n, "$isNode"), "$isElement");
      }, null, null, 4, 0, null, 72, "call"]
    },
    FilteredElementList_removeRange_closure: {
      "^": "Closure:3;$ti",
      call$1: [function(el) {
        return J.remove$0$ax(el);
      }, null, null, 4, 0, null, 559, "call"]
    },
    Lists: {
      "^": "Object;$ti"
    },
    NodeListWrapper: {
      "^": "Object;$ti"
    }
  }], ["dart.dom.indexed_db", "dart:indexed_db",, P, {
    "^": "",
    _KeyRangeFactoryProvider: {
      "^": "Object;$ti"
    },
    Cursor: {
      "^": "Interceptor;$ti",
      $isCursor: 1,
      "%": ""
    },
    CursorWithValue: {
      "^": "Cursor;$ti",
      $isCursorWithValue: 1,
      "%": ""
    },
    Database: {
      "^": "EventTarget;$ti",
      $isDatabase: 1,
      "%": ""
    },
    IdbFactory: {
      "^": "Interceptor;$ti",
      $isIdbFactory: 1,
      "%": ""
    },
    Index: {
      "^": "Interceptor;$ti",
      $isIndex: 1,
      "%": ""
    },
    KeyRange: {
      "^": "Interceptor;$ti",
      $isKeyRange: 1,
      "%": "IDBKeyRange"
    },
    ObjectStore: {
      "^": "Interceptor;$ti",
      $isObjectStore: 1,
      "%": ""
    },
    Observation: {
      "^": "Interceptor;$ti",
      $isObservation: 1,
      "%": ""
    },
    Observer: {
      "^": "Interceptor;$ti",
      $isObserver: 1,
      "%": ""
    },
    ObserverChanges: {
      "^": "Interceptor;$ti",
      $isObserverChanges: 1,
      "%": ""
    },
    OpenDBRequest: {
      "^": "Request0;$ti",
      $isOpenDBRequest: 1,
      "%": ""
    },
    Request0: {
      "^": "EventTarget;$ti",
      $isRequest0: 1,
      "%": ""
    },
    Transaction: {
      "^": "EventTarget;$ti",
      $isTransaction: 1,
      "%": ""
    },
    VersionChangeEvent: {
      "^": "Event;$ti",
      $isVersionChangeEvent: 1,
      "%": "IDBVersionChangeEvent"
    }
  }], ["dart.io", "dart:io",, P, {
    "^": "",
    BytesBuilder: {
      "^": "Object;$ti"
    },
    _CopyingBytesBuilder0: {
      "^": "Object;$ti",
      $isBytesBuilder: 1
    },
    _BytesBuilder: {
      "^": "Object;$ti",
      $isBytesBuilder: 1
    },
    IOException: {
      "^": "Object;$ti",
      $isException: 1
    },
    OSError: {
      "^": "Object;$ti"
    },
    _BufferAndStart: {
      "^": "Object;$ti"
    },
    _IOCrypto: {
      "^": "Object;$ti"
    },
    ZLibOption: {
      "^": "Object;$ti"
    },
    ZLibCodec: {
      "^": "Codec;$ti",
      $asCodec: function() {
        return [[P.List, P.int], [P.List, P.int]];
      }
    },
    GZipCodec: {
      "^": "Codec;$ti",
      $asCodec: function() {
        return [[P.List, P.int], [P.List, P.int]];
      }
    },
    ZLibEncoder: {
      "^": "Converter;$ti",
      $asStreamTransformer: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asConverter: function() {
        return [[P.List, P.int], [P.List, P.int]];
      }
    },
    ZLibDecoder: {
      "^": "Converter;$ti",
      $asStreamTransformer: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asConverter: function() {
        return [[P.List, P.int], [P.List, P.int]];
      }
    },
    RawZLibFilter: {
      "^": "Object;$ti"
    },
    _BufferSink: {
      "^": "ByteConversionSink;$ti"
    },
    _ZLibEncoderSink: {
      "^": "_FilterSink;$ti"
    },
    _ZLibDecoderSink: {
      "^": "_FilterSink;$ti"
    },
    _FilterSink: {
      "^": "ByteConversionSink;$ti"
    },
    Directory: {
      "^": "Object;$ti",
      $isFileSystemEntity: 1
    },
    _Directory: {
      "^": "FileSystemEntity;$ti",
      $isDirectory: 1
    },
    _AsyncDirectoryListerOps: {
      "^": "Object;$ti"
    },
    _AsyncDirectoryLister: {
      "^": "Object;$ti"
    },
    _EmbedderConfig: {
      "^": "Object;$ti"
    },
    _EventHandler: {
      "^": "Object;$ti"
    },
    FileMode: {
      "^": "Object;$ti"
    },
    FileLock: {
      "^": "Object;$ti"
    },
    File0: {
      "^": "Object;$ti",
      $isFileSystemEntity: 1
    },
    RandomAccessFile: {
      "^": "Object;$ti"
    },
    FileSystemException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    _FileStream: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [[P.List, P.int]];
      }
    },
    _FileStreamConsumer: {
      "^": "StreamConsumer;$ti",
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      }
    },
    _File: {
      "^": "FileSystemEntity;$ti",
      $isFile0: 1
    },
    _RandomAccessFileOps: {
      "^": "Object;$ti"
    },
    _RandomAccessFile: {
      "^": "Object;$ti",
      $isRandomAccessFile: 1
    },
    FileSystemEntityType: {
      "^": "Object;$ti"
    },
    FileStat: {
      "^": "Object;$ti"
    },
    FileSystemEntity: {
      "^": "Object;$ti"
    },
    FileSystemEvent: {
      "^": "Object;$ti"
    },
    FileSystemCreateEvent: {
      "^": "FileSystemEvent;$ti"
    },
    FileSystemModifyEvent: {
      "^": "FileSystemEvent;$ti"
    },
    FileSystemDeleteEvent: {
      "^": "FileSystemEvent;$ti"
    },
    FileSystemMoveEvent: {
      "^": "FileSystemEvent;$ti"
    },
    _FileSystemWatcher: {
      "^": "Object;$ti"
    },
    _IOResourceInfo: {
      "^": "Object;$ti"
    },
    _ReadWriteResourceInfo: {
      "^": "_IOResourceInfo;$ti"
    },
    _FileResourceInfo: {
      "^": "_ReadWriteResourceInfo;$ti"
    },
    _ProcessResourceInfo: {
      "^": "_IOResourceInfo;$ti"
    },
    _SocketResourceInfo: {
      "^": "_ReadWriteResourceInfo;$ti"
    },
    _IOService: {
      "^": "Object;$ti"
    },
    IOSink: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $isStreamSink: 1,
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1
    },
    _StreamSinkImpl0: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isSink: 1
    },
    _IOSinkImpl0: {
      "^": "_StreamSinkImpl0;$ti",
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1,
      $as_StreamSinkImpl0: function() {
        return [[P.List, P.int]];
      }
    },
    Link: {
      "^": "Object;$ti",
      $isFileSystemEntity: 1
    },
    _Link: {
      "^": "FileSystemEntity;$ti",
      $isLink: 1
    },
    _Namespace: {
      "^": "Object;$ti"
    },
    IOOverrides: {
      "^": "Object;$ti"
    },
    _IOOverridesScope: {
      "^": "IOOverrides;$ti"
    },
    Platform0: {
      "^": "Object;$ti"
    },
    _Platform: {
      "^": "Object;$ti"
    },
    _CaseInsensitiveStringMap: {
      "^": "MapBase;$ti",
      $asMapBase: function($V) {
        return [P.String, $V];
      },
      $asMapMixin: function($V) {
        return [P.String, $V];
      },
      $asMap: function($V) {
        return [P.String, $V];
      }
    },
    _ProcessUtils: {
      "^": "Object;$ti"
    },
    ProcessInfo: {
      "^": "Object;$ti"
    },
    ProcessStartMode: {
      "^": "Object;$ti"
    },
    Process: {
      "^": "Object;$ti"
    },
    ProcessResult: {
      "^": "Object;$ti"
    },
    ProcessSignal: {
      "^": "Object;$ti"
    },
    SignalException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    ProcessException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    SecureServerSocket: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [P.SecureSocket];
      }
    },
    RawSecureServerSocket: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [P.RawSecureSocket];
      }
    },
    SecureSocket: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      },
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $isStreamSink: 1,
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1,
      $isSocket: 1
    },
    RawSecureSocket: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [P.RawSocketEvent];
      },
      $isRawSocket: 1
    },
    X509Certificate: {
      "^": "Object;$ti"
    },
    _FilterStatus: {
      "^": "Object;$ti"
    },
    _RawSecureSocket: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [P.RawSocketEvent];
      },
      $isRawSecureSocket: 1,
      $isRawSocket: 1
    },
    _ExternalBuffer: {
      "^": "Object;$ti"
    },
    _SecureFilter: {
      "^": "Object;$ti"
    },
    TlsException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    HandshakeException: {
      "^": "TlsException;$ti"
    },
    CertificateException: {
      "^": "TlsException;$ti"
    },
    SecurityContext: {
      "^": "Object;$ti"
    },
    _ServiceObject0: {
      "^": "Object;$ti"
    },
    InternetAddressType: {
      "^": "Object;$ti"
    },
    InternetAddress: {
      "^": "Object;$ti"
    },
    NetworkInterface: {
      "^": "Object;$ti"
    },
    RawServerSocket: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [P.RawSocket];
      }
    },
    ServerSocket: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [P.Socket];
      }
    },
    SocketDirection: {
      "^": "Object;$ti"
    },
    SocketOption: {
      "^": "Object;$ti"
    },
    RawSocketEvent: {
      "^": "Object;$ti"
    },
    ConnectionTask: {
      "^": "Object;$ti"
    },
    RawSocket: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [P.RawSocketEvent];
      }
    },
    Socket: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: function() {
        return [[P.List, P.int]];
      },
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $isStreamSink: 1,
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1
    },
    Datagram: {
      "^": "Object;$ti"
    },
    RawDatagramSocket: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [P.RawSocketEvent];
      }
    },
    SocketException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    _StdStream: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [[P.List, P.int]];
      }
    },
    Stdin: {
      "^": "_StdStream;$ti"
    },
    Stdout: {
      "^": "_StdSink;$ti"
    },
    StdoutException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    StdinException: {
      "^": "Object;$ti",
      $isException: 1,
      $isIOException: 1
    },
    _StdConsumer: {
      "^": "Object;$ti",
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      }
    },
    _StdSink: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $asEventSink: function() {
        return [[P.List, P.int]];
      },
      $isStreamConsumer: 1,
      $asStreamConsumer: function() {
        return [[P.List, P.int]];
      },
      $isStreamSink: 1,
      $asStreamSink: function() {
        return [[P.List, P.int]];
      },
      $isSink: 1,
      $asSink: function() {
        return [[P.List, P.int]];
      },
      $isStringSink: 1,
      $isIOSink: 1
    },
    StdioType: {
      "^": "Object;$ti"
    },
    _StdIOUtils: {
      "^": "Object;$ti"
    },
    SystemEncoding: {
      "^": "Encoding;$ti"
    },
    _WindowsCodePageEncoder: {
      "^": "Converter;$ti",
      $asStreamTransformer: function() {
        return [P.String, [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [P.String, [P.List, P.int]];
      },
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    _WindowsCodePageEncoderSink: {
      "^": "StringConversionSinkBase;$ti"
    },
    _WindowsCodePageDecoder: {
      "^": "Converter;$ti",
      $asStreamTransformer: function() {
        return [[P.List, P.int], P.String];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], P.String];
      },
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      }
    },
    _WindowsCodePageDecoderSink: {
      "^": "ByteConversionSinkBase;$ti"
    },
    RawSynchronousSocket: {
      "^": "Object;$ti"
    }
  }], ["dart.isolate", "dart:isolate",, P, {
    "^": "",
    _ReceivePortImpl: {
      "^": "Stream;$ti",
      $asStream: Isolate.functionThatReturnsNull,
      $isReceivePort: 1
    },
    Capability: {
      "^": "Object;$ti"
    },
    IsolateSpawnException: {
      "^": "Object;$ti",
      $isException: 1
    },
    Isolate0: {
      "^": "Object;$ti"
    },
    SendPort: {
      "^": "Object;$ti",
      $isCapability: 1
    },
    ReceivePort: {
      "^": "Object;$ti",
      $isStream: 1,
      $asStream: Isolate.functionThatReturnsNull
    },
    RawReceivePort: {
      "^": "Object;$ti"
    },
    RemoteError: {
      "^": "Object;$ti",
      $isError: 1
    }
  }], ["dart.js", "dart:js",, P, {
    "^": "",
    _convertDartFunction: [function(f, captureThis) {
      return function(_call, f, captureThis) {
        return function() {
          return _call(f, captureThis, this, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunction, H.interceptedTypeCheck(f, "$isFunction"), H.boolTypeCheck(captureThis));
    }, null, null, 4, 3, null, 18, 15, 401],
    _callDartFunction: [function(callback, captureThis, $self, $arguments) {
      var arguments0, dartArgs;
      H.boolTypeCheck(captureThis);
      H.listTypeCheck($arguments);
      if (captureThis) {
        arguments0 = [$self];
        C.JSArray_methods.addAll$1(arguments0, $arguments);
        $arguments = arguments0;
      }
      dartArgs = P.List_List$from(J.map$1$1$ax($arguments, P.js___convertToDart$closure(), null), true, null);
      return P._convertToJS(P.Function_apply(H.interceptedTypeCheck(callback, "$isFunction"), dartArgs, null));
    }, null, null, 16, 0, null, 43, 401, 168, 94],
    _defineProperty: [function(o, $name, value) {
      var exception;
      H.stringTypeCheck($name);
      try {
        if (P._isExtensible(o) && !P._hasOwnProperty(o, $name)) {
          Object.defineProperty(o, $name, {value: value});
          return true;
        }
      } catch (exception) {
        H.unwrapException(exception);
      }
      return false;
    }, null, null, 12, 0, null, 25, 8, 1],
    _hasOwnProperty: [function(o, $name) {
      return Object.prototype.hasOwnProperty.call(o, H.stringTypeCheck($name));
    }, null, null, 8, 0, null, 25, 8],
    _isExtensible: [function(o) {
      return Object.isExtensible(o);
    }, null, null, 4, 0, null, 25],
    _getOwnProperty: [function(o, $name) {
      H.stringTypeCheck($name);
      if (P._hasOwnProperty(o, $name))
        return o[$name];
      return;
    }, null, null, 8, 0, null, 25, 8],
    _isLocalObject: [function(o) {
      return o instanceof Object;
    }, null, null, 4, 0, null, 25],
    _convertToJS: [function(o) {
      var t1;
      if (o == null || typeof o === "string" || typeof o === "number" || typeof o === "boolean")
        return o;
      t1 = J.getInterceptor$(o);
      if (!!t1.$isJsObject)
        return o._js$_jsObject;
      if (H.isBrowserObject(o))
        return o;
      if (!!t1.$isTypedData)
        return o;
      if (!!t1.$isDateTime)
        return H.Primitives_lazyAsJsDate(o);
      if (!!t1.$isFunction)
        return P._getJsProxy(o, "$dart_jsFunction", new P._convertToJS_closure());
      return P._getJsProxy(o, "_$dart_jsObject", new P._convertToJS_closure0($.$get$_dartProxyCtor()));
    }, "call$1", "js___convertToJS$closure", 4, 0, 3, 25],
    _getJsProxy: [function(o, propertyName, createProxy) {
      var jsProxy;
      H.stringTypeCheck(propertyName);
      H.functionTypeCheck(createProxy, {func: 1, args: [,]});
      jsProxy = P._getOwnProperty(o, propertyName);
      if (jsProxy == null) {
        jsProxy = createProxy.call$1(o);
        P._defineProperty(o, propertyName, jsProxy);
      }
      return jsProxy;
    }, null, null, 12, 0, null, 25, 105, 403],
    _convertToDart: [function(o) {
      if (o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean")
        return o;
      else if (P._isLocalObject(o) && H.isBrowserObject(o))
        return H.convertFromBrowserObject(o);
      else if (P._isLocalObject(o) && !!J.getInterceptor$(o).$isTypedData)
        return o;
      else if (o instanceof Date)
        return P.DateTime$fromMillisecondsSinceEpoch(H.intTypeCheck(o.getTime()), false);
      else if (o.constructor === $.$get$_dartProxyCtor())
        return o.o;
      else
        return P._wrapToDart(o);
    }, "call$1", "js___convertToDart$closure", 4, 0, 70, 25],
    _wrapToDart: [function(o) {
      if (typeof o == "function")
        return P._getDartProxy(o, $.$get$DART_CLOSURE_PROPERTY_NAME(), new P._wrapToDart_closure());
      if (o instanceof Array)
        return P._getDartProxy(o, $.$get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure0());
      return P._getDartProxy(o, $.$get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure1());
    }, null, null, 4, 0, null, 25],
    _getDartProxy: [function(o, propertyName, createProxy) {
      var dartProxy;
      H.stringTypeCheck(propertyName);
      H.functionTypeCheck(createProxy, {func: 1, args: [,]});
      dartProxy = P._getOwnProperty(o, propertyName);
      if (dartProxy == null || !P._isLocalObject(o)) {
        dartProxy = createProxy.call$1(o);
        P._defineProperty(o, propertyName, dartProxy);
      }
      return dartProxy;
    }, null, null, 12, 0, null, 25, 105, 403],
    _convertDartFunctionFast: [function(f) {
      var existing, ret;
      H.interceptedTypeCheck(f, "$isFunction");
      existing = f.$dart_jsFunction;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunctionFast, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f.$dart_jsFunction = ret;
      return ret;
    }, null, null, 4, 0, null, 15],
    _callDartFunctionFast: [function(callback, $arguments) {
      H.listTypeCheck($arguments);
      return P.Function_apply(H.interceptedTypeCheck(callback, "$isFunction"), $arguments, null);
    }, null, null, 8, 0, null, 43, 94],
    allowInterop: [1, function(f, $F) {
      H.assertIsSubtype($F, P.Function, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'F' in 'allowInterop'.");
      H.assertSubtypeOfRuntimeType(f, $F);
      if (typeof f == "function")
        return f;
      else
        return H.assertSubtypeOfRuntimeType(P._convertDartFunctionFast(f), $F);
    }, function(f) {
      return P.allowInterop(f, P.Function);
    }, null, "call$1", null, 4, 0, null, 15],
    JsObject: {
      "^": "Object;_js$_jsObject,$ti",
      JsObject$_fromJs$1: [function(_jsObject) {
      }, null, null, 4, 0, null, 402],
      $index: ["super$JsObject$$index", function(_, property) {
        if (typeof property !== "string" && typeof property !== "number")
          throw H.wrapException(P.ArgumentError$("property is not a String or num"));
        return P._convertToDart(this._js$_jsObject[property]);
      }, null, "get$[]", 5, 0, null, 67],
      $indexSet: ["super$JsObject$$indexSet", function(_, property, value) {
        if (typeof property !== "string" && typeof property !== "number")
          throw H.wrapException(P.ArgumentError$("property is not a String or num"));
        this._js$_jsObject[property] = P._convertToJS(value);
      }, null, "get$[]=", 9, 0, null, 67, 1],
      get$hashCode: [function(_) {
        return 0;
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof P.JsObject && this._js$_jsObject === other._js$_jsObject;
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        var t1, exception;
        try {
          t1 = String(this._js$_jsObject);
          return t1;
        } catch (exception) {
          H.unwrapException(exception);
          t1 = this.super$Object$toString(this);
          return t1;
        }
      }, null, "get$toString", 1, 0, null],
      callMethod$2: [function(method, args) {
        var t1, t2;
        H.listTypeCheck(args);
        if (typeof method !== "string" && typeof method !== "number")
          throw H.wrapException(P.ArgumentError$("method is not a String or num"));
        t1 = this._js$_jsObject;
        t2 = args == null ? null : P.List_List$from(J.map$1$1$ax(args, P.js___convertToJS$closure(), null), true, null);
        return P._convertToDart(t1[method].apply(t1, t2));
      }, function(method) {
        return this.callMethod$2(method, null);
      }, "callMethod$1", null, null, "get$callMethod", 4, 2, null, 0, 61, 71],
      static: {
        JsObject$_fromJs: [function(_jsObject) {
          var t1 = new P.JsObject(_jsObject, []);
          t1.JsObject$_fromJs$1(_jsObject);
          return t1;
        }, null, null, 4, 0, null, 402],
        JsObject_JsObject: [function($constructor, $arguments) {
          var constr, args, factoryFunction;
          H.interceptedTypeCheck($constructor, "$isJsFunction");
          H.listTypeCheck($arguments);
          constr = P._convertToJS($constructor);
          if ($arguments == null)
            return H.interceptedTypeCheck(P._wrapToDart(new constr()), "$isJsObject");
          if ($arguments instanceof Array)
            switch ($arguments.length) {
              case 0:
                return H.interceptedTypeCheck(P._wrapToDart(new constr()), "$isJsObject");
              case 1:
                return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]))), "$isJsObject");
              case 2:
                return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]), P._convertToJS($arguments[1]))), "$isJsObject");
              case 3:
                return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]), P._convertToJS($arguments[1]), P._convertToJS($arguments[2]))), "$isJsObject");
              case 4:
                return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]), P._convertToJS($arguments[1]), P._convertToJS($arguments[2]), P._convertToJS($arguments[3]))), "$isJsObject");
            }
          args = [null];
          C.JSArray_methods.addAll$1(args, J.map$1$1$ax($arguments, P.js___convertToJS$closure(), null));
          factoryFunction = constr.bind.apply(constr, args);
          String(factoryFunction);
          return H.interceptedTypeCheck(P._wrapToDart(new factoryFunction()), "$isJsObject");
        }, null, null, 4, 2, null, 0, 335, 94],
        JsObject_JsObject$jsify: [function(object) {
          var t1 = J.getInterceptor$(object);
          if (!t1.$isMap && !t1.$isIterable)
            throw H.wrapException(P.ArgumentError$("object must be a Map or Iterable"));
          return H.interceptedTypeCheck(P._wrapToDart(P.JsObject__convertDataTree(object)), "$isJsObject");
        }, null, null, 4, 0, null, 9],
        JsObject__convertDataTree: [function(data) {
          return new P.JsObject__convertDataTree__convert(P._IdentityHashMap$(null, null)).call$1(data);
        }, null, null, 4, 0, null, 34]
      }
    },
    JsObject__convertDataTree__convert: {
      "^": "Closure:3;_convertedObjects,$ti",
      call$1: [function(o) {
        var t1, t2, convertedMap, key, convertedList;
        t1 = this._convertedObjects;
        if (t1.containsKey$1(o))
          return J.$index$asx(t1, o);
        t2 = J.getInterceptor$(o);
        if (!!t2.$isMap) {
          convertedMap = {};
          J.$indexSet$ax(t1, o, convertedMap);
          for (t1 = J.get$iterator$ax(o.get$keys()); t1.moveNext$0();) {
            key = t1.get$current();
            convertedMap[key] = this.call$1(o.$index(0, key));
          }
          return convertedMap;
        } else if (!!t2.$isIterable) {
          convertedList = [];
          J.$indexSet$ax(t1, o, convertedList);
          C.JSArray_methods.addAll$1(convertedList, t2.map$1$1(o, this, null));
          return convertedList;
        } else
          return P._convertToJS(o);
      }, null, null, 4, 0, null, 25, "call"]
    },
    JsFunction: {
      "^": "JsObject;_js$_jsObject,$ti",
      static: {
        JsFunction$_fromJs: [function(jsObject) {
          var t1 = new P.JsFunction(jsObject, []);
          t1.JsObject$_fromJs$1(jsObject);
          return t1;
        }, null, null, 4, 0, null, 241]
      }
    },
    JsArray: {
      "^": "_JsArray_JsObject_ListMixin;_js$_jsObject,$ti",
      _checkIndex$1: [function(index) {
        var t1;
        H.intTypeCheck(index);
        if (typeof index === "number" && Math.floor(index) === index)
          if (!(index < 0)) {
            t1 = this.get$length(this);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = index >= t1;
          } else
            t1 = true;
        else
          t1 = false;
        if (t1)
          throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
      }, null, "get$_checkIndex", 4, 0, null, 6],
      _checkInsertIndex$1: [function(index) {
        var t1;
        H.intTypeCheck(index);
        if (typeof index === "number" && Math.floor(index) === index)
          if (!(index < 0)) {
            t1 = J.$add$ansx(this.get$length(this), 1);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = index >= t1;
          } else
            t1 = true;
        else
          t1 = false;
        if (t1)
          throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this), null, null));
      }, null, "get$_checkInsertIndex", 4, 0, null, 6],
      $index: [function(_, index) {
        if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index))
          this._checkIndex$1(H.intTypeCheck(index));
        return H.assertSubtypeOfRuntimeType(this.super$JsObject$$index(0, index), H.getTypeArgumentByIndex(this, 0));
      }, null, "get$[]", 5, 0, null, 6],
      $indexSet: [function(_, index, value) {
        H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
        if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index))
          this._checkIndex$1(H.intTypeCheck(index));
        this.super$JsObject$$indexSet(0, index, value);
      }, null, "get$[]=", 9, 0, null, 6, 1],
      get$length: [function(_) {
        var len = this._js$_jsObject.length;
        if (typeof len === "number" && len >>> 0 === len)
          return len;
        throw H.wrapException(P.StateError$("Bad JsArray length"));
      }, null, null, 3, 0, null],
      set$length: [function(_, $length) {
        this.super$JsObject$$indexSet(0, "length", H.intTypeCheck($length));
      }, null, null, 7, 0, null, 35],
      add$1: [function(_, value) {
        this.callMethod$2("push", [H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0))]);
      }, "call$1", "get$add", 5, 0, 2, 1],
      addAll$1: [function(_, iterable) {
        H.assertSubtype(iterable, "$isIterable", this.$ti, "$asIterable");
        this.callMethod$2("push", H.listTypeCheck(iterable instanceof Array ? iterable : P.List_List$from(iterable, true, null)));
      }, null, "get$addAll", 5, 0, null, 13],
      insert$2: [function(_, index, element) {
        H.intTypeCheck(index);
        H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
        this._checkInsertIndex$1(index);
        this.callMethod$2("splice", [index, 0, element]);
      }, null, "get$insert", 9, 0, null, 6, 10],
      removeAt$1: [function(_, index) {
        H.intTypeCheck(index);
        this._checkIndex$1(index);
        return H.assertSubtypeOfRuntimeType(J.$index$asx(this.callMethod$2("splice", [index, 1]), 0), H.getTypeArgumentByIndex(this, 0));
      }, null, "get$removeAt", 5, 0, null, 6],
      removeLast$0: [function(_) {
        if (J.$eq$(this.get$length(this), 0))
          throw H.wrapException(P.RangeError$(-1));
        return H.assertSubtypeOfRuntimeType(this.callMethod$1("pop"), H.getTypeArgumentByIndex(this, 0));
      }, null, "get$removeLast", 1, 0, null],
      setRange$4: [function(_, start, end, iterable, skipCount) {
        var $length, args;
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        H.assertSubtype(iterable, "$isIterable", this.$ti, "$asIterable");
        H.intTypeCheck(skipCount);
        P.JsArray__checkRange(start, end, this.get$length(this));
        if (typeof end !== "number")
          return end.$sub();
        if (typeof start !== "number")
          return H.iae(start);
        $length = end - start;
        if ($length === 0)
          return;
        if (typeof skipCount !== "number")
          return skipCount.$lt();
        if (skipCount < 0)
          throw H.wrapException(P.ArgumentError$(skipCount));
        args = [start, $length];
        C.JSArray_methods.addAll$1(args, J.take$1$ax(J.skip$1$ax(iterable, skipCount), $length));
        this.callMethod$2("splice", args);
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null, 16, 5, 7, 13, 87],
      sort$1: [function(_, compare) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
        this.callMethod$2("sort", compare == null ? [] : [compare]);
      }, function($receiver) {
        return this.sort$1($receiver, null);
      }, "sort$0", null, null, "get$sort", 1, 2, null, 0, 79],
      $isEfficientLengthIterable: 1,
      $isListMixin: 1,
      $isIterable: 1,
      $isList: 1,
      static: {
        JsArray$_fromJs: [function(jsObject, $E) {
          var t1 = new P.JsArray(jsObject, [$E]);
          t1.JsObject$_fromJs$1(jsObject);
          return t1;
        }, null, null, 4, 0, null, 241],
        JsArray__checkRange: [function(start, end, $length) {
          var t1;
          H.intTypeCheck(start);
          H.intTypeCheck(end);
          H.intTypeCheck($length);
          if (typeof start !== "number")
            return start.$lt();
          if (start >= 0) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = start > $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.RangeError$range(start, 0, $length, null, null));
          if (typeof end !== "number")
            return end.$lt();
          if (end >= start) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = end > $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.RangeError$range(end, start, $length, null, null));
        }, null, null, 12, 0, null, 5, 7, 35]
      }
    },
    _convertToJS_closure: {
      "^": "Closure:3;$ti",
      call$1: [function(o) {
        var jsFunction;
        H.interceptedTypeCheck(o, "$isFunction");
        jsFunction = P._convertDartFunction(o, false);
        P._defineProperty(jsFunction, $.$get$DART_CLOSURE_PROPERTY_NAME(), o);
        return jsFunction;
      }, null, null, 4, 0, null, 25, "call"]
    },
    _convertToJS_closure0: {
      "^": "Closure:3;ctor,$ti",
      call$1: [function(o) {
        return new this.ctor(o);
      }, null, null, 4, 0, null, 25, "call"]
    },
    _wrapToDart_closure: {
      "^": "Closure:139;$ti",
      call$1: [function(o) {
        return P.JsFunction$_fromJs(o);
      }, null, null, 4, 0, null, 25, "call"]
    },
    _wrapToDart_closure0: {
      "^": "Closure:159;$ti",
      call$1: [function(o) {
        return P.JsArray$_fromJs(o, null);
      }, null, null, 4, 0, null, 25, "call"]
    },
    _wrapToDart_closure1: {
      "^": "Closure:162;$ti",
      call$1: [function(o) {
        return P.JsObject$_fromJs(o);
      }, null, null, 4, 0, null, 25, "call"]
    },
    _JsArray_JsObject_ListMixin: {
      "^": "JsObject+ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isListMixin: 1,
      $isIterable: 1,
      $isList: 1
    }
  }], ["dart.js_util", "dart:js_util",, P, {
    "^": "",
    jsify: [function(object) {
      var t1 = J.getInterceptor$(object);
      if (!t1.$isMap && !t1.$isIterable)
        throw H.wrapException(P.ArgumentError$("object must be a Map or Iterable"));
      return P._convertDataTree(object);
    }, null, null, 4, 0, null, 9],
    _convertDataTree: [function(data) {
      return new P._convertDataTree__convert(P._IdentityHashMap$(null, null)).call$1(data);
    }, null, null, 4, 0, null, 34],
    _convertDataTree__convert: {
      "^": "Closure:3;_convertedObjects,$ti",
      call$1: [function(o) {
        var t1, t2, convertedMap, key, convertedList;
        t1 = this._convertedObjects;
        if (t1.containsKey$1(o))
          return J.$index$asx(t1, o);
        t2 = J.getInterceptor$(o);
        if (!!t2.$isMap) {
          convertedMap = {};
          J.$indexSet$ax(t1, o, convertedMap);
          for (t1 = J.get$iterator$ax(o.get$keys()); t1.moveNext$0();) {
            key = t1.get$current();
            convertedMap[key] = this.call$1(o.$index(0, key));
          }
          return convertedMap;
        } else if (!!t2.$isIterable) {
          convertedList = [];
          J.$indexSet$ax(t1, o, convertedList);
          C.JSArray_methods.addAll$1(convertedList, t2.map$1$1(o, this, null));
          return convertedList;
        } else
          return o;
      }, null, null, 4, 0, null, 25, "call"]
    }
  }], ["dart.math", "dart:math",, P, {
    "^": "",
    min: [1, function(a, b, $T) {
      H.assertIsSubtype($T, P.num, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'min'.");
      H.assertSubtypeOfRuntimeType(a, $T);
      H.assertSubtypeOfRuntimeType(b, $T);
      return Math.min(H.checkNum(a), H.checkNum(b));
    }, function(a, b) {
      return P.min(a, b, P.num);
    }, null, "call$2", null, 8, 0, null, 33, 54],
    max: [1, function(a, b, $T) {
      H.assertIsSubtype($T, P.num, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'max'.");
      H.assertSubtypeOfRuntimeType(a, $T);
      H.assertSubtypeOfRuntimeType(b, $T);
      return Math.max(H.checkNum(a), H.checkNum(b));
    }, function(a, b) {
      return P.max(a, b, P.num);
    }, null, "call$2", null, 8, 0, null, 33, 54],
    log: [function(x) {
      return Math.log(H.checkNum(H.numTypeCheck(x)));
    }, null, null, 4, 0, null, 37],
    pow: [function(x, exponent) {
      H.numTypeCheck(x);
      H.numTypeCheck(exponent);
      H.checkNum(x);
      H.checkNum(exponent);
      return Math.pow(x, exponent);
    }, null, null, 8, 0, null, 37, 404],
    _JenkinsSmiHash_combine0: [function(hash, value) {
      H.intTypeCheck(hash);
      H.intTypeCheck(value);
      if (typeof hash !== "number")
        return hash.$add();
      if (typeof value !== "number")
        return H.iae(value);
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    }, null, null, 8, 0, null, 155, 1],
    _JenkinsSmiHash_finish0: [function(hash) {
      H.intTypeCheck(hash);
      if (typeof hash !== "number")
        return H.iae(hash);
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }, null, null, 4, 0, null, 155],
    _JenkinsSmiHash_hash2: [function(a, b) {
      return P._JenkinsSmiHash_finish0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, H.intTypeCheck(a)), H.intTypeCheck(b)));
    }, null, null, 8, 0, null, 33, 54],
    _JSRandom: {
      "^": "Object;$ti",
      $isRandom: 1
    },
    _Random: {
      "^": "Object;$ti",
      $isRandom: 1
    },
    _JSSecureRandom: {
      "^": "Object;$ti",
      $isRandom: 1
    },
    _JenkinsSmiHash0: {
      "^": "Object;$ti"
    },
    Point: {
      "^": "Object;x>,y>,$ti",
      toString$0: [function(_) {
        return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
      }, null, "get$toString", 1, 0, null],
      $eq: [function(_, other) {
        var t1;
        if (other == null)
          return false;
        if (!H.checkSubtype(other, "$isPoint", [P.num], null))
          return false;
        t1 = J.getInterceptor$x(other);
        return J.$eq$(this.x, t1.get$x(other)) && J.$eq$(this.y, t1.get$y(other));
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return P._JenkinsSmiHash_hash2(J.get$hashCode$(this.x), J.get$hashCode$(this.y));
      }, null, null, 3, 0, null],
      $add: [function(_, other) {
        var t1;
        H.assertSubtype(other, "$isPoint", this.$ti, "$asPoint");
        t1 = H.getTypeArgumentByIndex(this, 0);
        return P.Point$(H.assertSubtypeOfRuntimeType(J.$add$ansx(this.x, other.x), t1), H.assertSubtypeOfRuntimeType(J.$add$ansx(this.y, other.y), t1), t1);
      }, null, "get$+", 5, 0, null, 3],
      $sub: [function(_, other) {
        var t1;
        H.assertSubtype(other, "$isPoint", this.$ti, "$asPoint");
        t1 = H.getTypeArgumentByIndex(this, 0);
        return P.Point$(H.assertSubtypeOfRuntimeType(J.$sub$n(this.x, other.x), t1), H.assertSubtypeOfRuntimeType(J.$sub$n(this.y, other.y), t1), t1);
      }, null, "get$-", 5, 0, null, 3],
      $mul: [function(_, factor) {
        var t1;
        H.numTypeCheck(factor);
        t1 = H.getTypeArgumentByIndex(this, 0);
        return P.Point$(H.assertSubtypeOfRuntimeType(J.$mul$ns(this.x, factor), t1), H.assertSubtypeOfRuntimeType(J.$mul$ns(this.y, factor), t1), t1);
      }, null, "get$*", 5, 0, null, 373],
      static: {
        Point$: [function(x, y, $T) {
          return new P.Point(x, y, [$T]);
        }, null, null, 8, 0, null, 37, 77]
      }
    },
    Random: {
      "^": "Object;$ti"
    },
    _RectangleBase: {
      "^": "Object;$ti"
    },
    Rectangle: {
      "^": "_RectangleBase;$ti"
    },
    MutableRectangle: {
      "^": "_RectangleBase;$ti",
      $isRectangle: 1
    }
  }], ["dart.mirrors", "dart:mirrors",, P, {
    "^": "",
    MirrorSystem: {
      "^": "Object;$ti"
    },
    Mirror: {
      "^": "Object;$ti"
    },
    IsolateMirror: {
      "^": "Object;$ti",
      $isMirror: 1
    },
    DeclarationMirror: {
      "^": "Object;$ti",
      $isMirror: 1
    },
    ObjectMirror: {
      "^": "Object;$ti",
      $isMirror: 1
    },
    InstanceMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isObjectMirror: 1
    },
    ClosureMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isObjectMirror: 1,
      $isInstanceMirror: 1
    },
    LibraryMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      $isObjectMirror: 1
    },
    LibraryDependencyMirror: {
      "^": "Object;$ti",
      $isMirror: 1
    },
    CombinatorMirror: {
      "^": "Object;$ti",
      $isMirror: 1
    },
    TypeMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1
    },
    ClassMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      $isObjectMirror: 1,
      $isTypeMirror: 1
    },
    FunctionTypeMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      $isObjectMirror: 1,
      $isTypeMirror: 1,
      $isClassMirror: 1
    },
    TypeVariableMirror: {
      "^": "TypeMirror;$ti"
    },
    TypedefMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      $isTypeMirror: 1
    },
    MethodMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1
    },
    VariableMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1
    },
    ParameterMirror: {
      "^": "Object;$ti",
      $isMirror: 1,
      $isDeclarationMirror: 1,
      $isVariableMirror: 1
    },
    SourceLocation1: {
      "^": "Object;$ti"
    },
    Comment0: {
      "^": "Object;$ti"
    },
    MirrorsUsed: {
      "^": "Object;$ti"
    }
  }], ["dart.dom.svg", "dart:svg",, P, {
    "^": "",
    _SvgElementFactoryProvider: {
      "^": "Object;$ti"
    },
    AElement: {
      "^": "GraphicsElement;$ti",
      $isAElement: 1,
      $isUriReference: 1,
      "%": "SVGAElement"
    },
    Angle: {
      "^": "Interceptor;$ti",
      $isAngle: 1,
      "%": ""
    },
    AnimateElement: {
      "^": "AnimationElement;$ti",
      $isAnimateElement: 1,
      "%": "SVGAnimateElement"
    },
    AnimateMotionElement: {
      "^": "AnimationElement;$ti",
      $isAnimateMotionElement: 1,
      "%": "SVGAnimateMotionElement"
    },
    AnimateTransformElement: {
      "^": "AnimationElement;$ti",
      $isAnimateTransformElement: 1,
      "%": "SVGAnimateTransformElement"
    },
    AnimatedAngle: {
      "^": "Interceptor;$ti",
      $isAnimatedAngle: 1,
      "%": ""
    },
    AnimatedBoolean: {
      "^": "Interceptor;$ti",
      $isAnimatedBoolean: 1,
      "%": ""
    },
    AnimatedEnumeration: {
      "^": "Interceptor;$ti",
      $isAnimatedEnumeration: 1,
      "%": ""
    },
    AnimatedInteger: {
      "^": "Interceptor;$ti",
      $isAnimatedInteger: 1,
      "%": ""
    },
    AnimatedLength: {
      "^": "Interceptor;$ti",
      $isAnimatedLength: 1,
      "%": "SVGAnimatedLength"
    },
    AnimatedLengthList: {
      "^": "Interceptor;$ti",
      $isAnimatedLengthList: 1,
      "%": "SVGAnimatedLengthList"
    },
    AnimatedNumber: {
      "^": "Interceptor;$ti",
      $isAnimatedNumber: 1,
      "%": "SVGAnimatedNumber"
    },
    AnimatedNumberList: {
      "^": "Interceptor;$ti",
      $isAnimatedNumberList: 1,
      "%": ""
    },
    AnimatedPreserveAspectRatio: {
      "^": "Interceptor;$ti",
      $isAnimatedPreserveAspectRatio: 1,
      "%": ""
    },
    AnimatedRect: {
      "^": "Interceptor;$ti",
      $isAnimatedRect: 1,
      "%": ""
    },
    AnimatedString: {
      "^": "Interceptor;$ti",
      $isAnimatedString: 1,
      "%": ""
    },
    AnimatedTransformList: {
      "^": "Interceptor;$ti",
      $isAnimatedTransformList: 1,
      "%": ""
    },
    AnimationElement: {
      "^": "SvgElement;$ti",
      $isAnimationElement: 1,
      $isTests: 1,
      "%": ";SVGAnimationElement"
    },
    CircleElement: {
      "^": "GeometryElement;$ti",
      $isCircleElement: 1,
      "%": "SVGCircleElement"
    },
    ClipPathElement: {
      "^": "GraphicsElement;$ti",
      $isClipPathElement: 1,
      "%": "SVGClipPathElement"
    },
    DefsElement: {
      "^": "GraphicsElement;$ti",
      $isDefsElement: 1,
      "%": "SVGDefsElement"
    },
    DescElement: {
      "^": "SvgElement;$ti",
      $isDescElement: 1,
      "%": "SVGDescElement"
    },
    DiscardElement: {
      "^": "SvgElement;$ti",
      $isDiscardElement: 1,
      "%": "SVGDiscardElement"
    },
    EllipseElement: {
      "^": "GeometryElement;$ti",
      $isEllipseElement: 1,
      "%": "SVGEllipseElement"
    },
    FEBlendElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEBlendElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEBlendElement"
    },
    FEColorMatrixElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEColorMatrixElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEColorMatrixElement"
    },
    FEComponentTransferElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEComponentTransferElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEComponentTransferElement"
    },
    FECompositeElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFECompositeElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFECompositeElement"
    },
    FEConvolveMatrixElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEConvolveMatrixElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEConvolveMatrixElement"
    },
    FEDiffuseLightingElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEDiffuseLightingElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEDiffuseLightingElement"
    },
    FEDisplacementMapElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEDisplacementMapElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEDisplacementMapElement"
    },
    FEDistantLightElement: {
      "^": "SvgElement;$ti",
      $isFEDistantLightElement: 1,
      "%": "SVGFEDistantLightElement"
    },
    FEFloodElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEFloodElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEFloodElement"
    },
    FEFuncAElement: {
      "^": "_SVGComponentTransferFunctionElement;$ti",
      $isFEFuncAElement: 1,
      "%": "SVGFEFuncAElement"
    },
    FEFuncBElement: {
      "^": "_SVGComponentTransferFunctionElement;$ti",
      $isFEFuncBElement: 1,
      "%": "SVGFEFuncBElement"
    },
    FEFuncGElement: {
      "^": "_SVGComponentTransferFunctionElement;$ti",
      $isFEFuncGElement: 1,
      "%": "SVGFEFuncGElement"
    },
    FEFuncRElement: {
      "^": "_SVGComponentTransferFunctionElement;$ti",
      $isFEFuncRElement: 1,
      "%": "SVGFEFuncRElement"
    },
    FEGaussianBlurElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEGaussianBlurElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEGaussianBlurElement"
    },
    FEImageElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEImageElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      $isUriReference: 1,
      "%": "SVGFEImageElement"
    },
    FEMergeElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEMergeElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEMergeElement"
    },
    FEMergeNodeElement: {
      "^": "SvgElement;$ti",
      $isFEMergeNodeElement: 1,
      "%": "SVGFEMergeNodeElement"
    },
    FEMorphologyElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEMorphologyElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEMorphologyElement"
    },
    FEOffsetElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFEOffsetElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFEOffsetElement"
    },
    FEPointLightElement: {
      "^": "SvgElement;0x=,0y=,$ti",
      $isFEPointLightElement: 1,
      "%": "SVGFEPointLightElement"
    },
    FESpecularLightingElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFESpecularLightingElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFESpecularLightingElement"
    },
    FESpotLightElement: {
      "^": "SvgElement;0x=,0y=,$ti",
      $isFESpotLightElement: 1,
      "%": "SVGFESpotLightElement"
    },
    FETileElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFETileElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFETileElement"
    },
    FETurbulenceElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFETurbulenceElement: 1,
      $isFilterPrimitiveStandardAttributes: 1,
      "%": "SVGFETurbulenceElement"
    },
    FilterElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFilterElement: 1,
      $isUriReference: 1,
      "%": "SVGFilterElement"
    },
    FilterPrimitiveStandardAttributes: {
      "^": "Interceptor;$ti"
    },
    FitToViewBox: {
      "^": "Interceptor;$ti"
    },
    ForeignObjectElement: {
      "^": "GraphicsElement;0height=,0width=,0x=,0y=,$ti",
      $isForeignObjectElement: 1,
      "%": "SVGForeignObjectElement"
    },
    GElement: {
      "^": "GraphicsElement;$ti",
      $isGElement: 1,
      "%": "SVGGElement"
    },
    GeometryElement: {
      "^": "GraphicsElement;$ti",
      $isGeometryElement: 1,
      "%": ";SVGGeometryElement"
    },
    GraphicsElement: {
      "^": "SvgElement;$ti",
      $isGraphicsElement: 1,
      $isTests: 1,
      "%": ";SVGGraphicsElement"
    },
    ImageElement0: {
      "^": "GraphicsElement;0height=,0width=,0x=,0y=,$ti",
      $isImageElement0: 1,
      $isUriReference: 1,
      "%": "SVGImageElement"
    },
    Length: {
      "^": "Interceptor;$ti",
      $isLength: 1,
      "%": ""
    },
    LengthList: {
      "^": "_LengthList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Length];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Length];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Length];
      },
      $isList: 1,
      $asList: function() {
        return [P.Length];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.Length];
      },
      $isLengthList: 1,
      "%": ""
    },
    LineElement: {
      "^": "GeometryElement;$ti",
      $isLineElement: 1,
      "%": "SVGLineElement"
    },
    LinearGradientElement: {
      "^": "_GradientElement;$ti",
      $isLinearGradientElement: 1,
      "%": "SVGLinearGradientElement"
    },
    MarkerElement: {
      "^": "SvgElement;$ti",
      $isFitToViewBox: 1,
      $isMarkerElement: 1,
      "%": "SVGMarkerElement"
    },
    MaskElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isMaskElement: 1,
      $isTests: 1,
      "%": "SVGMaskElement"
    },
    Matrix: {
      "^": "Interceptor;$ti",
      $isMatrix: 1,
      "%": ""
    },
    MetadataElement: {
      "^": "SvgElement;$ti",
      $isMetadataElement: 1,
      "%": "SVGMetadataElement"
    },
    Number: {
      "^": "Interceptor;$ti",
      $isNumber: 1,
      "%": ""
    },
    NumberList: {
      "^": "_NumberList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Number];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Number];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Number];
      },
      $isList: 1,
      $asList: function() {
        return [P.Number];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.Number];
      },
      $isNumberList: 1,
      "%": ""
    },
    PathElement: {
      "^": "GeometryElement;$ti",
      $isPathElement: 1,
      "%": "SVGPathElement"
    },
    PatternElement: {
      "^": "SvgElement;0height=,0width=,0x=,0y=,$ti",
      $isFitToViewBox: 1,
      $isPatternElement: 1,
      $isTests: 1,
      $isUriReference: 1,
      "%": "SVGPatternElement"
    },
    Point0: {
      "^": "Interceptor;$ti",
      $isPoint0: 1,
      "%": ""
    },
    PointList: {
      "^": "Interceptor;$ti",
      $isPointList: 1,
      "%": ""
    },
    PolygonElement: {
      "^": "GeometryElement;$ti",
      $isPolygonElement: 1,
      "%": "SVGPolygonElement"
    },
    PolylineElement: {
      "^": "GeometryElement;$ti",
      $isPolylineElement: 1,
      "%": "SVGPolylineElement"
    },
    PreserveAspectRatio: {
      "^": "Interceptor;$ti",
      $isPreserveAspectRatio: 1,
      "%": ""
    },
    RadialGradientElement: {
      "^": "_GradientElement;$ti",
      $isRadialGradientElement: 1,
      "%": "SVGRadialGradientElement"
    },
    Rect0: {
      "^": "Interceptor;$ti",
      $isRect0: 1,
      "%": ""
    },
    RectElement: {
      "^": "GeometryElement;0height=,0width=,0x=,0y=,$ti",
      $isRectElement: 1,
      "%": "SVGRectElement"
    },
    ScriptElement: {
      "^": "SvgElement;$ti",
      $isScriptElement: 1,
      $isUriReference: 1,
      "%": "SVGScriptElement"
    },
    SetElement: {
      "^": "AnimationElement;$ti",
      $isSetElement: 1,
      "%": "SVGSetElement"
    },
    StopElement: {
      "^": "SvgElement;$ti",
      $isStopElement: 1,
      "%": "SVGStopElement"
    },
    StringList: {
      "^": "_StringList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.String];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.String];
      },
      $isStringList: 1,
      "%": ""
    },
    StyleElement0: {
      "^": "SvgElement;$ti",
      $isStyleElement0: 1,
      "%": "SVGStyleElement"
    },
    AttributeClassSet: {
      "^": "CssClassSetImpl;_svg$_element,$ti",
      readClasses$0: [function() {
        var classname, t1, s, trimmed;
        classname = J.$index$asx(J.get$attributes$x(this._svg$_element), "class");
        t1 = P.String;
        s = P.LinkedHashSet_LinkedHashSet(null, null, null, t1);
        if (classname == null)
          return s;
        for (t1 = C.JSArray_methods.get$iterator(H.setRuntimeTypeInfo(classname.split(" "), [t1])); t1.moveNext$0();) {
          trimmed = J.trim$0$s(t1.get$current());
          if (!J.get$isEmpty$asx(trimmed))
            s.add$1(0, trimmed);
        }
        return s;
      }, null, "get$readClasses", 0, 0, null],
      writeClasses$1: [function(s) {
        J.setAttribute$2$x(this._svg$_element, "class", H.interceptedTypeCheck(s, "$isSet").join$1(0, " "));
      }, null, "get$writeClasses", 4, 0, null, 50],
      static: {
        AttributeClassSet$: [function(_element) {
          return new P.AttributeClassSet(_element, []);
        }, null, null, 4, 0, null, 92]
      }
    },
    SvgElement: {
      "^": "Element;$ti",
      get$classes: [function(receiver) {
        return P.AttributeClassSet$(receiver);
      }, null, null, 3, 0, null],
      get$children: [function(receiver) {
        return P.FilteredElementList$(receiver);
      }, null, null, 3, 0, null],
      createFragment$3$treeSanitizer$validator: [function(receiver, svg, treeSanitizer, validator) {
        var html, fragment, svgFragment, root, t1, t2;
        H.stringTypeCheck(svg);
        H.interceptedTypeCheck(validator, "$isNodeValidator");
        H.interceptedTypeCheck(treeSanitizer, "$isNodeTreeSanitizer");
        if (treeSanitizer == null) {
          if (validator == null) {
            validator = W.NodeValidatorBuilder$common();
            validator.allowSvg$0();
          }
          treeSanitizer = W.NodeTreeSanitizer_NodeTreeSanitizer(validator);
        }
        html = '<svg version="1.1">' + H.S(svg) + "</svg>";
        fragment = J.createFragment$2$treeSanitizer$x(J.get$body$x(W.document()), html, treeSanitizer);
        svgFragment = W.DocumentFragment_DocumentFragment();
        root = J.get$single$ax(J.get$nodes$x(fragment));
        for (t1 = J.getInterceptor$x(svgFragment); t2 = root.firstChild, t2 != null;)
          t1.append$1(svgFragment, t2);
        return svgFragment;
      }, function($receiver, svg, treeSanitizer) {
        return this.createFragment$3$treeSanitizer$validator($receiver, svg, treeSanitizer, null);
      }, "createFragment$2$treeSanitizer", null, null, "get$createFragment", 5, 5, null, 0, 0, 565, 117, 97],
      get$onChange: [function(receiver) {
        return C.EventStreamProvider_change.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onClick: [function(receiver) {
        return C.EventStreamProvider_click.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onDoubleClick: [function(receiver) {
        return C.EventStreamProvider_dblclick.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onKeyDown: [function(receiver) {
        return C.EventStreamProvider_keydown.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onMouseLeave: [function(receiver) {
        return C.EventStreamProvider_mouseleave.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onMouseMove: [function(receiver) {
        return C.EventStreamProvider_mousemove.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onMouseOver: [function(receiver) {
        return C.EventStreamProvider_mouseover.forElement$1(receiver);
      }, null, null, 3, 0, null],
      get$onScroll: [function(receiver) {
        return C.EventStreamProvider_scroll.forElement$1(receiver);
      }, null, null, 3, 0, null],
      $isNoncedElement: 1,
      $isSvgElement: 1,
      "%": ";SVGElement"
    },
    SvgSvgElement: {
      "^": "GraphicsElement;0height=,0width=,0x=,0y=,$ti",
      $isFitToViewBox: 1,
      $isSvgSvgElement: 1,
      $isZoomAndPan: 1,
      "%": "SVGSVGElement"
    },
    SwitchElement: {
      "^": "GraphicsElement;$ti",
      $isSwitchElement: 1,
      "%": "SVGSwitchElement"
    },
    SymbolElement: {
      "^": "SvgElement;$ti",
      $isFitToViewBox: 1,
      $isSymbolElement: 1,
      "%": "SVGSymbolElement"
    },
    TSpanElement: {
      "^": "TextPositioningElement;$ti",
      $isTSpanElement: 1,
      "%": "SVGTSpanElement"
    },
    Tests: {
      "^": "Interceptor;$ti"
    },
    TextContentElement: {
      "^": "GraphicsElement;$ti",
      $isTextContentElement: 1,
      "%": ";SVGTextContentElement"
    },
    TextElement: {
      "^": "TextPositioningElement;$ti",
      $isTextElement: 1,
      "%": "SVGTextElement"
    },
    TextPathElement: {
      "^": "TextContentElement;$ti",
      $isTextPathElement: 1,
      $isUriReference: 1,
      "%": "SVGTextPathElement"
    },
    TextPositioningElement: {
      "^": "TextContentElement;0x=,0y=,$ti",
      $isTextPositioningElement: 1,
      "%": ";SVGTextPositioningElement"
    },
    TitleElement0: {
      "^": "SvgElement;$ti",
      $isTitleElement0: 1,
      "%": "SVGTitleElement"
    },
    Transform: {
      "^": "Interceptor;$ti",
      $isTransform: 1,
      "%": ""
    },
    TransformList: {
      "^": "_TransformList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Transform];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Transform];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Transform];
      },
      $isList: 1,
      $asList: function() {
        return [P.Transform];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.Transform];
      },
      $isTransformList: 1,
      "%": ""
    },
    UnitTypes: {
      "^": "Interceptor;$ti",
      $isUnitTypes: 1,
      "%": ""
    },
    UriReference: {
      "^": "Interceptor;$ti"
    },
    UseElement: {
      "^": "GraphicsElement;0height=,0width=,0x=,0y=,$ti",
      $isUriReference: 1,
      $isUseElement: 1,
      "%": "SVGUseElement"
    },
    ViewElement: {
      "^": "SvgElement;$ti",
      $isFitToViewBox: 1,
      $isViewElement: 1,
      $isZoomAndPan: 1,
      "%": "SVGViewElement"
    },
    ZoomAndPan: {
      "^": "Interceptor;$ti"
    },
    _GradientElement: {
      "^": "SvgElement;$ti",
      $isUriReference: 1,
      $is_GradientElement: 1,
      "%": ";SVGGradientElement"
    },
    _SVGComponentTransferFunctionElement: {
      "^": "SvgElement;$ti",
      $is_SVGComponentTransferFunctionElement: 1,
      "%": ";SVGComponentTransferFunctionElement"
    },
    _SVGFEDropShadowElement: {
      "^": "SvgElement;$ti",
      $isFilterPrimitiveStandardAttributes: 1,
      $is_SVGFEDropShadowElement: 1,
      "%": "SVGFEDropShadowElement"
    },
    _SVGMPathElement: {
      "^": "SvgElement;$ti",
      $isUriReference: 1,
      $is_SVGMPathElement: 1,
      "%": "SVGMPathElement"
    },
    _LengthList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Length];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Length];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Length];
      },
      $isList: 1,
      $asList: function() {
        return [P.Length];
      }
    },
    _LengthList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_LengthList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Length];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Length];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Length];
      },
      $isList: 1,
      $asList: function() {
        return [P.Length];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.Length];
      }
    },
    _NumberList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Number];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Number];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Number];
      },
      $isList: 1,
      $asList: function() {
        return [P.Number];
      }
    },
    _NumberList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_NumberList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Number];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Number];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Number];
      },
      $isList: 1,
      $asList: function() {
        return [P.Number];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.Number];
      }
    },
    _StringList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.String];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      }
    },
    _StringList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_StringList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.String];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.String];
      },
      $isList: 1,
      $asList: function() {
        return [P.String];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.String];
      }
    },
    _TransformList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Transform];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Transform];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Transform];
      },
      $isList: 1,
      $asList: function() {
        return [P.Transform];
      }
    },
    _TransformList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_TransformList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Transform];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [P.Transform];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Transform];
      },
      $isList: 1,
      $asList: function() {
        return [P.Transform];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [P.Transform];
      }
    }
  }], ["dart.typed_data", "dart:typed_data",, P, {
    "^": "",
    ByteData_ByteData$view: [function(buffer, offsetInBytes, $length) {
      H.interceptedTypeCheck(buffer, "$isByteBuffer");
      return (buffer && C.NativeByteBuffer_methods).asByteData$2(buffer, H.intTypeCheck(offsetInBytes), H.intTypeCheck($length));
    }, null, null, 4, 4, null, 16, 0, 216, 136, 35],
    Uint8List_Uint8List$view: [function(buffer, offsetInBytes, $length) {
      H.interceptedTypeCheck(buffer, "$isByteBuffer");
      return (buffer && C.NativeByteBuffer_methods).asUint8List$2(buffer, H.intTypeCheck(offsetInBytes), H.intTypeCheck($length));
    }, null, null, 4, 4, null, 16, 0, 216, 136, 35],
    ByteBuffer: {
      "^": "Object;$ti"
    },
    TypedData: {
      "^": "Object;$ti"
    },
    _TypedIntList: {
      "^": "TypedData;$ti"
    },
    _TypedFloatList: {
      "^": "TypedData;$ti"
    },
    Endian: {
      "^": "Object;_littleEndian,$ti"
    },
    ByteData: {
      "^": "Object;$ti",
      $isTypedData: 1
    },
    Int8List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Uint8List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Uint8ClampedList: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Int16List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Uint16List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Int32List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Uint32List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Int64List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Uint64List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1
    },
    Float32List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isTypedData: 1,
      $is_TypedFloatList: 1
    },
    Float64List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $asList: function() {
        return [P.double];
      },
      $isTypedData: 1,
      $is_TypedFloatList: 1
    },
    Float32x4List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float32x4];
      },
      $isTypedData: 1
    },
    Int32x4List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Int32x4];
      },
      $isList: 1,
      $asList: function() {
        return [P.Int32x4];
      },
      $isTypedData: 1
    },
    Float64x2List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.Float64x2];
      },
      $isList: 1,
      $asList: function() {
        return [P.Float64x2];
      },
      $isTypedData: 1
    },
    Float32x4: {
      "^": "Object;$ti"
    },
    Int32x4: {
      "^": "Object;$ti"
    },
    Float64x2: {
      "^": "Object;$ti"
    },
    UnmodifiableByteBufferView: {
      "^": "Object;$ti",
      $isByteBuffer: 1
    },
    UnmodifiableByteDataView: {
      "^": "Object;$ti",
      $isTypedData: 1,
      $isByteData: 1
    },
    _UnmodifiableListMixin: {
      "^": "Object;$ti"
    },
    UnmodifiableUint8ListView: {
      "^": "_UnmodifiableUint8ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isUint8List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint8List, P.Uint8List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableInt8ListView: {
      "^": "_UnmodifiableInt8ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isInt8List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int8List, P.Int8List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableUint8ClampedListView: {
      "^": "_UnmodifiableUint8ClampedListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isUint8ClampedList: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint8ClampedList, P.Uint8ClampedList];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableUint16ListView: {
      "^": "_UnmodifiableUint16ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isUint16List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint16List, P.Uint16List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableInt16ListView: {
      "^": "_UnmodifiableInt16ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isInt16List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int16List, P.Int16List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableUint32ListView: {
      "^": "_UnmodifiableUint32ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isUint32List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint32List, P.Uint32List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableInt32ListView: {
      "^": "_UnmodifiableInt32ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isInt32List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int32List, P.Int32List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableUint64ListView: {
      "^": "_UnmodifiableUint64ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isUint64List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint64List, P.Uint64List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableInt64ListView: {
      "^": "_UnmodifiableInt64ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $isTypedData: 1,
      $is_TypedIntList: 1,
      $isInt64List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int64List, P.Int64List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    UnmodifiableInt32x4ListView: {
      "^": "_UnmodifiableInt32x4ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $asUnmodifiableListMixin: function() {
        return [P.Int32x4];
      },
      $asUnmodifiableListBase: function() {
        return [P.Int32x4];
      },
      $asListBase: function() {
        return [P.Int32x4];
      },
      $asListMixin: function() {
        return [P.Int32x4];
      },
      $asIterable: function() {
        return [P.Int32x4];
      },
      $asList: function() {
        return [P.Int32x4];
      },
      $isTypedData: 1,
      $isInt32x4List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.Int32x4, P.Int32x4List, P.Int32x4List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Int32x4];
      }
    },
    UnmodifiableFloat32x4ListView: {
      "^": "_UnmodifiableFloat32x4ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $asUnmodifiableListMixin: function() {
        return [P.Float32x4];
      },
      $asUnmodifiableListBase: function() {
        return [P.Float32x4];
      },
      $asListBase: function() {
        return [P.Float32x4];
      },
      $asListMixin: function() {
        return [P.Float32x4];
      },
      $asIterable: function() {
        return [P.Float32x4];
      },
      $asList: function() {
        return [P.Float32x4];
      },
      $isTypedData: 1,
      $isFloat32x4List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.Float32x4, P.Float32x4List, P.Float32x4List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Float32x4];
      }
    },
    UnmodifiableFloat64x2ListView: {
      "^": "_UnmodifiableFloat64x2ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $asUnmodifiableListMixin: function() {
        return [P.Float64x2];
      },
      $asUnmodifiableListBase: function() {
        return [P.Float64x2];
      },
      $asListBase: function() {
        return [P.Float64x2];
      },
      $asListMixin: function() {
        return [P.Float64x2];
      },
      $asIterable: function() {
        return [P.Float64x2];
      },
      $asList: function() {
        return [P.Float64x2];
      },
      $isTypedData: 1,
      $isFloat64x2List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.Float64x2, P.Float64x2List, P.Float64x2List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Float64x2];
      }
    },
    UnmodifiableFloat32ListView: {
      "^": "_UnmodifiableFloat32ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asUnmodifiableListMixin: function() {
        return [P.double];
      },
      $asUnmodifiableListBase: function() {
        return [P.double];
      },
      $asListBase: function() {
        return [P.double];
      },
      $asListMixin: function() {
        return [P.double];
      },
      $asIterable: function() {
        return [P.double];
      },
      $asList: function() {
        return [P.double];
      },
      $isTypedData: 1,
      $is_TypedFloatList: 1,
      $isFloat32List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.double, P.Float32List, P.Float32List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.double];
      }
    },
    UnmodifiableFloat64ListView: {
      "^": "_UnmodifiableFloat64ListView_UnmodifiableListBase__UnmodifiableListMixin;$ti",
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asUnmodifiableListMixin: function() {
        return [P.double];
      },
      $asUnmodifiableListBase: function() {
        return [P.double];
      },
      $asListBase: function() {
        return [P.double];
      },
      $asListMixin: function() {
        return [P.double];
      },
      $asIterable: function() {
        return [P.double];
      },
      $asList: function() {
        return [P.double];
      },
      $isTypedData: 1,
      $is_TypedFloatList: 1,
      $isFloat64List: 1,
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.double, P.Float64List, P.Float64List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.double];
      }
    },
    _UnmodifiableFloat32ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asUnmodifiableListMixin: function() {
        return [P.double];
      },
      $asUnmodifiableListBase: function() {
        return [P.double];
      },
      $asListBase: function() {
        return [P.double];
      },
      $asListMixin: function() {
        return [P.double];
      },
      $asIterable: function() {
        return [P.double];
      },
      $asList: function() {
        return [P.double];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.double, P.Float32List, P.Float32List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.double];
      }
    },
    _UnmodifiableFloat32x4ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $asUnmodifiableListMixin: function() {
        return [P.Float32x4];
      },
      $asUnmodifiableListBase: function() {
        return [P.Float32x4];
      },
      $asListBase: function() {
        return [P.Float32x4];
      },
      $asListMixin: function() {
        return [P.Float32x4];
      },
      $asIterable: function() {
        return [P.Float32x4];
      },
      $asList: function() {
        return [P.Float32x4];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.Float32x4, P.Float32x4List, P.Float32x4List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Float32x4];
      }
    },
    _UnmodifiableFloat64ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asUnmodifiableListMixin: function() {
        return [P.double];
      },
      $asUnmodifiableListBase: function() {
        return [P.double];
      },
      $asListBase: function() {
        return [P.double];
      },
      $asListMixin: function() {
        return [P.double];
      },
      $asIterable: function() {
        return [P.double];
      },
      $asList: function() {
        return [P.double];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.double, P.Float64List, P.Float64List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.double];
      }
    },
    _UnmodifiableFloat64x2ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Float64x2];
      },
      $asUnmodifiableListMixin: function() {
        return [P.Float64x2];
      },
      $asUnmodifiableListBase: function() {
        return [P.Float64x2];
      },
      $asListBase: function() {
        return [P.Float64x2];
      },
      $asListMixin: function() {
        return [P.Float64x2];
      },
      $asIterable: function() {
        return [P.Float64x2];
      },
      $asList: function() {
        return [P.Float64x2];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.Float64x2, P.Float64x2List, P.Float64x2List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Float64x2];
      }
    },
    _UnmodifiableInt16ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int16List, P.Int16List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableInt32ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int32List, P.Int32List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableInt32x4ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $asUnmodifiableListMixin: function() {
        return [P.Int32x4];
      },
      $asUnmodifiableListBase: function() {
        return [P.Int32x4];
      },
      $asListBase: function() {
        return [P.Int32x4];
      },
      $asListMixin: function() {
        return [P.Int32x4];
      },
      $asIterable: function() {
        return [P.Int32x4];
      },
      $asList: function() {
        return [P.Int32x4];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.Int32x4, P.Int32x4List, P.Int32x4List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Int32x4];
      }
    },
    _UnmodifiableInt64ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int64List, P.Int64List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableInt8ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Int8List, P.Int8List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableUint16ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint16List, P.Uint16List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableUint32ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint32List, P.Uint32List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableUint64ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint64List, P.Uint64List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableUint8ClampedListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint8ClampedList, P.Uint8ClampedList];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _UnmodifiableUint8ListView_UnmodifiableListBase__UnmodifiableListMixin: {
      "^": "UnmodifiableListBase;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $is_UnmodifiableListMixin: 1,
      $as_UnmodifiableListMixin: function() {
        return [P.int, P.Uint8List, P.Uint8List];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    }
  }], ["dart.dom.web_audio", "dart:web_audio",, P, {
    "^": "",
    AnalyserNode: {
      "^": "AudioNode;$ti",
      $isAnalyserNode: 1,
      "%": ""
    },
    AudioBuffer: {
      "^": "Interceptor;$ti",
      $isAudioBuffer: 1,
      "%": ""
    },
    AudioBufferSourceNode: {
      "^": "AudioScheduledSourceNode;$ti",
      $isAudioBufferSourceNode: 1,
      "%": ""
    },
    AudioContext: {
      "^": "BaseAudioContext;$ti",
      $isAudioContext: 1,
      "%": ""
    },
    AudioDestinationNode: {
      "^": "AudioNode;$ti",
      $isAudioDestinationNode: 1,
      "%": ""
    },
    AudioListener: {
      "^": "Interceptor;$ti",
      $isAudioListener: 1,
      "%": ""
    },
    AudioNode: {
      "^": "EventTarget;$ti",
      $isAudioNode: 1,
      "%": ""
    },
    AudioParam: {
      "^": "Interceptor;$ti",
      $isAudioParam: 1,
      "%": ""
    },
    AudioParamMap: {
      "^": "_AudioParamMap_Interceptor_MapMixin;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      },
      $isAudioParamMap: 1,
      "%": ""
    },
    AudioProcessingEvent: {
      "^": "Event;$ti",
      $isAudioProcessingEvent: 1,
      "%": "AudioProcessingEvent"
    },
    AudioScheduledSourceNode: {
      "^": "AudioNode;$ti",
      $isAudioScheduledSourceNode: 1,
      "%": ""
    },
    AudioTrack: {
      "^": "Interceptor;$ti",
      $isAudioTrack: 1,
      "%": ""
    },
    AudioTrackList: {
      "^": "EventTarget;$ti",
      $isAudioTrackList: 1,
      "%": ""
    },
    AudioWorkletGlobalScope: {
      "^": "WorkletGlobalScope;$ti",
      $isAudioWorkletGlobalScope: 1,
      "%": ""
    },
    AudioWorkletNode: {
      "^": "AudioNode;$ti",
      $isAudioWorkletNode: 1,
      "%": ""
    },
    AudioWorkletProcessor: {
      "^": "Interceptor;$ti",
      $isAudioWorkletProcessor: 1,
      "%": ""
    },
    BaseAudioContext: {
      "^": "EventTarget;$ti",
      $isBaseAudioContext: 1,
      "%": ""
    },
    BiquadFilterNode: {
      "^": "AudioNode;$ti",
      $isBiquadFilterNode: 1,
      "%": ""
    },
    ChannelMergerNode: {
      "^": "AudioNode;$ti",
      $isChannelMergerNode: 1,
      "%": ""
    },
    ChannelSplitterNode: {
      "^": "AudioNode;$ti",
      $isChannelSplitterNode: 1,
      "%": ""
    },
    ConstantSourceNode: {
      "^": "AudioScheduledSourceNode;$ti",
      $isConstantSourceNode: 1,
      "%": ""
    },
    ConvolverNode: {
      "^": "AudioNode;$ti",
      $isConvolverNode: 1,
      "%": ""
    },
    DelayNode: {
      "^": "AudioNode;$ti",
      $isDelayNode: 1,
      "%": ""
    },
    DynamicsCompressorNode: {
      "^": "AudioNode;$ti",
      $isDynamicsCompressorNode: 1,
      "%": ""
    },
    GainNode: {
      "^": "AudioNode;$ti",
      $isGainNode: 1,
      "%": ""
    },
    IirFilterNode: {
      "^": "AudioNode;$ti",
      $isIirFilterNode: 1,
      "%": ""
    },
    MediaElementAudioSourceNode: {
      "^": "AudioNode;$ti",
      $isMediaElementAudioSourceNode: 1,
      "%": ""
    },
    MediaStreamAudioDestinationNode: {
      "^": "AudioNode;$ti",
      $isMediaStreamAudioDestinationNode: 1,
      "%": ""
    },
    MediaStreamAudioSourceNode: {
      "^": "AudioNode;$ti",
      $isMediaStreamAudioSourceNode: 1,
      "%": ""
    },
    OfflineAudioCompletionEvent: {
      "^": "Event;$ti",
      $isOfflineAudioCompletionEvent: 1,
      "%": "OfflineAudioCompletionEvent"
    },
    OfflineAudioContext: {
      "^": "BaseAudioContext;$ti",
      $isOfflineAudioContext: 1,
      "%": ""
    },
    OscillatorNode: {
      "^": "AudioScheduledSourceNode;$ti",
      $isOscillatorNode: 1,
      "%": ""
    },
    PannerNode: {
      "^": "AudioNode;$ti",
      $isPannerNode: 1,
      "%": ""
    },
    PeriodicWave: {
      "^": "Interceptor;$ti",
      $isPeriodicWave: 1,
      "%": ""
    },
    ScriptProcessorNode: {
      "^": "AudioNode;$ti",
      $isScriptProcessorNode: 1,
      "%": ""
    },
    StereoPannerNode: {
      "^": "AudioNode;$ti",
      $isStereoPannerNode: 1,
      "%": ""
    },
    WaveShaperNode: {
      "^": "AudioNode;$ti",
      $isWaveShaperNode: 1,
      "%": ""
    },
    _AudioParamMap_Interceptor_MapMixin: {
      "^": "Interceptor;$ti",
      $isMapMixin: 1,
      $asMapMixin: function() {
        return [P.String, null];
      },
      $isMap: 1,
      $asMap: function() {
        return [P.String, null];
      }
    }
  }], ["dart.dom.web_gl", "dart:web_gl",, P, {
    "^": "",
    ActiveInfo: {
      "^": "Interceptor;$ti",
      $isActiveInfo: 1,
      "%": ""
    },
    AngleInstancedArrays: {
      "^": "Interceptor;$ti",
      $isAngleInstancedArrays: 1,
      "%": ""
    },
    Buffer: {
      "^": "Interceptor;$ti",
      $isBuffer: 1,
      "%": ""
    },
    Canvas: {
      "^": "Interceptor;$ti",
      $isCanvas: 1,
      "%": ""
    },
    ColorBufferFloat: {
      "^": "Interceptor;$ti",
      $isColorBufferFloat: 1,
      "%": ""
    },
    CompressedTextureAstc: {
      "^": "Interceptor;$ti",
      $isCompressedTextureAstc: 1,
      "%": ""
    },
    CompressedTextureAtc: {
      "^": "Interceptor;$ti",
      $isCompressedTextureAtc: 1,
      "%": ""
    },
    CompressedTextureETC1: {
      "^": "Interceptor;$ti",
      $isCompressedTextureETC1: 1,
      "%": ""
    },
    CompressedTextureEtc: {
      "^": "Interceptor;$ti",
      $isCompressedTextureEtc: 1,
      "%": ""
    },
    CompressedTexturePvrtc: {
      "^": "Interceptor;$ti",
      $isCompressedTexturePvrtc: 1,
      "%": ""
    },
    CompressedTextureS3TC: {
      "^": "Interceptor;$ti",
      $isCompressedTextureS3TC: 1,
      "%": ""
    },
    CompressedTextureS3TCsRgb: {
      "^": "Interceptor;$ti",
      $isCompressedTextureS3TCsRgb: 1,
      "%": ""
    },
    ContextEvent: {
      "^": "Event;$ti",
      $isContextEvent: 1,
      "%": "WebGLContextEvent"
    },
    DebugRendererInfo: {
      "^": "Interceptor;$ti",
      $isDebugRendererInfo: 1,
      "%": ""
    },
    DebugShaders: {
      "^": "Interceptor;$ti",
      $isDebugShaders: 1,
      "%": ""
    },
    DepthTexture: {
      "^": "Interceptor;$ti",
      $isDepthTexture: 1,
      "%": ""
    },
    DrawBuffers: {
      "^": "Interceptor;$ti",
      $isDrawBuffers: 1,
      "%": ""
    },
    EXTsRgb: {
      "^": "Interceptor;$ti",
      $isEXTsRgb: 1,
      "%": ""
    },
    ExtBlendMinMax: {
      "^": "Interceptor;$ti",
      $isExtBlendMinMax: 1,
      "%": ""
    },
    ExtColorBufferFloat: {
      "^": "Interceptor;$ti",
      $isExtColorBufferFloat: 1,
      "%": ""
    },
    ExtColorBufferHalfFloat: {
      "^": "Interceptor;$ti",
      $isExtColorBufferHalfFloat: 1,
      "%": ""
    },
    ExtDisjointTimerQuery: {
      "^": "Interceptor;$ti",
      $isExtDisjointTimerQuery: 1,
      "%": ""
    },
    ExtDisjointTimerQueryWebGL2: {
      "^": "Interceptor;$ti",
      $isExtDisjointTimerQueryWebGL2: 1,
      "%": ""
    },
    ExtFragDepth: {
      "^": "Interceptor;$ti",
      $isExtFragDepth: 1,
      "%": ""
    },
    ExtShaderTextureLod: {
      "^": "Interceptor;$ti",
      $isExtShaderTextureLod: 1,
      "%": ""
    },
    ExtTextureFilterAnisotropic: {
      "^": "Interceptor;$ti",
      $isExtTextureFilterAnisotropic: 1,
      "%": ""
    },
    Framebuffer: {
      "^": "Interceptor;$ti",
      $isFramebuffer: 1,
      "%": ""
    },
    GetBufferSubDataAsync: {
      "^": "Interceptor;$ti",
      $isGetBufferSubDataAsync: 1,
      "%": ""
    },
    LoseContext: {
      "^": "Interceptor;$ti",
      $isLoseContext: 1,
      "%": ""
    },
    OesElementIndexUint: {
      "^": "Interceptor;$ti",
      $isOesElementIndexUint: 1,
      "%": ""
    },
    OesStandardDerivatives: {
      "^": "Interceptor;$ti",
      $isOesStandardDerivatives: 1,
      "%": ""
    },
    OesTextureFloat: {
      "^": "Interceptor;$ti",
      $isOesTextureFloat: 1,
      "%": ""
    },
    OesTextureFloatLinear: {
      "^": "Interceptor;$ti",
      $isOesTextureFloatLinear: 1,
      "%": ""
    },
    OesTextureHalfFloat: {
      "^": "Interceptor;$ti",
      $isOesTextureHalfFloat: 1,
      "%": ""
    },
    OesTextureHalfFloatLinear: {
      "^": "Interceptor;$ti",
      $isOesTextureHalfFloatLinear: 1,
      "%": ""
    },
    OesVertexArrayObject: {
      "^": "Interceptor;$ti",
      $isOesVertexArrayObject: 1,
      "%": ""
    },
    Program: {
      "^": "Interceptor;$ti",
      $isProgram: 1,
      "%": ""
    },
    Query: {
      "^": "Interceptor;$ti",
      $isQuery: 1,
      "%": ""
    },
    Renderbuffer: {
      "^": "Interceptor;$ti",
      $isRenderbuffer: 1,
      "%": ""
    },
    RenderingContext: {
      "^": "Interceptor;$ti",
      $isCanvasRenderingContext: 1,
      $isRenderingContext: 1,
      "%": ""
    },
    RenderingContext2: {
      "^": "Interceptor;$ti",
      $isRenderingContext2: 1,
      $is_WebGL2RenderingContextBase: 1,
      $is_WebGLRenderingContextBase: 1,
      "%": ""
    },
    Sampler: {
      "^": "Interceptor;$ti",
      $isSampler: 1,
      "%": ""
    },
    Shader: {
      "^": "Interceptor;$ti",
      $isShader: 1,
      "%": ""
    },
    ShaderPrecisionFormat: {
      "^": "Interceptor;$ti",
      $isShaderPrecisionFormat: 1,
      "%": ""
    },
    Sync: {
      "^": "Interceptor;$ti",
      $isSync: 1,
      "%": ""
    },
    Texture: {
      "^": "Interceptor;$ti",
      $isTexture: 1,
      "%": ""
    },
    TimerQueryExt: {
      "^": "Interceptor;$ti",
      $isTimerQueryExt: 1,
      "%": ""
    },
    TransformFeedback: {
      "^": "Interceptor;$ti",
      $isTransformFeedback: 1,
      "%": ""
    },
    UniformLocation: {
      "^": "Interceptor;$ti",
      $isUniformLocation: 1,
      "%": ""
    },
    VertexArrayObject: {
      "^": "Interceptor;$ti",
      $isVertexArrayObject: 1,
      "%": ""
    },
    VertexArrayObjectOes: {
      "^": "Interceptor;$ti",
      $isVertexArrayObjectOes: 1,
      "%": ""
    },
    WebGL: {
      "^": "Interceptor;$ti",
      $isWebGL: 1,
      "%": ""
    },
    _WebGL2RenderingContextBase: {
      "^": "Interceptor;$ti",
      $is_WebGL2RenderingContextBase: 1,
      $is_WebGLRenderingContextBase: 1,
      "%": ""
    },
    _WebGLRenderingContextBase: {
      "^": "Interceptor;$ti"
    }
  }], ["dart.dom.web_sql", "dart:web_sql",, P, {
    "^": "",
    SqlDatabase: {
      "^": "Interceptor;$ti",
      $isSqlDatabase: 1,
      "%": ""
    },
    SqlError: {
      "^": "Interceptor;0code=,0message=,$ti",
      message$2$color: function($receiver, arg0, arg1) {
        return $receiver.message.call$2$color(arg0, arg1);
      },
      $isSqlError: 1,
      "%": "SQLError"
    },
    SqlResultSet: {
      "^": "Interceptor;$ti",
      $isSqlResultSet: 1,
      "%": ""
    },
    SqlResultSetRowList: {
      "^": "_SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [[P.Map,,,]];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [[P.Map,,,]];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [[P.Map,,,]];
      },
      $isList: 1,
      $asList: function() {
        return [[P.Map,,,]];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [[P.Map,,,]];
      },
      $isSqlResultSetRowList: 1,
      "%": ""
    },
    SqlTransaction: {
      "^": "Interceptor;$ti",
      $isSqlTransaction: 1,
      "%": ""
    },
    _SqlResultSetRowList_Interceptor_ListMixin: {
      "^": "Interceptor;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [[P.Map,,,]];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [[P.Map,,,]];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [[P.Map,,,]];
      },
      $isList: 1,
      $asList: function() {
        return [[P.Map,,,]];
      }
    },
    _SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin: {
      "^": "_SqlResultSetRowList_Interceptor_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [[P.Map,,,]];
      },
      $isListMixin: 1,
      $asListMixin: function() {
        return [[P.Map,,,]];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [[P.Map,,,]];
      },
      $isList: 1,
      $asList: function() {
        return [[P.Map,,,]];
      },
      $isImmutableListMixin: 1,
      $asImmutableListMixin: function() {
        return [[P.Map,,,]];
      }
    }
  }], ["codemirror", "package:codemirror/codemirror.dart",, X, {
    "^": "",
    CodeMirror: {
      "^": "ProxyHolder;0_doc,jsProxy,_events,$ti",
      CodeMirror$fromElement$2$options: [function(element, options) {
        J.$indexSet$ax($.$get$CodeMirror__instances(), this.jsProxy, this);
      }, null, null, 4, 3, null, 0, 10, 118],
      get$onGutterClick: [function() {
        return this.onEvent$1$2$argCount("gutterClick", 4, P.int);
      }, null, null, 2, 0, null],
      getDoc$0: [function() {
        var t1 = this._doc;
        if (t1 == null) {
          t1 = X.Doc$fromProxy(H.interceptedTypeCheck(this.call$1("getDoc"), "$isJsObject"));
          this._doc = t1;
        }
        return t1;
      }, null, "get$getDoc", 0, 0, null],
      setOption$2: [function(option, value) {
        return this.callArgs$2("setOption", [H.stringTypeCheck(option), value]);
      }, null, "get$setOption", 8, 0, null, 568, 1],
      setReadOnly$2: [function(value, noCursor) {
        H.boolTypeCheck(value);
        H.boolTypeCheck(noCursor);
        if (value)
          if (noCursor)
            this.setOption$2("readOnly", "nocursor");
          else
            this.setOption$2("readOnly", true);
        else
          this.setOption$2("readOnly", false);
      }, function(value) {
        return this.setReadOnly$2(value, false);
      }, "setReadOnly$1", null, null, "get$setReadOnly", 4, 2, null, 18, 1, 569],
      refresh$0: [function() {
        return this.call$1("refresh");
      }, null, "get$refresh", 0, 0, null],
      setGutterMarker$3: [function(line, gutterID, value) {
        this.callArgs$2("setGutterMarker", [H.intTypeCheck(line), H.stringTypeCheck(gutterID), H.interceptedTypeCheck(value, "$isElement")]);
      }, null, "get$setGutterMarker", 12, 0, null, 49, 406, 1],
      clearGutter$1: [function(gutterID) {
        this.callArg$2("clearGutter", H.stringTypeCheck(gutterID));
      }, null, "get$clearGutter", 4, 0, null, 406],
      addWidget$3: [function(pos, node, scrollIntoView) {
        H.interceptedTypeCheck(pos, "$isPosition");
        H.interceptedTypeCheck(node, "$isElement");
        H.boolTypeCheck(scrollIntoView);
        this.callArgs$2("addWidget", [pos.toProxy$0(), node, scrollIntoView]);
      }, function(pos, node) {
        return this.addWidget$3(pos, node, false);
      }, "addWidget$2", null, null, "get$addWidget", 8, 2, null, 18, 302, 23, 571],
      addLineClass$3: [function(line, where, cssClass) {
        H.stringTypeCheck(where);
        H.stringTypeCheck(cssClass);
        return X.LineHandle$(H.interceptedTypeCheck(this.callArgs$2("addLineClass", [line instanceof X.LineHandle ? line.jsProxy : line, where, cssClass]), "$isJsObject"));
      }, null, "get$addLineClass", 12, 0, null, 49, 407, 408],
      removeLineClass$3: [function(line, where, cssClass) {
        var l;
        H.stringTypeCheck(where);
        H.stringTypeCheck(cssClass);
        l = line instanceof X.LineHandle ? line.jsProxy : line;
        if (cssClass == null)
          return X.LineHandle$(H.interceptedTypeCheck(this.callArgs$2("removeLineClass", [l, where]), "$isJsObject"));
        else
          return X.LineHandle$(H.interceptedTypeCheck(this.callArgs$2("removeLineClass", [l, where, cssClass]), "$isJsObject"));
      }, null, "get$removeLineClass", 8, 2, null, 0, 49, 407, 408],
      scrollTo$2: [function(_, x, y) {
        return this.callArgs$2("scrollTo", [H.intTypeCheck(x), H.intTypeCheck(y)]);
      }, null, "get$scrollTo", 9, 0, null, 37, 77],
      getScrollInfo$0: [function() {
        return X.ScrollInfo$(H.interceptedTypeCheck(this.call$1("getScrollInfo"), "$isJsObject"));
      }, null, "get$getScrollInfo", 0, 0, null],
      scrollIntoView$3$margin: [function(_, line, ch, margin) {
        var t1, t2;
        H.intTypeCheck(line);
        H.intTypeCheck(ch);
        H.intTypeCheck(margin);
        t1 = P.String;
        t2 = P.int;
        if (margin != null)
          this.callArgs$2("scrollIntoView", [P.JsObject_JsObject$jsify(P.LinkedHashMap_LinkedHashMap$_literal(["line", line, "ch", ch], t1, t2)), margin]);
        else
          this.callArgs$2("scrollIntoView", [P.JsObject_JsObject$jsify(P.LinkedHashMap_LinkedHashMap$_literal(["line", line, "ch", ch], t1, t2))]);
      }, function($receiver, line, ch) {
        return this.scrollIntoView$3$margin($receiver, line, ch, null);
      }, "scrollIntoView$2", null, null, "get$scrollIntoView", 9, 3, null, 0, 49, 262, 574],
      static: {
        CodeMirror__cm: [function() {
          return H.interceptedTypeCheck(J.$index$asx($.$get$context(), "CodeMirror"), "$isJsObject");
        }, null, null, 2, 0, null],
        CodeMirror__createFromElement: [function(element, options) {
          H.interceptedTypeCheck(element, "$isElement");
          H.interceptedTypeCheck(options, "$isMap");
          if (options == null)
            return P.JsObject_JsObject(H.interceptedTypeCheck(X.CodeMirror__cm(), "$isJsFunction"), [element]);
          else
            return P.JsObject_JsObject(H.interceptedTypeCheck(X.CodeMirror__cm(), "$isJsFunction"), [element, R.jsify0(options)]);
        }, null, null, 8, 0, null, 10, 118],
        CodeMirror$fromElement: [function(element, options) {
          var t1 = new X.CodeMirror(X.CodeMirror__createFromElement(element, options), P.LinkedHashMap_LinkedHashMap$_empty(P.String, [R.JsEventListener,,]), []);
          t1.CodeMirror$fromElement$2$options(element, options);
          return t1;
        }, null, null, 4, 3, null, 0, 10, 118]
      }
    },
    Doc: {
      "^": "ProxyHolder;0_editor,jsProxy,_events,$ti",
      getValue$1: [function(separator) {
        return H.stringTypeCheck(this.callArg$2("getValue", H.stringTypeCheck(separator)));
      }, function() {
        return this.getValue$1(null);
      }, "getValue$0", null, null, "get$getValue", 0, 2, null, 0, 90],
      setValue$1: [function(value) {
        return this.callArg$2("setValue", H.stringTypeCheck(value));
      }, null, "get$setValue", 4, 0, null, 1],
      lastLine$0: [function() {
        return H.intTypeCheck(this.call$1("lastLine"));
      }, null, "get$lastLine", 0, 0, null],
      getLine$1: [function(n) {
        return H.stringTypeCheck(this.callArg$2("getLine", H.intTypeCheck(n)));
      }, null, "get$getLine", 4, 0, null, 72],
      replaceRange$4: [function(_, replacement, from, to, origin) {
        var t1;
        H.stringTypeCheck(replacement);
        H.interceptedTypeCheck(from, "$isPosition");
        H.interceptedTypeCheck(to, "$isPosition");
        H.stringTypeCheck(origin);
        if (origin != null)
          t1 = [replacement, from.toProxy$0(), to.toProxy$0(), origin];
        else {
          t1 = from.toProxy$0();
          t1 = [replacement, t1, to == null ? null : to.toProxy$0()];
        }
        this.callArgs$2("replaceRange", t1);
      }, function($receiver, replacement, from) {
        return this.replaceRange$4($receiver, replacement, from, null, null);
      }, "replaceRange$2", function($receiver, replacement, from, to) {
        return this.replaceRange$4($receiver, replacement, from, to, null);
      }, "replaceRange$3", null, null, null, "get$replaceRange", 9, 4, null, 0, 0, 115, 121, 222, 575],
      static: {
        Doc$fromProxy: [function(proxy) {
          return new X.Doc(proxy, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [R.JsEventListener,,]), []);
        }, null, null, 4, 0, null, 566]
      }
    },
    Position: {
      "^": "Object;line<,ch,$ti",
      toProxy$0: [function() {
        return R.jsify0(P.LinkedHashMap_LinkedHashMap$_literal(["line", this.line, "ch", this.ch], P.String, P.int));
      }, null, "get$toProxy", 0, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof X.Position && J.$eq$(this.line, other.line) && J.$eq$(this.ch, other.ch);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.get$hashCode$(J.$or$n(J.$shl$n(this.line, 8), this.ch));
      }, null, null, 3, 0, null],
      compareTo$1: [function(_, other) {
        var t1, t2, t3;
        H.interceptedTypeCheck(other, "$isPosition");
        t1 = this.line;
        t2 = other.line;
        t3 = J.getInterceptor$(t1);
        if (t3.$eq(t1, t2))
          return J.$sub$n(this.ch, other.ch);
        return t3.$sub(t1, t2);
      }, null, "get$compareTo", 5, 0, null, 3],
      $lt: [function(_, other) {
        return J.$lt$n(this.compareTo$1(0, H.interceptedTypeCheck(other, "$isPosition")), 0);
      }, null, "get$<", 5, 0, null, 3],
      $le: [function(_, other) {
        return J.$le$n(this.compareTo$1(0, H.interceptedTypeCheck(other, "$isPosition")), 0);
      }, null, "get$<=", 5, 0, null, 3],
      $ge: [function(_, other) {
        return J.$ge$n(this.compareTo$1(0, H.interceptedTypeCheck(other, "$isPosition")), 0);
      }, null, "get$>=", 5, 0, null, 3],
      $gt: [function(_, other) {
        return J.$gt$n(this.compareTo$1(0, H.interceptedTypeCheck(other, "$isPosition")), 0);
      }, null, "get$>", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[" + H.S(this.line) + ":" + H.S(this.ch) + "]";
      }, null, "get$toString", 1, 0, null],
      $isComparable: 1,
      $asComparable: function() {
        return [X.Position];
      },
      static: {
        Position$: [function(line, ch) {
          return new X.Position(line, ch, []);
        }, null, null, 8, 0, null, 49, 262]
      }
    },
    ModeInfo: {
      "^": "ProxyHolder;$ti"
    },
    Span: {
      "^": "Object;$ti"
    },
    TextMarker: {
      "^": "ProxyHolder;$ti"
    },
    LineWidget: {
      "^": "ProxyHolder;$ti"
    },
    LineHandle: {
      "^": "ProxyHolder;jsProxy,_events,$ti",
      get$height: [function(_) {
        return H.numTypeCheck(J.$index$asx(this.jsProxy, "height"));
      }, null, null, 3, 0, null],
      static: {
        LineHandle$: [function(jsProxy) {
          return new X.LineHandle(jsProxy, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [R.JsEventListener,,]), []);
        }, null, null, 4, 0, null, 405]
      }
    },
    ScrollInfo: {
      "^": "ProxyHolder;jsProxy,_events,$ti",
      get$left: [function(_) {
        return H.intTypeCheck(J.$index$asx(this.jsProxy, "left"));
      }, null, null, 3, 0, null],
      get$top: [function(_) {
        return H.intTypeCheck(J.$index$asx(this.jsProxy, "top"));
      }, null, null, 3, 0, null],
      get$width: [function(_) {
        return H.intTypeCheck(J.$index$asx(this.jsProxy, "width"));
      }, null, null, 3, 0, null],
      get$height: [function(_) {
        return H.intTypeCheck(J.$index$asx(this.jsProxy, "height"));
      }, null, null, 3, 0, null],
      static: {
        ScrollInfo$: [function(jsProxy) {
          return new X.ScrollInfo(jsProxy, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [R.JsEventListener,,]), []);
        }, null, null, 4, 0, null, 405]
      }
    },
    Token: {
      "^": "Object;$ti"
    },
    ProxyHolder: {
      "^": "Object;$ti",
      call$1: [function(methodName) {
        return this.jsProxy.callMethod$1(H.stringTypeCheck(methodName));
      }, null, "get$$call", 4, 0, null, 46],
      callArg$2: [function(methodName, arg) {
        return this.jsProxy.callMethod$2(H.stringTypeCheck(methodName), [arg]);
      }, null, "get$callArg", 8, 0, null, 46, 44],
      callArgs$2: [function(methodName, args) {
        return this.jsProxy.callMethod$2(H.stringTypeCheck(methodName), H.listTypeCheck(args));
      }, null, "get$callArgs", 8, 0, null, 46, 71],
      onEvent$1$2$argCount: [1, function(eventName, argCount, $T) {
        var t1, t2, t3;
        H.stringTypeCheck(eventName);
        H.intTypeCheck(argCount);
        t1 = this._events;
        if (!t1.containsKey$1(eventName))
          if (argCount === 4)
            J.$indexSet$ax(t1, eventName, R.JsEventListener$(this.jsProxy, eventName, argCount, new X.ProxyHolder_onEvent_closure(), $T));
          else if (argCount === 3)
            J.$indexSet$ax(t1, eventName, R.JsEventListener$(this.jsProxy, eventName, argCount, new X.ProxyHolder_onEvent_closure0(), $T));
          else {
            t2 = J.getInterceptor$ax(t1);
            t3 = this.jsProxy;
            if (argCount === 2)
              t2.$indexSet(t1, eventName, R.JsEventListener$(t3, eventName, argCount, null, $T));
            else
              t2.$indexSet(t1, eventName, R.JsEventListener$(t3, eventName, 1, null, $T));
          }
        return H.assertSubtype(J.get$stream$z(J.$index$asx(t1, eventName)), "$isStream", [$T], "$asStream");
      }, function(eventName, argCount) {
        return this.onEvent$1$2$argCount(eventName, argCount, null);
      }, "onEvent$2$argCount", function(eventName) {
        return this.onEvent$1$2$argCount(eventName, 1, null);
      }, "onEvent$1", null, "call$2$argCount", null, "get$onEvent", 4, 3, null, 205, 409, 410],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.jsProxy);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof X.ProxyHolder && J.$eq$(this.jsProxy, other.jsProxy);
      }, null, "get$==", 5, 0, null, 3]
    },
    ProxyHolder_onEvent_closure: {
      "^": "Closure:166;$ti",
      call$3: [function(a, b, c) {
        return a;
      }, null, null, 12, 0, null, 33, 54, 70, "call"]
    },
    ProxyHolder_onEvent_closure0: {
      "^": "Closure:67;$ti",
      call$2: [function(a, b) {
        return a;
      }, null, null, 8, 0, null, 33, 54, "call"]
    }
  }], ["codemirror.js_utils", "package:codemirror/src/js_utils.dart",, R, {
    "^": "",
    jsify0: [function(object) {
      return P.JsObject_JsObject$jsify(object);
    }, null, null, 4, 0, null, 9],
    JsEventListener: {
      "^": "Object;_proxy<,_js_utils$_name<,cvtEvent<,argCount<,0_js_utils$_controller<,0_callback<,$ti",
      set$_js_utils$_controller: function(_controller) {
        this._js_utils$_controller = H.assertSubtype(_controller, "$isStreamController", this.$ti, "$asStreamController");
      },
      set$_callback: function(_callback) {
        this._callback = H.interceptedTypeCheck(_callback, "$isJsFunction");
      },
      get$stream: [function(_) {
        if (this._js_utils$_controller == null)
          this.set$_js_utils$_controller(P.StreamController_StreamController$broadcast(new R.JsEventListener_stream_closure(this), new R.JsEventListener_stream_closure0(this), true, H.getTypeArgumentByIndex(this, 0)));
        return J.get$stream$z(this._js_utils$_controller);
      }, null, null, 3, 0, null],
      cvtEvent$1: function(arg0) {
        return this.cvtEvent.call$1(arg0);
      },
      cvtEvent$2: function(arg0, arg1) {
        return this.cvtEvent.call$2(arg0, arg1);
      },
      cvtEvent$3: function(arg0, arg1, arg2) {
        return this.cvtEvent.call$3(arg0, arg1, arg2);
      },
      static: {
        JsEventListener$: [function(_proxy, _name, argCount, cvtEvent, $T) {
          return new R.JsEventListener(_proxy, _name, cvtEvent, argCount, [$T]);
        }, null, null, 8, 5, null, 205, 0, 550, 293, 410, 580]
      }
    },
    JsEventListener_stream_closure0: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        if (J.$eq$(t1.get$argCount(), 4))
          t1.set$_callback(H.interceptedTypeCheck(t1.get$_proxy().callMethod$2("on", [t1.get$_js_utils$_name(), new R.JsEventListener_stream__closure(t1)]), "$isJsFunction"));
        else if (J.$eq$(t1.get$argCount(), 3))
          t1.set$_callback(H.interceptedTypeCheck(t1.get$_proxy().callMethod$2("on", [t1.get$_js_utils$_name(), new R.JsEventListener_stream__closure0(t1)]), "$isJsFunction"));
        else if (J.$eq$(t1.get$argCount(), 2))
          t1.set$_callback(H.interceptedTypeCheck(t1.get$_proxy().callMethod$2("on", [t1.get$_js_utils$_name(), new R.JsEventListener_stream__closure1(t1)]), "$isJsFunction"));
        else
          t1.set$_callback(H.interceptedTypeCheck(t1.get$_proxy().callMethod$2("on", [t1.get$_js_utils$_name(), new R.JsEventListener_stream__closure2(t1)]), "$isJsFunction"));
      }, null, null, 0, 0, null, "call"]
    },
    JsEventListener_stream__closure: {
      "^": "Closure:172;$this,$ti",
      call$4: [function(obj, a, b, c) {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = t1.get$_js_utils$_controller();
        t3 = t1.get$cvtEvent() == null ? a : t1.cvtEvent$3(a, b, c);
        J.add$1$ax(t2, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
      }, null, null, 16, 0, null, 85, 33, 54, 70, "call"]
    },
    JsEventListener_stream__closure0: {
      "^": "Closure:174;$this,$ti",
      call$3: [function(obj, a, b) {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = t1.get$_js_utils$_controller();
        t3 = t1.get$cvtEvent() == null ? a : t1.cvtEvent$2(a, b);
        J.add$1$ax(t2, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
      }, null, null, 12, 0, null, 85, 33, 54, "call"]
    },
    JsEventListener_stream__closure1: {
      "^": "Closure:9;$this,$ti",
      call$2: [function(obj, a) {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = t1.get$_js_utils$_controller();
        t3 = t1.get$cvtEvent() == null ? a : t1.cvtEvent$1(a);
        J.add$1$ax(t2, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
      }, null, null, 8, 0, null, 85, 33, "call"]
    },
    JsEventListener_stream__closure2: {
      "^": "Closure:4;$this,$ti",
      call$1: [function(obj) {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = t1.get$_js_utils$_controller();
        t3 = t1.get$cvtEvent() == null ? null : t1.cvtEvent$1(obj);
        J.add$1$ax(t2, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
      }, null, null, 4, 0, null, 85, "call"]
    },
    JsEventListener_stream_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$_proxy().callMethod$2("off", [t1.get$_js_utils$_name(), t1.get$_callback()]);
        t1.set$_callback(null);
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:collection/src/canonicalized_map.dart",, M, {
    "^": "",
    _isToStringVisiting0: [function(o) {
      return J.any$1$ax($.$get$_toStringVisiting0(), new M._isToStringVisiting_closure(o));
    }, null, null, 4, 0, null, 25],
    CanonicalizedMap: {
      "^": "Object;$ti",
      CanonicalizedMap$from$3$isValidKey: [function(other, canonicalize, isValidKey, $C, $K, $V) {
        this.addAll$1(0, other);
      }, null, null, 8, 3, null, 0, 3, 411, 297],
      $index: [function(_, key) {
        var pair;
        if (!this._isValidKey$1(key))
          return;
        pair = J.$index$asx(this._base, this._canonicalize.call$1(H.subtypeOfRuntimeTypeCast(key, H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1))));
        return pair == null ? null : pair.last;
      }, null, "get$[]", 5, 0, null, 4],
      $indexSet: [function(_, key, value) {
        var t1, t2;
        t1 = H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1);
        H.assertSubtypeOfRuntimeType(key, t1);
        t2 = H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2);
        H.assertSubtypeOfRuntimeType(value, t2);
        if (!this._isValidKey$1(key))
          return;
        J.$indexSet$ax(this._base, this._canonicalize.call$1(key), B.Pair$(key, value, t1, t2));
      }, null, "get$[]=", 9, 0, null, 4, 1],
      addAll$1: [function(_, other) {
        H.assertSubtype(other, "$isMap", [H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2)], "$asMap").forEach$1(0, new M.CanonicalizedMap_addAll_closure(this));
      }, null, "get$addAll", 5, 0, null, 3],
      cast$2$0: [1, function(_, K2, V2) {
        return J.cast$2$0$ax(this._base, K2, V2);
      }, function($receiver) {
        return this.cast$2$0($receiver, null, null);
      }, "cast$0", null, "call$0", "get$cast", 1, 0, null],
      clear$0: [function(_) {
        J.clear$0$ax(this._base);
      }, null, "get$clear", 1, 0, null],
      containsKey$1: [function(key) {
        if (!this._isValidKey$1(key))
          return false;
        return this._base.containsKey$1(this._canonicalize.call$1(H.subtypeOfRuntimeTypeCast(key, H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1))));
      }, null, "get$containsKey", 4, 0, null, 4],
      get$entries: [function(_) {
        return J.map$1$1$ax(J.get$entries$z(this._base), new M.CanonicalizedMap_entries_closure(this), [P.MapEntry, H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2)]);
      }, null, null, 3, 0, null],
      forEach$1: [function(_, f) {
        J.forEach$1$ax(this._base, new M.CanonicalizedMap_forEach_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2)]})));
      }, null, "get$forEach", 5, 0, null, 15],
      get$isEmpty: [function(_) {
        return J.get$isEmpty$asx(this._base);
      }, null, null, 3, 0, null],
      get$isNotEmpty: [function(_) {
        return J.get$isNotEmpty$asx(this._base);
      }, null, null, 3, 0, null],
      get$keys: [function() {
        return J.map$1$1$ax(J.get$values$z(this._base), new M.CanonicalizedMap_keys_closure(this), H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1));
      }, null, null, 2, 0, null],
      get$length: [function(_) {
        return J.get$length$asx(this._base);
      }, null, null, 3, 0, null],
      map$2$1: [1, function(_, transform, K2, V2) {
        return J.map$2$1$ax(this._base, new M.CanonicalizedMap_map_closure(this, H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2)]}), K2, V2), K2, V2);
      }, function($receiver, transform) {
        return this.map$2$1($receiver, transform, null, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 204],
      putIfAbsent$2: [function(key, ifAbsent) {
        H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1));
        H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2)});
        return J.get$last$ax(this._base.putIfAbsent$2(this._canonicalize.call$1(key), new M.CanonicalizedMap_putIfAbsent_closure(this, key, ifAbsent)));
      }, null, "get$putIfAbsent", 8, 0, null, 4, 101],
      remove$1: [function(_, key) {
        var pair;
        if (!this._isValidKey$1(key))
          return;
        pair = J.remove$1$ax(this._base, this._canonicalize.call$1(H.subtypeOfRuntimeTypeCast(key, H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1))));
        return pair == null ? null : pair.last;
      }, null, "get$remove", 5, 0, null, 4],
      get$values: [function(_) {
        return J.map$1$1$ax(J.get$values$z(this._base), new M.CanonicalizedMap_values_closure(this), H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2));
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        var t1, result;
        t1 = {};
        if (M._isToStringVisiting0(this))
          return "{...}";
        result = P.StringBuffer$("");
        try {
          J.add$1$ax($.$get$_toStringVisiting0(), this);
          result.write$1("{");
          t1.first = true;
          this.forEach$1(0, new M.CanonicalizedMap_toString_closure(t1, this, result));
          result.write$1("}");
        } finally {
          J.removeLast$0$ax($.$get$_toStringVisiting0());
        }
        return J.toString$0$(result);
      }, null, "get$toString", 1, 0, null],
      _isValidKey$1: [function(key) {
        var t1;
        if (key == null || H.checkSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1))) {
          t1 = this._isValidKeyFn;
          t1 = t1 == null || t1.call$1(key);
        } else
          t1 = false;
        return t1;
      }, null, "get$_isValidKey", 4, 0, null, 4],
      $isMap: 1,
      $asMap: function($C, $K, $V) {
        return [$K, $V];
      }
    },
    CanonicalizedMap_addAll_closure: {
      "^": "Closure;$this,$ti",
      call$2: [function(key, value) {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1));
        H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2));
        t2.$indexSet(t1, key, value);
        return value;
      }, null, null, 8, 0, null, 4, 1, "call"],
      $signature: function() {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2);
        return {func: 1, ret: t3, args: [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), t3]};
      }
    },
    CanonicalizedMap_addEntries_closure: {
      "^": "Closure;$ti"
    },
    CanonicalizedMap_entries_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(e) {
        var t1, t2, t3, t4;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1);
        t4 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2);
        t1 = H.assertSubtype(e, "$isMapEntry", [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 0), [B.Pair, t3, t4]], "$asMapEntry").value;
        t2 = J.getInterceptor$ax(t1);
        return P.MapEntry$_(t2.get$first(t1), t2.get$last(t1), t3, t4);
      }, null, null, 4, 0, null, 19, "call"],
      $signature: function() {
        var t1, t2, t3, t4;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1);
        t4 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2);
        return {func: 1, ret: [P.MapEntry, t3, t4], args: [[P.MapEntry, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 0), [B.Pair, t3, t4]]]};
      }
    },
    CanonicalizedMap_forEach_closure: {
      "^": "Closure;$this,f,$ti",
      call$2: [function(key, pair) {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 0));
        H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)], "$asPair");
        return this.f.call$2(pair.first, pair.last);
      }, null, null, 8, 0, null, 4, 191, "call"],
      $signature: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        return {func: 1, ret: -1, args: [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 0), [B.Pair, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)]]};
      }
    },
    CanonicalizedMap_keys_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(pair) {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        return H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)], "$asPair").first;
      }, null, null, 4, 0, null, 191, "call"],
      $signature: function() {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1);
        return {func: 1, ret: t3, args: [[B.Pair, t3, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)]]};
      }
    },
    CanonicalizedMap_map_closure: {
      "^": "Closure;$this,transform,K2,V2,$ti",
      call$2: [function(_, pair) {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        H.assertSubtypeOfRuntimeType(_, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 0));
        H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)], "$asPair");
        return this.transform.call$2(pair.first, pair.last);
      }, null, null, 8, 0, null, 12, 191, "call"],
      $signature: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        return {func: 1, ret: [P.MapEntry, this.K2, this.V2], args: [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 0), [B.Pair, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)]]};
      }
    },
    CanonicalizedMap_putIfAbsent_closure: {
      "^": "Closure;$this,key,ifAbsent,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        return B.Pair$(this.key, this.ifAbsent.call$0(), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2));
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        return {func: 1, ret: [B.Pair, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)]};
      }
    },
    CanonicalizedMap_values_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(pair) {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        return H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)], "$asPair").last;
      }, null, null, 4, 0, null, 191, "call"],
      $signature: function() {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2);
        return {func: 1, ret: t3, args: [[B.Pair, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), t3]]};
      }
    },
    CanonicalizedMap_toString_closure: {
      "^": "Closure;_box_0,$this,result,$ti",
      call$2: [function(k, v) {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        H.assertSubtypeOfRuntimeType(k, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1));
        H.assertSubtypeOfRuntimeType(v, H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2));
        t1 = this._box_0;
        if (!t1.first)
          this.result.write$1(", ");
        t1.first = false;
        this.result.write$1(H.S(k) + ": " + H.S(v));
      }, null, null, 8, 0, null, 253, 112, "call"],
      $signature: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$(t1);
        return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgumentIntercepted(t2, t1, "CanonicalizedMap", 2)]};
      }
    },
    _isToStringVisiting_closure: {
      "^": "Closure:17;o,$ti",
      call$1: [function(e) {
        var t1 = this.o;
        return t1 == null ? e == null : t1 === e;
      }, null, null, 4, 0, null, 19, "call"]
    }
  }], ["", "package:collection/src/combined_wrappers/combined_iterable.dart",, S, {
    "^": "",
    CombinedIterableView: {
      "^": "IterableBase;$ti"
    },
    _CombinedIterator: {
      "^": "Object;$ti",
      $isIterator: 1
    }
  }], ["", "package:collection/src/combined_wrappers/combined_list.dart",, B, {
    "^": "",
    CombinedListView: {
      "^": "ListBase;$ti",
      $isUnmodifiableListMixin: 1,
      $isUnmodifiableListBase: 1,
      $isUnmodifiableListView: 1
    }
  }], ["", "package:collection/src/combined_wrappers/combined_map.dart",, L, {
    "^": "",
    CombinedMapView: {
      "^": "UnmodifiableMapBase;$ti"
    }
  }], ["", "package:collection/src/empty_unmodifiable_set.dart",, O, {
    "^": "",
    EmptyUnmodifiableSet: {
      "^": "IterableBase;$ti",
      $isEfficientLengthIterable: 1,
      $isSet: 1,
      $isUnmodifiableSetView: 1,
      $isUnmodifiableSetMixin: 1,
      $is_DelegatingIterableBase: 1,
      $isDelegatingIterable: 1,
      $isDelegatingSet: 1,
      $is_UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin: 1
    }
  }], ["", "package:collection/src/equality.dart",, U, {
    "^": "",
    Equality: {
      "^": "Object;$ti"
    },
    EqualityBy: {
      "^": "Object;$ti",
      $isEquality: 1,
      $asEquality: function($E, $F) {
        return [$E];
      }
    },
    DefaultEquality: {
      "^": "Object;$ti",
      $isEquality: 1
    },
    IdentityEquality: {
      "^": "Object;$ti",
      $isEquality: 1
    },
    IterableEquality: {
      "^": "Object;$ti",
      $isEquality: 1,
      $asEquality: function($E) {
        return [[P.Iterable, $E]];
      }
    },
    ListEquality: {
      "^": "Object;$ti",
      $isEquality: 1,
      $asEquality: function($E) {
        return [[P.List, $E]];
      }
    },
    _UnorderedEquality: {
      "^": "Object;$ti",
      $isEquality: 1,
      $asEquality: function($E, $T) {
        return [$T];
      }
    },
    UnorderedIterableEquality: {
      "^": "_UnorderedEquality;$ti",
      $asEquality: function($E) {
        return [[P.Iterable, $E]];
      },
      $as_UnorderedEquality: function($E) {
        return [$E, [P.Iterable, $E]];
      }
    },
    SetEquality: {
      "^": "_UnorderedEquality;$ti",
      $asEquality: function($E) {
        return [[P.Set, $E]];
      },
      $as_UnorderedEquality: function($E) {
        return [$E, [P.Set, $E]];
      }
    },
    _MapEntry: {
      "^": "Object;$ti"
    },
    MapEquality: {
      "^": "Object;$ti",
      $isEquality: 1,
      $asEquality: function($K, $V) {
        return [[P.Map, $K, $V]];
      }
    },
    MultiEquality: {
      "^": "Object;$ti",
      $isEquality: 1
    },
    DeepCollectionEquality: {
      "^": "Object;$ti",
      $isEquality: 1,
      $asEquality: Isolate.functionThatReturnsNull
    },
    CaseInsensitiveEquality: {
      "^": "Object;$ti",
      $isEquality: 1,
      $asEquality: function() {
        return [P.String];
      }
    }
  }], ["", "package:collection/src/equality_map.dart",, N, {
    "^": "",
    EqualityMap: {
      "^": "DelegatingMap;$ti"
    }
  }], ["", "package:collection/src/equality_set.dart",, E, {
    "^": "",
    EqualitySet: {
      "^": "DelegatingSet;$ti"
    }
  }], ["", "package:collection/src/iterable_zip.dart",, A, {
    "^": "",
    IterableZip: {
      "^": "IterableBase;$ti",
      $asIterableBase: function($T) {
        return [[P.List, $T]];
      },
      $asIterable: function($T) {
        return [[P.List, $T]];
      }
    },
    _IteratorZip: {
      "^": "Object;$ti",
      $isIterator: 1,
      $asIterator: function($T) {
        return [[P.List, $T]];
      }
    }
  }], ["", "package:collection/src/priority_queue.dart",, Y, {
    "^": "",
    PriorityQueue: {
      "^": "Object;$ti"
    },
    HeapPriorityQueue: {
      "^": "Object;$ti",
      $isPriorityQueue: 1
    }
  }], ["", "package:collection/src/queue_list.dart",, Q, {
    "^": "",
    QueueList: {
      "^": "_QueueList_Object_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isListMixin: 1,
      $isQueue: 1,
      $isIterable: 1,
      $isList: 1
    },
    _CastQueueList: {
      "^": "QueueList;$ti",
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asListMixin: function($S, $T) {
        return [$T];
      },
      $asQueue: function($S, $T) {
        return [$T];
      },
      $asIterable: function($S, $T) {
        return [$T];
      },
      $asList: function($S, $T) {
        return [$T];
      },
      $asQueueList: function($S, $T) {
        return [$T];
      },
      $as_QueueList_Object_ListMixin: function($S, $T) {
        return [$T];
      }
    },
    _QueueList_Object_ListMixin: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isListMixin: 1,
      $isIterable: 1,
      $isList: 1
    }
  }], ["", "package:collection/src/union_set.dart",, M, {
    "^": "",
    UnionSet: {
      "^": "_UnionSet_SetBase_UnmodifiableSetMixin;$ti",
      $isUnmodifiableSetMixin: 1
    },
    _UnionSet_SetBase_UnmodifiableSetMixin: {
      "^": "SetBase;$ti",
      $isUnmodifiableSetMixin: 1
    }
  }], ["", "package:collection/src/union_set_controller.dart",, Y, {
    "^": "",
    UnionSetController: {
      "^": "Object;$ti"
    }
  }], ["", "package:collection/src/unmodifiable_wrappers.dart",, L, {
    "^": "",
    NonGrowableListView: {
      "^": "_NonGrowableListView_DelegatingList_NonGrowableListMixin;$ti",
      $isNonGrowableListMixin: 1
    },
    NonGrowableListMixin: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1
    },
    UnmodifiableSetView: {
      "^": "_UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin;$ti",
      $isUnmodifiableSetMixin: 1
    },
    UnmodifiableSetMixin: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isSet: 1
    },
    UnmodifiableMapMixin: {
      "^": "Object;$ti",
      $isMap: 1
    },
    _NonGrowableListView_DelegatingList_NonGrowableListMixin: {
      "^": "DelegatingList;$ti",
      $isNonGrowableListMixin: 1
    },
    _UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin: {
      "^": "DelegatingSet;$ti",
      $isUnmodifiableSetMixin: 1
    }
  }], ["", "package:collection/src/utils.dart",, B, {
    "^": "",
    Pair: {
      "^": "Object;first>,last>,$ti",
      static: {
        Pair$: [function(first, last, $E, $F) {
          return new B.Pair(first, last, [$E, $F]);
        }, null, null, 8, 0, null, 583, 584]
      }
    }
  }], ["", "package:collection/src/wrappers.dart",, M, {
    "^": "",
    _DelegatingIterableBase: {
      "^": "Object;$ti",
      $isIterable: 1
    },
    DelegatingIterable: {
      "^": "_DelegatingIterableBase;$ti"
    },
    DelegatingList: {
      "^": "DelegatingIterable;$ti",
      $isEfficientLengthIterable: 1,
      $isList: 1
    },
    DelegatingSet: {
      "^": "DelegatingIterable;$ti",
      $isEfficientLengthIterable: 1,
      $isSet: 1
    },
    DelegatingQueue: {
      "^": "DelegatingIterable;$ti",
      $isEfficientLengthIterable: 1,
      $isQueue: 1
    },
    DelegatingMap: {
      "^": "Object;$ti",
      $isMap: 1
    },
    MapKeySet: {
      "^": "_MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isSet: 1,
      $isUnmodifiableSetMixin: 1
    },
    MapValueSet: {
      "^": "_DelegatingIterableBase;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($K, $V) {
        return [$V];
      },
      $asIterable: function($K, $V) {
        return [$V];
      },
      $isSet: 1,
      $asSet: function($K, $V) {
        return [$V];
      },
      $as_DelegatingIterableBase: function($K, $V) {
        return [$V];
      }
    },
    _MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin: {
      "^": "_DelegatingIterableBase;$ti",
      $isEfficientLengthIterable: 1,
      $isSet: 1,
      $isUnmodifiableSetMixin: 1
    }
  }], ["", "package:devtools/src/charts/charts.dart",, O, {
    "^": "",
    LineChart: {
      "^": "Object;0_windowResizeSubscription,parent>,0dim,0data>,$ti",
      set$_windowResizeSubscription: function(_windowResizeSubscription) {
        this._windowResizeSubscription = H.assertSubtype(_windowResizeSubscription, "$isStreamSubscription", [W.Event], "$asStreamSubscription");
      },
      set$dim: function(dim) {
        this.dim = H.assertSubtype(dim, "$isPoint", [P.int], "$asPoint");
      },
      set$data: function(_, data) {
        this.data = H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "LineChart", 0));
      },
      LineChart$2$classes: [function($parent, classes, $T) {
        var t1, t2;
        t1 = this.parent;
        J.set$position$x(J.get$style$x(t1.get$element()), "relative");
        this.set$_windowResizeSubscription(J.get$onResize$x(W.window()).listen$1(new O.LineChart_closure(this)));
        P.Timer_run(this.get$_updateSize());
        t2 = A.div(null, classes, null);
        t2.layoutVertical$0();
        J.flex$0$z(t2);
        t2 = H.interceptedTypeCheck(J.add$1$ax(t1, t2), "$isCoreElement");
        this.chartElement = t2;
        t2.setInnerHtml$1(0, '<svg viewBox="0 0 500 98">\n<polyline fill="none" stroke="#0074d9" stroke-width="2" points=""/>\n</svg>\n');
      }, null, null, 4, 3, null, 0, 24, 190],
      _updateSize$0: [function() {
        if (!this.get$isMounted())
          return;
        var rect = J.getBoundingClientRect$0$x(this.chartElement.get$element());
        if (J.$eq$((rect && C._DomRect_methods).get$width(rect), 0) || J.$eq$(C._DomRect_methods.get$height(rect), 0))
          return;
        J.setAttribute$2$x(J.get$first$ax(J.get$children$x(this.chartElement.get$element())), "viewBox", "0 0 " + H.S(C._DomRect_methods.get$width(rect)) + " 98");
        this.set$dim(P.Point$(J.toInt$0$n(C._DomRect_methods.get$width(rect)), J.toInt$0$n(C._DomRect_methods.get$height(rect)), P.int));
        if (this.data != null)
          this._charts$_state.setState$1(new O.LineChart__updateSize_closure(this));
      }, "call$0", "get$_updateSize", 0, 0, 0],
      set$disabled: [function(_, value) {
        J.set$disabled$z(this.parent, H.boolTypeCheck(value));
      }, null, null, 7, 0, null, 1],
      updateFrom$1: [function(data) {
        H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "LineChart", 0));
        this.set$data(0, data);
        this.update$1(data);
      }, null, "get$updateFrom", 4, 0, null, 34],
      get$isMounted: [function() {
        return J.get$parent$x(this.chartElement.get$element()) != null;
      }, null, null, 2, 0, null]
    },
    LineChart_closure: {
      "^": "Closure:58;$this,$ti",
      call$1: [function(e) {
        H.interceptedTypeCheck(e, "$isEvent");
        return this.$this._updateSize$0();
      }, null, null, 4, 0, null, 19, "call"]
    },
    LineChart__updateSize_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.update$1(J.get$data$x(t1));
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:devtools/src/core/message_bus.dart",, A, {
    "^": "",
    BusEvent: {
      "^": "Object;type,data>,$ti",
      toString$0: [function(_) {
        return this.type;
      }, null, "get$toString", 1, 0, null],
      static: {
        BusEvent$: [function(type, data) {
          return new A.BusEvent(type, data, []);
        }, null, null, 4, 3, null, 0, 29, 34]
      }
    },
    MessageBus: {
      "^": "Object;0_message_bus$_controller,$ti",
      set$_message_bus$_controller: function(_controller) {
        this._message_bus$_controller = H.assertSubtype(_controller, "$isStreamController", [A.BusEvent], "$asStreamController");
      },
      MessageBus$0: [function() {
        this.set$_message_bus$_controller(P.StreamController_StreamController$broadcast(null, null, false, A.BusEvent));
      }, null, null, 0, 0, null],
      onEvent$1$type: [function(type) {
        var t1;
        H.stringTypeCheck(type);
        t1 = this._message_bus$_controller;
        if (type == null)
          return J.get$stream$z(t1);
        else
          return J.where$1$ax(J.get$stream$z(t1), new A.MessageBus_onEvent_closure(type));
      }, null, "get$onEvent", 0, 3, null, 0, 29],
      addEvent$1: [function($event) {
        H.interceptedTypeCheck($event, "$isBusEvent");
        J.add$1$ax(this._message_bus$_controller, $event);
      }, null, "get$addEvent", 4, 0, null, 22],
      static: {
        MessageBus$: [function() {
          var t1 = new A.MessageBus([]);
          t1.MessageBus$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    MessageBus_onEvent_closure: {
      "^": "Closure:188;type,$ti",
      call$1: [function($event) {
        return J.$eq$(H.interceptedTypeCheck($event, "$isBusEvent").type, this.type);
      }, null, null, 4, 0, null, 22, "call"]
    }
  }], ["", "package:devtools/src/debugger/debugger.dart",, X, {
    "^": "",
    _breakpointComparator: [function(a, b) {
      var t1, t2, aRef, bRef, compare;
      H.interceptedTypeCheck(a, "$isBreakpoint");
      H.interceptedTypeCheck(b, "$isBreakpoint");
      t1 = new X._breakpointComparator_getRef();
      t2 = new X._breakpointComparator_getPos();
      aRef = t1.call$1(a.location);
      bRef = t1.call$1(b.location);
      compare = J.compareTo$1$ns(aRef.uri, bRef.uri);
      if (compare !== 0)
        return compare;
      return J.$sub$n(t2.call$1(a.location), t2.call$1(b.location));
    }, "call$2", "debugger___breakpointComparator$closure", 8, 0, 215, 33, 54],
    DebuggerScreen: {
      "^": "Screen;debuggerState<,_initialized,0deviceStatus<,0_breakpointsCountDiv,0_sourcePathDiv<,0sourceEditor<,0callStackView<,0variablesView<,0breakpointsView<,0scriptsView<,0consoleArea<,name,id,iconClass,0framework,_visible,statusItems,$ti",
      DebuggerScreen$0: [function() {
        var t1 = N.StatusItem$();
        this.deviceStatus = t1;
        this.addStatusItem$1(t1);
      }, null, null, 0, 0, null],
      createContent$1: [function(framework) {
        var t1, screenDiv, resumeButton, pauseButton, t2, t3, t4, breakOnExceptionControl, t5, t6, t7, t8, t9, stepIn, stepOver, stepOut, t10, sourceArea, consoleDiv, navEditorPanels, options, codeMirror;
        t1 = {};
        H.interceptedTypeCheck(framework, "$isFramework");
        screenDiv = A.div(null, null, null);
        screenDiv.layoutVertical$0();
        resumeButton = N.PButton$icon("Resume", C.UrlIcon_ww8, null);
        resumeButton.primary$0();
        resumeButton.small$0();
        resumeButton.clazz$1("margin-left");
        resumeButton.set$disabled(0, true);
        pauseButton = N.PButton$icon("Pause", C.UrlIcon_bhs, null);
        pauseButton.small$0();
        t2 = new X.DebuggerScreen_createContent__updateResumeButton(resumeButton);
        t3 = new X.DebuggerScreen_createContent__updatePauseButton(pauseButton);
        resumeButton.click$1(0, new X.DebuggerScreen_createContent_closure(this, t2));
        pauseButton.click$1(0, new X.DebuggerScreen_createContent_closure0(this, t3));
        t4 = this.debuggerState;
        t4.get$onPausedChanged().listen$1(new X.DebuggerScreen_createContent_closure1(t3, t2));
        t1.stepOver = null;
        t1.stepIn = null;
        t1.stepOut = null;
        breakOnExceptionControl = X.BreakOnExceptionControl$();
        breakOnExceptionControl.get$onPauseModeChanged().listen$1(new X.DebuggerScreen_createContent_closure2(this));
        t4.get$onExceptionPauseModeChanged().listen$1(new X.DebuggerScreen_createContent_closure3(breakOnExceptionControl));
        this.consoleArea = X.ConsoleArea$();
        t2 = A.div(null, "section", null);
        t3 = J.getInterceptor$z(t2);
        t3.flex$0(t2);
        t2.layoutHorizontal$0();
        t5 = A.div(null, "debugger-menu", null);
        t5.layoutVertical$0();
        t6 = [A.CoreElement];
        J.add$1$ax(t5, H.setRuntimeTypeInfo([this._buildMenuNav$0()], t6));
        t7 = A.div(null, null, null);
        J.set$overflowX$x(J.get$style$x(t7.get$element()), "hidden");
        t7.layoutVertical$0();
        t8 = A.div(null, "section", null);
        t8.layoutHorizontal$0();
        t9 = A.div(null, "btn-group flex-no-wrap margin-left", null);
        stepIn = N.PButton$(null);
        stepIn.add$1(0, H.setRuntimeTypeInfo([A.span(null, "octicon octicon-chevron-down", null), A.span(null, null, "Step in")], t6));
        stepIn.small$0();
        t1.stepIn = stepIn;
        stepOver = N.PButton$(null);
        stepOver.add$1(0, H.setRuntimeTypeInfo([A.span(null, "octicon octicon-chevron-right", null), A.span(null, null, "Step over")], t6));
        stepOver.small$0();
        t1.stepOver = stepOver;
        stepOut = N.PButton$(null);
        stepOut.add$1(0, H.setRuntimeTypeInfo([A.span(null, "octicon octicon-chevron-up", null), A.span(null, null, "Step out")], t6));
        stepOut.small$0();
        t1.stepOut = stepOut;
        J.add$1$ax(t9, H.setRuntimeTypeInfo([stepIn, stepOver, stepOut], t6));
        t10 = A.div(null, null, null);
        J.flex$0$z(t10);
        J.add$1$ax(t8, H.setRuntimeTypeInfo([pauseButton, resumeButton, t9, t10, breakOnExceptionControl], t6));
        sourceArea = A.div(null, "section table-border", null);
        sourceArea.layoutVertical$0();
        t10 = H.interceptedTypeCheck(A.div(null, "source-head", null), "$isCoreElement");
        this._sourcePathDiv = t10;
        J.add$1$ax(sourceArea, H.setRuntimeTypeInfo([t10], t6));
        consoleDiv = A.div(null, "section table-border", null);
        consoleDiv.layoutVertical$0();
        J.add$1$ax(consoleDiv, this.consoleArea.get$element());
        J.add$1$ax(t7, H.setRuntimeTypeInfo([t8, sourceArea, consoleDiv], t6));
        navEditorPanels = H.setRuntimeTypeInfo([t5, t7], t6);
        t3.add$1(t2, navEditorPanels);
        J.add$1$ax(screenDiv, H.setRuntimeTypeInfo([t2], t6));
        J.setInnerHtml$1$x(this._sourcePathDiv, "&nbsp;");
        t6 = [P.num];
        t2 = H.setRuntimeTypeInfo([22, 78], t6);
        A.flexSplit(navEditorPanels, 12, true, H.setRuntimeTypeInfo([200, 600], t6), t2);
        t2 = H.setRuntimeTypeInfo([80, 20], t6);
        A.flexSplit([sourceArea, consoleDiv], 12, false, H.setRuntimeTypeInfo([200, 60], t6), t2);
        t4.get$onSupportsStepping().listen$1(new X.DebuggerScreen_createContent_closure4(t1, this));
        J.click$1$z(t1.stepOver, new X.DebuggerScreen_createContent_closure5(this));
        J.click$1$z(t1.stepIn, new X.DebuggerScreen_createContent_closure6(this));
        J.click$1$z(t1.stepOut, new X.DebuggerScreen_createContent_closure7(this));
        t1 = P.String;
        options = P.LinkedHashMap_LinkedHashMap$_literal(["mode", "dart", "lineNumbers", true, "gutters", H.setRuntimeTypeInfo(["breakpoints"], [t1])], t1, null);
        codeMirror = X.CodeMirror$fromElement(sourceArea.element, options);
        codeMirror.setReadOnly$1(true);
        J.setAttribute$2$x(J.$index$asx(J.get$children$x(J.get$parent$x(this._sourcePathDiv.get$element())), 1), "flex", "");
        this.sourceEditor = X.SourceEditor$(codeMirror, t4);
        t4.get$onBreakpointsChanged().listen$1(new X.DebuggerScreen_createContent_closure8(this));
        t4.get$onPausedChanged().listen$1(new X.DebuggerScreen_createContent_closure9(this));
        t4.get$onPausedChanged().listen$1(new X.DebuggerScreen_createContent_closure10(this));
        this.callStackView.get$onSelectionChanged().listen$1(new X.DebuggerScreen_createContent_closure11(this));
        this.consoleArea.refresh$0();
        E.messageBus().onEvent$1$type("reload.start").listen$1(new X.DebuggerScreen_createContent_closure12(this));
        E.messageBus().onEvent$1$type("reload.end").listen$1(new X.DebuggerScreen_createContent_closure13(this));
        E.messageBus().onEvent$1$type("restart.start").listen$1(new X.DebuggerScreen_createContent_closure14(this));
        E.messageBus().onEvent$1$type("restart.end").listen$1(new X.DebuggerScreen_createContent_closure15(this));
        return screenDiv;
      }, null, "get$createContent", 4, 0, null, 127],
      entering$0: [function() {
        if (!this._initialized)
          this._initialize$0();
      }, null, "get$entering", 0, 0, null],
      _initialize$0: [function() {
        this._initialized = true;
        E.serviceManager().get$onConnectionAvailable().listen$1(this.get$_handleConnectionStart());
        if (E.serviceManager().get$hasConnection())
          this._handleConnectionStart$1(E.serviceManager().get$service());
        E.serviceManager().get$isolateManager().get$onSelectedIsolateChanged().listen$1(this.get$_handleIsolateChanged());
        E.serviceManager().get$onConnectionClosed().listen$1(this.get$_handleConnectionStop());
      }, null, "get$_initialize", 0, 0, null],
      _buildMenuNav$0: [function() {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, scriptCountDiv, menu;
        t1 = {};
        this.callStackView = X.CallStackView$();
        t2 = this.debuggerState;
        this.variablesView = X.VariablesView$(t2, new X.DebuggerScreen__buildMenuNav_closure(this));
        t3 = H.interceptedTypeCheck(A.span(null, "counter", "0"), "$isCoreElement");
        this._breakpointsCountDiv = t3;
        t3 = X.BreakpointsView$(t3, t2, t2.get$getShortScriptName());
        this.breakpointsView = t3;
        t3.get$onDoubleClick(t3).listen$1(new X.DebuggerScreen__buildMenuNav_closure0(this));
        t1.scriptCountDiv = null;
        t3 = X.ScriptsView$(t2.get$getShortScriptName());
        this.scriptsView = t3;
        t3.get$onSelectionChanged().listen$1(new X.DebuggerScreen__buildMenuNav_closure1(this));
        this.scriptsView.get$onScriptsChanged().listen$1(new X.DebuggerScreen__buildMenuNav_closure2(t1, this));
        t3 = N.PNavMenuItem$("Call stack");
        t3.click$1(0, new X.DebuggerScreen__buildMenuNav_closure3(this));
        t4 = this.callStackView.get$element();
        t5 = N.PNavMenuItem$("Variables");
        t5.click$1(0, new X.DebuggerScreen__buildMenuNav_closure4(this));
        t6 = this.variablesView.get$element();
        t7 = N.PNavMenuItem$("Breakpoints");
        t7.add$1(0, this._breakpointsCountDiv);
        t7.click$1(0, new X.DebuggerScreen__buildMenuNav_closure5(this));
        t8 = this.breakpointsView.get$element();
        t9 = N.PNavMenuItem$("Scripts");
        scriptCountDiv = A.span(null, "counter", "0");
        t1.scriptCountDiv = scriptCountDiv;
        t9.add$1(0, scriptCountDiv);
        t9.click$1(0, new X.DebuggerScreen__buildMenuNav_closure6(this));
        menu = N.PNavMenu$(H.setRuntimeTypeInfo([t3, t4, t5, t6, t7, t8, t9, this.scriptsView.get$element()], [A.CoreElement]), false);
        menu.flex$0(0);
        menu.layoutVertical$0();
        t2.get$onBreakpointsChanged().listen$1(new X.DebuggerScreen__buildMenuNav_closure7(this));
        return menu;
      }, null, "get$_buildMenuNav", 0, 0, null],
      _handleConnectionStart$1: [function(service) {
        H.interceptedTypeCheck(service, "$isVmService");
        this.debuggerState.setVmService$1(E.serviceManager().get$service());
        service.get$onStdoutEvent().listen$1(new X.DebuggerScreen__handleConnectionStart_closure(this));
        service.get$onStderrEvent().listen$1(new X.DebuggerScreen__handleConnectionStart_closure0(this));
        if (E.serviceManager().get$isolateManager().get$selectedIsolate() != null)
          this._handleIsolateChanged$1(E.serviceManager().get$isolateManager().get$selectedIsolate());
      }, "call$1", "get$_handleConnectionStart", 4, 0, 46, 74],
      _handleIsolateChanged$1: [function(isolateRef) {
        var t1;
        H.interceptedTypeCheck(isolateRef, "$isIsolateRef");
        if (isolateRef == null) {
          this.scriptsView.clearScripts$0();
          this.debuggerState.switchToIsolate$1(isolateRef);
          return;
        }
        t1 = this.debuggerState;
        if (isolateRef.$eq(0, t1.get$isolateRef()))
          return;
        t1.switchToIsolate$1(isolateRef);
        E.serviceManager().get$service().getIsolate$1(isolateRef.id).then$1$1(new X.DebuggerScreen__handleIsolateChanged_closure(this), null).catchError$1(new X.DebuggerScreen__handleIsolateChanged_closure0(this));
      }, "call$1", "get$_handleIsolateChanged", 4, 0, 199, 179],
      _handleConnectionStop$1: [function($event) {
        var t1;
        J.set$text$x(this.deviceStatus.get$element(), "");
        this.scriptsView.clearScripts$0();
        t1 = this.debuggerState;
        t1.switchToIsolate$1(null);
        t1.dispose$0();
      }, "call$1", "get$_handleConnectionStop", 4, 0, 6, 22],
      _populateFromIsolate$1: [function(isolate) {
        return this._populateFromIsolate$body$DebuggerScreen(H.interceptedTypeCheck(isolate, "$isIsolate"));
      }, null, "get$_populateFromIsolate", 4, 0, null, 255],
      _populateFromIsolate$body$DebuggerScreen: [function(isolate) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, scripts, t1, t2, isRunning, $async$temp1;
        var $async$_populateFromIsolate$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$temp1 = J;
                $async$goto = 2;
                return P._asyncAwait(E.serviceManager().get$service().getScripts$1(isolate.id), $async$_populateFromIsolate$1);
              case 2:
                // returning from await.
                scripts = $async$temp1.toList$0$ax($async$result.scripts);
                t1 = $async$self.debuggerState;
                t1.set$scripts(scripts);
                t1.setRootLib$1(isolate.rootLib);
                t1.updateFrom$1(isolate);
                t2 = isolate.pauseEvent;
                isRunning = t2 == null || J.$eq$(J.get$kind$x(t2), "Resume");
                $async$self.scriptsView.showScripts$4$selectRootScript(scripts, t1.get$rootLib().get$uri(), t1.get$commonScriptPrefix(), isRunning);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_populateFromIsolate$1, $async$completer);
      }, null, null, 4, 0, null, 255],
      _displaySource$1: [function(script) {
        var t1;
        H.interceptedTypeCheck(script, "$isScript");
        t1 = this._sourcePathDiv;
        if (script == null) {
          J.setInnerHtml$1$x(t1, "&nbsp;");
          this.sourceEditor.displayScript$1(script);
        } else {
          J.set$text$x(t1, script.uri);
          this.sourceEditor.displayScript$1(script);
        }
      }, null, "get$_displaySource", 4, 0, null, 128],
      _retrieveFullStringValue$1: [function(stringRef) {
        return this._retrieveFullStringValue$body$DebuggerScreen(H.interceptedTypeCheck(stringRef, "$isInstanceRef"));
      }, null, "get$_retrieveFullStringValue", 4, 0, null, 256],
      _retrieveFullStringValue$body$DebuggerScreen: [function(stringRef) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this, result;
        var $async$_retrieveFullStringValue$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (!J.$eq$(stringRef.valueAsStringIsTruncated, true)) {
                  $async$returnValue = stringRef.valueAsString;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait(E.serviceManager().get$service().getObject$4$count$offset(J.get$id$z($async$self.debuggerState.get$isolateRef()), stringRef.id, stringRef.length, 0), $async$_retrieveFullStringValue$1);
              case 3:
                // returning from await.
                result = $async$result;
                if (result instanceof S.Instance) {
                  $async$returnValue = result.valueAsString;
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  $async$returnValue = H.S(stringRef.valueAsString) + "...";
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_retrieveFullStringValue$1, $async$completer);
      }, null, null, 4, 0, null, 256],
      static: {
        DebuggerScreen$: [function() {
          var t1 = new X.DebuggerScreen(X.DebuggerState$(), false, "Debugger", "debugger", "octicon-bug", B.Property$(false, P.bool), H.setRuntimeTypeInfo([], [N.StatusItem]), []);
          t1.DebuggerScreen$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    DebuggerScreen_createContent__updateResumeButton: {
      "^": "Closure:68;resumeButton,$ti",
      call$1$disabled: [function(disabled) {
        var t1;
        H.boolTypeCheck(disabled);
        t1 = this.resumeButton;
        J.set$disabled$z(t1, disabled);
        t1.changeIcon$1(disabled ? "/icons/general/resume_white_disabled@2x.png" : "/icons/general/resume_white@2x.png");
      }, function() {
        return this.call$1$disabled(null);
      }, "call$0", null, null, null, 0, 3, null, 0, 418, "call"]
    },
    DebuggerScreen_createContent__updatePauseButton: {
      "^": "Closure:68;pauseButton,$ti",
      call$1$disabled: [function(disabled) {
        var t1;
        H.boolTypeCheck(disabled);
        t1 = this.pauseButton;
        J.set$disabled$z(t1, disabled);
        t1.changeIcon$1(disabled ? "/icons/general/pause_black_disabled@2x.png" : "/icons/general/pause_black@2x.png");
      }, function() {
        return this.call$1$disabled(null);
      }, "call$0", null, null, null, 0, 3, null, 0, 418, "call"]
    },
    DebuggerScreen_createContent_closure: {
      "^": "Closure:32;$this,_updateResumeButton,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._updateResumeButton;
                t1.call$1$disabled(true);
                $async$goto = 2;
                return P._asyncAwait($async$self.$this.get$debuggerState().resume$0(), $async$call$0);
              case 2:
                // returning from await.
                t1.call$1$disabled(false);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen_createContent_closure0: {
      "^": "Closure:32;$this,_updatePauseButton,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._updatePauseButton;
                t1.call$1$disabled(true);
                $async$goto = 2;
                return P._asyncAwait(J.pause$0$z($async$self.$this.get$debuggerState()), $async$call$0);
              case 2:
                // returning from await.
                t1.call$1$disabled(false);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen_createContent_closure1: {
      "^": "Closure:16;_updatePauseButton,_updateResumeButton,$ti",
      call$1: [function(isPaused) {
        H.boolTypeCheck(isPaused);
        this._updatePauseButton.call$1$disabled(isPaused);
        this._updateResumeButton.call$1$disabled(!isPaused);
      }, null, null, 4, 0, null, 599, "call"]
    },
    DebuggerScreen_createContent_closure2: {
      "^": "Closure:15;$this,$ti",
      call$1: [function(mode) {
        H.stringTypeCheck(mode);
        this.$this.get$debuggerState().setExceptionPauseMode$1(mode);
      }, null, null, 4, 0, null, 177, "call"]
    },
    DebuggerScreen_createContent_closure3: {
      "^": "Closure:15;breakOnExceptionControl,$ti",
      call$1: [function(mode) {
        this.breakOnExceptionControl.set$exceptionPauseMode(H.stringTypeCheck(mode));
      }, null, null, 4, 0, null, 177, "call"]
    },
    DebuggerScreen_createContent_closure4: {
      "^": "Closure:16;_box_0,$this,$ti",
      call$1: [function(value) {
        var t1, t2;
        H.boolTypeCheck(value);
        t1 = this._box_0;
        t1.stepIn.set$enabled(value);
        t2 = t1.stepOver;
        t2.set$enabled(value && this.$this.get$debuggerState().get$_lastEvent().get$topFrame() != null);
        t1 = t1.stepOut;
        t1.set$enabled(value && this.$this.get$debuggerState().get$_lastEvent().get$topFrame() != null);
      }, null, null, 4, 0, null, 1, "call"]
    },
    DebuggerScreen_createContent_closure5: {
      "^": "Closure:24;$this,$ti",
      call$0: [function() {
        return this.$this.get$debuggerState().stepOver$0();
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen_createContent_closure6: {
      "^": "Closure:24;$this,$ti",
      call$0: [function() {
        return this.$this.get$debuggerState().stepIn$0();
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen_createContent_closure7: {
      "^": "Closure:24;$this,$ti",
      call$0: [function() {
        return this.$this.get$debuggerState().stepOut$0();
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen_createContent_closure8: {
      "^": "Closure:214;$this,$ti",
      call$1: [function(breakpoints) {
        return this.$call$body$DebuggerScreen_createContent_closure2(H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList"));
      }, null, null, 4, 0, null, 176, "call"],
      $call$body$DebuggerScreen_createContent_closure2: [function(breakpoints) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$self = this;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$self.$this.get$sourceEditor().setBreakpoints$1(breakpoints);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 176]
    },
    DebuggerScreen_createContent_closure9: {
      "^": "Closure:63;$this,$ti",
      call$1: [function(paused) {
        return this.$call$body$DebuggerScreen_createContent_closure1(H.boolTypeCheck(paused));
      }, null, null, 4, 0, null, 178, "call"],
      $call$body$DebuggerScreen_createContent_closure1: [function(paused) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$self = this, t1, stack, $frames, reportedException, t2, frame, newFrame, t3, newVars, t4, frames0;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = paused ? 2 : 4;
                break;
              case 2:
                // then
                $async$goto = 5;
                return P._asyncAwait(t1.get$debuggerState().getStack$0(), $async$call$1);
              case 5:
                // returning from await.
                stack = $async$result;
                $frames = stack.asyncCausalFrames;
                if ($frames == null)
                  $frames = stack.frames;
                reportedException = t1.get$debuggerState().get$reportedException();
                if (reportedException != null && J.get$isNotEmpty$asx($frames)) {
                  t2 = J.getInterceptor$ax($frames);
                  frame = t2.get$first($frames);
                  newFrame = S.Frame$();
                  newFrame.type = H.stringTypeCheck(frame.type);
                  newFrame.index = H.intTypeCheck(frame.index);
                  newFrame.$function = H.interceptedTypeCheck(frame.$function, "$isFuncRef");
                  newFrame.code = H.interceptedTypeCheck(frame.code, "$isCodeRef");
                  newFrame.location = H.interceptedTypeCheck(frame.location, "$isSourceLocation");
                  newFrame.kind = H.stringTypeCheck(frame.kind);
                  t3 = [S.BoundVariable];
                  newVars = H.setRuntimeTypeInfo([], t3);
                  t4 = S.BoundVariable$();
                  t4.name = "<exception>";
                  t4.value = reportedException;
                  C.JSArray_methods.add$1(newVars, t4);
                  t4 = frame.vars;
                  C.JSArray_methods.addAll$1(newVars, t4 == null ? H.setRuntimeTypeInfo([], t3) : t4);
                  newFrame.set$vars(newVars);
                  frames0 = H.setRuntimeTypeInfo([newFrame], [S.Frame]);
                  C.JSArray_methods.addAll$1(frames0, t2.sublist$1($frames, 1));
                  $frames = frames0;
                }
                t1.get$callStackView().showFrames$2$selectTop($frames, true);
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                t1.get$callStackView().clearFrames$0();
                t1.get$sourceEditor().clearExecutionPoint$0();
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 178]
    },
    DebuggerScreen_createContent_closure10: {
      "^": "Closure:63;$this,$ti",
      call$1: [function(paused) {
        return this.$call$body$DebuggerScreen_createContent_closure0(H.boolTypeCheck(paused));
      }, null, null, 4, 0, null, 178, "call"],
      $call$body$DebuggerScreen_createContent_closure0: [function(paused) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$self = this, t1, t2, topFrame, scriptRef, script, position, t3, file;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = paused && $async$self.$this.get$debuggerState().get$_lastEvent().get$topFrame() != null;
                t2 = $async$self.$this;
                $async$goto = t1 ? 2 : 4;
                break;
              case 2:
                // then
                topFrame = t2.get$debuggerState().get$_lastEvent().get$topFrame();
                scriptRef = topFrame.location.get$script();
                $async$goto = 5;
                return P._asyncAwait(t2.get$debuggerState().getScript$1(scriptRef), $async$call$1);
              case 5:
                // returning from await.
                script = $async$result;
                position = t2.get$debuggerState().calculatePosition$2(script, topFrame.location.get$tokenPos());
                t1 = scriptRef.uri;
                t3 = J.getInterceptor$s(t1);
                file = t3.substring$1(t1, J.$add$ansx(t3.lastIndexOf$1(t1, "/"), 1));
                J.set$text$x(t2.get$deviceStatus().get$element(), "paused at " + H.S(file) + " " + H.S(position.line) + ":" + H.S(position.column));
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                J.set$text$x(t2.get$deviceStatus().get$element(), "");
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 178]
    },
    DebuggerScreen_createContent_closure11: {
      "^": "Closure:75;$this,$ti",
      call$1: [function(frame) {
        return this.$call$body$DebuggerScreen_createContent_closure(H.interceptedTypeCheck(frame, "$isFrame"));
      }, null, null, 4, 0, null, 73, "call"],
      $call$body$DebuggerScreen_createContent_closure: [function(frame) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$self = this, t1, $location, scriptRef, script, position;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = frame == null ? 2 : 4;
                break;
              case 2:
                // then
                t1 = $async$self.$this;
                t1.get$callStackView().clearFrames$0();
                t1.get$variablesView().clearVariables$0();
                t1.get$sourceEditor().clearExecutionPoint$0();
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $location = frame.location;
                $async$goto = $location != null ? 5 : 6;
                break;
              case 5:
                // then
                scriptRef = $location.script;
                t1 = $async$self.$this;
                $async$goto = 7;
                return P._asyncAwait(t1.get$debuggerState().getScript$1(scriptRef), $async$call$1);
              case 7:
                // returning from await.
                script = $async$result;
                position = t1.get$debuggerState().calculatePosition$2(script, $location.tokenPos);
                J.set$text$x(t1.get$_sourcePathDiv(), script.uri);
                t1.get$sourceEditor().displayExecutionPoint$2$position(script, position);
              case 6:
                // join
                $async$self.$this.get$variablesView().showVariables$1(frame);
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 73]
    },
    DebuggerScreen_createContent_closure12: {
      "^": "Closure:21;$this,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isBusEvent");
        J.clear$0$ax(this.$this.get$consoleArea());
      }, null, null, 4, 0, null, 12, "call"]
    },
    DebuggerScreen_createContent_closure13: {
      "^": "Closure:21;$this,$ti",
      call$1: [function($event) {
        H.interceptedTypeCheck($event, "$isBusEvent");
        J.appendText$1$z(this.$this.get$consoleArea(), H.S($event.data) + "\n\n");
      }, null, null, 4, 0, null, 22, "call"]
    },
    DebuggerScreen_createContent_closure14: {
      "^": "Closure:21;$this,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isBusEvent");
        J.clear$0$ax(this.$this.get$consoleArea());
      }, null, null, 4, 0, null, 12, "call"]
    },
    DebuggerScreen_createContent_closure15: {
      "^": "Closure:21;$this,$ti",
      call$1: [function($event) {
        H.interceptedTypeCheck($event, "$isBusEvent");
        J.appendText$1$z(this.$this.get$consoleArea(), H.S($event.data) + "\n\n");
      }, null, null, 4, 0, null, 22, "call"]
    },
    DebuggerScreen__buildMenuNav_closure: {
      "^": "Closure:77;$this,$ti",
      call$1: [function(variable) {
        return this.$call$body$DebuggerScreen__buildMenuNav_closure1(H.interceptedTypeCheck(variable, "$isBoundVariable"));
      }, null, null, 4, 0, null, 261, "call"],
      $call$body$DebuggerScreen__buildMenuNav_closure1: [function(variable) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this, value, t1, result, t2;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (variable == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                value = variable.value;
                t1 = J.getInterceptor$(value);
                if (!!t1.$isSentinel) {
                  $async$returnValue = value.valueAsString;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if (!!t1.$isTypeArgumentsRef) {
                  $async$returnValue = value.name;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                H.interceptedTypeCheck(value, "$isInstanceRef");
                t1 = value.valueAsString;
                $async$goto = t1 != null && !value.valueAsStringIsTruncated ? 3 : 5;
                break;
              case 3:
                // then
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                t1 = $async$self.$this;
                $async$goto = 6;
                return P._asyncAwait(E.serviceManager().get$service().invoke$4(J.get$id$z(t1.get$debuggerState().get$isolateRef()), value.id, "toString", H.setRuntimeTypeInfo([], [P.String])), $async$call$1);
              case 6:
                // returning from await.
                result = $async$result;
                t2 = J.getInterceptor$(result);
                $async$goto = !!t2.$isErrorRef ? 7 : 9;
                break;
              case 7:
                // then
                $async$returnValue = H.S(result.kind) + " " + H.S(result.message);
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 8;
                break;
              case 9:
                // else
                $async$goto = !!t2.$isInstanceRef ? 10 : 11;
                break;
              case 10:
                // then
                $async$goto = 12;
                return P._asyncAwait(t1._retrieveFullStringValue$1(result), $async$call$1);
              case 12:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 11:
                // join
              case 8:
                // join
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 261]
    },
    DebuggerScreen__buildMenuNav_closure0: {
      "^": "Closure:78;$this,$ti",
      call$1: [function(breakpoint) {
        return this.$call$body$DebuggerScreen__buildMenuNav_closure0(H.interceptedTypeCheck(breakpoint, "$isBreakpoint"));
      }, null, null, 4, 0, null, 173, "call"],
      $call$body$DebuggerScreen__buildMenuNav_closure0: [function(breakpoint) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$self = this, $location, t1, script, pos;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $location = breakpoint.location;
                t1 = J.getInterceptor$($location);
                $async$goto = !!t1.$isSourceLocation ? 2 : 4;
                break;
              case 2:
                // then
                t1 = $async$self.$this;
                $async$goto = 5;
                return P._asyncAwait(t1.get$debuggerState().getScript$1($location.script), $async$call$1);
              case 5:
                // returning from await.
                script = $async$result;
                pos = t1.get$debuggerState().calculatePosition$2(script, $location.tokenPos);
                t1.get$sourceEditor().displayScript$2$scrollTo(script, X.SourcePosition$(J.$sub$n(pos.line, 1), null));
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $async$goto = !!t1.$isUnresolvedSourceLocation ? 6 : 7;
                break;
              case 6:
                // then
                t1 = $async$self.$this;
                $async$goto = 8;
                return P._asyncAwait(t1.get$debuggerState().getScript$1($location.script), $async$call$1);
              case 8:
                // returning from await.
                script = $async$result;
                t1.get$sourceEditor().displayScript$2$scrollTo(script, X.SourcePosition$(J.$sub$n($location.line, 1), null));
              case 7:
                // join
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 173]
    },
    DebuggerScreen__buildMenuNav_closure1: {
      "^": "Closure:79;$this,$ti",
      call$1: [function(scriptRef) {
        return this.$call$body$DebuggerScreen__buildMenuNav_closure(H.interceptedTypeCheck(scriptRef, "$isScriptRef"));
      }, null, null, 4, 0, null, 215, "call"],
      $call$body$DebuggerScreen__buildMenuNav_closure: [function(scriptRef) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$returnValue, $async$self = this, isolateRef, result, t1;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (scriptRef == null) {
                  $async$self.$this._displaySource$1(null);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                isolateRef = E.serviceManager().get$isolateManager().get$selectedIsolate();
                $async$goto = 3;
                return P._asyncAwait(E.serviceManager().get$service().getObject$2(isolateRef.id, scriptRef.id), $async$call$1);
              case 3:
                // returning from await.
                result = $async$result;
                t1 = $async$self.$this;
                if (result instanceof S.Script)
                  t1._displaySource$1(result);
                else
                  t1._displaySource$1(null);
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 215]
    },
    DebuggerScreen__buildMenuNav_closure2: {
      "^": "Closure:50;_box_0,$this,$ti",
      call$1: [function(_) {
        J.set$text$x(this._box_0.scriptCountDiv, J.toString$0$(J.get$length$asx(this.$this.get$scriptsView().get$items())));
      }, null, null, 4, 0, null, 12, "call"]
    },
    DebuggerScreen__buildMenuNav_closure3: {
      "^": "Closure:0;$this,$ti",
      call$0: [function() {
        return this.$this.get$callStackView().get$element().toggleAttribute$1("hidden");
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen__buildMenuNav_closure4: {
      "^": "Closure:0;$this,$ti",
      call$0: [function() {
        return this.$this.get$variablesView().get$element().toggleAttribute$1("hidden");
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen__buildMenuNav_closure5: {
      "^": "Closure:0;$this,$ti",
      call$0: [function() {
        return this.$this.get$breakpointsView().get$element().toggleAttribute$1("hidden");
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen__buildMenuNav_closure6: {
      "^": "Closure:0;$this,$ti",
      call$0: [function() {
        return this.$this.get$scriptsView().get$element().toggleAttribute$1("hidden");
      }, null, null, 0, 0, null, "call"]
    },
    DebuggerScreen__buildMenuNav_closure7: {
      "^": "Closure:81;$this,$ti",
      call$1: [function(breakpoints) {
        H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList");
        this.$this.get$breakpointsView().showBreakpoints$1(breakpoints);
      }, null, null, 4, 0, null, 176, "call"]
    },
    DebuggerScreen__handleConnectionStart_closure: {
      "^": "Closure:23;$this,$ti",
      call$1: [function(e) {
        var message = S.decodeBase64(H.interceptedTypeCheck(e, "$isEvent0").bytes);
        J.appendText$1$z(this.$this.get$consoleArea(), message);
      }, null, null, 4, 0, null, 19, "call"]
    },
    DebuggerScreen__handleConnectionStart_closure0: {
      "^": "Closure:23;$this,$ti",
      call$1: [function(e) {
        var message = S.decodeBase64(H.interceptedTypeCheck(e, "$isEvent0").bytes);
        J.appendText$1$z(this.$this.get$consoleArea(), message);
      }, null, null, 4, 0, null, 19, "call"]
    },
    DebuggerScreen__handleIsolateChanged_closure: {
      "^": "Closure:4;$this,$ti",
      call$1: [function(result) {
        var t1 = this.$this;
        if (result instanceof S.Isolate)
          t1._populateFromIsolate$1(result);
        else
          t1.get$scriptsView().clearScripts$0();
      }, null, null, 4, 0, null, 59, "call"]
    },
    DebuggerScreen__handleIsolateChanged_closure0: {
      "^": "Closure:4;$this,$ti",
      call$1: [function(e) {
        this.$this.get$framework().showError$2("Error retrieving isolate information", e);
      }, null, null, 4, 0, null, 19, "call"]
    },
    DebuggerState: {
      "^": "Object;0_service,0_debugSubscription,0isolateRef<,0scripts,_scriptCache,_debugger$_paused,_supportsStepping,0_lastEvent<,_breakpoints,_exceptionPauseMode,0_reportedException,0commonScriptPrefix<,0rootLib<,$ti",
      set$_debugSubscription: function(_debugSubscription) {
        this._debugSubscription = H.assertSubtype(_debugSubscription, "$isStreamSubscription", [S.Event0], "$asStreamSubscription");
      },
      set$scripts: function(scripts) {
        this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
      },
      get$isPaused: [function() {
        return J.get$value$x(this._debugger$_paused);
      }, null, null, 2, 0, null],
      get$onPausedChanged: [function() {
        return this._debugger$_paused;
      }, null, null, 2, 0, null],
      get$onSupportsStepping: [function() {
        return X.Observable_Observable$concat(H.setRuntimeTypeInfo([this._debugger$_paused, this._supportsStepping], [[P.Stream, P.bool]]), P.bool);
      }, null, null, 2, 0, null],
      get$onBreakpointsChanged: [function() {
        return this._breakpoints;
      }, null, null, 2, 0, null],
      get$onExceptionPauseModeChanged: [function() {
        return this._exceptionPauseMode;
      }, null, null, 2, 0, null],
      get$breakpoints: [function() {
        return J.get$value$x(this._breakpoints);
      }, null, null, 2, 0, null],
      setVmService$1: [function(service) {
        H.interceptedTypeCheck(service, "$isVmService");
        this._service = service;
        this.set$_debugSubscription(service.get$onDebugEvent().listen$1(this.get$_handleIsolateEvent()));
      }, null, "get$setVmService", 4, 0, null, 74],
      switchToIsolate$1: [function(ref) {
        return this.switchToIsolate$body$DebuggerState(H.interceptedTypeCheck(ref, "$isIsolateRef"));
      }, null, "get$switchToIsolate", 4, 0, null, 81],
      switchToIsolate$body$DebuggerState: [function(ref) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$returnValue, $async$self = this, result, t1;
        var $async$switchToIsolate$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$self.isolateRef = ref;
                $async$self._updatePaused$1(false);
                $async$self._clearCaches$0();
                if (ref == null) {
                  J.add$1$ax($async$self._breakpoints, H.setRuntimeTypeInfo([], [S.Breakpoint]));
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait($async$self._service.getIsolate$1(J.get$id$z($async$self.isolateRef)), $async$switchToIsolate$1);
              case 3:
                // returning from await.
                result = $async$result;
                if (result instanceof S.Isolate) {
                  t1 = result.pauseEvent;
                  if (t1 != null && !J.$eq$(J.get$kind$x(t1), "Resume")) {
                    t1 = H.interceptedTypeCheck(result.pauseEvent, "$isEvent0");
                    $async$self._lastEvent = t1;
                    $async$self._reportedException = H.interceptedTypeCheck(t1.exception, "$isInstanceRef");
                    $async$self._updatePaused$1(true);
                  }
                  J.add$1$ax($async$self._breakpoints, result.breakpoints);
                  J.add$1$ax($async$self._exceptionPauseMode, result.exceptionPauseMode);
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$switchToIsolate$1, $async$completer);
      }, null, null, 4, 0, null, 81],
      pause$0: [function(_) {
        return J.pause$1$z(this._service, J.get$id$z(this.isolateRef));
      }, null, "get$pause", 1, 0, null],
      resume$0: [function() {
        return this._service.resume$1(J.get$id$z(this.isolateRef));
      }, "call$0", "get$resume", 0, 0, 24],
      stepOver$0: [function() {
        var t1, useAsyncStepping, t2;
        t1 = this._lastEvent;
        useAsyncStepping = J.$eq$(t1 == null ? null : t1.get$atAsyncSuspension(), true);
        t1 = this._service;
        t2 = J.get$id$z(this.isolateRef);
        return t1.resume$2$step(t2, useAsyncStepping ? "OverAsyncSuspension" : "Over");
      }, null, "get$stepOver", 0, 0, null],
      stepIn$0: [function() {
        return this._service.resume$2$step(J.get$id$z(this.isolateRef), "Into");
      }, null, "get$stepIn", 0, 0, null],
      stepOut$0: [function() {
        return this._service.resume$2$step(J.get$id$z(this.isolateRef), "Out");
      }, null, "get$stepOut", 0, 0, null],
      clearBreakpoints$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$clearBreakpoints$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(P.Future_forEach(J.toList$0$ax(J.get$value$x($async$self._breakpoints)), new X.DebuggerState_clearBreakpoints_closure($async$self), S.Breakpoint), $async$clearBreakpoints$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$clearBreakpoints$0, $async$completer);
      }, null, "get$clearBreakpoints", 0, 0, null],
      addBreakpoint$2: [function(scriptId, line) {
        H.stringTypeCheck(scriptId);
        H.intTypeCheck(line);
        return this._service.addBreakpoint$3(J.get$id$z(this.isolateRef), scriptId, line);
      }, null, "get$addBreakpoint", 8, 0, null, 288, 49],
      addBreakpointByPathFragment$2: [function(path, line) {
        return this.addBreakpointByPathFragment$body$DebuggerState(H.stringTypeCheck(path), H.intTypeCheck(line));
      }, null, "get$addBreakpointByPathFragment", 8, 0, null, 26, 49],
      addBreakpointByPathFragment$body$DebuggerState: [function(path, line) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, ref;
        var $async$addBreakpointByPathFragment$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                ref = J.firstWhere$2$orElse$ax($async$self.scripts, new X.DebuggerState_addBreakpointByPathFragment_closure(path), new X.DebuggerState_addBreakpointByPathFragment_closure0());
                if (ref != null) {
                  $async$returnValue = $async$self._service.addBreakpoint$3(J.get$id$z($async$self.isolateRef), ref.id, line);
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$addBreakpointByPathFragment$2, $async$completer);
      }, null, null, 8, 0, null, 26, 49],
      removeBreakpoint$1: [function(breakpoint) {
        H.interceptedTypeCheck(breakpoint, "$isBreakpoint");
        return this._service.removeBreakpoint$2(J.get$id$z(this.isolateRef), breakpoint.id);
      }, null, "get$removeBreakpoint", 4, 0, null, 173],
      setExceptionPauseMode$1: [function(mode) {
        H.stringTypeCheck(mode);
        return this._service.setExceptionPauseMode$2(J.get$id$z(this.isolateRef), mode);
      }, null, "get$setExceptionPauseMode", 4, 0, null, 177],
      getStack$0: [function() {
        return this._service.getStack$1(J.get$id$z(this.isolateRef));
      }, null, "get$getStack", 0, 0, null],
      get$reportedException: [function() {
        return this._reportedException;
      }, null, null, 2, 0, null],
      _handleIsolateEvent$1: [function($event) {
        var t1, t2;
        H.interceptedTypeCheck($event, "$isEvent0");
        if (!J.$eq$(J.get$id$z($event.isolate), J.get$id$z(this.isolateRef)))
          return;
        J.add$1$ax(this._supportsStepping, $event.topFrame != null);
        this._lastEvent = $event;
        switch ($event.kind) {
          case "Resume":
            this._updatePaused$1(false);
            this._reportedException = null;
            break;
          case "PauseStart":
          case "PauseExit":
          case "PauseBreakpoint":
          case "PauseInterrupted":
          case "PauseException":
          case "PausePostRequest":
            this._reportedException = H.interceptedTypeCheck($event.exception, "$isInstanceRef");
            this._updatePaused$1(true);
            break;
          case "BreakpointAdded":
            t1 = this._breakpoints;
            t2 = J.getInterceptor$x(t1);
            J.add$1$ax(t2.get$value(t1), $event.breakpoint);
            t2.add$1(t1, t2.get$value(t1));
            break;
          case "BreakpointResolved":
            t1 = this._breakpoints;
            t2 = J.getInterceptor$x(t1);
            J.remove$1$ax(t2.get$value(t1), $event.breakpoint);
            J.add$1$ax(t2.get$value(t1), $event.breakpoint);
            t2.add$1(t1, t2.get$value(t1));
            break;
          case "BreakpointRemoved":
            t1 = this._breakpoints;
            t2 = J.getInterceptor$x(t1);
            J.remove$1$ax(t2.get$value(t1), $event.breakpoint);
            t2.add$1(t1, t2.get$value(t1));
            break;
        }
      }, "call$1", "get$_handleIsolateEvent", 4, 0, 11, 22],
      _clearCaches$0: [function() {
        J.clear$0$ax(this._scriptCache);
        this._lastEvent = null;
        this._reportedException = null;
      }, null, "get$_clearCaches", 0, 0, null],
      dispose$0: [function() {
        var t1 = this._debugSubscription;
        if (!(t1 == null))
          t1.cancel$0();
      }, null, "get$dispose", 0, 0, null],
      _updatePaused$1: [function(value) {
        var t1, t2;
        H.boolTypeCheck(value);
        t1 = this._debugger$_paused;
        t2 = J.getInterceptor$x(t1);
        if (!J.$eq$(t2.get$value(t1), value))
          t2.add$1(t1, value);
      }, null, "get$_updatePaused", 4, 0, null, 1],
      getInstance$1: [function(instanceRef) {
        H.interceptedTypeCheck(instanceRef, "$isInstanceRef");
        return this._service.getObject$2(J.get$id$z(this.isolateRef), instanceRef.id);
      }, null, "get$getInstance", 4, 0, null, 172],
      getScript$1: [function(scriptRef) {
        return this.getScript$body$DebuggerState(H.interceptedTypeCheck(scriptRef, "$isScriptRef"));
      }, null, "get$getScript", 4, 0, null, 215],
      getScript$body$DebuggerState: [function(scriptRef) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(S.Script),
          $async$returnValue, $async$self = this, t1, $async$temp1, $async$temp2, $async$temp3, $async$temp4;
        var $async$getScript$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._scriptCache;
                $async$goto = !t1.containsKey$1(scriptRef.id) ? 3 : 4;
                break;
              case 3:
                // then
                $async$temp1 = J;
                $async$temp2 = t1;
                $async$temp3 = scriptRef.id;
                $async$temp4 = H;
                $async$goto = 5;
                return P._asyncAwait($async$self._service.getObject$2(J.get$id$z($async$self.isolateRef), scriptRef.id), $async$getScript$1);
              case 5:
                // returning from await.
                $async$temp1.$indexSet$ax($async$temp2, $async$temp3, $async$temp4.interceptedTypeCheck($async$result, "$isScript"));
              case 4:
                // join
                $async$returnValue = J.$index$asx(t1, scriptRef.id);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$getScript$1, $async$completer);
      }, null, null, 4, 0, null, 215],
      calculatePosition$2: [function(script, tokenPos) {
        var table, t1, t2, t3, line, index, t4;
        H.interceptedTypeCheck(script, "$isScript");
        H.intTypeCheck(tokenPos);
        table = script.tokenPosTable;
        if (table == null)
          return;
        for (t1 = J.get$iterator$ax(table); t1.moveNext$0();) {
          t2 = t1.get$current();
          if (t2 == null || J.get$isEmpty$asx(t2))
            continue;
          t3 = J.getInterceptor$ax(t2);
          line = t3.elementAt$1(t2, 0);
          index = 1;
          while (true) {
            t4 = J.$sub$n(t3.get$length(t2), 1);
            if (typeof t4 !== "number")
              return H.iae(t4);
            if (!(index < t4))
              break;
            if (J.$eq$(t3.elementAt$1(t2, index), tokenPos))
              return X.SourcePosition$(line, t3.elementAt$1(t2, index + 1));
            index += 2;
          }
        }
        return;
      }, null, "get$calculatePosition", 8, 0, null, 128, 609],
      setRootLib$1: [function(rootLib) {
        var scriptPrefix;
        H.interceptedTypeCheck(rootLib, "$isLibraryRef");
        this.rootLib = rootLib;
        scriptPrefix = rootLib.uri;
        if (J.getInterceptor$s(scriptPrefix).startsWith$1(scriptPrefix, "package:"))
          scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, J.$add$ansx(C.JSString_methods.indexOf$1(scriptPrefix, "/"), 1));
        else if (C.JSString_methods.contains$1(scriptPrefix, "/lib/")) {
          scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/lib/"));
          if (J.getInterceptor$asx(scriptPrefix).contains$1(scriptPrefix, "/"))
            scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, J.$add$ansx(C.JSString_methods.lastIndexOf$1(scriptPrefix, "/"), 1));
        } else if (C.JSString_methods.contains$1(scriptPrefix, "/bin/")) {
          scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/bin/"));
          if (J.getInterceptor$asx(scriptPrefix).contains$1(scriptPrefix, "/"))
            scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, J.$add$ansx(C.JSString_methods.lastIndexOf$1(scriptPrefix, "/"), 1));
        } else if (C.JSString_methods.contains$1(scriptPrefix, "/test/")) {
          scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/test/"));
          if (J.getInterceptor$asx(scriptPrefix).contains$1(scriptPrefix, "/"))
            scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, J.$add$ansx(C.JSString_methods.lastIndexOf$1(scriptPrefix, "/"), 1));
        } else
          scriptPrefix = null;
        this.commonScriptPrefix = scriptPrefix;
      }, null, "get$setRootLib", 4, 0, null, 422],
      getShortScriptName$1: [function(uri) {
        var t1;
        H.stringTypeCheck(uri);
        t1 = this.commonScriptPrefix;
        if (t1 == null)
          return uri;
        if (!J.getInterceptor$s(uri).startsWith$1(uri, t1))
          return uri;
        if (J.startsWith$1$s(this.commonScriptPrefix, "package:"))
          return C.JSString_methods.substring$1(uri, 8);
        else
          return C.JSString_methods.substring$1(uri, J.get$length$asx(this.commonScriptPrefix));
      }, "call$1", "get$getShortScriptName", 4, 0, 7, 65],
      updateFrom$1: [function(isolate) {
        J.add$1$ax(this._breakpoints, H.interceptedTypeCheck(isolate, "$isIsolate").breakpoints);
      }, null, "get$updateFrom", 4, 0, null, 255],
      static: {
        DebuggerState$: [function() {
          var t1, t2;
          t1 = P.String;
          t2 = P.bool;
          return new X.DebuggerState(P.LinkedHashMap_LinkedHashMap$_empty(t1, S.Script), U.BehaviorSubject_BehaviorSubject(null, null, false, false, t2), U.BehaviorSubject_BehaviorSubject(null, null, false, false, t2), U.BehaviorSubject_BehaviorSubject(null, null, H.setRuntimeTypeInfo([], [S.Breakpoint]), false, [P.List, S.Breakpoint]), U.BehaviorSubject_BehaviorSubject(null, null, null, false, t1), []);
        }, null, null, 0, 0, null]
      }
    },
    DebuggerState_clearBreakpoints_closure: {
      "^": "Closure:84;$this,$ti",
      call$1: [function(breakpoint) {
        return this.$this.removeBreakpoint$1(H.interceptedTypeCheck(breakpoint, "$isBreakpoint"));
      }, null, null, 4, 0, null, 173, "call"]
    },
    DebuggerState_addBreakpointByPathFragment_closure: {
      "^": "Closure:42;path,$ti",
      call$1: [function(ref) {
        return J.endsWith$1$s(H.interceptedTypeCheck(ref, "$isScriptRef").uri, this.path);
      }, null, null, 4, 0, null, 81, "call"]
    },
    DebuggerState_addBreakpointByPathFragment_closure0: {
      "^": "Closure:1;$ti",
      call$0: [function() {
        return;
      }, null, null, 0, 0, null, "call"]
    },
    SourcePosition: {
      "^": "Object;line<,column<,$ti",
      toString$0: [function(_) {
        return H.S(this.line) + " " + H.S(this.column);
      }, null, "get$toString", 1, 0, null],
      static: {
        SourcePosition$: [function(line, column) {
          return new X.SourcePosition(line, column, []);
        }, null, null, 4, 2, null, 0, 49, 99]
      }
    },
    SourceEditor: {
      "^": "Object;codeMirror,debuggerState<,0currentScript>,0executionPoint<,breakpoints<,linesToBreakpoints<,0_currentLineClass,0_executionPointElement,_lastScrollPositions,$ti",
      set$breakpoints: function(breakpoints) {
        this.breakpoints = H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList");
      },
      SourceEditor$2: [function(codeMirror, debuggerState) {
        this.codeMirror.get$onGutterClick().listen$1(new X.SourceEditor_closure(this));
      }, null, null, 8, 0, null, 345, 151],
      setBreakpoints$1: [function(breakpoints) {
        this.set$breakpoints(H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList"));
        this._refreshMarkers$0();
      }, null, "get$setBreakpoints", 4, 0, null, 176],
      _refreshMarkers$0: [function() {
        var t1, t2, t3, t4, t5, t6, t7, line;
        t1 = this.codeMirror;
        t1.clearGutter$1("breakpoints");
        t2 = this.linesToBreakpoints;
        J.clear$0$ax(t2);
        if (this.currentScript == null)
          return;
        for (t3 = J.get$iterator$ax(this.breakpoints), t4 = this.debuggerState; t3.moveNext$0();) {
          t5 = t3.get$current();
          t6 = t5.location;
          t7 = J.getInterceptor$(t6);
          if (!!t7.$isSourceLocation) {
            if (!J.$eq$(J.get$id$z(t6.script), J.get$id$z(this.currentScript)))
              continue;
            line = J.$sub$n(t4.calculatePosition$2(this.currentScript, t6.tokenPos).line, 1);
            J.add$1$ax(t2.putIfAbsent$2(line, new X.SourceEditor__refreshMarkers_closure()), t5);
            t1.setGutterMarker$3(line, "breakpoints", A.span(null, "octicon octicon-primitive-dot", null).get$element());
          } else if (!!t7.$isUnresolvedSourceLocation) {
            if (!J.$eq$(J.get$id$z(t6.script), J.get$id$z(this.currentScript)))
              continue;
            line = J.$sub$n(t6.line, 1);
            J.add$1$ax(t2.putIfAbsent$2(line, new X.SourceEditor__refreshMarkers_closure0()), t5);
            t1.setGutterMarker$3(line, "breakpoints", A.span(null, "octicon octicon-primitive-dot", null).get$element());
          }
        }
        t1 = this.executionPoint;
        if (t1 != null && J.matches$1$x(t1, this.currentScript))
          if (J.get$position$x(this.executionPoint) != null)
            this._showLineClass$1(J.$sub$n(J.get$position$x(this.executionPoint).get$line(), 1));
      }, null, "get$_refreshMarkers", 0, 0, null],
      _clearLineClass$0: [function() {
        var t1 = this._currentLineClass;
        if (t1 != null) {
          this.codeMirror.removeLineClass$3(t1, "background", "executionLine");
          this._currentLineClass = null;
        }
        t1 = this._executionPointElement;
        if (!(t1 == null))
          t1.dispose$0();
        this._executionPointElement = null;
      }, null, "get$_clearLineClass", 0, 0, null],
      _showLineClass$1: [function(line) {
        H.intTypeCheck(line);
        if (J.$eq$(this._currentLineClass, line))
          return;
        this._clearLineClass$0();
        this._currentLineClass = line;
        this.codeMirror.addLineClass$3(line, "background", "executionLine");
      }, null, "get$_showLineClass", 4, 0, null, 49],
      displayExecutionPoint$2$position: [function(script, position) {
        var t1;
        H.interceptedTypeCheck(script, "$isScript");
        H.interceptedTypeCheck(position, "$isSourcePosition");
        this.executionPoint = X.ScriptAndPosition$(script, position);
        this.displayScript$2$scrollTo(script, position);
        t1 = this._executionPointElement;
        if (!(t1 == null))
          t1.dispose$0();
        this._executionPointElement = null;
        if (script.source != null && position != null) {
          this._executionPointElement = H.interceptedTypeCheck(A.span(null, "octicon octicon-arrow-up execution-marker", null), "$isCoreElement");
          this.codeMirror.addWidget$2(X.Position$(J.$sub$n(position.line, 1), J.$sub$n(position.column, 1)), this._executionPointElement.get$element());
        }
      }, null, "get$displayExecutionPoint", 4, 3, null, 0, 128, 69],
      clearExecutionPoint$0: [function() {
        this.executionPoint = null;
        this._clearLineClass$0();
        this._refreshMarkers$0();
      }, null, "get$clearExecutionPoint", 0, 0, null],
      displayScript$2$scrollTo: [function(newScript, $scrollTo) {
        var scrollInfo, t1, t2, sameScript, source, $top;
        H.interceptedTypeCheck(newScript, "$isScript");
        H.interceptedTypeCheck($scrollTo, "$isSourcePosition");
        if (this.currentScript != null) {
          scrollInfo = this.codeMirror.getScrollInfo$0();
          J.$indexSet$ax(this._lastScrollPositions, this.currentScript.get$uri(), scrollInfo.get$top(scrollInfo));
        }
        t1 = this.currentScript;
        t1 = t1 == null ? null : t1.get$uri();
        t2 = newScript == null;
        sameScript = J.$eq$(t1, t2 ? null : newScript.uri);
        this.currentScript = newScript;
        if (t2)
          this.codeMirror.getDoc$0().setValue$1("");
        else {
          if (!sameScript) {
            source = newScript.source;
            if (source == null)
              source = "<source not available>";
            this.codeMirror.getDoc$0().setValue$1(source);
          }
          if ($scrollTo != null)
            J.scrollIntoView$3$margin$x(this.codeMirror, J.$sub$n($scrollTo.line, 1), 0, 150);
          else {
            $top = J.$index$asx(this._lastScrollPositions, newScript.uri);
            if ($top == null)
              $top = 0;
            J.scrollTo$2$x(this.codeMirror, 0, $top);
          }
        }
        t1 = this._executionPointElement;
        if (!(t1 == null))
          t1.dispose$0();
        this._executionPointElement = null;
        this._refreshMarkers$0();
      }, function(newScript) {
        return this.displayScript$2$scrollTo(newScript, null);
      }, "displayScript$1", null, null, "get$displayScript", 4, 3, null, 0, 611, 612],
      static: {
        SourceEditor$: [function(codeMirror, debuggerState) {
          var t1 = P.int;
          t1 = new X.SourceEditor(codeMirror, debuggerState, H.setRuntimeTypeInfo([], [S.Breakpoint]), P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.List, S.Breakpoint]), P.LinkedHashMap_LinkedHashMap$_empty(P.String, t1), []);
          t1.SourceEditor$2(codeMirror, debuggerState);
          return t1;
        }, null, null, 8, 0, null, 345, 151]
      }
    },
    SourceEditor_closure: {
      "^": "Closure:86;$this,$ti",
      call$1: [function(line) {
        var t1, lineBps, t2, bp;
        H.intTypeCheck(line);
        t1 = this.$this;
        lineBps = J.$index$asx(t1.get$linesToBreakpoints(), line);
        if (lineBps == null || J.get$isEmpty$asx(lineBps)) {
          t2 = t1.get$debuggerState();
          t1 = J.get$id$z(J.get$currentScript$z(t1));
          if (typeof line !== "number")
            return line.$add();
          t2.addBreakpoint$2(t1, line + 1).catchError$1(new X.SourceEditor__closure());
        } else {
          bp = J.removeAt$1$ax(lineBps, 0);
          t1.get$debuggerState().removeBreakpoint$1(bp).catchError$1(new X.SourceEditor__closure0());
        }
      }, null, null, 4, 0, null, 49, "call"]
    },
    SourceEditor__closure: {
      "^": "Closure:4;$ti",
      call$1: [function(_) {
      }, null, null, 4, 0, null, 12, "call"]
    },
    SourceEditor__closure0: {
      "^": "Closure:4;$ti",
      call$1: [function(_) {
      }, null, null, 4, 0, null, 12, "call"]
    },
    SourceEditor__refreshMarkers_closure: {
      "^": "Closure:43;$ti",
      call$0: [function() {
        return H.setRuntimeTypeInfo([], [S.Breakpoint]);
      }, null, null, 0, 0, null, "call"]
    },
    SourceEditor__refreshMarkers_closure0: {
      "^": "Closure:43;$ti",
      call$0: [function() {
        return H.setRuntimeTypeInfo([], [S.Breakpoint]);
      }, null, null, 0, 0, null, "call"]
    },
    BreakpointsView: {
      "^": "Object;_breakpointsCountDiv,0_items,$ti",
      set$_items: function(_items) {
        this._items = H.assertSubtype(_items, "$isSelectableList", [S.Breakpoint], "$asSelectableList");
      },
      BreakpointsView$3: [function(_breakpointsCountDiv, debuggerState, uriDescriber) {
        var t1 = N.SelectableList$(S.Breakpoint);
        t1.flex$0(0);
        t1.clazz$1("menu-item-bottom-border");
        t1.clazz$1("debugger-items-list");
        this.set$_items(t1);
        this._items.setRenderer$1(new X.BreakpointsView_closure(uriDescriber, debuggerState));
      }, null, null, 12, 0, null, 414, 151, 250],
      get$onDoubleClick: [function(_) {
        return J.get$onDoubleClick$x(this._items);
      }, null, null, 3, 0, null],
      get$element: [function() {
        return this._items;
      }, null, null, 2, 0, null],
      showBreakpoints$1: [function(breakpoints) {
        var t1;
        breakpoints = J.toList$0$ax(H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList"));
        t1 = J.getInterceptor$ax(breakpoints);
        t1.sort$1(breakpoints, X.debugger___breakpointComparator$closure());
        this._items.setItems$1(breakpoints);
        J.set$text$x(this._breakpointsCountDiv, J.toString$0$(t1.get$length(breakpoints)));
      }, null, "get$showBreakpoints", 4, 0, null, 176],
      $isCoreElementView: 1,
      static: {
        BreakpointsView$: [function(_breakpointsCountDiv, debuggerState, uriDescriber) {
          var t1 = new X.BreakpointsView(_breakpointsCountDiv, []);
          t1.BreakpointsView$3(_breakpointsCountDiv, debuggerState, uriDescriber);
          return t1;
        }, null, null, 12, 0, null, 414, 151, 250]
      }
    },
    BreakpointsView_closure: {
      "^": "Closure:88;uriDescriber,debuggerState,$ti",
      call$1: [function(breakpoint) {
        var $location, element, t1;
        H.interceptedTypeCheck(breakpoint, "$isBreakpoint");
        $location = breakpoint.location;
        element = A.li(null, "list-item", null);
        t1 = J.getInterceptor$($location);
        if (!!t1.$isUnresolvedSourceLocation) {
          element.set$text(0, this.uriDescriber.call$1($location.script.get$uri()));
          element.add$1(0, A.span(null, "subtle", " line " + H.S($location.line)));
        } else if (!!t1.$isSourceLocation) {
          element.set$text(0, this.uriDescriber.call$1($location.script.get$uri()));
          t1 = this.debuggerState;
          t1.getScript$1($location.script).then$1$1(new X.BreakpointsView__closure(t1, $location, element), null);
        }
        if (!breakpoint.resolved)
          element.add$1(0, A.span(null, "subtle", " (unresolved)"));
        return element;
      }, null, null, 4, 0, null, 173, "call"]
    },
    BreakpointsView__closure: {
      "^": "Closure:89;debuggerState,location,element,$ti",
      call$1: [function(script) {
        J.add$1$ax(this.element, A.span(null, "subtle", " line " + H.S(this.debuggerState.calculatePosition$2(H.interceptedTypeCheck(script, "$isScript"), this.location.get$tokenPos()).line)));
      }, null, null, 4, 0, null, 128, "call"]
    },
    ScriptsView: {
      "^": "Object;0_items,0rootLib<,$ti",
      set$_items: function(_items) {
        this._items = H.assertSubtype(_items, "$isSelectableList", [S.ScriptRef], "$asSelectableList");
      },
      ScriptsView$1: [function(uriDescriber) {
        var t1 = N.SelectableList$(S.ScriptRef);
        t1.flex$0(0);
        t1.clazz$1("debugger-items-list");
        this.set$_items(t1);
        this._items.setRenderer$1(new X.ScriptsView_closure(uriDescriber));
      }, null, null, 4, 0, null, 250],
      get$items: [function() {
        return this._items.get$items();
      }, null, null, 2, 0, null],
      get$element: [function() {
        return this._items;
      }, null, null, 2, 0, null],
      get$onSelectionChanged: [function() {
        return this._items.get$onSelectionChanged();
      }, null, null, 2, 0, null],
      get$onScriptsChanged: [function() {
        return this._items.get$onItemsChanged();
      }, null, null, 2, 0, null],
      showScripts$4$selectRootScript: [function(scripts, rootLib, commonPrefix, selectRootScript) {
        var t1, selection;
        H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
        H.stringTypeCheck(rootLib);
        H.stringTypeCheck(commonPrefix);
        H.boolTypeCheck(selectRootScript);
        this.rootLib = rootLib;
        t1 = J.getInterceptor$ax(scripts);
        t1.sort$1(scripts, new X.ScriptsView_showScripts_closure(this, commonPrefix));
        selection = selectRootScript ? t1.firstWhere$2$orElse(scripts, new X.ScriptsView_showScripts_closure0(rootLib), new X.ScriptsView_showScripts_closure1()) : null;
        this._items.setItems$2$selection(scripts, selection);
      }, null, "get$showScripts", 12, 3, null, 18, 613, 422, 614, 615],
      _convertDartInternalUris$1: [function(uri) {
        H.stringTypeCheck(uri);
        if (J.getInterceptor$s(uri).startsWith$1(uri, "dart:_"))
          return C.JSString_methods.replaceAll$2(uri, "dart:_", "dart:");
        else
          return uri;
      }, null, "get$_convertDartInternalUris", 4, 0, null, 65],
      clearScripts$0: [function() {
        return this._items.clearItems$0();
      }, null, "get$clearScripts", 0, 0, null],
      $isCoreElementView: 1,
      static: {
        ScriptsView$: [function(uriDescriber) {
          var t1 = new X.ScriptsView([]);
          t1.ScriptsView$1(uriDescriber);
          return t1;
        }, null, null, 4, 0, null, 250]
      }
    },
    ScriptsView_closure: {
      "^": "Closure:90;uriDescriber,$ti",
      call$1: [function(scriptRef) {
        var uri, $name, element;
        uri = H.interceptedTypeCheck(scriptRef, "$isScriptRef").uri;
        $name = this.uriDescriber.call$1(uri);
        element = A.li(null, "list-item", $name);
        if ($name != uri)
          element.add$1(0, A.span(null, "subtle", " " + H.S(uri)));
        element.set$tooltip(uri);
        return element;
      }, null, null, 4, 0, null, 215, "call"]
    },
    ScriptsView_showScripts_closure: {
      "^": "Closure:91;$this,commonPrefix,$ti",
      call$2: [function(ref1, ref2) {
        var uri1, uri2, t1;
        H.interceptedTypeCheck(ref1, "$isScriptRef");
        H.interceptedTypeCheck(ref2, "$isScriptRef");
        uri1 = ref1.uri;
        uri2 = ref2.uri;
        t1 = this.$this;
        uri1 = t1._convertDartInternalUris$1(uri1);
        uri2 = t1._convertDartInternalUris$1(uri2);
        t1 = this.commonPrefix;
        if (t1 != null)
          if (J.getInterceptor$s(uri1).startsWith$1(uri1, t1) && !J.startsWith$1$s(uri2, t1))
            return -1;
          else if (!C.JSString_methods.startsWith$1(uri1, t1) && J.startsWith$1$s(uri2, t1))
            return 1;
        t1 = J.getInterceptor$s(uri1).startsWith$1(uri1, "dart:");
        if (t1 && !J.startsWith$1$s(uri2, "dart:"))
          return 1;
        else if (!t1 && J.startsWith$1$s(uri2, "dart:"))
          return -1;
        return C.JSString_methods.compareTo$1(uri1, uri2);
      }, null, null, 8, 0, null, 616, 617, "call"]
    },
    ScriptsView_showScripts_closure0: {
      "^": "Closure:42;rootLib,$ti",
      call$1: [function(script) {
        return J.$eq$(H.interceptedTypeCheck(script, "$isScriptRef").uri, this.rootLib);
      }, null, null, 4, 0, null, 128, "call"]
    },
    ScriptsView_showScripts_closure1: {
      "^": "Closure:1;$ti",
      call$0: [function() {
        return;
      }, null, null, 0, 0, null, "call"]
    },
    CallStackView: {
      "^": "Object;0_items,$ti",
      set$_items: function(_items) {
        this._items = H.assertSubtype(_items, "$isSelectableList", [S.Frame], "$asSelectableList");
      },
      CallStackView$0: [function() {
        var t1 = N.SelectableList$(S.Frame);
        t1.flex$0(0);
        t1.clazz$1("menu-item-bottom-border");
        t1.clazz$1("debugger-items-list");
        this.set$_items(t1);
        this._items.setRenderer$1(new X.CallStackView_closure());
      }, null, null, 0, 0, null],
      get$items: [function() {
        return this._items.get$items();
      }, null, null, 2, 0, null],
      get$element: [function() {
        return this._items;
      }, null, null, 2, 0, null],
      get$onSelectionChanged: [function() {
        return this._items.get$onSelectionChanged();
      }, null, null, 2, 0, null],
      showFrames$2$selectTop: [function($frames, selectTop) {
        var t1, t2, frame;
        t1 = [S.Frame];
        H.assertSubtype($frames, "$isList", t1, "$asList");
        H.boolTypeCheck(selectTop);
        t2 = J.getInterceptor$asx($frames);
        if (t2.get$isEmpty($frames)) {
          frame = S.Frame$();
          frame.kind = "EmptyStackMarker";
          t2 = S.CodeRef$();
          t2.name = "<no call frames>";
          frame.code = t2;
          this._items.setItems$1(H.setRuntimeTypeInfo([frame], t1));
        } else {
          t1 = this._items;
          t1.setItems$2$selection($frames, t2.get$isEmpty($frames) ? null : t2.get$first($frames));
        }
      }, null, "get$showFrames", 4, 3, null, 18, 618, 619],
      clearFrames$0: [function() {
        this._items.setItems$1(H.setRuntimeTypeInfo([], [S.Frame]));
      }, null, "get$clearFrames", 0, 0, null],
      $isCoreElementView: 1,
      static: {
        CallStackView$: [function() {
          var t1 = new X.CallStackView([]);
          t1.CallStackView$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    CallStackView_closure: {
      "^": "Closure:73;$ti",
      call$1: [function(frame) {
        var t1, $name, locationDescription, element;
        H.interceptedTypeCheck(frame, "$isFrame");
        t1 = frame.code;
        $name = t1 == null ? null : J.get$name$x(t1);
        if ($name == null)
          $name = "<none>";
        $name = J.replaceAll$2$s(C.JSString_methods.startsWith$1($name, "[Unoptimized] ") ? C.JSString_methods.substring$1($name, 14) : $name, "<anonymous closure>", "<closure>");
        if (J.$eq$(frame.kind, "AsyncSuspensionMarker")) {
          $name = "<async break>";
          locationDescription = null;
        } else if (!J.$eq$(frame.kind, "EmptyStackMarker")) {
          locationDescription = frame.location.get$script().get$uri();
          if (J.getInterceptor$asx(locationDescription).contains$1(locationDescription, "/"))
            locationDescription = C.JSString_methods.substring$1(locationDescription, J.$add$ansx(C.JSString_methods.lastIndexOf$1(locationDescription, "/"), 1));
        } else
          locationDescription = null;
        element = A.li(null, "list-item", $name);
        if (J.$eq$(frame.kind, "AsyncSuspensionMarker") || J.$eq$(frame.kind, "EmptyStackMarker"))
          element.toggleClass$1("subtle");
        if (locationDescription != null)
          element.add$1(0, A.span(null, "subtle", " " + locationDescription));
        return element;
      }, null, null, 4, 0, null, 73, "call"]
    },
    VariablesView: {
      "^": "Object;0_items,$ti",
      set$_items: function(_items) {
        this._items = H.assertSubtype(_items, "$isSelectableTree", [S.BoundVariable], "$asSelectableTree");
      },
      VariablesView$2: [function(debuggerState, variableDescriber) {
        var t1 = N.SelectableTree$(S.BoundVariable);
        t1.flex$0(0);
        t1.clazz$1("menu-item-bottom-border");
        t1.clazz$1("debugger-items-list");
        this.set$_items(t1);
        this._items.setChildProvider$1(X.VariablesChildProvider$(debuggerState));
        this._items.setRenderer$1(new X.VariablesView_closure(variableDescriber));
      }, null, null, 8, 0, null, 151, 415],
      get$items: [function() {
        return this._items.get$items();
      }, null, null, 2, 0, null],
      get$element: [function() {
        return this._items;
      }, null, null, 2, 0, null],
      showVariables$1: [function(frame) {
        var t1, t2;
        H.interceptedTypeCheck(frame, "$isFrame");
        t1 = this._items;
        t2 = frame.vars;
        t1.setItems$1(t2 == null ? H.setRuntimeTypeInfo([], [S.BoundVariable]) : t2);
      }, null, "get$showVariables", 4, 0, null, 73],
      clearVariables$0: [function() {
        this._items.setItems$1(H.setRuntimeTypeInfo([], [S.BoundVariable]));
      }, null, "get$clearVariables", 0, 0, null],
      $isCoreElementView: 1,
      static: {
        VariablesView$: [function(debuggerState, variableDescriber) {
          var t1 = new X.VariablesView([]);
          t1.VariablesView$2(debuggerState, variableDescriber);
          return t1;
        }, null, null, 8, 0, null, 151, 415]
      }
    },
    VariablesView_closure: {
      "^": "Closure:93;variableDescriber,$ti",
      call$1: [function(variable) {
        var t1, $name, value, t2, valueStr, element;
        t1 = {};
        H.interceptedTypeCheck(variable, "$isBoundVariable");
        $name = variable.name;
        value = variable.value;
        t2 = J.getInterceptor$(value);
        if (!!t2.$isInstanceRef) {
          valueStr = value.valueAsString;
          if (valueStr == null)
            valueStr = J.get$name$x(value.classRef);
          else {
            if (value.valueAsStringIsTruncated)
              valueStr += "...";
            if (J.$eq$(value.kind, "String"))
              valueStr = "'" + H.S(valueStr) + "'";
          }
          if (J.$eq$(value.kind, "List"))
            valueStr = "[" + H.S(value.length) + "] " + H.S(valueStr);
          else if (J.$eq$(value.kind, "Map"))
            valueStr = "{ " + H.S(value.length) + " } " + H.S(valueStr);
          else {
            t2 = value.kind;
            if (t2 != null && J.endsWith$1$s(t2, "List"))
              valueStr = "[" + H.S(value.length) + "] " + H.S(valueStr);
          }
        } else if (!!t2.$isSentinel)
          valueStr = value.valueAsString;
        else
          valueStr = !!t2.$isTypeArgumentsRef ? value.name : t2.toString$0(value);
        element = A.li(null, "list-item", null);
        J.add$1$ax(element, H.setRuntimeTypeInfo([A.span(null, null, $name), A.span(null, "subtle", " " + H.S(valueStr))], [A.CoreElement]));
        t1.sub = null;
        t1.sub = J.get$onMouseOver$x(element.element).listen$1(new X.VariablesView__closure(t1, this.variableDescriber, variable, element));
        return element;
      }, null, null, 4, 0, null, 261, "call"]
    },
    VariablesView__closure: {
      "^": "Closure:19;_box_0,variableDescriber,variable,element,$ti",
      call$1: [function(e) {
        H.interceptedTypeCheck(e, "$isMouseEvent");
        this._box_0.sub.cancel$0();
        this.variableDescriber.call$1(this.variable).then$1$1(new X.VariablesView___closure(this.element), null);
      }, null, null, 4, 0, null, 19, "call"]
    },
    VariablesView___closure: {
      "^": "Closure:15;element,$ti",
      call$1: [function(desc) {
        this.element.set$tooltip(H.stringTypeCheck(desc));
      }, null, null, 4, 0, null, 620, "call"]
    },
    VariablesChildProvider: {
      "^": "ChildProvider;debuggerState<,$ti",
      hasChildren$1: [function(item) {
        var value = H.interceptedTypeCheck(item, "$isBoundVariable").value;
        return value instanceof S.InstanceRef && value.valueAsString == null;
      }, "call$1", "get$hasChildren", 4, 0, 18, 66],
      getChildren$1: [function(item) {
        return this.getChildren$body$VariablesChildProvider(H.interceptedTypeCheck(item, "$isBoundVariable"));
      }, null, "get$getChildren", 4, 0, null, 66],
      getChildren$body$VariablesChildProvider: [function(item) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, S.BoundVariable]),
          $async$returnValue, $async$self = this, value, result, t1, result0, index, t2;
        var $async$getChildren$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                value = item.value;
                if (!(value instanceof S.InstanceRef)) {
                  $async$returnValue = H.setRuntimeTypeInfo([], [S.BoundVariable]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait($async$self.debuggerState.getInstance$1(value), $async$getChildren$1);
              case 3:
                // returning from await.
                result = $async$result;
                if (!(result instanceof S.Instance)) {
                  $async$returnValue = H.setRuntimeTypeInfo([], [S.BoundVariable]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = result.associations;
                if (t1 != null) {
                  $async$returnValue = J.toList$0$ax(J.map$1$1$ax(t1, new X.VariablesChildProvider_getChildren_closure(), S.BoundVariable));
                  // goto return
                  $async$goto = 1;
                  break;
                } else if (result.elements != null) {
                  result0 = H.setRuntimeTypeInfo([], [S.BoundVariable]);
                  for (t1 = J.get$iterator$ax(result.elements), index = 0; t1.moveNext$0();) {
                    value = t1.get$current();
                    t2 = S.BoundVariable$();
                    t2.name = "[" + index + "]";
                    t2.value = value;
                    C.JSArray_methods.add$1(result0, t2);
                    ++index;
                  }
                  $async$returnValue = result0;
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  t1 = result.fields;
                  t2 = S.BoundVariable;
                  if (t1 != null) {
                    $async$returnValue = J.toList$0$ax(J.map$1$1$ax(t1, new X.VariablesChildProvider_getChildren_closure0(), t2));
                    // goto return
                    $async$goto = 1;
                    break;
                  } else {
                    $async$returnValue = H.setRuntimeTypeInfo([], [t2]);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$getChildren$1, $async$completer);
      }, null, null, 4, 0, null, 66],
      $asChildProvider: function() {
        return [S.BoundVariable];
      },
      static: {
        VariablesChildProvider$: [function(debuggerState) {
          return new X.VariablesChildProvider(debuggerState, []);
        }, null, null, 4, 0, null, 151]
      }
    },
    VariablesChildProvider_getChildren_closure: {
      "^": "Closure:95;$ti",
      call$1: [function(assoc) {
        var keyString, t1;
        H.interceptedTypeCheck(assoc, "$isMapAssociation");
        keyString = H.stringTypeCheck(assoc.key.get$valueAsString());
        t1 = assoc.key;
        if (t1 instanceof S.InstanceRef && J.$eq$(t1.kind, "String"))
          keyString = "'" + H.S(keyString) + "'";
        t1 = S.BoundVariable$();
        t1.name = "[" + H.S(keyString) + "]";
        t1.value = assoc.value;
        return t1;
      }, null, null, 4, 0, null, 622, "call"]
    },
    VariablesChildProvider_getChildren_closure0: {
      "^": "Closure:96;$ti",
      call$1: [function(field) {
        var t1;
        H.interceptedTypeCheck(field, "$isBoundField");
        t1 = S.BoundVariable$();
        t1.name = H.stringTypeCheck(J.get$name$x(field.decl));
        t1.value = field.value;
        return t1;
      }, null, null, 4, 0, null, 424, "call"]
    },
    BreakOnExceptionControl: {
      "^": "CoreElement;0_unhandledElement<,0_allElement<,_pauseModeController<,element,$ti",
      BreakOnExceptionControl$0: [function() {
        var unhandled, t1, all, t2, t3, t4, t5;
        unhandled = A.CoreElement$("input", null, null, null);
        unhandled.setAttribute$2(0, "type", "checkbox");
        t1 = H.interceptedTypeCheck(unhandled.element, "$isInputElement");
        this._unhandledElement = t1;
        all = A.CoreElement$("input", null, null, null);
        all.setAttribute$2(0, "type", "checkbox");
        t2 = H.interceptedTypeCheck(all.element, "$isInputElement");
        this._allElement = t2;
        t3 = A.CoreElement$("label", null, null, null);
        t4 = [A.CoreElement];
        t3.add$1(0, H.setRuntimeTypeInfo([unhandled, A.span(null, null, " Break on unhandled exceptions")], t4));
        t5 = A.CoreElement$("label", null, null, null);
        t5.add$1(0, H.setRuntimeTypeInfo([all, A.span(null, null, " Break on all exceptions")], t4));
        this.add$1(0, H.setRuntimeTypeInfo([t3, t5], t4));
        (t1 && C.InputElement_methods).get$onChange(t1).listen$1(new X.BreakOnExceptionControl_closure(this));
        (t2 && C.InputElement_methods).get$onChange(t2).listen$1(new X.BreakOnExceptionControl_closure0(this, unhandled));
      }, null, null, 0, 0, null],
      get$onPauseModeChanged: [function() {
        return J.get$stream$z(this._pauseModeController);
      }, null, null, 2, 0, null],
      get$exceptionPauseMode: [function() {
        if (J.get$checked$x(this._allElement))
          return "All";
        else if (J.get$checked$x(this._unhandledElement))
          return "Unhandled";
        else
          return "None";
      }, null, null, 2, 0, null],
      set$exceptionPauseMode: [function(value) {
        var t1;
        H.stringTypeCheck(value);
        if (value === "All") {
          J.set$checked$x(this._allElement, true);
          J.set$checked$x(this._unhandledElement, true);
          J.setAttribute$2$x(this._unhandledElement, "disabled", "");
        } else {
          t1 = this._allElement;
          if (value === "Unhandled") {
            J.set$checked$x(t1, false);
            J.set$checked$x(this._unhandledElement, true);
            J.remove$1$ax(J.get$attributes$x(this._unhandledElement), "disabled");
          } else {
            J.set$checked$x(t1, false);
            J.set$checked$x(this._unhandledElement, false);
            J.remove$1$ax(J.get$attributes$x(this._unhandledElement), "disabled");
          }
        }
      }, null, null, 6, 0, null, 1],
      static: {
        BreakOnExceptionControl$: [function() {
          var t1 = new X.BreakOnExceptionControl(P.StreamController_StreamController$broadcast(null, null, false, P.String), W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "break-on-exceptions margin-left flex-no-wrap", null);
          t1.BreakOnExceptionControl$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    BreakOnExceptionControl_closure: {
      "^": "Closure:10;$this,$ti",
      call$1: [function(_) {
        var t1;
        H.interceptedTypeCheck(_, "$isEvent");
        t1 = this.$this;
        J.add$1$ax(t1.get$_pauseModeController(), t1.get$exceptionPauseMode());
      }, null, null, 4, 0, null, 12, "call"]
    },
    BreakOnExceptionControl_closure0: {
      "^": "Closure:10;$this,unhandled,$ti",
      call$1: [function(_) {
        var t1, t2;
        H.interceptedTypeCheck(_, "$isEvent");
        t1 = this.$this;
        t2 = this.unhandled;
        if (J.get$checked$x(t1.get$_allElement())) {
          t2.set$enabled(false);
          J.set$checked$x(t1.get$_unhandledElement(), true);
        } else
          t2.set$enabled(true);
        J.add$1$ax(t1.get$_pauseModeController(), t1.get$exceptionPauseMode());
      }, null, null, 4, 0, null, 12, "call"]
    },
    ScriptAndPosition: {
      "^": "Object;script<,position>,$ti",
      get$uri: [function() {
        return this.script.get$uri();
      }, null, null, 2, 0, null],
      matches$1: [function(_, script) {
        H.interceptedTypeCheck(script, "$isScript");
        return J.$eq$(this.get$uri(), script.uri);
      }, "call$1", "get$matches", 5, 0, 98, 128],
      static: {
        ScriptAndPosition$: [function(script, position) {
          return new X.ScriptAndPosition(script, position, []);
        }, null, null, 4, 3, null, 0, 128, 69]
      }
    },
    _breakpointComparator_getRef: {
      "^": "Closure:99;$ti",
      call$1: [function($location) {
        var t1 = J.getInterceptor$($location);
        if (!!t1.$isSourceLocation)
          return $location.script;
        else if (!!t1.$isUnresolvedSourceLocation)
          return $location.script;
        else
          return;
      }, null, null, 4, 0, null, 181, "call"]
    },
    _breakpointComparator_getPos: {
      "^": "Closure:47;$ti",
      call$1: [function($location) {
        var t1 = J.getInterceptor$($location);
        if (!!t1.$isSourceLocation) {
          t1 = $location.tokenPos;
          return t1 == null ? 0 : t1;
        } else if (!!t1.$isUnresolvedSourceLocation) {
          t1 = $location.line;
          return t1 == null ? 0 : t1;
        } else
          return 0;
      }, null, null, 4, 0, null, 181, "call"]
    },
    ConsoleArea: {
      "^": "Object;_timer,_bufferedText<,0_debugger$_container,0_debugger$_editor,$ti",
      ConsoleArea$0: [function() {
        var options, t1;
        options = P.LinkedHashMap_LinkedHashMap$_literal(["mode", "text/plain"], P.String, null);
        t1 = A.div(null, null, null);
        t1.layoutVertical$0();
        J.flex$0$z(t1);
        H.interceptedTypeCheck(t1, "$isCoreElement");
        this._debugger$_container = t1;
        t1 = X.CodeMirror$fromElement(t1.element, options);
        this._debugger$_editor = t1;
        t1.setReadOnly$1(true);
        J.setAttribute$2$x(J.$index$asx(J.get$children$x(this._debugger$_container.get$element()), 0), "flex", "");
      }, null, null, 0, 0, null],
      get$element: [function() {
        return this._debugger$_container;
      }, null, null, 2, 0, null],
      refresh$0: [function() {
        return this._debugger$_editor.refresh$0();
      }, null, "get$refresh", 0, 0, null],
      clear$0: [function(_) {
        this._debugger$_editor.getDoc$0().setValue$1("");
      }, null, "get$clear", 1, 0, null],
      appendText$1: [function(_, text) {
        this._bufferedText.write$1(H.stringTypeCheck(text));
        this._timer.invoke$1(new X.ConsoleArea_appendText_closure(this));
      }, null, "get$appendText", 5, 0, null, 17],
      _append$1: [function(text) {
        var lastLineIndex, lastLine;
        H.stringTypeCheck(text);
        J.replaceRange$2$asx(this._debugger$_editor.getDoc$0(), text, X.Position$(J.$add$ansx(this._debugger$_editor.getDoc$0().lastLine$0(), 1), 0));
        lastLineIndex = this._debugger$_editor.getDoc$0().lastLine$0();
        lastLine = this._debugger$_editor.getDoc$0().getLine$1(lastLineIndex);
        J.scrollIntoView$2$x(this._debugger$_editor, lastLineIndex, lastLine.length);
      }, null, "get$_append", 4, 0, null, 17],
      getContents$0: [function() {
        return this._debugger$_editor.getDoc$0().getValue$0();
      }, null, "get$getContents", 0, 0, null],
      $isCoreElementView: 1,
      static: {
        ConsoleArea$: [function() {
          var t1 = new X.ConsoleArea(B.DelayedTimer$(C.Duration_100000, C.Duration_1000000), P.StringBuffer$(""), []);
          t1.ConsoleArea$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    ConsoleArea_appendText_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1, string;
        t1 = this.$this;
        string = J.toString$0$(t1.get$_bufferedText());
        J.clear$0$ax(t1.get$_bufferedText());
        t1._append$1(string);
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:devtools/src/eval_on_dart_library.dart",, B, {
    "^": "",
    EvalOnDartLibrary: {
      "^": "Object;_eval_on_dart_library$_disposed<,libraryName,service<,0_libraryRef,0_initializeComplete,0selectedIsolateStreamSubscription,0_isolateId<,0allPendingRequestsDone,$ti",
      set$_libraryRef: function(_libraryRef) {
        this._libraryRef = H.assertSubtype(_libraryRef, "$isCompleter", [S.LibraryRef], "$asCompleter");
      },
      set$_initializeComplete: function(_initializeComplete) {
        this._initializeComplete = H.assertSubtype(_initializeComplete, "$isFuture", [-1], "$asFuture");
      },
      EvalOnDartLibrary$3$isolateId: [function(libraryName, service, isolateId) {
        this.set$_libraryRef(P.Completer_Completer(S.LibraryRef));
        if (isolateId != null)
          this._eval_on_dart_library$_init$2(isolateId, false);
        else
          this.selectedIsolateStreamSubscription = H.interceptedTypeCheck(E.serviceManager().get$isolateManager().getSelectedIsolate$1(new B.EvalOnDartLibrary_closure(this)), "$isStreamSubscription");
      }, null, null, 8, 3, null, 0, 425, 74, 28],
      _eval_on_dart_library$_init$2: [function(isolateId, isIsolateNull) {
        return this._init$body$EvalOnDartLibrary(H.stringTypeCheck(isolateId), H.boolTypeCheck(isIsolateNull));
      }, null, "get$_eval_on_dart_library$_init", 8, 0, null, 28, 426],
      _init$body$EvalOnDartLibrary: [function(isolateId, isIsolateNull) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$_eval_on_dart_library$_init$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait($async$self._initializeComplete, $async$_eval_on_dart_library$_init$2);
              case 2:
                // returning from await.
                if ($async$self._libraryRef.get$isCompleted())
                  $async$self.set$_libraryRef(P.Completer_Completer(S.LibraryRef));
                if (!isIsolateNull)
                  $async$self.set$_initializeComplete($async$self._eval_on_dart_library$_initialize$1(isolateId));
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_eval_on_dart_library$_init$2, $async$completer);
      }, null, null, 8, 0, null, 28, 426],
      get$isolateId: [function() {
        return this._isolateId;
      }, null, null, 2, 0, null],
      get$libraryRef: [function() {
        return this._libraryRef.get$future();
      }, null, null, 2, 0, null],
      _eval_on_dart_library$_initialize$1: [function(isolateId) {
        return this._initialize$body$EvalOnDartLibrary(H.stringTypeCheck(isolateId));
      }, null, "get$_eval_on_dart_library$_initialize", 4, 0, null, 28],
      _initialize$body$EvalOnDartLibrary: [function(isolateId) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, isolate, library, e, t1, t2, exception, $async$exception, $async$temp1;
        var $async$_eval_on_dart_library$_initialize$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  $async$self._isolateId = isolateId;
                  $async$handler = 4;
                  $async$temp1 = H;
                  $async$goto = 7;
                  return P._asyncAwait($async$self.service.getIsolate$1(isolateId), $async$_eval_on_dart_library$_initialize$1);
                case 7:
                  // returning from await.
                  isolate = $async$temp1.interceptedTypeCheck($async$result, "$isIsolate");
                  for (t1 = J.get$iterator$ax(isolate.get$libraries()), t2 = $async$self.libraryName; t1.moveNext$0();) {
                    library = t1.get$current();
                    if (J.$eq$(library.get$uri(), t2)) {
                      J.complete$1$z($async$self._libraryRef, library);
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    }
                  }
                  $async$self._libraryRef.completeError$1("Library " + H.S(t2) + " not found");
                  $async$handler = 2;
                  // goto after finally
                  $async$goto = 6;
                  break;
                case 4:
                  // catch
                  $async$handler = 3;
                  $async$exception = $async$currentError;
                  e = H.unwrapException($async$exception);
                  $async$self._eval_on_dart_library$_handleError$1(e);
                  // goto after finally
                  $async$goto = 6;
                  break;
                case 3:
                  // uncaught
                  // goto rethrow
                  $async$goto = 2;
                  break;
                case 6:
                  // after finally
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
                case 2:
                  // rethrow
                  return P._asyncRethrow($async$currentError, $async$completer);
              }
        });
        return P._asyncStartSync($async$_eval_on_dart_library$_initialize$1, $async$completer);
      }, null, null, 4, 0, null, 28],
      eval$3$isAlive$scope: [function(expression, isAlive, scope) {
        var t1;
        H.stringTypeCheck(expression);
        t1 = P.String;
        return this.addRequest$1$2(H.interceptedTypeCheck(isAlive, "$isObjectGroup"), new B.EvalOnDartLibrary_eval_closure(this, expression, H.assertSubtype(scope, "$isMap", [t1, t1], "$asMap")), S.InstanceRef);
      }, function(expression, isAlive) {
        return this.eval$3$isAlive$scope(expression, isAlive, null);
      }, "eval$2$isAlive", null, null, "get$$eval", 4, 5, null, 0, 0, 147, 124, 184],
      _eval$2$scope: [function(expression, scope) {
        var t1;
        H.stringTypeCheck(expression);
        t1 = P.String;
        H.assertSubtype(scope, "$isMap", [t1, t1], "$asMap");
        return this._eval$body$EvalOnDartLibrary(expression, scope);
      }, null, "get$_eval", 4, 3, null, 0, 147, 184],
      _eval$body$EvalOnDartLibrary: [function(expression, scope) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(S.InstanceRef),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, libraryRef, result, e, t1, exception, $async$exception;
        var $async$_eval$2$scope = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._eval_on_dart_library$_disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$handler = 4;
                $async$goto = 7;
                return P._asyncAwait($async$self._libraryRef.get$future(), $async$_eval$2$scope);
              case 7:
                // returning from await.
                libraryRef = $async$result;
                $async$goto = 8;
                return P._asyncAwait($async$self.service.evaluate$4$scope($async$self._isolateId, J.get$id$z(libraryRef), expression, scope), $async$_eval$2$scope);
              case 8:
                // returning from await.
                result = $async$result;
                if (result instanceof S.ErrorRef)
                  throw H.wrapException(result);
                t1 = H.futureOrCheck(result, {futureOr: 1, type: S.InstanceRef});
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                e = H.unwrapException($async$exception);
                $async$self._eval_on_dart_library$_handleError$1(e);
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_eval$2$scope, $async$completer);
      }, null, null, 4, 3, null, 0, 147, 184],
      _eval_on_dart_library$_handleError$1: [function(e) {
        var t1;
        if (this._eval_on_dart_library$_disposed)
          return;
        t1 = J.getInterceptor$(e);
        switch (t1.get$runtimeType(e)) {
          case C.Type_RPCError_SOa:
            P.print("RPCError " + H.S(t1.get$code(e)) + ": " + H.S(e.get$details()));
            break;
          case C.Type_Error_A6W:
            P.print(H.S(t1.get$kind(e)) + ": " + H.S(t1.get$message(e)));
            break;
          default:
            P.print("Unrecognized error: " + H.S(e));
        }
      }, null, "get$_eval_on_dart_library$_handleError", 4, 0, null, 19],
      getLibrary$2: [function(instance, isAlive) {
        return this.getObjHelper$1$2(H.interceptedTypeCheck(instance, "$isLibraryRef"), H.interceptedTypeCheck(isAlive, "$isObjectGroup"), S.Library);
      }, null, "get$getLibrary", 8, 0, null, 271, 124],
      getClass$2: [function(instance, isAlive) {
        return this.getObjHelper$1$2(H.interceptedTypeCheck(instance, "$isClassRef"), H.interceptedTypeCheck(isAlive, "$isObjectGroup"), S.Class);
      }, null, "get$getClass", 8, 0, null, 271, 124],
      getInstance$2: [function(instanceRefFuture, isAlive) {
        return this.getInstance$body$EvalOnDartLibrary(H.futureOrCheck(instanceRefFuture, {futureOr: 1, type: S.InstanceRef}), H.interceptedTypeCheck(isAlive, "$isObjectGroup"));
      }, null, "get$getInstance", 8, 0, null, 165, 124],
      getInstance$body$EvalOnDartLibrary: [function(instanceRefFuture, isAlive) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(S.Instance),
          $async$returnValue, $async$self = this;
        var $async$getInstance$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 4;
                return P._asyncAwait(instanceRefFuture, $async$getInstance$2);
              case 4:
                // returning from await.
                $async$goto = 3;
                return P._asyncAwait($async$self.getObjHelper$1$2($async$result, isAlive, S.Instance), $async$getInstance$2);
              case 3:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$getInstance$2, $async$completer);
      }, null, null, 8, 0, null, 165, 124],
      addRequest$1$2: [1, function(isAlive, request, $T) {
        return this.addRequest$body$EvalOnDartLibrary(H.interceptedTypeCheck(isAlive, "$isObjectGroup"), H.functionTypeCheck(request, {func: 1, ret: [P.Future, $T]}), $T, $T);
      }, function(isAlive, request) {
        return this.addRequest$1$2(isAlive, request, null);
      }, "addRequest$2", null, "call$2", "get$addRequest", 8, 0, null, 124, 123],
      addRequest$body$EvalOnDartLibrary: [1, function(isAlive, request, $T, $async$type) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter($async$type),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, previousDone, e, t1, response, t2, t3, exception, $async$exception;
        var $async$addRequest$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = isAlive != null;
                if (t1 && isAlive.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                response = P.Completer_Completer($T);
                t2 = new B.EvalOnDartLibrary_addRequest_wrappedRequest($async$self, isAlive, response, request);
                t3 = $async$self.allPendingRequestsDone;
                $async$goto = t3 == null || t3.get$isCompleted() ? 3 : 5;
                break;
              case 3:
                // then
                $async$self.allPendingRequestsDone = response;
                t2.call$0();
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                if (t1 && isAlive.disposed || $async$self._eval_on_dart_library$_disposed) {
                  response.complete$1(0, null);
                  $async$returnValue = response.get$future();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                previousDone = $async$self.allPendingRequestsDone.get$future();
                $async$self.allPendingRequestsDone = response;
                $async$handler = 7;
                $async$goto = 10;
                return P._asyncAwait(previousDone, $async$addRequest$1$2);
              case 10:
                // returning from await.
                $async$handler = 2;
                // goto after finally
                $async$goto = 9;
                break;
              case 7:
                // catch
                $async$handler = 6;
                $async$exception = $async$currentError;
                e = H.unwrapException($async$exception);
                if (!$async$self._eval_on_dart_library$_disposed)
                  P.print(e);
                // goto after finally
                $async$goto = 9;
                break;
              case 6:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 9:
                // after finally
                t2.call$0();
              case 4:
                // join
                $async$returnValue = response.get$future();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$addRequest$1$2, $async$completer);
      }, null, null, 8, 0, null, 124, 123],
      getObjHelper$1$4$count$offset: [1, function(instance, isAlive, count, offset, $T) {
        H.assertIsSubtype($T, S.Obj, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'getObjHelper'.");
        H.interceptedTypeCheck(instance, "$isObjRef");
        return this.addRequest$1$2(H.interceptedTypeCheck(isAlive, "$isObjectGroup"), new B.EvalOnDartLibrary_getObjHelper_closure(this, instance, H.intTypeCheck(offset), H.intTypeCheck(count), $T), $T);
      }, function(instance, isAlive, count, offset) {
        return this.getObjHelper$1$4$count$offset(instance, isAlive, count, offset, S.Obj);
      }, "getObjHelper$4$count$offset", function(instance, isAlive, $T) {
        return this.getObjHelper$1$4$count$offset(instance, isAlive, null, null, $T);
      }, "getObjHelper$1$2", null, "call$4$count$offset", null, "get$getObjHelper", 8, 5, null, 0, 0, 271, 124, 42, 52],
      static: {
        EvalOnDartLibrary$: [function(libraryName, service, isolateId) {
          var t1 = new B.EvalOnDartLibrary(false, libraryName, service, []);
          t1.EvalOnDartLibrary$3$isolateId(libraryName, service, isolateId);
          return t1;
        }, null, null, 8, 3, null, 0, 425, 74, 28]
      }
    },
    EvalOnDartLibrary_closure: {
      "^": "Closure:30;$this,$ti",
      call$1: [function(isolate) {
        var t1, id;
        H.interceptedTypeCheck(isolate, "$isIsolateRef");
        t1 = isolate == null;
        id = !t1 ? isolate.id : null;
        this.$this._eval_on_dart_library$_init$2(id, t1);
      }, null, null, 4, 0, null, 255, "call"]
    },
    EvalOnDartLibrary_eval_closure: {
      "^": "Closure:102;$this,expression,scope,$ti",
      call$0: [function() {
        return this.$this._eval$2$scope(this.expression, this.scope);
      }, null, null, 0, 0, null, "call"]
    },
    EvalOnDartLibrary_addRequest_wrappedRequest: {
      "^": "Closure:0;$this,isAlive,response,request,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, value, e, t1, exception, $async$exception;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.isAlive;
                if (t1 != null && t1.get$disposed() || $async$self.$this.get$_eval_on_dart_library$_disposed()) {
                  J.complete$1$z($async$self.response, null);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$handler = 4;
                $async$goto = 7;
                return P._asyncAwait($async$self.request.call$0(), $async$call$0);
              case 7:
                // returning from await.
                value = $async$result;
                t1 = $async$self.response;
                if (!$async$self.$this.get$_eval_on_dart_library$_disposed())
                  J.complete$1$z(t1, value);
                else
                  J.complete$1$z(t1, null);
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                e = H.unwrapException($async$exception);
                t1 = $async$self.response;
                if ($async$self.$this.get$_eval_on_dart_library$_disposed())
                  J.complete$1$z(t1, null);
                else
                  t1.completeError$1(e);
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    EvalOnDartLibrary_getObjHelper_closure: {
      "^": "Closure;$this,instance,offset,count,T,$ti",
      call$0: [function() {
        return this.$call$body$EvalOnDartLibrary_getObjHelper_closure(this.T);
      }, null, null, 0, 0, null, "call"],
      $call$body$EvalOnDartLibrary_getObjHelper_closure: [function($async$type) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter($async$type),
          $async$returnValue, $async$self = this, t1, $async$temp1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$temp1 = H;
                $async$goto = 3;
                return P._asyncAwait(t1.get$service().getObject$4$count$offset(t1.get$_isolateId(), J.get$id$z($async$self.instance), $async$self.count, $async$self.offset), $async$call$0);
              case 3:
                // returning from await.
                $async$returnValue = $async$temp1.assertSubtypeOfRuntimeType($async$result, $async$self.T);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null],
      $signature: function() {
        return {func: 1, ret: [P.Future, this.T]};
      }
    }
  }], ["", "package:devtools/src/framework/framework.dart",, N, {
    "^": "",
    Framework: {
      "^": "Object;0current<,0auxiliaryStatus<,$ti",
      Framework$0: [function() {
        J.get$onPopState$x(W.window()).listen$1(this.get$handlePopState());
        this.globalStatus = N.StatusLine$(A.CoreElement$from(W.querySelector("#global-status")));
        this.pageStatus = N.StatusLine$(A.CoreElement$from(W.querySelector("#page-status")));
        this.auxiliaryStatus = N.StatusLine$(A.CoreElement$from(W.querySelector("#auxiliary-status")));
        this.globalActions = N.ActionsContainer$(A.CoreElement$from(W.querySelector("#global-actions")));
      }, null, null, 0, 0, null],
      addScreen$1: [function($screen) {
        J.add$1$ax(this.screens, H.interceptedTypeCheck($screen, "$isScreen"));
      }, null, "get$addScreen", 4, 0, null, 296],
      navigateTo$1: [function(id) {
        var $screen, search, ref;
        $screen = this.getScreen$1(H.stringTypeCheck(id));
        search = J.get$search$x(J.get$location$x(W.window()));
        ref = search == null ? $screen.get$ref() : search + H.S($screen.get$ref());
        J.pushState$3$x(J.get$history$x(W.window()), null, $screen.name, ref);
        this.load$1(0, $screen);
      }, null, "get$navigateTo", 4, 0, null, 104],
      loadScreenFromLocation$0: [function() {
        var id, $screen;
        id = J.get$hash$x(J.get$location$x(W.window()));
        $screen = this.getScreen$1(J.get$isNotEmpty$asx(id) ? C.JSString_methods.substring$1(id, 1) : id);
        if ($screen == null)
          $screen = J.get$first$ax(this.screens);
        if ($screen != null)
          this.load$1(0, $screen);
        else
          this.load$1(0, F.NotFoundScreen$());
      }, null, "get$loadScreenFromLocation", 0, 0, null],
      getScreen$1: [function(id) {
        return J.firstWhere$2$orElse$ax(this.screens, new N.Framework_getScreen_closure(H.stringTypeCheck(id)), new N.Framework_getScreen_closure0());
      }, null, "get$getScreen", 4, 0, null, 104],
      handlePopState$1: [function($event) {
        H.interceptedTypeCheck($event, "$isPopStateEvent");
        this.loadScreenFromLocation$0();
      }, "call$1", "get$handlePopState", 4, 0, 103, 22],
      get$mainElement: [function() {
        return A.CoreElement$from(W.querySelector("#content"));
      }, null, null, 2, 0, null],
      load$1: [function(_, $screen) {
        var t1, t2, t3, t4, screenContent;
        H.interceptedTypeCheck($screen, "$isScreen");
        if (this.current == null)
          J.clear$0$ax(J.get$children$x(this.get$mainElement().get$element()));
        t1 = this.current;
        if (t1 != null) {
          this.current = null;
          t1.exiting$0();
          t1.set$visible(false);
          this.pageStatus.removeAll$0();
          J.hidden$1$z(J.$index$asx(this._screenContents, t1), true);
        }
        this.current = $screen;
        t1 = this._screenContents;
        t2 = t1.containsKey$1($screen);
        t3 = J.getInterceptor$asx(t1);
        t4 = this.current;
        if (t2)
          J.hidden$1$z(t3.$index(t1, t4), false);
        else {
          t4.set$framework(this);
          screenContent = this.current.createContent$1(this);
          screenContent.attribute$1("full");
          J.add$1$ax(this.get$mainElement(), screenContent);
          t3.$indexSet(t1, this.current, screenContent);
        }
        this.current.set$visible(true);
        this.current.entering$0();
        J.addAll$1$ax(this.pageStatus, this.current.get$statusItems());
        this.updatePage$0();
      }, null, "get$load", 5, 0, null, 296],
      updatePage$0: [function() {
        var t1, t2;
        for (t1 = J.get$iterator$ax(W.querySelectorAll("#main-nav a", W.Element)); t1.moveNext$0();) {
          t2 = t1.get$current();
          A.CoreElement$from(t2).toggleClass$2("active", J.$eq$(this.current.get$ref(), J.$index$asx(J.get$attributes$x(t2), "href")));
        }
      }, null, "get$updatePage", 0, 0, null],
      showWarning$2$title: [function(message, title) {
        this._showMessage$3$title$warning(H.stringTypeCheck(message), H.stringTypeCheck(title), true);
      }, function(message) {
        return this.showWarning$2$title(message, null);
      }, "showWarning$1", null, null, "get$showWarning", 4, 3, null, 0, 21, 86],
      showError$2: [function(title, error) {
        var message;
        H.stringTypeCheck(title);
        if (error != null) {
          message = H.S(error);
          if (C.JSString_methods.startsWith$1(message, "[object ") || C.JSString_methods.startsWith$1(message, "Instance of "))
            message = null;
        } else
          message = null;
        this._showMessage$3$error$title(message, true, title);
      }, null, "get$showError", 4, 2, null, 0, 86, 14],
      _showMessage$4$error$title$warning: [function(message, error, title, warning) {
        var flash, t1;
        H.stringTypeCheck(message);
        H.stringTypeCheck(title);
        H.boolTypeCheck(warning);
        H.boolTypeCheck(error);
        flash = N.PFlash$(null);
        if (warning)
          flash.warning$0();
        if (error)
          flash.error$0(0);
        J.click$1$z(flash.addClose$0(), this.get$clearMessages());
        if (title != null)
          flash.add$1(0, A.label(null, null, title));
        if (message != null)
          for (t1 = C.JSArray_methods.get$iterator(H.setRuntimeTypeInfo(message.split("\n\n"), [P.String])); t1.moveNext$0();)
            flash.add$1(0, A.div(null, null, t1.get$current()));
        A.CoreElement$from(W.querySelector("#messages-container")).add$1(0, flash);
      }, function(message, error, title) {
        return this._showMessage$4$error$title$warning(message, error, title, false);
      }, "_showMessage$3$error$title", function(message, title, warning) {
        return this._showMessage$4$error$title$warning(message, false, title, warning);
      }, "_showMessage$3$title$warning", null, null, null, "get$_showMessage", 4, 7, null, 18, 0, 18, 21, 14, 86, 635],
      clearMessages$0: [function() {
        J.clear$0$ax(J.get$children$x(W.querySelector("#messages-container")));
      }, "call$0", "get$clearMessages", 0, 0, 0],
      toast$2$title: [function(message, title) {
        var toast = N.Toast$(H.stringTypeCheck(message), H.stringTypeCheck(title));
        A.CoreElement$from(W.querySelector("#toast-container")).add$1(0, toast);
        toast.show$0(0);
      }, function(message) {
        return this.toast$2$title(message, null);
      }, "toast$1", null, null, "get$toast", 4, 3, null, 0, 21, 86],
      addGlobalAction$1: [function(action) {
        H.interceptedTypeCheck(action, "$isActionButton");
        this.globalActions.addAction$1(action);
      }, null, "get$addGlobalAction", 4, 0, null, 63],
      clearGlobalActions$0: [function() {
        this.globalActions.clearActions$0();
      }, null, "get$clearGlobalActions", 0, 0, null]
    },
    Framework_getScreen_closure: {
      "^": "Closure:104;id,$ti",
      call$1: [function($screen) {
        return J.$eq$(H.interceptedTypeCheck($screen, "$isScreen").id, this.id);
      }, null, null, 4, 0, null, 296, "call"]
    },
    Framework_getScreen_closure0: {
      "^": "Closure:1;$ti",
      call$0: [function() {
        return;
      }, null, null, 0, 0, null, "call"]
    },
    StatusLine: {
      "^": "Object;element<,_framework$_items,$ti",
      add$1: [function(_, item) {
        J.add$1$ax(this._framework$_items, H.interceptedTypeCheck(item, "$isStatusItem"));
        this._rebuild$0();
      }, "call$1", "get$add", 5, 0, 105, 66],
      _rebuild$0: [function() {
        var t1, t2, t3, t4, t5, t6;
        t1 = this.element;
        t2 = J.getInterceptor$ax(t1);
        t2.clear$0(t1);
        t3 = this._framework$_items;
        t4 = J.getInterceptor$asx(t3);
        if (t4.get$isNotEmpty(t3)) {
          t2.add$1(t1, t4.get$first(t3).get$element());
          for (t3 = J.get$iterator$ax(t4.sublist$1(t3, 1)); t3.moveNext$0();) {
            t4 = t3.get$current();
            t5 = W.SpanElement_SpanElement();
            t6 = J.getInterceptor$x(t5);
            t6.set$text(t5, "\u2022");
            J.add$1$ax(t6.get$classes(t5), "separator");
            t2.add$1(t1, t5);
            t2.add$1(t1, t4.element);
          }
        }
      }, null, "get$_rebuild", 0, 0, null],
      remove$1: [function(_, item) {
        J.remove$1$ax(this._framework$_items, H.interceptedTypeCheck(item, "$isStatusItem"));
        this._rebuild$0();
      }, null, "get$remove", 5, 0, null, 66],
      addAll$1: [function(_, items) {
        J.addAll$1$ax(this._framework$_items, H.assertSubtype(items, "$isList", [N.StatusItem], "$asList"));
        this._rebuild$0();
      }, null, "get$addAll", 5, 0, null, 189],
      removeAll$0: [function() {
        J.clear$0$ax(this._framework$_items);
        this._rebuild$0();
      }, null, "get$removeAll", 0, 0, null],
      static: {
        StatusLine$: [function(element) {
          return new N.StatusLine(element, H.setRuntimeTypeInfo([], [N.StatusItem]), []);
        }, null, null, 4, 0, null, 10]
      }
    },
    ActionsContainer: {
      "^": "Object;element<,_actions,$ti",
      addAction$1: [function(action) {
        var t1, t2;
        H.interceptedTypeCheck(action, "$isActionButton");
        t1 = this._actions;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isEmpty(t1))
          J.add$1$ax(this.element, A.span("horiz-padding", "masthead-item", "\u2022"));
        t2.add$1(t1, action);
        J.add$1$ax(this.element, action.get$element());
      }, null, "get$addAction", 4, 0, null, 63],
      clearActions$0: [function() {
        J.clear$0$ax(this._actions);
        J.clear$0$ax(this.element);
      }, null, "get$clearActions", 0, 0, null],
      static: {
        ActionsContainer$: [function(element) {
          return new N.ActionsContainer(element, H.setRuntimeTypeInfo([], [N.ActionButton]), []);
        }, null, null, 4, 0, null, 10]
      }
    },
    Screen: {
      "^": "Object;name>,id>,0framework<,statusItems<,$ti",
      set$framework: function(framework) {
        this.framework = H.interceptedTypeCheck(framework, "$isFramework");
      },
      get$ref: [function() {
        var t1 = this.id;
        return J.get$isEmpty$asx(t1) ? t1 : "#" + H.S(t1);
      }, null, null, 2, 0, null],
      get$visible: [function() {
        return J.get$value$x(this._visible);
      }, null, null, 2, 0, null],
      set$visible: [function(value) {
        J.set$value$x(this._visible, H.boolTypeCheck(value));
      }, null, null, 6, 0, null, 1],
      entering$0: [function() {
      }, null, "get$entering", 0, 0, null],
      get$isCurrentScreen: [function() {
        var t1 = this.framework;
        return t1 != null && J.$eq$(t1.get$current(), this);
      }, null, null, 2, 0, null],
      exiting$0: [function() {
      }, null, "get$exiting", 0, 0, null],
      addStatusItem$1: [function(item) {
        J.add$1$ax(this.statusItems, H.interceptedTypeCheck(item, "$isStatusItem"));
      }, null, "get$addStatusItem", 4, 0, null, 66],
      toString$0: [function(_) {
        return "Screen(" + H.S(this.id) + ")";
      }, null, "get$toString", 1, 0, null]
    },
    SetStateMixin: {
      "^": "Object;$ti",
      setState$1: [function(rebuild) {
        H.interceptedTypeCheck(rebuild, "$isFunction");
        J.requestAnimationFrame$1$x(W.window(), new N.SetStateMixin_setState_closure(rebuild));
      }, null, "get$setState", 4, 0, null, 637],
      static: {
        SetStateMixin$: [function() {
          return new N.SetStateMixin([]);
        }, null, null, 0, 0, null]
      }
    },
    SetStateMixin_setState_closure: {
      "^": "Closure:106;rebuild,$ti",
      call$1: [function(_) {
        H.numTypeCheck(_);
        return this.rebuild.call$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    HelpInfo: {
      "^": "Object;$ti"
    },
    StatusItem: {
      "^": "Object;element<,$ti",
      static: {
        StatusItem$: [function() {
          return new N.StatusItem(A.span(null, null, null), []);
        }, null, null, 0, 0, null]
      }
    },
    Toast: {
      "^": "CoreElement;title,message>,element,$ti",
      Toast$2$message$title: [function(message, title) {
        var t1 = this.title;
        if (t1 != null)
          this.add$1(0, A.label(null, null, t1));
        this.add$1(0, A.div(null, null, this.message));
      }, null, null, 0, 5, null, 0, 0, 21, 86],
      show$0: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this;
        var $async$show$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(J.get$animationFrame$x(W.window()), $async$show$0);
              case 2:
                // returning from await.
                J.set$left$x(J.get$style$x($async$self.element), "0px");
                P.Timer_Timer(C.Duration_500000, new N.Toast_show_closure($async$self));
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$show$0, $async$completer);
      }, null, "get$show", 1, 0, null],
      _hide$0: [function() {
        J.set$left$x(J.get$style$x(this.element), "400px");
        P.Timer_Timer(C.Duration_500000, this.get$dispose());
      }, "call$0", "get$_hide", 0, 0, 0],
      toString$0: [function(_) {
        return H.S(this.title) + " " + H.S(this.message);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        Toast$: [function(message, title) {
          var t1 = new N.Toast(title, message, W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "toast", null);
          t1.Toast$2$message$title(message, title);
          return t1;
        }, null, null, 0, 5, null, 0, 0, 21, 86]
      }
    },
    Toast_show_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        P.Timer_Timer(C.Duration_4000000, this.$this.get$_hide());
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:devtools/src/framework/framework_core.dart",, E, {
    "^": "",
    FrameworkCore_init: [function() {
      E.FrameworkCore__setServiceConnectionManager();
    }, null, null, 0, 0, null],
    FrameworkCore__setServiceConnectionManager: [function() {
      E.setGlobal(C.Type_ServiceConnectionManager_qdG, R.ServiceConnectionManager$());
      E.setGlobal(C.Type_MessageBus_MAi, A.MessageBus$());
    }, null, null, 0, 0, null],
    FrameworkCore_initVmService: [function(errorReporter) {
      H.functionTypeCheck(errorReporter, {func: 1, ret: -1, args: [P.String,,]});
      return E.FrameworkCore_initVmService$body(errorReporter);
    }, null, null, 4, 0, null, 431],
    FrameworkCore_initVmService$body: [function(errorReporter) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$handler = 1, $async$currentError, $async$next = [], port, finishedCompleter, service, e, portStr, exception, $async$exception;
      var $async$FrameworkCore_initVmService = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              port = null;
              if (J.get$isNotEmpty$asx(J.get$search$x(J.get$location$x(W.window())))) {
                portStr = J.$index$asx(P.Uri_parse(J.toString$0$(J.get$location$x(W.window())), 0, null).get$queryParameters(), "port");
                if (portStr != null)
                  port = P.int_tryParse(portStr, null);
              }
              $async$goto = port != null ? 2 : 3;
              break;
            case 2:
              // then
              finishedCompleter = P.Completer_Completer(P.Null);
              $async$handler = 5;
              $async$goto = 8;
              return P._asyncAwait(R.connect("localhost", port, finishedCompleter), $async$FrameworkCore_initVmService);
            case 8:
              // returning from await.
              service = $async$result;
              $async$goto = E.serviceManager() != null ? 9 : 10;
              break;
            case 9:
              // then
              $async$goto = 11;
              return P._asyncAwait(E.serviceManager().vmServiceOpened$2$onClosed(service, finishedCompleter.get$future()), $async$FrameworkCore_initVmService);
            case 11:
              // returning from await.
            case 10:
              // join
              $async$handler = 1;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              errorReporter.call$2("Unable to connect to app on port " + H.S(port), e);
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 7:
              // after finally
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$FrameworkCore_initVmService, $async$completer);
    }, null, null, 4, 0, null, 431],
    FrameworkCore: {
      "^": "Object;$ti"
    }
  }], ["", "package:devtools/src/globals.dart",, E, {
    "^": "",
    serviceManager: [function() {
      return H.interceptedTypeCheck(J.$index$asx($.$get$globals(), C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager");
    }, null, null, 2, 0, null],
    messageBus: [function() {
      return H.interceptedTypeCheck(J.$index$asx($.$get$globals(), C.Type_MessageBus_MAi), "$isMessageBus");
    }, null, null, 2, 0, null],
    setGlobal: [function(clazz, instance) {
      H.interceptedTypeCheck(clazz, "$isType");
      J.$indexSet$ax($.$get$globals(), clazz, instance);
    }, null, null, 8, 0, null, 697, 271]
  }], ["diagnostics_node", "package:devtools/src/inspector/diagnostics_node.dart",, M, {
    "^": "",
    _invertMap: [1, function(inverted, $K, $V) {
      H.assertSubtype(inverted, "$isMap", [$V, $K], "$asMap");
      return P.Map_Map$fromEntries(J.map$1$1$ax(inverted.get$entries(inverted), new M._invertMap_closure($V, $K), [P.MapEntry, $K, $V]), $K, $V);
    }, function(inverted) {
      return M._invertMap(inverted, null, null);
    }, null, "call$1", null, 4, 0, null, 639],
    _invertMap_closure: {
      "^": "Closure;V,K,$ti",
      call$1: [function(entry) {
        var t1, t2;
        t1 = this.V;
        t2 = this.K;
        H.assertSubtype(entry, "$isMapEntry", [t1, t2], "$asMapEntry");
        return P.MapEntry$_(entry.value, entry.key, t2, t1);
      }, null, null, 4, 0, null, 642, "call"],
      $signature: function() {
        var t1, t2;
        t1 = this.K;
        t2 = this.V;
        return {func: 1, ret: [P.MapEntry, t1, t2], args: [[P.MapEntry, t2, t1]]};
      }
    },
    RemoteDiagnosticsNode: {
      "^": "DiagnosticableTree;parent>,0propertyDocFuture,0cachedProperties,inspectorService<,json,0_valueProperties,isProperty<,0_creationLocation,0_childrenFuture,0_children,$ti",
      set$cachedProperties: function(cachedProperties) {
        this.cachedProperties = H.assertSubtype(cachedProperties, "$isList", [M.RemoteDiagnosticsNode], "$asList");
      },
      set$_childrenFuture: function(_childrenFuture) {
        this._childrenFuture = H.assertSubtype(_childrenFuture, "$isFuture", [[P.List, M.RemoteDiagnosticsNode]], "$asFuture");
      },
      set$_children: function(_, _children) {
        this._children = H.assertSubtype(_children, "$isList", [M.RemoteDiagnosticsNode], "$asList");
      },
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof M.RemoteDiagnosticsNode))
          return false;
        return J.$eq$(this.get$dartDiagnosticRef(), other.get$dartDiagnosticRef());
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.get$dartDiagnosticRef());
      }, null, null, 3, 0, null],
      get$separator: [function() {
        return this.get$showSeparator() ? ":" : "";
      }, null, null, 2, 0, null],
      get$name: [function(_) {
        return this.getStringMember$1("name");
      }, null, null, 3, 0, null],
      get$showSeparator: [function() {
        return this.getBooleanMember$2("showSeparator", true);
      }, null, null, 2, 0, null],
      get$description: [function() {
        return this.getStringMember$1("description");
      }, null, null, 2, 0, null],
      get$level: [function() {
        return this.getLevelMember$2("level", C.DiagnosticLevel_3);
      }, null, null, 2, 0, null],
      get$showName: [function() {
        return this.getBooleanMember$2("showName", true);
      }, null, null, 2, 0, null],
      get$style: [function(_) {
        return this.getStyleMember$2("style", C.DiagnosticsTreeStyle_0);
      }, null, null, 3, 0, null],
      get$hasDefaultValue: [function() {
        return this.json.containsKey$1("defaultValue");
      }, null, null, 2, 0, null],
      get$allowWrap: [function() {
        return this.getBooleanMember$2("allowWrap", true);
      }, null, null, 2, 0, null],
      get$hasCreationLocation: [function() {
        return this._creationLocation != null || this.json.containsKey$1("creationLocation");
      }, null, null, 2, 0, null],
      set$creationLocation: [function($location) {
        this._creationLocation = H.interceptedTypeCheck($location, "$isInspectorSourceLocation");
      }, null, null, 6, 0, null, 181],
      get$creationLocation: [function() {
        var t1 = this._creationLocation;
        if (t1 != null)
          return t1;
        if (!this.get$hasCreationLocation())
          return;
        t1 = M.InspectorSourceLocation$(H.assertSubtype(J.$index$asx(this.json, "creationLocation"), "$isMap", [P.String, P.Object], "$asMap"), null);
        this._creationLocation = t1;
        return t1;
      }, null, null, 2, 0, null],
      get$propertyType: [function() {
        return this.getStringMember$1("propertyType");
      }, null, null, 2, 0, null],
      getStringMember$1: [function(memberName) {
        return B.JsonUtils_getStringMember(this.json, H.stringTypeCheck(memberName));
      }, null, "get$getStringMember", 4, 0, null, 142],
      getBooleanMember$2: [function(memberName, defaultValue) {
        var t1, t2;
        H.stringTypeCheck(memberName);
        H.boolTypeCheck(defaultValue);
        t1 = this.json;
        t2 = J.getInterceptor$asx(t1);
        if (t2.$index(t1, memberName) == null)
          return defaultValue;
        return H.boolTypeCheck(t2.$index(t1, memberName));
      }, null, "get$getBooleanMember", 8, 0, null, 142, 268],
      getLevelMember$2: [function(memberName, defaultValue) {
        var value, level;
        H.stringTypeCheck(memberName);
        H.interceptedTypeCheck(defaultValue, "$isDiagnosticLevel");
        value = H.stringTypeCheck(J.$index$asx(this.json, memberName));
        if (value == null)
          return defaultValue;
        level = C.Map_omyhD.$index(0, value);
        return level == null ? defaultValue : level;
      }, null, "get$getLevelMember", 8, 0, null, 142, 268],
      getStyleMember$2: [function(memberName, defaultValue) {
        var t1, value, style;
        H.stringTypeCheck(memberName);
        H.interceptedTypeCheck(defaultValue, "$isDiagnosticsTreeStyle");
        t1 = this.json;
        if (!t1.containsKey$1(memberName))
          return defaultValue;
        value = H.stringTypeCheck(J.$index$asx(t1, memberName));
        if (value == null)
          return defaultValue;
        style = C.Map_kTHDR.$index(0, value);
        return style == null ? defaultValue : style;
      }, null, "get$getStyleMember", 8, 0, null, 142, 268],
      get$valueRef: [function() {
        return E.InspectorInstanceRef$(H.stringTypeCheck(J.$index$asx(this.json, "valueId")));
      }, null, null, 2, 0, null],
      get$valuePropertiesJson: [function() {
        return H.assertSubtype(J.$index$asx(this.json, "valueProperties"), "$isMap", [P.String, P.Object], "$asMap");
      }, null, null, 2, 0, null],
      get$hasChildren: [function() {
        if (this.getBooleanMember$2("hasChildren", false))
          return true;
        var children = H.listTypeCheck(J.$index$asx(this.json, "children"));
        return J.$eq$(children == null ? null : J.get$isNotEmpty$asx(children), true);
      }, null, null, 2, 0, null],
      get$isCreatedByLocalProject: [function() {
        return this.getBooleanMember$2("createdByLocalProject", false);
      }, null, null, 2, 0, null],
      get$isSummaryTree: [function() {
        return this.getBooleanMember$2("summaryTree", false);
      }, null, null, 2, 0, null],
      get$widgetRuntimeType: [function() {
        return this.getStringMember$1("widgetRuntimeType");
      }, null, null, 2, 0, null],
      get$childrenReady: [function() {
        return this.json.containsKey$1("children") || this._children != null || !this.get$hasChildren();
      }, null, null, 2, 0, null],
      get$children: [function(_) {
        this._computeChildren$0();
        return this._childrenFuture;
      }, null, null, 3, 0, null],
      get$childrenNow: [function() {
        this._maybePopulateChildren$0();
        return this._children;
      }, null, null, 2, 0, null],
      _computeChildren$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
        var $async$_computeChildren$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$self._maybePopulateChildren$0();
                if (!$async$self.get$hasChildren() || $async$self._children != null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = $async$self._childrenFuture;
                $async$goto = t1 != null ? 3 : 4;
                break;
              case 3:
                // then
                $async$goto = 5;
                return P._asyncAwait(t1, $async$_computeChildren$0);
              case 5:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 4:
                // join
                $async$self.set$_childrenFuture($async$self._getChildrenHelper$0());
                $async$handler = 6;
                $async$goto = 9;
                return P._asyncAwait($async$self._childrenFuture, $async$_computeChildren$0);
              case 9:
                // returning from await.
                $async$self.set$_children(0, $async$result);
                $async$next.push(8);
                // goto finally
                $async$goto = 7;
                break;
              case 6:
                // uncaught
                $async$next = [2];
              case 7:
                // finally
                $async$handler = 2;
                if ($async$self._children == null)
                  $async$self.set$_children(0, H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]));
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 8:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_computeChildren$0, $async$completer);
      }, null, "get$_computeChildren", 0, 0, null],
      _getChildrenHelper$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, M.RemoteDiagnosticsNode]),
          $async$returnValue, $async$self = this, t1;
        var $async$_getChildrenHelper$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self.inspectorService, $async$_getChildrenHelper$0);
              case 3:
                // returning from await.
                t1 = $async$result;
                $async$returnValue = t1 == null ? null : t1.getChildren$3($async$self.get$dartDiagnosticRef(), $async$self.get$isSummaryTree(), $async$self);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_getChildrenHelper$0, $async$completer);
      }, null, "get$_getChildrenHelper", 0, 0, null],
      _maybePopulateChildren$0: [function() {
        var t1, jsonArray, nodes, t2, t3, child;
        if (!this.get$hasChildren() || this._children != null)
          return;
        t1 = P.Object;
        jsonArray = H.assertSubtype(J.$index$asx(this.json, "children"), "$isList", [t1], "$asList");
        if (J.$eq$(jsonArray == null ? null : J.get$isNotEmpty$asx(jsonArray), true)) {
          nodes = H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]);
          for (t2 = J.get$iterator$ax(jsonArray), t1 = [P.String, t1], t3 = this.inspectorService; t2.moveNext$0();) {
            child = M.RemoteDiagnosticsNode$(H.assertSubtype(t2.get$current(), "$isMap", t1, "$asMap"), t3, false, this.parent);
            child.parent = this;
            C.JSArray_methods.add$1(nodes, child);
          }
          this.set$_children(0, nodes);
        }
      }, null, "get$_maybePopulateChildren", 0, 0, null],
      get$dartDiagnosticRef: [function() {
        return E.InspectorInstanceRef$(H.stringTypeCheck(J.$index$asx(this.json, "objectId")));
      }, null, null, 2, 0, null],
      get$inlineProperties: [function() {
        var t1, t2, t3, element;
        if (this.cachedProperties == null) {
          this.set$cachedProperties(H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]));
          t1 = this.json;
          if (t1.containsKey$1("properties")) {
            t2 = P.Object;
            for (t1 = J.get$iterator$ax(H.assertSubtype(J.$index$asx(t1, "properties"), "$isList", [t2], "$asList")), t2 = [P.String, t2], t3 = this.inspectorService; t1.moveNext$0();) {
              element = H.assertSubtype(t1.get$current(), "$isMap", t2, "$asMap");
              J.add$1$ax(this.cachedProperties, M.RemoteDiagnosticsNode$(element, t3, true, this.parent));
            }
            this.trackPropertiesMatchingParameters$1(this.cachedProperties);
          }
        }
        return this.cachedProperties;
      }, null, null, 2, 0, null],
      trackPropertiesMatchingParameters$1: [function(nodes) {
        var t1, parameterLocations, names, t2, $name, parameterLocation;
        H.assertSubtype(nodes, "$isList", [M.RemoteDiagnosticsNode], "$asList");
        t1 = this.get$creationLocation();
        parameterLocations = t1 == null ? null : t1.getParameterLocations$0();
        if (parameterLocations != null) {
          names = P.LinkedHashMap_LinkedHashMap$_empty(P.String, M.InspectorSourceLocation);
          for (t1 = J.get$iterator$ax(parameterLocations); t1.moveNext$0();) {
            t2 = t1.get$current();
            $name = t2.getName$0();
            if ($name != null)
              names.$indexSet(0, $name, t2);
          }
          for (t1 = J.get$iterator$ax(nodes); t1.moveNext$0();) {
            t2 = t1.get$current();
            t2.parent = this;
            $name = t2.get$name(t2);
            if ($name != null) {
              parameterLocation = names.$index(0, $name);
              if (parameterLocation != null)
                t2.set$creationLocation(parameterLocation);
            }
          }
        }
        return nodes;
      }, null, "get$trackPropertiesMatchingParameters", 4, 0, null, 644],
      get$widget: [function() {
        var t1 = S.Catalog_instance();
        return t1 == null ? null : t1.getWidget$1(this.get$widgetRuntimeType());
      }, null, null, 2, 0, null],
      get$icon: [function() {
        var t1, icon;
        if (this.isProperty)
          return;
        t1 = this.get$widget();
        icon = t1 == null ? null : t1.get$icon();
        t1 = icon == null;
        return t1 && this.get$widgetRuntimeType() != null ? t1 ? $.$get$RemoteDiagnosticsNode_iconMaker().fromWidgetName$1(this.get$widgetRuntimeType()) : icon : icon;
      }, null, null, 2, 0, null],
      debugFillProperties$1: [function(properties) {
        var t1, t2, t3;
        H.interceptedTypeCheck(properties, "$isDiagnosticPropertiesBuilder");
        this.super$Diagnosticable$debugFillProperties(properties);
        for (t1 = J.get$iterator$ax(this.get$inlineProperties()), t2 = M.RemoteDiagnosticsNode; t1.moveNext$0();) {
          t3 = t1.get$current();
          properties.add$1(0, U.DiagnosticsProperty$(t3.get$name(t3), t3, true, C.C__NoDefaultValue, null, false, null, null, C.DiagnosticLevel_3, null, false, true, true, false, C.DiagnosticsTreeStyle_7, null, t2));
        }
      }, null, "get$debugFillProperties", 4, 0, null, 433],
      debugDescribeChildren$0: [function() {
        var children, regularChildren, t1;
        children = this.get$childrenNow();
        if (children == null || J.get$isEmpty$asx(children))
          return C.List_empty;
        regularChildren = H.setRuntimeTypeInfo([], [U.DiagnosticsNode]);
        for (t1 = J.get$iterator$ax(children); t1.moveNext$0();)
          C.JSArray_methods.add$1(regularChildren, t1.get$current().toDiagnosticsNode$0());
        return regularChildren;
      }, null, "get$debugDescribeChildren", 0, 0, null],
      toDiagnosticsNode$2$name$style: [function($name, style) {
        var t1;
        H.stringTypeCheck($name);
        H.interceptedTypeCheck(style, "$isDiagnosticsTreeStyle");
        t1 = $name == null ? this.get$name(this) : $name;
        return this.super$DiagnosticableTree$toDiagnosticsNode(t1, style == null ? C.DiagnosticsTreeStyle_0 : style);
      }, function(style) {
        return this.toDiagnosticsNode$2$name$style(null, style);
      }, "toDiagnosticsNode$1$style", function() {
        return this.toDiagnosticsNode$2$name$style(null, null);
      }, "toDiagnosticsNode$0", null, null, null, "get$toDiagnosticsNode", 0, 5, null, 0, 0, 8, 140],
      toStringShort$0: [function() {
        return this.get$description();
      }, null, "get$toStringShort", 0, 0, null],
      setSelectionInspector$1: [function(uiAlreadyUpdated) {
        return this.setSelectionInspector$body$RemoteDiagnosticsNode(H.boolTypeCheck(uiAlreadyUpdated));
      }, null, "get$setSelectionInspector", 4, 0, null, 110],
      setSelectionInspector$body$RemoteDiagnosticsNode: [function(uiAlreadyUpdated) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, t1;
        var $async$setSelectionInspector$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait($async$self.inspectorService, $async$setSelectionInspector$1);
              case 2:
                // returning from await.
                t1 = $async$result;
                $async$goto = 3;
                return P._asyncAwait(t1 == null ? null : t1.setSelectionInspector$2($async$self.get$valueRef(), uiAlreadyUpdated), $async$setSelectionInspector$1);
              case 3:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$setSelectionInspector$1, $async$completer);
      }, null, null, 4, 0, null, 110],
      hasChildren$1: function(arg0) {
        return this.get$hasChildren().call$1(arg0);
      },
      static: {
        RemoteDiagnosticsNode$: [function(json, inspectorService, isProperty, $parent) {
          return new M.RemoteDiagnosticsNode($parent, inspectorService, json, isProperty, []);
        }, null, null, 16, 0, null, 2, 163, 641, 24]
      }
    },
    InspectorSourceLocation: {
      "^": "Object;json,parent>,$ti",
      get$path: [function(_) {
        return B.JsonUtils_getStringMember(this.json, "file");
      }, null, null, 3, 0, null],
      getName$0: [function() {
        return B.JsonUtils_getStringMember(this.json, "name");
      }, null, "get$getName", 0, 0, null],
      getParameterLocations$0: [function() {
        var t1, t2, parametersJson, ret, i, t3;
        t1 = this.json;
        if (t1.containsKey$1("parameterLocations")) {
          t2 = P.Object;
          parametersJson = H.assertSubtype(J.$index$asx(t1, "parameterLocations"), "$isList", [t2], "$asList");
          ret = H.setRuntimeTypeInfo([], [M.InspectorSourceLocation]);
          t1 = J.getInterceptor$asx(parametersJson);
          t2 = [P.String, t2];
          i = 0;
          while (true) {
            t3 = t1.get$length(parametersJson);
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (!(i < t3))
              break;
            C.JSArray_methods.add$1(ret, M.InspectorSourceLocation$(H.assertSubtype(t1.$index(parametersJson, i), "$isMap", t2, "$asMap"), this));
            ++i;
          }
          return ret;
        }
        return;
      }, null, "get$getParameterLocations", 0, 0, null],
      static: {
        InspectorSourceLocation$: [function(json, $parent) {
          return new M.InspectorSourceLocation(json, $parent, []);
        }, null, null, 8, 0, null, 2, 24]
      }
    },
    SourcePosition0: {
      "^": "Object;$ti"
    }
  }], ["flutter_widget", "package:devtools/src/inspector/flutter_widget.dart",, S, {
    "^": "",
    Category: {
      "^": "Object;label,icon<,$ti",
      static: {
        "^": "Category_input<,Category_text<,Category_values<",
        Category_forLabel: [function(label) {
          var t1, t2;
          H.stringTypeCheck(label);
          if ($.Category__categories == null) {
            $.Category__categories = P.LinkedHashMap_LinkedHashMap$_empty(P.String, S.Category);
            for (t1 = C.JSArray_methods.get$iterator(C.List_ZZ9); t1.moveNext$0();) {
              t2 = t1.get$current();
              J.$indexSet$ax($.Category__categories, t2.label, t2);
            }
          }
          return J.$index$asx($.Category__categories, label);
        }, null, null, 4, 0, null, 648]
      }
    },
    FlutterWidget: {
      "^": "Object;json,icon<,$ti",
      get$name: [function(_) {
        return B.JsonUtils_getStringMember(this.json, "name");
      }, null, null, 3, 0, null],
      static: {
        FlutterWidget$: [function(json) {
          return new S.FlutterWidget(json, S.FlutterWidget_initIcon(json), []);
        }, null, null, 4, 0, null, 2],
        FlutterWidget_initIcon: [function(json) {
          var t1, categories, category, icon;
          t1 = P.Object;
          categories = H.assertSubtype(H.assertSubtype(json, "$isMap", [P.String, t1], "$asMap").$index(0, "categories"), "$isList", [t1], "$asList");
          if (categories != null)
            for (t1 = J.get$iterator$ax(categories); t1.moveNext$0();) {
              category = S.Category_forLabel(H.stringTypeCheck(t1.get$current()));
              if (category != null) {
                icon = category.icon;
                if (icon != null)
                  return icon;
              }
            }
          return;
        }, null, null, 4, 0, null, 2]
      }
    },
    Catalog: {
      "^": "Object;widgets,$ti",
      getWidget$1: [function($name) {
        H.stringTypeCheck($name);
        return $name != null ? J.$index$asx(this.widgets, $name) : null;
      }, null, "get$getWidget", 4, 0, null, 8],
      static: {
        Catalog$_: [function(widgets) {
          return new S.Catalog(widgets, []);
        }, null, null, 4, 0, null, 649],
        Catalog_instance: [function() {
          return $.Catalog__instance;
        }, null, null, 2, 0, null],
        Catalog_load: [function() {
          var t1 = $.Catalog__cachedCatalog;
          if (t1 == null) {
            t1 = S.Catalog__loadHelper();
            $.Catalog__cachedCatalog = t1;
          }
          return t1;
        }, null, null, 0, 0, null],
        Catalog__loadHelper: [function() {
          var $async$goto = 0,
            $async$completer = P._makeAsyncAwaitCompleter(S.Catalog),
            $async$returnValue, response, t1;
          var $async$Catalog__loadHelper = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
            if ($async$errorCode === 1)
              return P._asyncRethrow($async$result, $async$completer);
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  $async$goto = 3;
                  return P._asyncAwait(G.get("widgets.json", null), $async$Catalog__loadHelper);
                case 3:
                  // returning from await.
                  response = $async$result;
                  t1 = S.Catalog_decode(response.get$body(response));
                  $.Catalog__instance = t1;
                  $async$returnValue = t1;
                  // goto return
                  $async$goto = 1;
                  break;
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
          });
          return P._asyncStartSync($async$Catalog__loadHelper, $async$completer);
        }, null, null, 0, 0, null],
        Catalog_decode: [function(source) {
          var t1, json, t2, widgets, t3, widget;
          t1 = P.Object;
          json = H.assertSubtype(P.jsonDecode(H.stringTypeCheck(source), null), "$isList", [t1], "$asList");
          t2 = P.String;
          widgets = P.LinkedHashMap_LinkedHashMap$_empty(t2, S.FlutterWidget);
          for (t3 = J.get$iterator$ax(json), t1 = [t2, t1]; t3.moveNext$0();) {
            widget = S.FlutterWidget$(H.assertSubtype(t3.get$current(), "$isMap", t1, "$asMap"));
            widgets.$indexSet(0, widget.get$name(widget), widget);
          }
          return S.Catalog$_(widgets);
        }, null, null, 4, 0, null, 11]
      }
    }
  }], ["inspector", "package:devtools/src/inspector/inspector.dart",, D, {
    "^": "",
    InspectorScreen: {
      "^": "Screen;0refreshTreeButton,inspectorStateMixin,0inspectorService<,0inspectorController,0progressElement,0inspectorContainer,0splitterSubscription,displayedWidgetTrackingNotice,name,id,iconClass,0framework,_visible,statusItems,$ti",
      set$splitterSubscription: function(splitterSubscription) {
        this.splitterSubscription = H.assertSubtype(splitterSubscription, "$isStreamSubscription", [P.Object], "$asStreamSubscription");
      },
      set$displayedWidgetTrackingNotice: function(displayedWidgetTrackingNotice) {
        this.displayedWidgetTrackingNotice = H.boolTypeCheck(displayedWidgetTrackingNotice);
      },
      createContent$1: [function(framework) {
        var screenDiv, buttonSection, t1, t2, t3, t4, t5;
        H.interceptedTypeCheck(framework, "$isFramework");
        screenDiv = A.div(null, "custom-scrollbar", null);
        screenDiv.layoutVertical$0();
        buttonSection = A.div(null, "section", null);
        buttonSection.layoutHorizontal$0();
        t1 = A.div(null, "btn-group", null);
        t2 = Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_woc).button;
        t3 = N.PButton$icon("Refresh Tree", C.UrlIcon_mZF, null);
        t3.small$0();
        t3.set$disabled(0, true);
        t3.click$1(0, this.get$_refreshInspector());
        this.refreshTreeButton = t3;
        J.add$1$ax(t1, H.setRuntimeTypeInfo([t2, t3], [N.PButton]));
        t3 = N.ProgressElement$();
        t3.clazz$1("margin-left");
        t3.set$display(0, "none");
        this.progressElement = t3;
        t2 = A.div(null, null, null);
        J.flex$0$z(t2);
        t4 = [A.CoreElement];
        t5 = J.getInterceptor$ax(buttonSection);
        t5.add$1(buttonSection, H.setRuntimeTypeInfo([t1, t3, t2], t4));
        J.forEach$1$ax(Y.getServiceExtensionButtons(), t5.get$add(buttonSection));
        t5 = H.interceptedTypeCheck(A.div(null, "inspector-container", null), "$isCoreElement");
        this.inspectorContainer = t5;
        J.add$1$ax(screenDiv, H.setRuntimeTypeInfo([buttonSection, t5], t4));
        E.serviceManager().get$onConnectionAvailable().listen$1(this.get$_inspector$_handleConnectionStart());
        if (E.serviceManager().get$hasConnection())
          this._inspector$_handleConnectionStart$1(E.serviceManager().get$service());
        E.serviceManager().get$onConnectionClosed().listen$1(this.get$_inspector$_handleConnectionStop());
        return screenDiv;
      }, null, "get$createContent", 4, 0, null, 127],
      exiting$0: [function() {
        this.framework.clearMessages$0();
      }, null, "get$exiting", 0, 0, null],
      _inspector$_handleConnectionStart$1: [function(service) {
        H.interceptedTypeCheck(service, "$isVmService");
        return this._handleConnectionStart$body$InspectorScreen(service);
      }, "call$1", "get$_inspector$_handleConnectionStart", 4, 0, 46, 74],
      _handleConnectionStart$body$InspectorScreen: [function(service) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, spinner, pubRootDirectory, spinner0, t1, inspectorTree, detailsInspectorTree, elements, $async$temp1;
        var $async$_inspector$_handleConnectionStart$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                J.set$disabled$z($async$self.refreshTreeButton, false);
                spinner0 = N.Spinner$();
                spinner0.clazz$1("padded");
                spinner = spinner0;
                J.add$1$ax($async$self.inspectorContainer, spinner);
                $async$handler = 3;
                $async$goto = 6;
                return P._asyncAwait(E.ensureInspectorServiceDependencies(), $async$_inspector$_handleConnectionStart$1);
              case 6:
                // returning from await.
                $async$temp1 = H;
                $async$goto = 7;
                return P._asyncAwait(E.InspectorService_create(service).catchError$1(new D.InspectorScreen__handleConnectionStart_closure()), $async$_inspector$_handleConnectionStart$1);
              case 7:
                // returning from await.
                t1 = $async$temp1.interceptedTypeCheck($async$result, "$isInspectorService");
                $async$self.inspectorService = t1;
                $async$goto = 8;
                return P._asyncAwait(t1 == null ? null : t1.inferPubRootDirectoryIfNeeded$0(), $async$_inspector$_handleConnectionStart$1);
              case 8:
                // returning from await.
                pubRootDirectory = $async$result;
                $async$next.push(5);
                // goto finally
                $async$goto = 4;
                break;
              case 3:
                // uncaught
                $async$next = [2];
              case 4:
                // finally
                $async$handler = 2;
                J.remove$0$ax(spinner.get$element());
                J.set$disabled$z($async$self.refreshTreeButton, false);
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 5:
                // after finally
                t1 = $async$self.inspectorService;
                if (t1 == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = Z.InspectorController$(t1, new D.InspectorScreen__handleConnectionStart_closure0(), true, null, C.FlutterTreeType_0);
                $async$self.inspectorController = t1;
                inspectorTree = H.interceptedTypeCheck(t1.inspectorTree, "$isInspectorTreeWeb");
                detailsInspectorTree = H.interceptedTypeCheck($async$self.inspectorController.get$details().get$inspectorTree(), "$isInspectorTreeWeb");
                elements = H.setRuntimeTypeInfo([inspectorTree.get$element().get$element(), detailsInspectorTree.get$element().get$element()], [W.Element]);
                J.add$1$ax($async$self.inspectorContainer, elements);
                t1 = [P.num];
                $async$self.set$splitterSubscription(A.flexSplitBidirectional(elements, 12, H.setRuntimeTypeInfo([35, 65], t1), null, H.setRuntimeTypeInfo([60, 40], t1)));
                $async$self.inspectorController.setVisibleToUser$1(true);
                $async$self.inspectorController.setActivate$1(true);
                if (!$async$self.displayedWidgetTrackingNotice)
                  $async$self.inspectorService.isWidgetCreationTracked$0().then$1$1(new D.InspectorScreen__handleConnectionStart_closure1($async$self), null);
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_inspector$_handleConnectionStart$1, $async$completer);
      }, null, null, 4, 0, null, 74],
      _inspector$_handleConnectionStop$1: [function($event) {
        var t1;
        J.set$disabled$z(this.refreshTreeButton, true);
        t1 = this.inspectorController;
        if (!(t1 == null))
          t1.setActivate$1(false);
        t1 = this.inspectorController;
        if (!(t1 == null))
          t1.dispose$0();
        this.inspectorController = null;
        t1 = this.splitterSubscription;
        if (!(t1 == null))
          t1.cancel$0();
        this.set$splitterSubscription(null);
      }, "call$1", "get$_inspector$_handleConnectionStop", 4, 0, 6, 22],
      _refreshInspector$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, t1;
        var $async$_refreshInspector$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                J.set$disabled$z($async$self.refreshTreeButton, true);
                t1 = $async$self.inspectorController;
                $async$goto = 2;
                return P._asyncAwait(t1 == null ? null : t1.onForceRefresh$0(), $async$_refreshInspector$0);
              case 2:
                // returning from await.
                J.set$disabled$z($async$self.refreshTreeButton, false);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_refreshInspector$0, $async$completer);
      }, "call$0", "get$_refreshInspector", 0, 0, 0],
      static: {
        InspectorScreen$: [function() {
          return new D.InspectorScreen(N.SetStateMixin$(), false, "Flutter Inspector", "inspector", "octicon-device-mobile", B.Property$(false, P.bool), H.setRuntimeTypeInfo([], [N.StatusItem]), []);
        }, null, null, 0, 0, null]
      }
    },
    InspectorScreen__handleConnectionStart_closure: {
      "^": "Closure:4;$ti",
      call$1: [function(e) {
        return;
      }, null, null, 4, 0, null, 19, "call"]
    },
    InspectorScreen__handleConnectionStart_closure0: {
      "^": "Closure:107;$ti",
      call$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType: [function(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType) {
        var t1 = {func: 1, ret: -1, args: [K.InspectorTreeNode]};
        H.functionTypeCheck(onExpand, t1);
        H.functionTypeCheck(onHover, t1);
        H.functionTypeCheck(onNodeAdded, {func: 1, ret: -1, args: [K.InspectorTreeNode, M.RemoteDiagnosticsNode]});
        H.functionTypeCheck(onSelectionChange, {func: 1, ret: -1});
        H.boolTypeCheck(summaryTree);
        H.interceptedTypeCheck(treeType, "$isFlutterTreeType");
        if ($._useHtmlInspectorTreeRenderer)
          return K.InspectorTreeHtml$(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType);
        return E.InspectorTreeCanvas$(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType);
      }, function() {
        return this.call$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType(null, null, null, null, null, null);
      }, "call$0", null, null, null, 0, 13, null, 0, 0, 0, 0, 0, 0, 220, 197, 200, 207, 156, 106, "call"]
    },
    InspectorScreen__handleConnectionStart_closure1: {
      "^": "Closure:16;$this,$ti",
      call$1: [function(value) {
        var t1;
        if (H.boolTypeCheck(value))
          return;
        t1 = this.$this;
        t1.set$displayedWidgetTrackingNotice(true);
        t1.get$framework().showWarning$1("The widget creation tracking feature is not enabled (this is\nrequired for advanced Flutter Inspector functionality).\n\nTo fix this relaunch your application by running 'flutter run\n--track-widget-creation' or run your application from VS Code or IntelliJ.");
      }, null, null, 4, 0, null, 1, "call"]
    }
  }], ["inspector_controller", "package:devtools/src/inspector/inspector_controller.dart",, Z, {
    "^": "",
    _logError: [function(error) {
      P.print(error);
    }, null, null, 4, 0, null, 14],
    textStyleForLevel: [function(level) {
      switch (H.interceptedTypeCheck(level, "$isDiagnosticLevel")) {
        case C.DiagnosticLevel_0:
          return $.$get$grayed();
        case C.DiagnosticLevel_4:
          return $.$get$warning();
        case C.DiagnosticLevel_9:
          return $.$get$error();
        case C.DiagnosticLevel_2:
        case C.DiagnosticLevel_3:
        case C.DiagnosticLevel_1:
        default:
          return C.TextStyle_mOc;
      }
    }, null, null, 4, 0, null, 218],
    InspectorController: {
      "^": "Object;isSummaryTree<,parent>,0details<,0inspectorTree<,treeType,inspectorService<,0flutterIsolateSubscription,_disposed,0_refreshRateLimiter,_treeGroups,_selectionGroups,flutterAppFrameReady,treeLoadStarted,0subtreeRoot,programaticSelectionChangeInProgress,0selectedNode,0lastExpanded,isActive,valueToInspectorTreeNode,visibleToUser,highlightNodesShownInBothTrees,$ti",
      set$flutterIsolateSubscription: function(flutterIsolateSubscription) {
        this.flutterIsolateSubscription = H.assertSubtype(flutterIsolateSubscription, "$isStreamSubscription", [S.IsolateRef], "$asStreamSubscription");
      },
      InspectorController$5$inspectorService$inspectorTreeFactory$isSummaryTree$parent$treeType: [function(inspectorService, inspectorTreeFactory, isSummaryTree, $parent, treeType) {
        var t1, t2;
        this._refreshRateLimiter = B.RateLimiter$(5, this.get$refresh());
        t1 = this.isSummaryTree;
        t2 = this.treeType;
        this.inspectorTree = H.interceptedTypeCheck(inspectorTreeFactory.call$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType(this.get$_onExpand(), this.get$highlightShowNode(), this.get$_inspector_controller$_onNodeAdded(), this.get$selectionChanged(), t1, t2), "$isInspectorTree");
        if (t1)
          this.details = Z.InspectorController$(this.inspectorService, inspectorTreeFactory, false, this, t2);
        else
          this.details = null;
        this.set$flutterIsolateSubscription(E.serviceManager().get$isolateManager().getSelectedIsolate$1(new Z.InspectorController_closure(this)));
      }, null, null, 0, 11, null, 0, 0, 27, 0, 0, 163, 438, 439, 24, 106],
      set$currentShowNode: [function(node) {
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        this.inspectorTree.set$hover(node);
        return node;
      }, null, null, 6, 0, null, 23],
      get$detailsSubtree: [function() {
        return this.parent != null;
      }, null, null, 2, 0, null],
      get$selectedDiagnostic: [function() {
        var t1 = this.selectedNode;
        return t1 == null ? null : t1.get$diagnostic();
      }, null, null, 2, 0, null],
      setVisibleToUser$1: [function(visible) {
        var t1;
        H.boolTypeCheck(visible);
        if (J.$eq$(this.visibleToUser, visible))
          return;
        this.visibleToUser = visible;
        t1 = this.details;
        if (!(t1 == null))
          t1.setVisibleToUser$1(visible);
        if (this.visibleToUser) {
          if (this.parent == null)
            this.maybeLoadUI$0();
        } else
          this.shutdownTree$1(false);
      }, null, "get$setVisibleToUser", 4, 0, null, 287],
      hasDiagnosticsValue$1: [function(ref) {
        return this.valueToInspectorTreeNode.containsKey$1(H.interceptedTypeCheck(ref, "$isInspectorInstanceRef"));
      }, null, "get$hasDiagnosticsValue", 4, 0, null, 81],
      findDiagnosticsValue$1: [function(ref) {
        var t1 = J.$index$asx(this.valueToInspectorTreeNode, H.interceptedTypeCheck(ref, "$isInspectorInstanceRef"));
        return t1 == null ? null : t1.get$diagnostic();
      }, null, "get$findDiagnosticsValue", 4, 0, null, 81],
      endShowNode$0: [function() {
        this.highlightShowNode$1(null);
      }, null, "get$endShowNode", 0, 0, null],
      highlightShowNode$1: [function(node) {
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        this.set$currentShowNode(node == null && this.parent != null ? this.findMatchingInspectorTreeNode$1(this.parent.get$selectedDiagnostic()) : node);
        return true;
      }, "call$1", "get$highlightShowNode", 4, 0, 108, 23],
      findMatchingInspectorTreeNode$1: [function(node) {
        H.interceptedTypeCheck(node, "$isRemoteDiagnosticsNode");
        if ((node == null ? null : node.get$valueRef()) == null)
          return;
        return J.$index$asx(this.valueToInspectorTreeNode, node.get$valueRef());
      }, null, "get$findMatchingInspectorTreeNode", 4, 0, null, 23],
      getPendingUpdateDone$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$getPendingUpdateDone$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait($async$self._selectionGroups.get$pendingUpdateDone(), $async$getPendingUpdateDone$0);
              case 2:
                // returning from await.
                $async$goto = 3;
                return P._asyncAwait($async$self._treeGroups.get$pendingUpdateDone(), $async$getPendingUpdateDone$0);
              case 3:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$getPendingUpdateDone$0, $async$completer);
      }, null, "get$getPendingUpdateDone", 0, 0, null],
      refresh$0: [function() {
        if (!this.visibleToUser)
          return P.Future_Future$value(null, -1);
        if (this.details != null)
          return P.Future_wait(H.setRuntimeTypeInfo([this.getPendingUpdateDone$0(), this.details.getPendingUpdateDone$0()], [[P.Future, -1]]), null, false, -1);
        else
          return this.getPendingUpdateDone$0();
      }, "call$0", "get$refresh", 0, 0, 109],
      shutdownTree$1: [function(isolateStopped) {
        var t1;
        H.boolTypeCheck(isolateStopped);
        this.programaticSelectionChangeInProgress = true;
        J.clear$1$ax(this._treeGroups, isolateStopped);
        J.clear$1$ax(this._selectionGroups, isolateStopped);
        this.set$currentShowNode(null);
        this.selectedNode = null;
        this.lastExpanded = null;
        this.subtreeRoot = null;
        t1 = this.inspectorTree;
        J.set$root$z(t1, t1.createNode$0());
        t1 = this.details;
        if (!(t1 == null))
          t1.shutdownTree$1(isolateStopped);
        this.programaticSelectionChangeInProgress = false;
        J.clear$0$ax(this.valueToInspectorTreeNode);
      }, null, "get$shutdownTree", 4, 0, null, 440],
      onIsolateStopped$0: [function() {
        this.flutterAppFrameReady = false;
        this.treeLoadStarted = false;
        this.shutdownTree$1(true);
      }, null, "get$onIsolateStopped", 0, 0, null],
      onForceRefresh$0: [function() {
        if (!this.visibleToUser || this._disposed)
          return P.Future_Future$value(null, -1);
        this.recomputeTreeRoot$3(null, null, false);
        return this.getPendingUpdateDone$0();
      }, null, "get$onForceRefresh", 0, 0, null],
      setActivate$1: [function(enabled) {
        if (!H.boolTypeCheck(enabled)) {
          this.onIsolateStopped$0();
          this.isActive = false;
          return;
        }
        if (this.isActive)
          return;
        this.isActive = true;
        this.inspectorService.addClient$1(this);
        this.maybeLoadUI$0();
      }, null, "get$setActivate", 4, 0, null, 211],
      maybeLoadUI$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, ready;
        var $async$maybeLoadUI$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (!$async$self.visibleToUser || !$async$self.isActive) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = $async$self.flutterAppFrameReady ? 3 : 5;
                break;
              case 3:
                // then
                $async$goto = 6;
                return P._asyncAwait($async$self.updateSelectionFromService$0(), $async$maybeLoadUI$0);
              case 6:
                // returning from await.
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$goto = 7;
                return P._asyncAwait($async$self.inspectorService.isWidgetTreeReady$0(), $async$maybeLoadUI$0);
              case 7:
                // returning from await.
                ready = $async$result;
                $async$self.flutterAppFrameReady = ready;
                $async$goto = $async$self.isActive && ready ? 8 : 9;
                break;
              case 8:
                // then
                $async$goto = 10;
                return P._asyncAwait($async$self.maybeLoadUI$0(), $async$maybeLoadUI$0);
              case 10:
                // returning from await.
              case 9:
                // join
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$maybeLoadUI$0, $async$completer);
      }, null, "get$maybeLoadUI", 0, 0, null],
      recomputeTreeRoot$3: [function(newSelection, detailsSelection, setSubtreeRoot) {
        H.interceptedTypeCheck(newSelection, "$isRemoteDiagnosticsNode");
        H.interceptedTypeCheck(detailsSelection, "$isRemoteDiagnosticsNode");
        H.boolTypeCheck(setSubtreeRoot);
        return this.recomputeTreeRoot$body$InspectorController(newSelection, detailsSelection, setSubtreeRoot);
      }, null, "get$recomputeTreeRoot", 12, 0, null, 213, 217, 260],
      recomputeTreeRoot$body$InspectorController: [function(newSelection, detailsSelection, setSubtreeRoot) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, group, node, rootNode, error, t1, exception, $async$exception;
        var $async$recomputeTreeRoot$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$self._treeGroups.cancelNext$0();
                $async$handler = 4;
                group = $async$self._treeGroups.get$next();
                $async$goto = 7;
                return P._asyncAwait($async$self.get$detailsSubtree() ? group.getDetailsSubtree$1($async$self.subtreeRoot) : group.getRoot$1($async$self.treeType), $async$recomputeTreeRoot$3);
              case 7:
                // returning from await.
                node = $async$result;
                if (node == null || group.get$disposed()) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$self._treeGroups.promoteNext$0();
                $async$self.clearValueToInspectorTreeNodeMapping$0();
                t1 = $async$self.inspectorTree;
                if (node != null) {
                  rootNode = t1.setupInspectorTreeNode$4$expandChildren$expandProperties(t1.createNode$0(), node, true, false);
                  J.set$root$z($async$self.inspectorTree, rootNode);
                } else
                  J.set$root$z(t1, t1.createNode$0());
                $async$self.refreshSelection$3(newSelection, detailsSelection, setSubtreeRoot);
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                error = H.unwrapException($async$exception);
                Z._logError(error);
                $async$self._treeGroups.cancelNext$0();
                // goto return
                $async$goto = 1;
                break;
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$recomputeTreeRoot$3, $async$completer);
      }, null, null, 12, 0, null, 213, 217, 260],
      clearValueToInspectorTreeNodeMapping$0: [function() {
        var t1 = this.parent;
        if (t1 != null)
          J.forEach$1$ax(this.valueToInspectorTreeNode.get$keys(), t1.get$maybeUpdateValueUI());
        J.clear$0$ax(this.valueToInspectorTreeNode);
      }, null, "get$clearValueToInspectorTreeNodeMapping", 0, 0, null],
      showDetailSubtrees$2: [function(subtreeRoot, subtreeSelection) {
        var t1;
        H.interceptedTypeCheck(subtreeRoot, "$isRemoteDiagnosticsNode");
        H.interceptedTypeCheck(subtreeSelection, "$isRemoteDiagnosticsNode");
        this.subtreeRoot = subtreeRoot;
        t1 = this.details;
        if (!(t1 == null))
          t1.setSubtreeRoot$2(subtreeRoot, subtreeSelection);
      }, null, "get$showDetailSubtrees", 8, 0, null, 664, 665],
      setSubtreeRoot$2: [function(node, selection) {
        var t1;
        H.interceptedTypeCheck(node, "$isRemoteDiagnosticsNode");
        H.interceptedTypeCheck(selection, "$isRemoteDiagnosticsNode");
        if (selection == null)
          selection = node;
        t1 = node == null;
        if (!t1 && node.$eq(0, this.subtreeRoot)) {
          this.applyNewSelection$3(selection, null, false);
          return;
        }
        this.subtreeRoot = node;
        if (t1) {
          this.shutdownTree$1(false);
          return;
        }
        this.clearValueToInspectorTreeNodeMapping$0();
        this.recomputeTreeRoot$3(selection, null, false);
      }, null, "get$setSubtreeRoot", 8, 0, null, 23, 134],
      getSubtreeRootNode$0: [function() {
        var t1 = this.subtreeRoot;
        if (t1 == null)
          return;
        return J.$index$asx(this.valueToInspectorTreeNode, t1.get$valueRef());
      }, null, "get$getSubtreeRootNode", 0, 0, null],
      refreshSelection$3: [function(newSelection, detailsSelection, setSubtreeRoot) {
        H.interceptedTypeCheck(newSelection, "$isRemoteDiagnosticsNode");
        H.interceptedTypeCheck(detailsSelection, "$isRemoteDiagnosticsNode");
        H.boolTypeCheck(setSubtreeRoot);
        if (newSelection == null)
          newSelection = this.get$selectedDiagnostic();
        this.setSelectedNode$1(this.findMatchingInspectorTreeNode$1(newSelection));
        this.syncSelectionHelper$2(setSubtreeRoot, detailsSelection);
        if (this.details != null)
          if (this.subtreeRoot != null && this.getSubtreeRootNode$0() == null) {
            this.subtreeRoot = newSelection;
            this.details.setSubtreeRoot$2(newSelection, detailsSelection);
          }
        this.syncTreeSelection$0();
      }, null, "get$refreshSelection", 12, 0, null, 213, 217, 260],
      syncTreeSelection$0: [function() {
        this.programaticSelectionChangeInProgress = true;
        this.inspectorTree.set$selection(this.selectedNode);
        this.programaticSelectionChangeInProgress = false;
        this.animateTo$1(this.selectedNode);
      }, null, "get$syncTreeSelection", 0, 0, null],
      selectAndShowNode$1: [function(node) {
        H.interceptedTypeCheck(node, "$isRemoteDiagnosticsNode");
        if (node == null)
          return;
        this.selectAndShowInspectorInstanceRef$1(node.get$valueRef());
      }, null, "get$selectAndShowNode", 4, 0, null, 23],
      selectAndShowInspectorInstanceRef$1: [function(ref) {
        var node = J.$index$asx(this.valueToInspectorTreeNode, H.interceptedTypeCheck(ref, "$isInspectorInstanceRef"));
        if (node == null)
          return;
        this.setSelectedNode$1(node);
        this.syncTreeSelection$0();
      }, null, "get$selectAndShowInspectorInstanceRef", 4, 0, null, 81],
      maybeUpdateValueUI$1: [function(valueRef) {
        var node = J.$index$asx(this.valueToInspectorTreeNode, H.interceptedTypeCheck(valueRef, "$isInspectorInstanceRef"));
        if (node == null)
          return;
        this.inspectorTree.nodeChanged$1(node);
      }, "call$1", "get$maybeUpdateValueUI", 4, 0, 110, 667],
      onFlutterFrame$0: [function() {
        this.flutterAppFrameReady = true;
        if (!this.visibleToUser)
          return;
        if (!this.treeLoadStarted) {
          this.treeLoadStarted = true;
          this.maybeLoadUI$0();
        }
        this._refreshRateLimiter.scheduleRequest$0();
      }, null, "get$onFlutterFrame", 0, 0, null],
      onInspectorSelectionChanged$0: [function() {
        if (!this.visibleToUser)
          return;
        if (this.get$detailsSubtree())
          return;
        this.updateSelectionFromService$0();
      }, null, "get$onInspectorSelectionChanged", 0, 0, null],
      updateSelectionFromService$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, firstFrame, group, pendingSelectionFuture, pendingDetailsFuture, newSelection, detailsSelection, error, t1, t2, exception, $async$exception;
        var $async$updateSelectionFromService$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                firstFrame = !$async$self.treeLoadStarted;
                $async$self.treeLoadStarted = true;
                $async$self._selectionGroups.cancelNext$0();
                group = $async$self._selectionGroups.get$next();
                t1 = $async$self.treeType;
                t2 = $async$self.isSummaryTree;
                pendingSelectionFuture = J.getSelection$3$z(group, $async$self.get$selectedDiagnostic(), t1, t2);
                pendingDetailsFuture = t2 ? J.getSelection$3$z(group, $async$self.get$selectedDiagnostic(), t1, false) : null;
                $async$handler = 4;
                $async$goto = 7;
                return P._asyncAwait(pendingSelectionFuture, $async$updateSelectionFromService$0);
              case 7:
                // returning from await.
                newSelection = $async$result;
                if (group.get$disposed()) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                detailsSelection = null;
                $async$goto = pendingDetailsFuture != null ? 8 : 9;
                break;
              case 8:
                // then
                $async$goto = 10;
                return P._asyncAwait(pendingDetailsFuture, $async$updateSelectionFromService$0);
              case 10:
                // returning from await.
                detailsSelection = $async$result;
                if (group.get$disposed()) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 9:
                // join
                if (!firstFrame) {
                  t1 = detailsSelection;
                  t1 = t1 == null ? null : t1.get$valueRef();
                  t2 = $async$self.details.get$selectedDiagnostic();
                  if (J.$eq$(t1, t2 == null ? null : t2.get$valueRef())) {
                    t1 = newSelection;
                    t1 = t1 == null ? null : t1.get$valueRef();
                    t2 = $async$self.get$selectedDiagnostic();
                    t1 = J.$eq$(t1, t2 == null ? null : t2.get$valueRef());
                  } else
                    t1 = false;
                } else
                  t1 = false;
                if (t1) {
                  $async$self._selectionGroups.cancelNext$0();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$self._selectionGroups.promoteNext$0();
                $async$self.subtreeRoot = H.interceptedTypeCheck(newSelection, "$isRemoteDiagnosticsNode");
                $async$self.applyNewSelection$3(newSelection, detailsSelection, true);
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                error = H.unwrapException($async$exception);
                if (J.$eq$($async$self._selectionGroups.get$next(), group)) {
                  Z._logError(error);
                  $async$self._selectionGroups.cancelNext$0();
                }
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$updateSelectionFromService$0, $async$completer);
      }, null, "get$updateSelectionFromService", 0, 0, null],
      applyNewSelection$3: [function(newSelection, detailsSelection, setSubtreeRoot) {
        H.interceptedTypeCheck(newSelection, "$isRemoteDiagnosticsNode");
        H.interceptedTypeCheck(detailsSelection, "$isRemoteDiagnosticsNode");
        H.boolTypeCheck(setSubtreeRoot);
        if (this.findMatchingInspectorTreeNode$1(newSelection) == null)
          this.recomputeTreeRoot$3(newSelection, detailsSelection, setSubtreeRoot);
        this.refreshSelection$3(newSelection, detailsSelection, setSubtreeRoot);
      }, null, "get$applyNewSelection", 12, 0, null, 213, 217, 260],
      animateTo$1: [function(node) {
        var targets, t1, t2, diagnosticsNode;
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        if (node == null)
          return;
        targets = H.setRuntimeTypeInfo([node], [K.InspectorTreeNode]);
        while (true) {
          if (node.get$parent(node) != null) {
            t1 = node.get$diagnostic();
            t1 = J.$eq$(t1 == null ? null : t1.get$isProperty(), true);
          } else
            t1 = false;
          if (!t1)
            break;
          node = node.get$parent(node);
        }
        for (t1 = J.get$iterator$ax(node.get$children(node)); t1.moveNext$0();) {
          t2 = t1.get$current();
          diagnosticsNode = t2.get$diagnostic();
          C.JSArray_methods.add$1(targets, t2);
          if (!t2.get$isLeaf() && t2.get$expanded())
            break;
          if (diagnosticsNode != null && !diagnosticsNode.isProperty)
            break;
        }
        this.inspectorTree.animateToTargets$1(targets);
      }, null, "get$animateTo", 4, 0, null, 23],
      setSelectedNode$1: [function(newSelection) {
        var t1;
        H.interceptedTypeCheck(newSelection, "$isInspectorTreeNode");
        t1 = this.selectedNode;
        if (newSelection == null ? t1 == null : newSelection === t1)
          return;
        if (t1 != null)
          if (!this.get$detailsSubtree())
            this.inspectorTree.nodeChanged$1(J.get$parent$x(this.selectedNode));
        this.selectedNode = newSelection;
        this.lastExpanded = null;
        this.endShowNode$0();
        t1 = this.details;
        if (t1 != null)
          t1.endShowNode$0();
        else {
          t1 = this.parent;
          if (t1 != null)
            t1.endShowNode$0();
        }
        this.animateTo$1(this.selectedNode);
      }, null, "get$setSelectedNode", 4, 0, null, 213],
      _onExpand$1: [function(node) {
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        this.inspectorTree.maybePopulateChildren$1(node);
      }, "call$1", "get$_onExpand", 4, 0, 111, 23],
      selectionChanged$0: [function() {
        var node, t1, maybeReroot;
        if (J.$eq$(this.visibleToUser, false))
          return;
        node = this.inspectorTree.get$selection();
        t1 = node != null;
        if (t1)
          this.inspectorTree.maybePopulateChildren$1(node);
        if (this.programaticSelectionChangeInProgress)
          return;
        if (t1) {
          this.setSelectedNode$1(node);
          t1 = this.isSummaryTree;
          maybeReroot = t1 && this.details != null && this.get$selectedDiagnostic() != null && !this.details.hasDiagnosticsValue$1(this.get$selectedDiagnostic().get$valueRef());
          this.syncSelectionHelper$2(maybeReroot, null);
          if (!maybeReroot)
            if (t1 && this.details != null)
              this.details.selectAndShowNode$1(this.get$selectedDiagnostic());
            else {
              t1 = this.parent;
              if (t1 != null)
                t1.selectAndShowNode$1(this.firstAncestorInParentTree$1(this.selectedNode));
            }
        }
      }, "call$0", "get$selectionChanged", 0, 0, 0],
      firstAncestorInParentTree$1: [function(node) {
        var t1, diagnostic;
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        t1 = this.parent;
        if (t1 == null)
          return node.get$diagnostic();
        for (; node != null;) {
          diagnostic = node.get$diagnostic();
          if (diagnostic != null && t1.hasDiagnosticsValue$1(diagnostic.get$valueRef()))
            return t1.findDiagnosticsValue$1(diagnostic.get$valueRef());
          node = node.get$parent(node);
        }
        return;
      }, null, "get$firstAncestorInParentTree", 4, 0, null, 23],
      syncSelectionHelper$2: [function(maybeRerootDetailsTree, detailsSelection) {
        var diagnostic, t1, toSelect;
        H.boolTypeCheck(maybeRerootDetailsTree);
        H.interceptedTypeCheck(detailsSelection, "$isRemoteDiagnosticsNode");
        if (!this.get$detailsSubtree() && this.selectedNode != null)
          this.inspectorTree.nodeChanged$1(J.get$parent$x(this.selectedNode));
        diagnostic = this.get$selectedDiagnostic();
        t1 = diagnostic != null;
        if (t1)
          if (diagnostic.get$isCreatedByLocalProject())
            this._navigateTo$1(diagnostic);
        if (this.get$detailsSubtree() || this.details == null)
          if (t1) {
            toSelect = this.selectedNode;
            while (true) {
              t1 = toSelect != null;
              if (!(t1 && toSelect.get$diagnostic().get$isProperty()))
                break;
              toSelect = toSelect.get$parent(toSelect);
            }
            if (t1)
              toSelect.get$diagnostic().setSelectionInspector$1(true);
          }
        if (maybeRerootDetailsTree)
          this.showDetailSubtrees$2(diagnostic, detailsSelection);
        else if (diagnostic != null)
          (detailsSelection == null ? diagnostic : detailsSelection).setSelectionInspector$1(true);
      }, null, "get$syncSelectionHelper", 8, 0, null, 668, 217],
      _navigateTo$1: [function(diagnostic) {
        H.interceptedTypeCheck(diagnostic, "$isRemoteDiagnosticsNode");
      }, null, "get$_navigateTo", 4, 0, null, 669],
      dispose$0: [function() {
        this._disposed = true;
        this.flutterIsolateSubscription.cancel$0();
        if (this.inspectorService != null)
          this.shutdownTree$1(false);
        this._treeGroups = null;
        this._selectionGroups = null;
        var t1 = this.details;
        if (!(t1 == null))
          t1.dispose$0();
      }, null, "get$dispose", 0, 0, null],
      _inspector_controller$_onNodeAdded$2: [function(node, diagnosticsNode) {
        var valueRef, t1;
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        H.interceptedTypeCheck(diagnosticsNode, "$isRemoteDiagnosticsNode");
        valueRef = diagnosticsNode.get$valueRef();
        if (valueRef.id != null && !diagnosticsNode.isProperty)
          J.$indexSet$ax(this.valueToInspectorTreeNode, valueRef, node);
        t1 = this.parent;
        if (!(t1 == null))
          t1.maybeUpdateValueUI$1(valueRef);
      }, "call$2", "get$_inspector_controller$_onNodeAdded", 8, 0, 112, 23, 442],
      $isInspectorServiceClient: 1,
      static: {
        InspectorController$: [function(inspectorService, inspectorTreeFactory, isSummaryTree, $parent, treeType) {
          var t1 = P.LinkedHashMap_LinkedHashMap$_empty(E.InspectorInstanceRef, K.InspectorTreeNode);
          t1 = new Z.InspectorController(isSummaryTree, $parent, treeType, inspectorService, false, E.InspectorObjectGroupManager$(inspectorService, "tree"), E.InspectorObjectGroupManager$(inspectorService, "selection"), false, false, false, false, t1, false, false, []);
          t1.InspectorController$5$inspectorService$inspectorTreeFactory$isSummaryTree$parent$treeType(inspectorService, inspectorTreeFactory, isSummaryTree, $parent, treeType);
          return t1;
        }, null, null, 0, 11, null, 0, 0, 27, 0, 0, 163, 438, 439, 24, 106]
      }
    },
    InspectorController_closure: {
      "^": "Closure:30;$this,$ti",
      call$1: [function(flutterIsolate) {
        if (H.interceptedTypeCheck(flutterIsolate, "$isIsolateRef") == null)
          this.$this.onIsolateStopped$0();
      }, null, null, 4, 0, null, 671, "call"]
    }
  }], ["", "package:devtools/src/inspector/inspector_service.dart",, E, {
    "^": "",
    ensureInspectorServiceDependencies: [function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue;
      var $async$ensureInspectorServiceDependencies = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($._inspectorDependenciesLoaded) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(S.Catalog_load(), $async$ensureInspectorServiceDependencies);
            case 3:
              // returning from await.
              $._inspectorDependenciesLoaded = true;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$ensureInspectorServiceDependencies, $async$completer);
    }, null, null, 0, 0, null],
    InspectorService: {
      "^": "Object;vmService<,clients,inspectorLibrary<,supportedServiceMethods,$ti",
      InspectorService$3: [function(vmService, inspectorLibrary, supportedServiceMethods) {
        var t1 = this.vmService;
        t1.get$onExtensionEvent().listen$1(this.get$onExtensionVmServiceRecieved());
        t1.get$onDebugEvent().listen$1(this.get$onDebugVmServiceReceived());
      }, null, null, 12, 0, null, 159, 443, 444],
      inferPubRootDirectoryIfNeeded$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this, group, root, children, t1, path, parts, t2, i, pubRootDirectory, $async$temp1;
        var $async$inferPubRootDirectoryIfNeeded$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                group = $async$self.createObjectGroup$1("temp");
                $async$goto = 3;
                return P._asyncAwait(group.getRoot$1(C.FlutterTreeType_0), $async$inferPubRootDirectoryIfNeeded$0);
              case 3:
                // returning from await.
                root = $async$result;
                $async$goto = root == null ? 4 : 5;
                break;
              case 4:
                // then
                $async$goto = 6;
                return P._asyncAwait(group.dispose$0(), $async$inferPubRootDirectoryIfNeeded$0);
              case 6:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 5:
                // join
                $async$goto = 7;
                return P._asyncAwait(root.get$children(root), $async$inferPubRootDirectoryIfNeeded$0);
              case 7:
                // returning from await.
                children = $async$result;
                if (J.$eq$(children == null ? null : J.get$isNotEmpty$asx(children), true)) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$temp1 = J;
                $async$goto = 8;
                return P._asyncAwait(group.getChildren$3(root.get$dartDiagnosticRef(), false, null), $async$inferPubRootDirectoryIfNeeded$0);
              case 8:
                // returning from await.
                t1 = $async$temp1.get$first$ax($async$result).get$creationLocation();
                path = t1 == null ? null : J.get$path$z(t1);
                $async$goto = path == null ? 9 : 10;
                break;
              case 9:
                // then
                $async$goto = 11;
                return P._asyncAwait(group.dispose$0(), $async$inferPubRootDirectoryIfNeeded$0);
              case 11:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 10:
                // join
                t1 = P.String;
                parts = H.setRuntimeTypeInfo(path.split("/"), [t1]);
                for (t2 = parts.length, i = t2 - 1; i >= 0; --i)
                  ;
                if (0 >= t2) {
                  $async$returnValue = H.ioore(parts, -1);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                parts.pop();
                pubRootDirectory = C.JSArray_methods.join$1(parts, "/");
                $async$goto = 12;
                return P._asyncAwait($async$self.setPubRootDirectories$1(H.setRuntimeTypeInfo([pubRootDirectory], [t1])), $async$inferPubRootDirectoryIfNeeded$0);
              case 12:
                // returning from await.
                $async$goto = 13;
                return P._asyncAwait(group.dispose$0(), $async$inferPubRootDirectoryIfNeeded$0);
              case 13:
                // returning from await.
                $async$returnValue = pubRootDirectory;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$inferPubRootDirectoryIfNeeded$0, $async$completer);
      }, null, "get$inferPubRootDirectoryIfNeeded", 0, 0, null],
      get$useDaemonApi: [function() {
        return true;
      }, null, null, 2, 0, null],
      createObjectGroup$1: [function(debugName) {
        return E.ObjectGroup$(H.stringTypeCheck(debugName), this);
      }, null, "get$createObjectGroup", 4, 0, null, 259],
      notifySelectionChanged$0: [function() {
        for (var t1 = J.get$iterator$ax(this.clients); t1.moveNext$0();)
          t1.get$current().onInspectorSelectionChanged$0();
      }, null, "get$notifySelectionChanged", 0, 0, null],
      addClient$1: [function(client) {
        J.add$1$ax(this.clients, H.interceptedTypeCheck(client, "$isInspectorServiceClient"));
      }, null, "get$addClient", 4, 0, null, 295],
      onDebugVmServiceReceived$1: [function($event) {
        H.interceptedTypeCheck($event, "$isEvent0");
        if (J.$eq$($event.kind, "Inspect")) {
          this.createObjectGroup$1("dummy").setSelection$2($event.inspectee, true);
          this.notifySelectionChanged$0();
        }
      }, "call$1", "get$onDebugVmServiceReceived", 4, 0, 11, 22],
      onExtensionVmServiceRecieved$1: [function(e) {
        var client, e0, t1, exception;
        if ("Flutter.Frame" === H.interceptedTypeCheck(e, "$isEvent0").kind)
          for (t1 = J.get$iterator$ax(this.clients); t1.moveNext$0();) {
            client = t1.get$current();
            try {
              client.onFlutterFrame$0();
            } catch (exception) {
              e0 = H.unwrapException(exception);
              P.log0("Error handling frame event", e0, 0, "", null, null, null, null);
            }
          }
      }, "call$1", "get$onExtensionVmServiceRecieved", 4, 0, 11, 19],
      isWidgetTreeReady$0: [function() {
        return this.invokeBoolServiceMethodNoArgs$1("isWidgetTreeReady");
      }, null, "get$isWidgetTreeReady", 0, 0, null],
      invokeBoolServiceMethodNoArgs$1: [function(methodName) {
        return this.invokeBoolServiceMethodNoArgs$body$InspectorService(H.stringTypeCheck(methodName));
      }, null, "get$invokeBoolServiceMethodNoArgs", 4, 0, null, 46],
      invokeBoolServiceMethodNoArgs$body$InspectorService: [function(methodName) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.bool),
          $async$returnValue, $async$self = this, t1, $async$temp1;
        var $async$invokeBoolServiceMethodNoArgs$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = $async$self.get$useDaemonApi() ? 3 : 5;
                break;
              case 3:
                // then
                $async$temp1 = J;
                $async$goto = 6;
                return P._asyncAwait($async$self.invokeServiceMethodDaemonNoGroupArgs$1(methodName), $async$invokeBoolServiceMethodNoArgs$1);
              case 6:
                // returning from await.
                $async$returnValue = $async$temp1.$eq$($async$result, true);
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$goto = 7;
                return P._asyncAwait($async$self.invokeServiceMethodObservatoryNoGroup$1(methodName), $async$invokeBoolServiceMethodNoArgs$1);
              case 7:
                // returning from await.
                t1 = $async$result;
                $async$returnValue = J.$eq$(t1 == null ? null : t1.get$valueAsString(), "true");
                // goto return
                $async$goto = 1;
                break;
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$invokeBoolServiceMethodNoArgs$1, $async$completer);
      }, null, null, 4, 0, null, 46],
      isWidgetCreationTracked$0: [function() {
        return this.invokeBoolServiceMethodNoArgs$1("isWidgetCreationTracked");
      }, null, "get$isWidgetCreationTracked", 0, 0, null],
      invokeServiceMethodDaemonNoGroupArgs$2: [function(methodName, args) {
        var t1, params, i, t2;
        H.stringTypeCheck(methodName);
        t1 = P.String;
        H.assertSubtype(args, "$isList", [t1], "$asList");
        params = P.LinkedHashMap_LinkedHashMap$_empty(t1, P.Object);
        if (args != null) {
          t1 = J.getInterceptor$asx(args);
          i = 0;
          while (true) {
            t2 = t1.get$length(args);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            params.$indexSet(0, "arg" + i, t1.$index(args, i));
            ++i;
          }
        }
        return this.invokeServiceMethodDaemonNoGroup$2(methodName, params);
      }, function(methodName) {
        return this.invokeServiceMethodDaemonNoGroupArgs$2(methodName, null);
      }, "invokeServiceMethodDaemonNoGroupArgs$1", null, null, "get$invokeServiceMethodDaemonNoGroupArgs", 4, 2, null, 0, 46, 71],
      setPubRootDirectories$1: [function(rootDirectories) {
        return this.invokeServiceMethodDaemonNoGroupArgs$2("setPubRootDirectories", H.assertSubtype(rootDirectories, "$isList", [P.String], "$asList"));
      }, null, "get$setPubRootDirectories", 4, 0, null, 678],
      invokeServiceMethodObservatoryNoGroup$1: [function(methodName) {
        return this.inspectorLibrary.eval$2$isAlive("WidgetInspectorService.instance." + H.S(H.stringTypeCheck(methodName)) + "()", null);
      }, null, "get$invokeServiceMethodObservatoryNoGroup", 4, 0, null, 46],
      invokeServiceMethodDaemonNoGroup$2: [function(methodName, args) {
        return this.invokeServiceMethodDaemonNoGroup$body$InspectorService(H.stringTypeCheck(methodName), H.assertSubtype(args, "$isMap", [P.String, P.Object], "$asMap"));
      }, null, "get$invokeServiceMethodDaemonNoGroup", 8, 0, null, 46, 71],
      invokeServiceMethodDaemonNoGroup$body$InspectorService: [function(methodName, args) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Object),
          $async$returnValue, $async$self = this, json;
        var $async$invokeServiceMethodDaemonNoGroup$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self.vmService.callServiceExtension$3$args$isolateId("ext.flutter.inspector." + H.S(methodName), args, $async$self.inspectorLibrary.get$isolateId()), $async$invokeServiceMethodDaemonNoGroup$2);
              case 3:
                // returning from await.
                json = $async$result.json;
                if (json.$index(0, "errorMessage") != null)
                  throw H.wrapException(P.Exception_Exception(H.S(methodName) + " -- " + H.S(json.$index(0, "errorMessage"))));
                $async$returnValue = json.$index(0, "result");
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$invokeServiceMethodDaemonNoGroup$2, $async$completer);
      }, null, null, 8, 0, null, 46, 71],
      static: {
        InspectorService$: [function(vmService, inspectorLibrary, supportedServiceMethods) {
          var t1 = new E.InspectorService(vmService, P.LinkedHashSet_LinkedHashSet(null, null, null, E.InspectorServiceClient), inspectorLibrary, supportedServiceMethods, []);
          t1.InspectorService$3(vmService, inspectorLibrary, supportedServiceMethods);
          return t1;
        }, null, null, 12, 0, null, 159, 443, 444],
        InspectorService_createGroup: [function(vmService, groupName) {
          return E.InspectorService_createGroup$body(H.interceptedTypeCheck(vmService, "$isVmService"), H.stringTypeCheck(groupName));
        }, null, null, 8, 0, null, 159, 445],
        InspectorService_createGroup$body: [function(vmService, groupName) {
          var $async$goto = 0,
            $async$completer = P._makeAsyncAwaitCompleter(E.ObjectGroup),
            $async$returnValue;
          var $async$InspectorService_createGroup = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
            if ($async$errorCode === 1)
              return P._asyncRethrow($async$result, $async$completer);
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  $async$goto = 3;
                  return P._asyncAwait(E.InspectorService_create(vmService), $async$InspectorService_createGroup);
                case 3:
                  // returning from await.
                  $async$returnValue = $async$result.createObjectGroup$1(groupName);
                  // goto return
                  $async$goto = 1;
                  break;
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
          });
          return P._asyncStartSync($async$InspectorService_createGroup, $async$completer);
        }, null, null, 8, 0, null, 159, 445],
        InspectorService_create: [function(vmService) {
          return E.InspectorService_create$body(H.interceptedTypeCheck(vmService, "$isVmService"));
        }, null, null, 4, 0, null, 159],
        InspectorService_create$body: [function(vmService) {
          var $async$goto = 0,
            $async$completer = P._makeAsyncAwaitCompleter(E.InspectorService),
            $async$returnValue, inspectorLibrary, $async$temp1, $async$temp2, $async$temp3, $async$temp4, $async$temp5;
          var $async$InspectorService_create = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
            if ($async$errorCode === 1)
              return P._asyncRethrow($async$result, $async$completer);
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  H.interceptedTypeCheck(vmService, "$isVmServiceWrapper");
                  inspectorLibrary = B.EvalOnDartLibrary$("package:flutter/src/widgets/widget_inspector.dart", vmService, null);
                  $async$temp1 = E;
                  $async$temp2 = vmService;
                  $async$temp3 = inspectorLibrary;
                  $async$temp4 = E;
                  $async$temp5 = inspectorLibrary;
                  $async$goto = 5;
                  return P._asyncAwait(inspectorLibrary.get$libraryRef(), $async$InspectorService_create);
                case 5:
                  // returning from await.
                  $async$goto = 4;
                  return P._asyncAwait($async$temp5.getLibrary$2($async$result, null), $async$InspectorService_create);
                case 4:
                  // returning from await.
                  $async$goto = 3;
                  return P._asyncAwait(new $async$temp4.InspectorService_create_lookupFunctionNames($async$result, inspectorLibrary).call$0(), $async$InspectorService_create);
                case 3:
                  // returning from await.
                  $async$returnValue = $async$temp1.InspectorService$($async$temp2, $async$temp3, $async$result);
                  // goto return
                  $async$goto = 1;
                  break;
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
          });
          return P._asyncStartSync($async$InspectorService_create, $async$completer);
        }, null, null, 4, 0, null, 159]
      }
    },
    InspectorService_create_lookupFunctionNames: {
      "^": "Closure:113;library,inspectorLibrary,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.Set, P.String]),
          $async$returnValue, $async$self = this, t1, t2, classObj, functionNames;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$iterator$ax(J.get$classes$x($async$self.library));
              case 3:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                t2 = t1.get$current();
                $async$goto = "WidgetInspectorService" === t2.name ? 5 : 6;
                break;
              case 5:
                // then
                $async$goto = 7;
                return P._asyncAwait($async$self.inspectorLibrary.getClass$2(t2, null), $async$call$0);
              case 7:
                // returning from await.
                classObj = $async$result;
                functionNames = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
                for (t1 = J.get$iterator$ax(classObj.functions); t1.moveNext$0();)
                  functionNames.add$1(0, t1.get$current().name);
                $async$returnValue = functionNames;
                // goto return
                $async$goto = 1;
                break;
              case 6:
                // join
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
                throw H.wrapException(P.Exception_Exception("WidgetInspectorService class not found"));
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    ObjectGroup: {
      "^": "Object;groupName,inspectorService<,disposed<,$ti",
      ObjectGroup$2: [function(debugName, inspectorService) {
        $.InspectorService_nextGroupId = J.$add$ansx($.InspectorService_nextGroupId, 1);
      }, null, null, 8, 0, null, 259, 163],
      get$inspectorLibrary: [function() {
        return this.inspectorService.get$inspectorLibrary();
      }, null, null, 2, 0, null],
      get$useDaemonApi: [function() {
        return this.inspectorService.get$useDaemonApi();
      }, null, null, 2, 0, null],
      dispose$0: [function() {
        var disposeComplete = this.invokeVoidServiceMethod$2("disposeGroup", this.groupName);
        this.disposed = true;
        return disposeComplete;
      }, null, "get$dispose", 0, 0, null],
      getRoot$1: [function(type) {
        switch (H.interceptedTypeCheck(type, "$isFlutterTreeType")) {
          case C.FlutterTreeType_0:
            return this.getRootWidget$0();
          case C.FlutterTreeType_1:
            return this.getRootRenderObject$0();
        }
        throw H.wrapException(P.Exception_Exception("Unexpected FlutterTreeType"));
      }, null, "get$getRoot", 4, 0, null, 29],
      invokeServiceMethodObservatory$1: [function(methodName) {
        return this.invokeServiceMethodObservatory1$2(H.stringTypeCheck(methodName), this.groupName);
      }, null, "get$invokeServiceMethodObservatory", 4, 0, null, 46],
      invokeServiceMethodObservatory1$2: [function(methodName, arg1) {
        H.stringTypeCheck(methodName);
        H.stringTypeCheck(arg1);
        return this.get$inspectorLibrary().eval$2$isAlive("WidgetInspectorService.instance." + H.S(methodName) + "('" + H.S(arg1) + "')", this);
      }, null, "get$invokeServiceMethodObservatory1", 8, 0, null, 46, 91],
      invokeServiceMethodDaemon$2: [function(methodName, objectGroup) {
        H.stringTypeCheck(methodName);
        H.stringTypeCheck(objectGroup);
        return this.invokeServiceMethodDaemonParams$2(methodName, P.LinkedHashMap_LinkedHashMap$_literal(["objectGroup", objectGroup == null ? this.groupName : objectGroup], P.String, P.Object));
      }, function(methodName) {
        return this.invokeServiceMethodDaemon$2(methodName, null);
      }, "invokeServiceMethodDaemon$1", null, null, "get$invokeServiceMethodDaemon", 4, 2, null, 0, 46, 446],
      invokeServiceMethodDaemonArg$3: [function(methodName, arg, objectGroup) {
        var t1, args;
        H.stringTypeCheck(methodName);
        H.stringTypeCheck(arg);
        t1 = P.String;
        args = P.LinkedHashMap_LinkedHashMap$_literal(["objectGroup", H.stringTypeCheck(objectGroup)], t1, t1);
        if (arg != null)
          args.$indexSet(0, "arg", arg);
        return this.invokeServiceMethodDaemonParams$2(methodName, args);
      }, null, "get$invokeServiceMethodDaemonArg", 12, 0, null, 46, 44, 446],
      _callServiceExtension$2: [function(extension, args) {
        var t1;
        H.stringTypeCheck(extension);
        t1 = P.Object;
        H.assertSubtype(args, "$isMap", [P.String, t1], "$asMap");
        if (this.disposed)
          return P.Future_Future$value(null, t1);
        return this.get$inspectorLibrary().addRequest$1$2(this, new E.ObjectGroup__callServiceExtension_closure(this, extension, args), t1);
      }, null, "get$_callServiceExtension", 8, 0, null, 254, 71],
      invokeServiceMethodDaemonParams$2: [function(methodName, params) {
        H.stringTypeCheck(methodName);
        H.assertSubtype(params, "$isMap", [P.String, P.Object], "$asMap");
        return this._callServiceExtension$2("ext.flutter.inspector." + H.S(methodName), params);
      }, null, "get$invokeServiceMethodDaemonParams", 8, 0, null, 46, 160],
      invokeServiceMethodDaemonInspectorRef$2: [function(methodName, arg) {
        var t1;
        H.stringTypeCheck(methodName);
        H.interceptedTypeCheck(arg, "$isInspectorInstanceRef");
        t1 = arg == null ? null : arg.id;
        return this.invokeServiceMethodDaemonArg$3(methodName, t1, this.groupName);
      }, null, "get$invokeServiceMethodDaemonInspectorRef", 8, 0, null, 46, 44],
      invokeServiceMethodObservatoryInspectorRef$2: [function(methodName, arg) {
        var t1, t2;
        H.stringTypeCheck(methodName);
        H.interceptedTypeCheck(arg, "$isInspectorInstanceRef");
        t1 = this.get$inspectorLibrary();
        t2 = "WidgetInspectorService.instance." + H.S(methodName) + "('";
        return t1.eval$2$isAlive(t2 + H.S(arg == null ? null : arg.id) + "', '" + H.S(this.groupName) + "')", this);
      }, null, "get$invokeServiceMethodObservatoryInspectorRef", 8, 0, null, 46, 44],
      invokeServiceMethodOnRefObservatory$2: [function(methodName, arg) {
        var t1;
        H.stringTypeCheck(methodName);
        H.interceptedTypeCheck(arg, "$isInstanceRef");
        if (arg == null)
          return this.get$inspectorLibrary().eval$2$isAlive("WidgetInspectorService.instance." + H.S(methodName) + "(null, '" + H.S(this.groupName) + "')", this);
        t1 = P.String;
        return this.get$inspectorLibrary().eval$3$isAlive$scope("WidgetInspectorService.instance." + H.S(methodName) + "(arg1, '" + H.S(this.groupName) + "')", this, P.LinkedHashMap_LinkedHashMap$_literal(["arg1", arg.id], t1, t1));
      }, null, "get$invokeServiceMethodOnRefObservatory", 8, 0, null, 46, 44],
      parseDiagnosticsNodeObservatory$1: [function(instanceRefFuture) {
        return this.parseDiagnosticsNodeObservatory$body$ObjectGroup(H.futureOrCheck(instanceRefFuture, {futureOr: 1, type: S.InstanceRef}));
      }, null, "get$parseDiagnosticsNodeObservatory", 4, 0, null, 165],
      parseDiagnosticsNodeObservatory$body$ObjectGroup: [function(instanceRefFuture) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
          $async$returnValue, $async$self = this, $async$temp1;
        var $async$parseDiagnosticsNodeObservatory$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$temp1 = H;
                $async$goto = 4;
                return P._asyncAwait(instanceRefFuture, $async$parseDiagnosticsNodeObservatory$1);
              case 4:
                // returning from await.
                $async$goto = 3;
                return P._asyncAwait($async$self.instanceRefToJson$1($async$result), $async$parseDiagnosticsNodeObservatory$1);
              case 3:
                // returning from await.
                $async$returnValue = $async$self.parseDiagnosticsNodeHelper$1($async$temp1.assertSubtype($async$result, "$isMap", [P.String, P.Object], "$asMap"));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$parseDiagnosticsNodeObservatory$1, $async$completer);
      }, null, null, 4, 0, null, 165],
      parseDiagnosticsNodeDaemon$1: [function(json) {
        return this.parseDiagnosticsNodeDaemon$body$ObjectGroup(H.assertSubtype(json, "$isFuture", [P.Object], "$asFuture"));
      }, null, "get$parseDiagnosticsNodeDaemon", 4, 0, null, 2],
      parseDiagnosticsNodeDaemon$body$ObjectGroup: [function(json) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
          $async$returnValue, $async$self = this, $async$temp1;
        var $async$parseDiagnosticsNodeDaemon$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$temp1 = H;
                $async$goto = 3;
                return P._asyncAwait(json, $async$parseDiagnosticsNodeDaemon$1);
              case 3:
                // returning from await.
                $async$returnValue = $async$self.parseDiagnosticsNodeHelper$1($async$temp1.assertSubtype($async$result, "$isMap", [P.String, P.Object], "$asMap"));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$parseDiagnosticsNodeDaemon$1, $async$completer);
      }, null, null, 4, 0, null, 2],
      parseDiagnosticsNodeHelper$1: [function(jsonElement) {
        H.assertSubtype(jsonElement, "$isMap", [P.String, P.Object], "$asMap");
        if (this.disposed)
          return;
        if (jsonElement == null)
          return;
        return M.RemoteDiagnosticsNode$(jsonElement, this, false, null);
      }, null, "get$parseDiagnosticsNodeHelper", 4, 0, null, 681],
      instanceRefToJson$1: [function(instanceRef) {
        return this.instanceRefToJson$body$ObjectGroup(H.interceptedTypeCheck(instanceRef, "$isInstanceRef"));
      }, null, "get$instanceRefToJson", 4, 0, null, 172],
      instanceRefToJson$body$ObjectGroup: [function(instanceRef) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Object),
          $async$returnValue, $async$self = this, instance, json;
        var $async$instanceRefToJson$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed || instanceRef == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait($async$self.get$inspectorLibrary().getInstance$2(instanceRef, $async$self), $async$instanceRefToJson$1);
              case 3:
                // returning from await.
                instance = $async$result;
                if ($async$self.disposed || instance == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                json = instance.valueAsString;
                if (json == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$returnValue = P.jsonDecode(json, null);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$instanceRefToJson$1, $async$completer);
      }, null, null, 4, 0, null, 172],
      parseDiagnosticsNodesObservatory$2: [function(instanceRefFuture, $parent) {
        return this.parseDiagnosticsNodesObservatory$body$ObjectGroup(H.futureOrCheck(instanceRefFuture, {futureOr: 1, type: S.InstanceRef}), H.interceptedTypeCheck($parent, "$isRemoteDiagnosticsNode"));
      }, null, "get$parseDiagnosticsNodesObservatory", 8, 0, null, 165, 24],
      parseDiagnosticsNodesObservatory$body$ObjectGroup: [function(instanceRefFuture, $parent) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, M.RemoteDiagnosticsNode]),
          $async$returnValue, $async$self = this, instanceRef, $async$temp1;
        var $async$parseDiagnosticsNodesObservatory$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed || instanceRefFuture == null) {
                  $async$returnValue = H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait(instanceRefFuture, $async$parseDiagnosticsNodesObservatory$2);
              case 3:
                // returning from await.
                instanceRef = $async$result;
                if ($async$self.disposed || false) {
                  $async$returnValue = H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$temp1 = H;
                $async$goto = 4;
                return P._asyncAwait($async$self.instanceRefToJson$1(instanceRef), $async$parseDiagnosticsNodesObservatory$2);
              case 4:
                // returning from await.
                $async$returnValue = $async$self.parseDiagnosticsNodesHelper$2($async$temp1.assertSubtype($async$result, "$isList", [P.Object], "$asList"), $parent);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$parseDiagnosticsNodesObservatory$2, $async$completer);
      }, null, null, 8, 0, null, 165, 24],
      parseDiagnosticsNodesHelper$2: [function(jsonObject, $parent) {
        var t1, nodes, t2;
        t1 = P.Object;
        H.assertSubtype(jsonObject, "$isList", [t1], "$asList");
        H.interceptedTypeCheck($parent, "$isRemoteDiagnosticsNode");
        if (this.disposed || jsonObject == null)
          return C.List_empty3;
        nodes = H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]);
        for (t2 = J.get$iterator$ax(jsonObject), t1 = [P.String, t1]; t2.moveNext$0();)
          C.JSArray_methods.add$1(nodes, M.RemoteDiagnosticsNode$(H.assertSubtype(t2.get$current(), "$isMap", t1, "$asMap"), this, false, $parent));
        return nodes;
      }, null, "get$parseDiagnosticsNodesHelper", 8, 0, null, 682, 24],
      parseDiagnosticsNodesDaemon$2: [function(jsonFuture, $parent) {
        return this.parseDiagnosticsNodesDaemon$body$ObjectGroup(H.futureOrCheck(jsonFuture, {futureOr: 1, type: P.Object}), H.interceptedTypeCheck($parent, "$isRemoteDiagnosticsNode"));
      }, null, "get$parseDiagnosticsNodesDaemon", 8, 0, null, 447, 24],
      parseDiagnosticsNodesDaemon$body$ObjectGroup: [function(jsonFuture, $parent) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, M.RemoteDiagnosticsNode]),
          $async$returnValue, $async$self = this, $async$temp1;
        var $async$parseDiagnosticsNodesDaemon$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed || jsonFuture == null) {
                  $async$returnValue = C.List_empty3;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$temp1 = H;
                $async$goto = 3;
                return P._asyncAwait(jsonFuture, $async$parseDiagnosticsNodesDaemon$2);
              case 3:
                // returning from await.
                $async$returnValue = $async$self.parseDiagnosticsNodesHelper$2($async$temp1.assertSubtype($async$result, "$isList", [P.Object], "$asList"), $parent);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$parseDiagnosticsNodesDaemon$2, $async$completer);
      }, null, null, 8, 0, null, 447, 24],
      getChildren$3: [function(instanceRef, summaryTree, $parent) {
        H.interceptedTypeCheck(instanceRef, "$isInspectorInstanceRef");
        H.boolTypeCheck(summaryTree);
        H.interceptedTypeCheck($parent, "$isRemoteDiagnosticsNode");
        return this.getListHelper$3(instanceRef, summaryTree ? "getChildrenSummaryTree" : "getChildrenDetailsSubtree", $parent);
      }, null, "get$getChildren", 12, 0, null, 172, 156, 24],
      getListHelper$3: [function(instanceRef, methodName, $parent) {
        return this.getListHelper$body$ObjectGroup(H.interceptedTypeCheck(instanceRef, "$isInspectorInstanceRef"), H.stringTypeCheck(methodName), H.interceptedTypeCheck($parent, "$isRemoteDiagnosticsNode"));
      }, null, "get$getListHelper", 12, 0, null, 172, 46, 24],
      getListHelper$body$ObjectGroup: [function(instanceRef, methodName, $parent) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, M.RemoteDiagnosticsNode]),
          $async$returnValue, $async$self = this;
        var $async$getListHelper$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed) {
                  $async$returnValue = C.List_empty3;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if ($async$self.get$useDaemonApi()) {
                  $async$returnValue = $async$self.parseDiagnosticsNodesDaemon$2($async$self.invokeServiceMethodDaemonInspectorRef$2(methodName, instanceRef), $parent);
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  $async$returnValue = $async$self.parseDiagnosticsNodesObservatory$2($async$self.invokeServiceMethodObservatoryInspectorRef$2(methodName, instanceRef), $parent);
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$getListHelper$3, $async$completer);
      }, null, null, 12, 0, null, 172, 46, 24],
      invokeServiceMethodReturningNode$1: [function(methodName) {
        return this.invokeServiceMethodReturningNode$body$ObjectGroup(H.stringTypeCheck(methodName));
      }, null, "get$invokeServiceMethodReturningNode", 4, 0, null, 46],
      invokeServiceMethodReturningNode$body$ObjectGroup: [function(methodName) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
          $async$returnValue, $async$self = this;
        var $async$invokeServiceMethodReturningNode$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if ($async$self.get$useDaemonApi()) {
                  $async$returnValue = $async$self.parseDiagnosticsNodeDaemon$1($async$self.invokeServiceMethodDaemon$1(methodName));
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  $async$returnValue = $async$self.parseDiagnosticsNodeObservatory$1($async$self.invokeServiceMethodObservatory$1(methodName));
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$invokeServiceMethodReturningNode$1, $async$completer);
      }, null, null, 4, 0, null, 46],
      invokeServiceMethodReturningNodeInspectorRef$2: [function(methodName, ref) {
        H.stringTypeCheck(methodName);
        H.interceptedTypeCheck(ref, "$isInspectorInstanceRef");
        if (this.disposed)
          return;
        if (this.get$useDaemonApi())
          return this.parseDiagnosticsNodeDaemon$1(this.invokeServiceMethodDaemonInspectorRef$2(methodName, ref));
        else
          return this.parseDiagnosticsNodeObservatory$1(this.invokeServiceMethodObservatoryInspectorRef$2(methodName, ref));
      }, null, "get$invokeServiceMethodReturningNodeInspectorRef", 8, 0, null, 46, 81],
      invokeVoidServiceMethod$2: [function(methodName, arg1) {
        return this.invokeVoidServiceMethod$body$ObjectGroup(H.stringTypeCheck(methodName), H.stringTypeCheck(arg1));
      }, null, "get$invokeVoidServiceMethod", 8, 0, null, 46, 91],
      invokeVoidServiceMethod$body$ObjectGroup: [function(methodName, arg1) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this;
        var $async$invokeVoidServiceMethod$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = $async$self.get$useDaemonApi() ? 3 : 5;
                break;
              case 3:
                // then
                $async$goto = 6;
                return P._asyncAwait($async$self.invokeServiceMethodDaemon$2(methodName, arg1), $async$invokeVoidServiceMethod$2);
              case 6:
                // returning from await.
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$goto = 7;
                return P._asyncAwait($async$self.invokeServiceMethodObservatory1$2(methodName, arg1), $async$invokeVoidServiceMethod$2);
              case 7:
                // returning from await.
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$invokeVoidServiceMethod$2, $async$completer);
      }, null, null, 8, 0, null, 46, 91],
      getRootWidget$0: [function() {
        return this.invokeServiceMethodReturningNode$1("getRootWidgetSummaryTree");
      }, null, "get$getRootWidget", 0, 0, null],
      getRootRenderObject$0: [function() {
        return this.invokeServiceMethodReturningNode$1("getRootRenderObject");
      }, null, "get$getRootRenderObject", 0, 0, null],
      getSelection$3: [function(_, previousSelection, treeType, localOnly) {
        return this.getSelection$body$ObjectGroup(_, H.interceptedTypeCheck(previousSelection, "$isRemoteDiagnosticsNode"), H.interceptedTypeCheck(treeType, "$isFlutterTreeType"), H.boolTypeCheck(localOnly));
      }, null, "get$getSelection", 13, 0, null, 448, 106, 449],
      getSelection$body$ObjectGroup: [function(_, previousSelection, treeType, localOnly) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
          $async$returnValue, $async$self = this, previousSelectionRef, newSelection;
        var $async$getSelection$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                previousSelectionRef = previousSelection != null ? previousSelection.get$dartDiagnosticRef() : null;
              case 3:
                // switch
                switch (treeType) {
                  case C.FlutterTreeType_0:
                    // goto case
                    $async$goto = 5;
                    break;
                  case C.FlutterTreeType_1:
                    // goto case
                    $async$goto = 6;
                    break;
                  default:
                    // goto default
                    $async$goto = 7;
                    break;
                }
                break;
              case 5:
                // case
                $async$goto = 8;
                return P._asyncAwait($async$self.invokeServiceMethodReturningNodeInspectorRef$2(localOnly ? "getSelectedSummaryWidget" : "getSelectedWidget", previousSelectionRef), $async$getSelection$3);
              case 8:
                // returning from await.
                newSelection = $async$result;
                // goto after switch
                $async$goto = 4;
                break;
              case 6:
                // case
                $async$goto = 9;
                return P._asyncAwait($async$self.invokeServiceMethodReturningNodeInspectorRef$2("getSelectedRenderObject", previousSelectionRef), $async$getSelection$3);
              case 9:
                // returning from await.
                newSelection = $async$result;
                // goto after switch
                $async$goto = 4;
                break;
              case 7:
                // default
                newSelection = null;
              case 4:
                // after switch
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if (newSelection != null && J.$eq$(newSelection.get$dartDiagnosticRef(), previousSelectionRef)) {
                  $async$returnValue = previousSelection;
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  $async$returnValue = newSelection;
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$getSelection$3, $async$completer);
      }, null, null, 13, 0, null, 448, 106, 449],
      setSelectionInspector$2: [function(selection, uiAlreadyUpdated) {
        H.interceptedTypeCheck(selection, "$isInspectorInstanceRef");
        H.boolTypeCheck(uiAlreadyUpdated);
        if (this.disposed)
          return P.Future_Future$value(null, -1);
        if (this.get$useDaemonApi())
          return this.handleSetSelectionDaemon$2(this.invokeServiceMethodDaemonInspectorRef$2("setSelectionById", selection), uiAlreadyUpdated);
        else
          return this.handleSetSelectionObservatory$2(this.invokeServiceMethodObservatoryInspectorRef$2("setSelectionById", selection), uiAlreadyUpdated);
      }, null, "get$setSelectionInspector", 8, 0, null, 134, 110],
      setSelection$2: [function(selection, uiAlreadyUpdated) {
        H.interceptedTypeCheck(selection, "$isInstanceRef");
        H.boolTypeCheck(uiAlreadyUpdated);
        this.handleSetSelectionObservatory$2(this.invokeServiceMethodOnRefObservatory$2("setSelection", selection), uiAlreadyUpdated);
      }, null, "get$setSelection", 8, 0, null, 134, 110],
      handleSetSelectionObservatory$2: [function(setSelectionResult, uiAlreadyUpdated) {
        return this.handleSetSelectionObservatory$body$ObjectGroup(H.assertSubtype(setSelectionResult, "$isFuture", [S.InstanceRef], "$asFuture"), H.boolTypeCheck(uiAlreadyUpdated));
      }, null, "get$handleSetSelectionObservatory", 8, 0, null, 258, 110],
      handleSetSelectionObservatory$body$ObjectGroup: [function(setSelectionResult, uiAlreadyUpdated) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, instanceRef;
        var $async$handleSetSelectionObservatory$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait(setSelectionResult, $async$handleSetSelectionObservatory$2);
              case 3:
                // returning from await.
                instanceRef = $async$result;
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$self.handleSetSelectionHelper$2("true" === instanceRef.valueAsString, uiAlreadyUpdated);
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$handleSetSelectionObservatory$2, $async$completer);
      }, null, null, 8, 0, null, 258, 110],
      handleSetSelectionHelper$2: [function(selectionChanged, uiAlreadyUpdated) {
        H.boolTypeCheck(selectionChanged);
        H.boolTypeCheck(uiAlreadyUpdated);
        if (selectionChanged && !uiAlreadyUpdated && !this.disposed)
          this.inspectorService.notifySelectionChanged$0();
      }, null, "get$handleSetSelectionHelper", 8, 0, null, 687, 110],
      handleSetSelectionDaemon$2: [function(setSelectionResult, uiAlreadyUpdated) {
        return this.handleSetSelectionDaemon$body$ObjectGroup(H.assertSubtype(setSelectionResult, "$isFuture", [P.Object], "$asFuture"), H.boolTypeCheck(uiAlreadyUpdated));
      }, null, "get$handleSetSelectionDaemon", 8, 0, null, 258, 110],
      handleSetSelectionDaemon$body$ObjectGroup: [function(setSelectionResult, uiAlreadyUpdated) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, json;
        var $async$handleSetSelectionDaemon$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait(setSelectionResult, $async$handleSetSelectionDaemon$2);
              case 3:
                // returning from await.
                json = $async$result;
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$self.handleSetSelectionHelper$2(H.boolTypeCheck(json), uiAlreadyUpdated);
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$handleSetSelectionDaemon$2, $async$completer);
      }, null, null, 8, 0, null, 258, 110],
      getDetailsSubtree$1: [function(node) {
        return this.getDetailsSubtree$body$ObjectGroup(H.interceptedTypeCheck(node, "$isRemoteDiagnosticsNode"));
      }, null, "get$getDetailsSubtree", 4, 0, null, 23],
      getDetailsSubtree$body$ObjectGroup: [function(node) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
          $async$returnValue, $async$self = this;
        var $async$getDetailsSubtree$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (node == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$returnValue = $async$self.invokeServiceMethodReturningNodeInspectorRef$2("getDetailsSubtree", node.get$dartDiagnosticRef());
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$getDetailsSubtree$1, $async$completer);
      }, null, null, 4, 0, null, 23],
      static: {
        ObjectGroup$: [function(debugName, inspectorService) {
          var t1 = new E.ObjectGroup(H.S(debugName) + "_" + H.S($.InspectorService_nextGroupId), inspectorService, false, []);
          t1.ObjectGroup$2(debugName, inspectorService);
          return t1;
        }, null, null, 8, 0, null, 259, 163]
      }
    },
    ObjectGroup__callServiceExtension_closure: {
      "^": "Closure:8;$this,extension,args,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$returnValue, $async$self = this, t1, t2, r, json;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = $async$self.extension;
                $async$goto = 3;
                return P._asyncAwait(t1.get$inspectorService().get$vmService().callServiceExtension$3$args$isolateId(t2, $async$self.args, t1.get$inspectorService().get$inspectorLibrary().get$isolateId()), $async$call$0);
              case 3:
                // returning from await.
                r = $async$result;
                if (t1.get$disposed()) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                json = r.json;
                if (json.$index(0, "errorMessage") != null)
                  throw H.wrapException(P.Exception_Exception(H.S(t2) + " -- " + H.S(json.$index(0, "errorMessage"))));
                $async$returnValue = json.$index(0, "result");
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    FlutterTreeType: {
      "^": "Object;index>,_inspector_service$_name,$ti",
      toString$0: [function(_) {
        return this._inspector_service$_name;
      }, null, "get$toString", 1, 0, null],
      static: {
        "^": "FlutterTreeType_renderObject<"
      }
    },
    InspectorServiceClient: {
      "^": "Object;$ti"
    },
    InspectorInstanceRef: {
      "^": "Object;id>,$ti",
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (other instanceof E.InspectorInstanceRef)
          return J.$eq$(this.id, other.id);
        return false;
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return "instance-" + H.S(this.id);
      }, null, "get$toString", 1, 0, null],
      static: {
        InspectorInstanceRef$: [function(id) {
          return new E.InspectorInstanceRef(id, []);
        }, null, null, 4, 0, null, 104]
      }
    },
    InspectorObjectGroupManager: {
      "^": "Object;inspectorService<,debugName,0_inspector_service$_current,0_inspector_service$_next,0_pendingNext,$ti",
      set$_pendingNext: function(_pendingNext) {
        this._pendingNext = H.assertSubtype(_pendingNext, "$isCompleter", [-1], "$asCompleter");
      },
      get$pendingUpdateDone: [function() {
        var t1 = this._pendingNext;
        if (t1 != null)
          return t1.get$future();
        if (this._inspector_service$_next == null)
          return P.Future_Future$value(null, -1);
        this.set$_pendingNext(P.Completer_Completer(-1));
        return this._pendingNext.get$future();
      }, null, null, 2, 0, null],
      get$current: [function() {
        var t1 = this._inspector_service$_current;
        if (t1 == null) {
          t1 = H.interceptedTypeCheck(this.inspectorService.createObjectGroup$1(this.debugName), "$isObjectGroup");
          this._inspector_service$_current = t1;
        }
        return t1;
      }, null, null, 2, 0, null],
      get$next: [function() {
        var t1 = this._inspector_service$_next;
        if (t1 == null) {
          t1 = H.interceptedTypeCheck(this.inspectorService.createObjectGroup$1(this.debugName), "$isObjectGroup");
          this._inspector_service$_next = t1;
        }
        return t1;
      }, null, null, 2, 0, null],
      clear$1: [function(_, isolateStopped) {
        if (H.boolTypeCheck(isolateStopped)) {
          this._inspector_service$_current = null;
          this._setNextNull$0();
        } else {
          this.clearCurrent$0();
          this.cancelNext$0();
        }
      }, null, "get$clear", 5, 0, null, 440],
      promoteNext$0: [function() {
        this.clearCurrent$0();
        this._inspector_service$_current = H.interceptedTypeCheck(this._inspector_service$_next, "$isObjectGroup");
        this._setNextNull$0();
      }, null, "get$promoteNext", 0, 0, null],
      clearCurrent$0: [function() {
        var t1 = this._inspector_service$_current;
        if (t1 != null) {
          t1.dispose$0();
          this._inspector_service$_current = null;
        }
      }, null, "get$clearCurrent", 0, 0, null],
      cancelNext$0: [function() {
        var t1 = this._inspector_service$_next;
        if (t1 != null) {
          t1.dispose$0();
          this._setNextNull$0();
        }
      }, null, "get$cancelNext", 0, 0, null],
      _setNextNull$0: [function() {
        this._inspector_service$_next = null;
        var t1 = this._pendingNext;
        if (t1 != null) {
          J.complete$1$z(t1, null);
          this.set$_pendingNext(null);
        }
      }, null, "get$_setNextNull", 0, 0, null],
      static: {
        InspectorObjectGroupManager$: [function(inspectorService, debugName) {
          return new E.InspectorObjectGroupManager(inspectorService, debugName, []);
        }, null, null, 8, 0, null, 163, 259]
      }
    }
  }], ["", "package:devtools/src/inspector/inspector_text_styles.dart",, R, {}], ["inspector_tree", "package:devtools/src/inspector/inspector_tree.dart",, K, {
    "^": "",
    PaintEntry: {
      "^": "Object;$ti",
      attach$1: [function(owner) {
        H.interceptedTypeCheck(owner, "$isInspectorTree");
      }, null, "get$attach", 4, 0, null, 257]
    },
    InspectorTreeNodeRenderBuilder: {
      "^": "Object;level<,$ti"
    },
    InspectorTreeNodeRender: {
      "^": "Object;entries>,$ti",
      attach$2: [function(owner, offset) {
        var t1;
        H.interceptedTypeCheck(owner, "$isInspectorTree");
        H.interceptedTypeCheck(offset, "$isOffset");
        if (!J.$eq$(this._owner, owner))
          this._owner = owner;
        this._offset = offset;
        for (t1 = J.get$iterator$ax(this.entries); t1.moveNext$0();)
          t1.get$current().attach$1(owner);
      }, null, "get$attach", 8, 0, null, 257, 52],
      get$offset: [function(_) {
        return this._offset;
      }, null, null, 3, 0, null],
      get$paintBounds: [function() {
        return J.$and$bn(this._offset, this.size);
      }, null, null, 2, 0, null]
    },
    InspectorTreeNode: {
      "^": "Object;0_renderObject,$ti",
      set$_renderObject: function(_renderObject) {
        this._renderObject = H.assertSubtype(_renderObject, "$isInspectorTreeNodeRender", [K.PaintEntry], "$asInspectorTreeNodeRender");
      },
      get$showLinesToChildren: [function() {
        var t1, t2;
        t1 = this._inspector_tree$_children;
        t2 = J.getInterceptor$asx(t1);
        return J.$gt$n(t2.get$length(t1), 1) && !t2.get$last(t1).get$isProperty();
      }, null, null, 2, 0, null],
      get$renderObject: [function() {
        var builder, icon, $name, textStyle, propertyType, properties, description, alpha, red, green, blue, t1, color, codePoint, match;
        if (this._renderObject != null || this.get$diagnostic() == null)
          return this._renderObject;
        builder = this.createRenderBuilder$0();
        icon = this.get$diagnostic().get$icon();
        if (this.get$showExpandCollapse())
          builder.addIcon$1(this.get$expanded() ? $.$get$collapseArrow() : $.$get$expandArrow());
        if (icon != null)
          builder.addIcon$1(icon);
        $name = J.get$name$x(this.get$diagnostic());
        textStyle = Z.textStyleForLevel(this.get$diagnostic().get$level());
        if (this.get$diagnostic().get$isProperty()) {
          propertyType = this.get$diagnostic().get$propertyType();
          properties = this.get$diagnostic().get$valuePropertiesJson();
          if (this.get$isCreatedByLocalProject())
            textStyle = textStyle.merge$1(C.TextStyle_QWq);
          if (J.$eq$($name == null ? null : C.JSString_methods.get$isNotEmpty($name), true) && this.get$diagnostic().get$showName())
            builder.appendText$2(0, H.S($name) + H.S(this.get$diagnostic().get$separator()) + " ", textStyle);
          description = this.get$diagnostic().get$description();
          if (propertyType != null && properties != null)
            switch (propertyType) {
              case "Color":
                alpha = B.JsonUtils_getIntMember(properties, "alpha");
                red = B.JsonUtils_getIntMember(properties, "red");
                green = B.JsonUtils_getIntMember(properties, "green");
                blue = B.JsonUtils_getIntMember(properties, "blue");
                t1 = new K.InspectorTreeNode_renderObject_radix();
                description = alpha === 255 ? "#" + H.S(t1.call$1(red)) + H.S(t1.call$1(green)) + H.S(t1.call$1(blue)) : "#" + H.S(t1.call$1(alpha)) + H.S(t1.call$1(red)) + H.S(t1.call$1(green)) + H.S(t1.call$1(blue));
                color = S.Color$fromARGB(alpha, red, green, blue);
                builder.addIcon$1($.$get$_colorIconMaker().getCustomIcon$1(color));
                break;
              case "IconData":
                codePoint = B.JsonUtils_getIntMember(properties, "codePoint");
                if (typeof codePoint !== "number")
                  return codePoint.$gt();
                if (codePoint > 0) {
                  icon = K.FlutterMaterialIcons_getIconForCodePoint(codePoint);
                  if (icon != null)
                    builder.addIcon$1(icon);
                }
                break;
            }
          builder.appendText$2(0, description, textStyle);
          if (J.$eq$(this.get$diagnostic().get$level(), C.DiagnosticLevel_1) && this.get$diagnostic().get$hasDefaultValue()) {
            builder.appendText$2(0, " ", textStyle);
            builder.addIcon$1($.$get$defaultIcon());
          }
        } else {
          if (J.$eq$($name == null ? null : C.JSString_methods.get$isNotEmpty($name), true) && this.get$diagnostic().get$showName() && $name !== "child") {
            if (J.startsWith$1$s($name, "child "))
              builder.appendText$2(0, $name, $.$get$grayed());
            else
              builder.appendText$2(0, $name, textStyle);
            if (this.get$diagnostic().get$showSeparator())
              builder.appendText$2(0, this.get$diagnostic().get$separator(), $.$get$grayed());
            else
              builder.appendText$2(0, " ", $.$get$grayed());
          }
          if (!this.get$diagnostic().get$isSummaryTree() && this.get$diagnostic().get$isCreatedByLocalProject())
            textStyle = textStyle.merge$1(C.TextStyle_yVv);
          description = this.get$diagnostic().get$description();
          match = $.$get$_primaryDescriptionPattern().firstMatch$1(description);
          if (match != null) {
            t1 = $.$get$grayed();
            builder.appendText$2(0, " ", t1);
            builder.appendText$2(0, match.group$1(1), textStyle);
            if (J.get$isNotEmpty$asx(match.group$1(2))) {
              builder.appendText$2(0, " ", textStyle);
              builder.appendText$2(0, match.group$1(2), t1);
            }
          } else {
            t1 = this.get$diagnostic().get$description();
            if (J.$eq$(t1 == null ? null : J.get$isNotEmpty$asx(t1), true)) {
              builder.appendText$2(0, " ", $.$get$grayed());
              builder.appendText$2(0, this.get$diagnostic().get$description(), textStyle);
            }
          }
        }
        this.set$_renderObject(builder.build$0());
        return this._renderObject;
      }, null, null, 2, 0, null],
      get$children: [function(_) {
        return this._inspector_tree$_children;
      }, null, null, 3, 0, null],
      get$isCreatedByLocalProject: [function() {
        return this._diagnostic.get$isCreatedByLocalProject();
      }, null, null, 2, 0, null],
      get$isProperty: [function() {
        return this.get$diagnostic() == null || this.get$diagnostic().get$isProperty();
      }, null, null, 2, 0, null],
      get$expanded: [function() {
        return this._expanded;
      }, null, null, 2, 0, null],
      get$showExpandCollapse: [function() {
        var t1 = this.get$diagnostic();
        return (J.$eq$(t1 == null ? null : t1.get$hasChildren(), true) || J.get$isNotEmpty$asx(this.get$children(this))) && this.allowExpandCollapse;
      }, null, null, 2, 0, null],
      set$expanded: [function(value) {
        var t1;
        H.boolTypeCheck(value);
        t1 = this._expanded;
        if (value == null ? t1 != null : value !== t1) {
          this._expanded = value;
          this.dirty$0();
        }
      }, null, null, 6, 0, null, 1],
      get$parent: [function(_) {
        return this._inspector_tree$_parent;
      }, null, null, 3, 0, null],
      set$parent: [function(_, value) {
        H.interceptedTypeCheck(value, "$isInspectorTreeNode");
        this._inspector_tree$_parent = value;
        if (!(value == null))
          value.dirty$0();
      }, null, null, 7, 0, null, 1],
      get$diagnostic: [function() {
        return this._diagnostic;
      }, null, null, 2, 0, null],
      set$diagnostic: [function(v) {
        H.interceptedTypeCheck(v, "$isRemoteDiagnosticsNode");
        this._diagnostic = v;
        this._expanded = H.boolTypeCheck(v.get$childrenReady());
        this.dirty$0();
      }, null, null, 6, 0, null, 112],
      dirty$0: [function() {
        this.set$_renderObject(null);
        if (this._childrenCount == null)
          return;
        this._childrenCount = null;
        if (this.get$parent(this) != null)
          this.get$parent(this).dirty$0();
      }, "call$0", "get$dirty", 0, 0, 0],
      get$childrenCount: [function() {
        var t1, count, t2;
        if (!this.get$expanded())
          this._childrenCount = 0;
        t1 = this._childrenCount;
        if (t1 != null)
          return t1;
        for (t1 = J.get$iterator$ax(this._inspector_tree$_children), count = 0; t1.moveNext$0();) {
          t2 = t1.get$current().get$subtreeSize();
          if (typeof t2 !== "number")
            return H.iae(t2);
          count += t2;
        }
        this._childrenCount = count;
        return count;
      }, null, null, 2, 0, null],
      get$hasPlaceholderChildren: [function() {
        return J.$eq$(J.get$length$asx(this.get$children(this)), 1) && J.get$first$ax(this.get$children(this)).get$diagnostic() == null;
      }, null, null, 2, 0, null],
      get$subtreeSize: [function() {
        return J.$add$ansx(this.get$childrenCount(), 1);
      }, null, null, 2, 0, null],
      get$isLeaf: [function() {
        return J.get$isEmpty$asx(this._inspector_tree$_children);
      }, null, null, 2, 0, null],
      getRowIndex$1: [function(node) {
        var index, $parent, t1, t2;
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        for (index = 0; true; node = $parent) {
          $parent = node.get$parent(node);
          if ($parent == null)
            break;
          for (t1 = J.get$iterator$ax($parent._inspector_tree$_children); t1.moveNext$0();) {
            t2 = t1.get$current();
            if (t2 === node)
              break;
            t2 = t2.get$subtreeSize();
            if (typeof t2 !== "number")
              return H.iae(t2);
            index += t2;
          }
          ++index;
        }
        return index;
      }, null, "get$getRowIndex", 4, 0, null, 23],
      getRow$2$selection: [function(index, selection) {
        var ticks, highlightDepth, node, current, depth, t1, children, i, t2, child, subtreeSize, current0;
        H.intTypeCheck(index);
        H.interceptedTypeCheck(selection, "$isInspectorTreeNode");
        ticks = H.setRuntimeTypeInfo([], [P.int]);
        if (J.$le$n(this.get$subtreeSize(), index))
          return;
        for (highlightDepth = null, node = this, current = 0, depth = 0; true;) {
          t1 = selection === node;
          if (t1)
            highlightDepth = depth;
          if (current === index)
            return K.InspectorTreeRow$(depth, highlightDepth, index, t1, !node.get$isProperty() && index !== 0 && node.get$parent(node).get$showLinesToChildren(), node, ticks);
          ++current;
          children = node._inspector_tree$_children;
          t1 = J.getInterceptor$asx(children);
          i = 0;
          while (true) {
            t2 = t1.get$length(children);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            child = t1.$index(children, i);
            subtreeSize = child.get$subtreeSize();
            if (typeof subtreeSize !== "number")
              return H.iae(subtreeSize);
            current0 = current + subtreeSize;
            if (typeof index !== "number")
              return H.iae(index);
            if (current0 > index) {
              if (J.$gt$n(t1.get$length(children), 1) && i + 1 !== t1.get$length(children) && !t1.get$last(children).get$isProperty())
                C.JSArray_methods.add$1(ticks, depth);
              node = child;
              break;
            }
            ++i;
            current = current0;
          }
          ++depth;
        }
        return;
      }, function(index) {
        return this.getRow$2$selection(index, null);
      }, "getRow$1", null, null, "get$getRow", 4, 3, null, 0, 6, 134],
      removeChild$1: [function(child) {
        H.interceptedTypeCheck(child, "$isInspectorTreeNode");
        child.set$parent(0, null);
        J.remove$1$ax(this._inspector_tree$_children, child);
        this.dirty$0();
      }, null, "get$removeChild", 4, 0, null, 130],
      appendChild$1: [function(child) {
        H.interceptedTypeCheck(child, "$isInspectorTreeNode");
        J.add$1$ax(this._inspector_tree$_children, child);
        child.set$parent(0, this);
        this.dirty$0();
      }, null, "get$appendChild", 4, 0, null, 130],
      clearChildren$0: [function() {
        J.clear$0$ax(this._inspector_tree$_children);
        this.dirty$0();
      }, null, "get$clearChildren", 0, 0, null]
    },
    InspectorTreeNode_renderObject_radix: {
      "^": "Closure:29;$ti",
      call$1: [function(chan) {
        return J.padLeft$2$s(J.toRadixString$1$n(H.intTypeCheck(chan), 16), 2, "0");
      }, null, null, 4, 0, null, 693, "call"]
    },
    InspectorTreeRow: {
      "^": "Object;node<,ticks,depth<,index>,lineToParent,isSelected,highlightDepth,$ti",
      static: {
        InspectorTreeRow$: [function(depth, highlightDepth, index, isSelected, lineToParent, node, ticks) {
          return new K.InspectorTreeRow(node, ticks, depth, index, lineToParent, isSelected, highlightDepth, []);
        }, null, null, 0, 15, null, 0, 0, 0, 0, 27, 0, 0, 161, 688, 6, 689, 690, 23, 691]
      }
    },
    InspectorTree: {
      "^": "Object;_onSelectionChange<,0_root,0_selection,0_hover,$ti",
      set$_root: function(_root) {
        this._root = H.interceptedTypeCheck(_root, "$isInspectorTreeNode");
      },
      set$_selection: function(_selection) {
        this._selection = H.interceptedTypeCheck(_selection, "$isInspectorTreeNode");
      },
      set$_hover: function(_hover) {
        this._hover = H.interceptedTypeCheck(_hover, "$isInspectorTreeNode");
      },
      get$root: [function(_) {
        return this._root;
      }, null, null, 3, 0, null],
      set$root: [function(_, node) {
        this.setState$1(new K.InspectorTree_root_closure(this, H.interceptedTypeCheck(node, "$isInspectorTreeNode")));
      }, null, null, 7, 0, null, 23],
      get$selection: [function() {
        return this._selection;
      }, null, null, 2, 0, null],
      set$selection: [function(node) {
        this.setState$1(new K.InspectorTree_selection_closure(this, H.interceptedTypeCheck(node, "$isInspectorTreeNode")));
      }, null, null, 6, 0, null, 23],
      get$hover: [function() {
        return this._hover;
      }, null, null, 2, 0, null],
      set$hover: [function(node) {
        var t1;
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        t1 = this._hover;
        if (node == null ? t1 == null : node === t1)
          return;
        this.setState$1(new K.InspectorTree_hover_closure(this, node));
      }, null, null, 6, 0, null, 23],
      getDepthIndent$1: [function(depth) {
        H.intTypeCheck(depth);
        if (typeof depth !== "number")
          return depth.$add();
        return (depth + 1) * 16 + 10;
      }, null, "get$getDepthIndent", 4, 0, null, 161],
      getRowY$1: [function(index) {
        H.intTypeCheck(index);
        if (typeof index !== "number")
          return H.iae(index);
        return 24 * index + 10;
      }, null, "get$getRowY", 4, 0, null, 6],
      nodeChanged$1: [function(node) {
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        if (node == null)
          return;
        this.setState$1(new K.InspectorTree_nodeChanged_closure(node));
      }, null, "get$nodeChanged", 4, 0, null, 23],
      removeNodeFromParent$1: [function(node) {
        this.setState$1(new K.InspectorTree_removeNodeFromParent_closure(H.interceptedTypeCheck(node, "$isInspectorTreeNode")));
      }, null, "get$removeNodeFromParent", 4, 0, null, 23],
      appendChild$2: [function(node, child) {
        this.setState$1(new K.InspectorTree_appendChild_closure(H.interceptedTypeCheck(node, "$isInspectorTreeNode"), H.interceptedTypeCheck(child, "$isInspectorTreeNode")));
      }, null, "get$appendChild", 8, 0, null, 23, 130],
      expandPath$1: [function(node) {
        var t1 = {};
        t1.node = node;
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        this.setState$1(new K.InspectorTree_expandPath_closure(t1));
      }, null, "get$expandPath", 4, 0, null, 23],
      get$numRows: [function() {
        return this.get$root(this) != null ? this.get$root(this).get$subtreeSize() : 0;
      }, null, null, 2, 0, null],
      getRowIndex$1: [function(y) {
        H.doubleTypeCheck(y);
        if (typeof y !== "number")
          return y.$sub();
        return C.JSNumber_methods._tdivFast$1(y - 10, 24);
      }, null, "get$getRowIndex", 4, 0, null, 77],
      getRowForNode$1: [function(node) {
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        return this.get$root(this).getRow$1(this.get$root(this).getRowIndex$1(node));
      }, null, "get$getRowForNode", 4, 0, null, 23],
      getRow$1: [function(offset) {
        var row, t1;
        H.interceptedTypeCheck(offset, "$isOffset");
        if (this.get$root(this) == null)
          return;
        row = this.getRowIndex$1(offset.get$dy(offset));
        t1 = this.get$root(this).get$subtreeSize();
        if (typeof row !== "number")
          return row.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        return row < t1 ? this.get$root(this).getRow$1(row) : null;
      }, null, "get$getRow", 4, 0, null, 52],
      onTap$1: [function(offset) {
        var row, t1;
        H.interceptedTypeCheck(offset, "$isOffset");
        row = this.getRow$1(offset);
        if (row == null)
          return;
        t1 = row.node.get$renderObject();
        this.onTapIcon$2(row, t1 == null ? null : t1.hitTest$1(offset));
      }, "call$1", "get$onTap", 4, 0, 49, 52],
      onTapIcon$2: [function(row, icon) {
        var t1;
        H.interceptedTypeCheck(row, "$isInspectorTreeRow");
        H.interceptedTypeCheck(icon, "$isIcon");
        t1 = $.$get$expandArrow();
        if (icon == null ? t1 == null : icon === t1) {
          this.setState$1(new K.InspectorTree_onTapIcon_closure(this, row));
          return;
        }
        t1 = $.$get$collapseArrow();
        if (icon == null ? t1 == null : icon === t1) {
          this.setState$1(new K.InspectorTree_onTapIcon_closure0(row));
          return;
        }
        this.set$selection(row.node);
      }, null, "get$onTapIcon", 8, 0, null, 152, 100],
      expandPropertiesByDefault$1: [function(style) {
        switch (H.interceptedTypeCheck(style, "$isDiagnosticsTreeStyle")) {
          case C.DiagnosticsTreeStyle_7:
          case C.DiagnosticsTreeStyle_8:
          case C.DiagnosticsTreeStyle_9:
            return false;
          case C.DiagnosticsTreeStyle_0:
          case C.DiagnosticsTreeStyle_1:
          case C.DiagnosticsTreeStyle_2:
          case C.DiagnosticsTreeStyle_3:
          case C.DiagnosticsTreeStyle_4:
          case C.DiagnosticsTreeStyle_5:
          case C.DiagnosticsTreeStyle_6:
          case C.DiagnosticsTreeStyle_10:
          case C.DiagnosticsTreeStyle_11:
            return true;
        }
        return true;
      }, null, "get$expandPropertiesByDefault", 4, 0, null, 140],
      setupInspectorTreeNode$4$expandChildren$expandProperties: [function(node, diagnosticsNode, expandChildren, expandProperties) {
        var t1, styleIsMultiline, t2;
        H.interceptedTypeCheck(node, "$isInspectorTreeNode");
        H.interceptedTypeCheck(diagnosticsNode, "$isRemoteDiagnosticsNode");
        H.boolTypeCheck(expandChildren);
        H.boolTypeCheck(expandProperties);
        node.set$diagnostic(diagnosticsNode);
        t1 = this._onNodeAdded;
        if (t1 != null)
          t1.call$2(node, diagnosticsNode);
        if (diagnosticsNode.get$hasChildren() || J.get$isNotEmpty$asx(diagnosticsNode.get$inlineProperties()))
          if (diagnosticsNode.get$childrenReady() || !diagnosticsNode.get$hasChildren()) {
            styleIsMultiline = this.expandPropertiesByDefault$1(diagnosticsNode.get$style(diagnosticsNode));
            t1 = node.get$diagnostic().get$childrenNow();
            t2 = expandChildren && styleIsMultiline;
            this.setupChildren$5$expandChildren$expandProperties(diagnosticsNode, node, t1, t2, expandProperties && styleIsMultiline);
          } else {
            node.clearChildren$0();
            node.appendChild$1(this.createNode$0());
          }
        return node;
      }, null, "get$setupInspectorTreeNode", 8, 5, null, 0, 0, 23, 442, 451, 344],
      setupChildren$5$expandChildren$expandProperties: [function($parent, treeNode, children, expandChildren, expandProperties) {
        var inlineProperties, t1, t2;
        H.interceptedTypeCheck($parent, "$isRemoteDiagnosticsNode");
        H.interceptedTypeCheck(treeNode, "$isInspectorTreeNode");
        H.assertSubtype(children, "$isList", [M.RemoteDiagnosticsNode], "$asList");
        H.boolTypeCheck(expandChildren);
        H.boolTypeCheck(expandProperties);
        treeNode.set$expanded(expandChildren);
        if (J.get$isNotEmpty$asx(treeNode.get$children(treeNode)))
          this.removeNodeFromParent$1(J.get$first$ax(treeNode.get$children(treeNode)));
        inlineProperties = $parent.get$inlineProperties();
        if (inlineProperties != null)
          for (t1 = J.get$iterator$ax(inlineProperties); t1.moveNext$0();) {
            t2 = t1.get$current();
            this.appendChild$2(treeNode, this.setupInspectorTreeNode$4$expandChildren$expandProperties(this.createNode$0(), t2, expandProperties, expandProperties));
          }
        if (children != null)
          for (t1 = J.get$iterator$ax(children); t1.moveNext$0();) {
            t2 = t1.get$current();
            this.appendChild$2(treeNode, this.setupInspectorTreeNode$4$expandChildren$expandProperties(this.createNode$0(), t2, expandChildren, expandProperties));
          }
      }, null, "get$setupChildren", 12, 5, null, 0, 0, 24, 301, 699, 451, 344],
      maybePopulateChildren$1: [function(treeNode) {
        H.interceptedTypeCheck(treeNode, "$isInspectorTreeNode");
        return this.maybePopulateChildren$body$InspectorTree(treeNode);
      }, null, "get$maybePopulateChildren", 4, 0, null, 301],
      maybePopulateChildren$body$InspectorTree: [function(treeNode) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, diagnostic, children, e, t1, exception, $async$exception;
        var $async$maybePopulateChildren$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                diagnostic = treeNode.get$diagnostic();
                if (diagnostic != null)
                  if (diagnostic.get$hasChildren())
                    t1 = treeNode.get$hasPlaceholderChildren() || J.get$isEmpty$asx(J.get$children$x(treeNode));
                  else
                    t1 = false;
                else
                  t1 = false;
                $async$goto = t1 ? 2 : 3;
                break;
              case 2:
                // then
                $async$handler = 5;
                $async$goto = 8;
                return P._asyncAwait(J.get$children$x(diagnostic), $async$maybePopulateChildren$1);
              case 8:
                // returning from await.
                children = $async$result;
                if (treeNode.get$hasPlaceholderChildren() || J.get$isEmpty$asx(J.get$children$x(treeNode))) {
                  $async$self.setupChildren$5$expandChildren$expandProperties(diagnostic, treeNode, children, true, false);
                  $async$self.nodeChanged$1(treeNode);
                  if (J.$eq$(treeNode, $async$self.get$selection()))
                    $async$self.expandPath$1(treeNode);
                }
                $async$handler = 1;
                // goto after finally
                $async$goto = 7;
                break;
              case 5:
                // catch
                $async$handler = 4;
                $async$exception = $async$currentError;
                e = H.unwrapException($async$exception);
                P.print(e);
                // goto after finally
                $async$goto = 7;
                break;
              case 4:
                // uncaught
                // goto rethrow
                $async$goto = 1;
                break;
              case 7:
                // after finally
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
              case 1:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$maybePopulateChildren$1, $async$completer);
      }, null, null, 4, 0, null, 301],
      onExpand$1: function(arg0) {
        return this.onExpand.call$1(arg0);
      },
      _onSelectionChange$0: function() {
        return this._onSelectionChange.call$0();
      }
    },
    InspectorTree_root_closure: {
      "^": "Closure:1;$this,node,$ti",
      call$0: [function() {
        this.$this.set$_root(this.node);
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_selection_closure: {
      "^": "Closure:1;$this,node,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = this.node;
        t1.set$_selection(t2);
        t1.expandPath$1(t2);
        if (t1.get$_onSelectionChange() != null)
          t1._onSelectionChange$0();
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_hover_closure: {
      "^": "Closure:1;$this,node,$ti",
      call$0: [function() {
        this.$this.set$_hover(this.node);
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_nodeChanged_closure: {
      "^": "Closure:1;node,$ti",
      call$0: [function() {
        this.node.dirty$0();
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_removeNodeFromParent_closure: {
      "^": "Closure:1;node,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.node;
        t2 = J.get$parent$x(t1);
        if (!(t2 == null))
          t2.removeChild$1(t1);
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_appendChild_closure: {
      "^": "Closure:1;node,child,$ti",
      call$0: [function() {
        this.node.appendChild$1(this.child);
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_expandPath_closure: {
      "^": "Closure:1;_box_0,$ti",
      call$0: [function() {
        var t1, t2;
        for (t1 = this._box_0; t2 = t1.node, t2 != null;) {
          if (!t2.get$expanded())
            t1.node.set$expanded(true);
          t1.node = J.get$parent$x(t1.node);
        }
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_onTapIcon_closure: {
      "^": "Closure:1;$this,row,$ti",
      call$0: [function() {
        var t1 = this.row;
        t1.get$node().set$expanded(true);
        this.$this.onExpand$1(t1.get$node());
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTree_onTapIcon_closure0: {
      "^": "Closure:1;row,$ti",
      call$0: [function() {
        this.row.get$node().set$expanded(false);
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTreeFixedRowHeight: {
      "^": "InspectorTree;$ti",
      animateToTargets$1: [function(targets) {
        var t1, targetRect, row, rowRect;
        for (t1 = J.get$iterator$ax(H.assertSubtype(targets, "$isList", [K.InspectorTreeNode], "$asList")), targetRect = null; t1.moveNext$0();) {
          row = this.getRowForNode$1(t1.get$current());
          if (row != null) {
            rowRect = this.getBoundingBox$1(row);
            targetRect = targetRect == null ? rowRect : targetRect.expandToInclude$1(rowRect);
          }
        }
        if (targetRect == null || targetRect.get$isEmpty(targetRect))
          return;
        this.scrollToRect$1(targetRect.inflate$1(20));
      }, null, "get$animateToTargets", 4, 0, null, 452]
    }
  }], ["", "package:devtools/src/inspector/inspector_tree_canvas.dart",, E, {
    "^": "",
    CanvasPaintEntry: {
      "^": "PaintEntry;x>,$ti"
    },
    IconPaintEntry0: {
      "^": "CanvasPaintEntry;iconRenderer,x,$ti",
      get$icon: [function() {
        return this.iconRenderer.get$icon();
      }, null, null, 2, 0, null],
      paint$1: [function(canvas) {
        var t1, image, t2;
        H.interceptedTypeCheck(canvas, "$isCanvasRenderingContext2D");
        t1 = this.iconRenderer;
        image = t1.get$image();
        if (image != null) {
          t2 = t1.get$iconHeight();
          if (typeof t2 !== "number")
            return H.iae(t2);
          (canvas && C.CanvasRenderingContext2D_methods).drawImageScaled$5(canvas, image, this.x, (24 - t2) / 2, t1.get$iconWidth(), t1.get$iconHeight());
        }
      }, null, "get$paint", 4, 0, null, 221],
      get$right: [function(_) {
        return J.$add$ansx(this.x, this.get$icon().get$iconWidth());
      }, null, null, 3, 0, null],
      attach$1: [function(owner) {
        var t1;
        H.interceptedTypeCheck(owner, "$isInspectorTree");
        t1 = this.iconRenderer;
        if (t1.get$image() == null)
          t1.loadImage$0().then$1$1(new E.IconPaintEntry_attach_closure(owner), null);
      }, null, "get$attach", 4, 0, null, 257],
      static: {
        IconPaintEntry$0: [function(iconRenderer, x) {
          return new E.IconPaintEntry0(iconRenderer, x, []);
        }, null, null, 0, 5, null, 0, 0, 453, 37]
      }
    },
    IconPaintEntry_attach_closure: {
      "^": "Closure:39;owner,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isCanvasImageSource");
        this.owner.setState$1(new E.IconPaintEntry_attach__closure());
      }, null, null, 4, 0, null, 12, "call"]
    },
    IconPaintEntry_attach__closure: {
      "^": "Closure:1;$ti",
      call$0: [function() {
      }, null, null, 0, 0, null, "call"]
    },
    TextPaintEntry: {
      "^": "CanvasPaintEntry;width>,text>,color>,font,x,$ti",
      get$icon: [function() {
        return;
      }, null, null, 2, 0, null],
      paint$1: [function(canvas) {
        var t1;
        H.interceptedTypeCheck(canvas, "$isCanvasRenderingContext2D");
        t1 = this.color;
        if (t1 != null)
          canvas.fillStyle = t1;
        t1 = this.font;
        if (t1 != null)
          canvas.font = H.stringTypeCheck(t1);
        (canvas && C.CanvasRenderingContext2D_methods).fillText$3(canvas, this.text, this.x, 17);
      }, null, "get$paint", 4, 0, null, 221],
      get$right: [function(_) {
        return J.$add$ansx(this.x, this.width);
      }, null, null, 3, 0, null],
      static: {
        TextPaintEntry$: [function(color, font, text, width, x) {
          return new E.TextPaintEntry(width, text, color, font, x, []);
        }, null, null, 0, 11, null, 0, 0, 0, 0, 0, 75, 454, 17, 56, 37]
      }
    },
    InspectorTreeNodeRenderCanvasBuilder: {
      "^": "InspectorTreeNodeRenderBuilder;x>,0lastStyle,0font,0color>,_inspector_tree_canvas$_entries,level,treeStyle,$ti",
      set$font: function(_, font) {
        this.font = H.stringTypeCheck(font);
      },
      appendText$2: [function(_, text, textStyle) {
        var t1, t2, width;
        H.stringTypeCheck(text);
        H.interceptedTypeCheck(textStyle, "$isTextStyle");
        if (text == null || C.JSString_methods.get$isEmpty(text))
          return;
        if (!J.$eq$(textStyle, this.lastStyle)) {
          t1 = textStyle.color;
          t2 = this.lastStyle;
          if (!J.$eq$(t1, t2 == null ? null : J.get$color$x(t2)))
            this.color = H.stringTypeCheck(Y.colorToCss(t1));
          t1 = H.stringTypeCheck(Y.fontStyleToCss(textStyle));
          this.font = t1;
          this.lastStyle = textStyle;
          J.set$font$x($.$get$InspectorTreeNodeRenderCanvasBuilder__measurementCanvas(), t1);
        }
        width = H.doubleTypeCheck(J.get$width$x(J.measureText$1$x($.$get$InspectorTreeNodeRenderCanvasBuilder__measurementCanvas(), text)));
        t1 = this.x;
        J.add$1$ax(this._inspector_tree_canvas$_entries, E.TextPaintEntry$(this.color, this.font, text, width, t1));
        this.x = H.doubleTypeCheck(J.$add$ansx(this.x, width));
      }, null, "get$appendText", 9, 0, null, 17, 248],
      addIcon$1: [function(icon) {
        var width, t1;
        H.interceptedTypeCheck(icon, "$isIcon");
        width = J.$add$ansx(icon.get$iconWidth(), 3);
        t1 = this.x;
        J.add$1$ax(this._inspector_tree_canvas$_entries, E.IconPaintEntry$0(Y.getIconRenderer(icon), t1));
        this.x = H.doubleTypeCheck(J.$add$ansx(this.x, width));
      }, null, "get$addIcon", 4, 0, null, 100],
      build$0: [function() {
        return E.InspectorTreeNodeCanvasRender$(this._inspector_tree_canvas$_entries, S.Size$(this.x, 24));
      }, null, "get$build", 0, 0, null],
      $asInspectorTreeNodeRenderBuilder: function() {
        return [E.InspectorTreeNodeCanvasRender];
      },
      static: {
        InspectorTreeNodeRenderCanvasBuilder$: [function(level, treeStyle) {
          return new E.InspectorTreeNodeRenderCanvasBuilder(0, H.setRuntimeTypeInfo([], [E.CanvasPaintEntry]), level, treeStyle, []);
        }, null, null, 0, 5, null, 0, 0, 218, 455]
      }
    },
    InspectorTreeNodeCanvasRender: {
      "^": "InspectorTreeNodeRender;entries,size,0_offset,0_owner,$ti",
      paint$2: [function(context, visible) {
        var t1, t2;
        H.interceptedTypeCheck(context, "$isCanvasRenderingContext2D");
        H.interceptedTypeCheck(visible, "$isRect");
        for (t1 = J.get$iterator$ax(this.entries); t1.moveNext$0();) {
          t2 = t1.get$current();
          if (J.$gt$n(J.$add$ansx(t2.x, J.get$dx$z(this.get$offset(this))), visible.get$right(visible)))
            return;
          if (J.$ge$n(J.$add$ansx(t2.get$right(t2), J.get$dx$z(this.get$offset(this))), visible.get$left(visible)))
            t2.paint$1(context);
        }
      }, null, "get$paint", 8, 0, null, 202, 287],
      hitTest$1: [function($location) {
        var t1, t2;
        $location = H.interceptedTypeCheck($location, "$isOffset").$sub(0, this.get$offset(this));
        if (J.$lt$n($location.get$dy($location), 0) || J.$ge$n($location.get$dy($location), J.get$height$x(this.size)))
          return;
        for (t1 = J.get$iterator$ax(this.entries); t1.moveNext$0();) {
          t2 = t1.get$current();
          if (J.$le$n(t2.x, $location.get$dx($location)) && J.$gt$n(t2.get$right(t2), $location.get$dx($location)))
            return t2.get$icon();
        }
        return;
      }, null, "get$hitTest", 4, 0, null, 181],
      $asInspectorTreeNodeRender: function() {
        return [E.CanvasPaintEntry];
      },
      static: {
        InspectorTreeNodeCanvasRender$: [function(entries, size) {
          return new E.InspectorTreeNodeCanvasRender(entries, size, []);
        }, null, null, 8, 0, null, 206, 239]
      }
    },
    InspectorTreeNodeCanvas: {
      "^": "InspectorTreeNode;0_renderObject,0_diagnostic,_inspector_tree$_children,_expanded,allowExpandCollapse,_inspector_tree$_parent,0_childrenCount,$ti",
      createRenderBuilder$0: [function() {
        return E.InspectorTreeNodeRenderCanvasBuilder$(this.get$diagnostic().get$level(), J.get$style$x(this.get$diagnostic()));
      }, null, "get$createRenderBuilder", 0, 0, null],
      static: {
        InspectorTreeNodeCanvas$: [function() {
          return new E.InspectorTreeNodeCanvas(H.setRuntimeTypeInfo([], [K.InspectorTreeNode]), true, true, null, []);
        }, null, null, 0, 0, null]
      }
    },
    InspectorTreeCanvas: {
      "^": "InspectorTreeFixedRowHeight;_inspector_tree_canvas$_recomputeRows,0_viewportCanvas,onHover,onExpand,_onSelectionChange,_onNodeAdded,0_root,0subtreeRoot,0_selection,0_hover,summaryTree,treeType,$ti",
      InspectorTreeCanvas$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType: [function(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType) {
        this._viewportCanvas = T.ViewportCanvas$(true, "inspector-tree inspector-tree-container", this.get$onMouseLeave(this), this.get$onMouseMove(this), this.get$onTap(), this.get$_paintCallback());
      }, null, null, 0, 13, null, 0, 0, 0, 0, 0, 0, 220, 197, 200, 207, 156, 106],
      _paintCallback$2: [function(canvas, rect) {
        var startRow, endRow, i;
        H.interceptedTypeCheck(canvas, "$isCanvasRenderingContext2D");
        H.interceptedTypeCheck(rect, "$isRect");
        startRow = this.getRowIndex$1(rect.get$top(rect));
        endRow = P.min(J.$add$ansx(this.getRowIndex$1(rect.get$bottom(rect)), 1), this.get$numRows(), P.int);
        i = startRow;
        while (true) {
          if (typeof i !== "number")
            return i.$lt();
          if (typeof endRow !== "number")
            return H.iae(endRow);
          if (!(i < endRow))
            break;
          this.paintRow$3(canvas, i, rect);
          ++i;
        }
      }, "call$2", "get$_paintCallback", 8, 0, 116, 221, 707],
      setState$1: [function(modifyState) {
        H.functionTypeCheck(modifyState, {func: 1, ret: -1}).call$0();
        if (!this._inspector_tree_canvas$_recomputeRows) {
          this._inspector_tree_canvas$_recomputeRows = true;
          J.requestAnimationFrame$1$x(W.window(), new E.InspectorTreeCanvas_setState_closure(this));
        }
      }, null, "get$setState", 4, 0, null, 457],
      _inspector_tree_canvas$_rebuildData$0: [function() {
        var t1, t2;
        if (this._inspector_tree_canvas$_recomputeRows) {
          this._inspector_tree_canvas$_recomputeRows = false;
          t1 = this.get$root(this);
          t2 = this._viewportCanvas;
          if (t1 != null) {
            t1 = this.get$numRows();
            if (typeof t1 !== "number")
              return H.iae(t1);
            t2.setContentSize$2(2020, C.JSNumber_methods.toDouble$0(24 * t1 + 20));
          } else
            t2.setContentSize$2(0, 0);
        }
        this._viewportCanvas.rebuild$1$force(true);
      }, null, "get$_inspector_tree_canvas$_rebuildData", 0, 0, null],
      onMouseMove$1: [function(_, offset) {
        var t1, t2;
        H.interceptedTypeCheck(offset, "$isOffset");
        t1 = this.onHover;
        if (t1 != null) {
          t2 = this.getRow$1(offset);
          t1.call$1(t2 == null ? null : t2.get$node());
        }
      }, "call$1", "get$onMouseMove", 5, 0, 49, 52],
      onMouseLeave$0: [function(_) {
        var t1 = this.onHover;
        if (t1 != null)
          t1.call$1(null);
      }, "call$0", "get$onMouseLeave", 1, 0, 0],
      get$element: [function() {
        return this._viewportCanvas.get$element();
      }, null, null, 2, 0, null],
      createNode$0: [function() {
        return E.InspectorTreeNodeCanvas$();
      }, null, "get$createNode", 0, 0, null],
      paintRow$3: [function(canvas, index, visible) {
        var _box_0, y, isVisible, t1, row, node, showExpandCollapse, renderObject, _endPath, _maybeStart, t2, t3, t4, highlight, width, paintBounds, backgroundColor, x, fillStyle;
        _box_0 = {};
        H.interceptedTypeCheck(canvas, "$isCanvasRenderingContext2D");
        H.intTypeCheck(index);
        H.interceptedTypeCheck(visible, "$isRect");
        canvas.save();
        y = this.getRowY$1(index);
        C.CanvasRenderingContext2D_methods.translate$2(canvas, 0, y);
        _box_0.currentX = 0;
        _box_0.currentColor = null;
        isVisible = new E.InspectorTreeCanvas_paintRow_isVisible(_box_0, visible);
        t1 = this.get$root(this);
        row = t1 == null ? null : t1.getRow$2$selection(index, this.get$selection());
        if (row == null)
          return;
        node = row.node;
        showExpandCollapse = node.get$showExpandCollapse();
        renderObject = H.interceptedTypeCheck(node.get$renderObject(), "$isInspectorTreeNodeCanvasRender");
        _box_0.hasPath = false;
        _endPath = new E.InspectorTreeCanvas_paintRow__endPath(_box_0, canvas);
        _maybeStart = new E.InspectorTreeCanvas_paintRow__maybeStart(_box_0, _endPath, canvas);
        for (t1 = J.get$iterator$ax(row.ticks), t2 = row.highlightDepth, t3 = J.getInterceptor$(t2); t1.moveNext$0();) {
          t4 = t1.get$current();
          _box_0.currentX = J.$sub$n(this.getDepthIndent$1(t4), 8);
          if (isVisible.call$1(1)) {
            _maybeStart.call$1(t3.$eq(t2, t4) ? C.Color_4278190080 : C.MaterialColor_Map_HFpTk_4288585374);
            C.CanvasRenderingContext2D_methods.moveTo$2(canvas, _box_0.currentX, 0);
            C.CanvasRenderingContext2D_methods.lineTo$2(canvas, _box_0.currentX, 24);
          }
        }
        if (row.lineToParent) {
          t1 = row.depth;
          t4 = J.getInterceptor$n(t1);
          highlight = t3.$eq(t2, t4.$sub(t1, 1));
          _box_0.currentX = J.$sub$n(this.getDepthIndent$1(t4.$sub(t1, 1)), 8);
          width = showExpandCollapse ? 8 : 16;
          if (isVisible.call$1(width)) {
            _maybeStart.call$1(highlight ? C.Color_4278190080 : C.MaterialColor_Map_HFpTk_4288585374);
            C.CanvasRenderingContext2D_methods.moveTo$2(canvas, _box_0.currentX, 0);
            C.CanvasRenderingContext2D_methods.lineTo$2(canvas, _box_0.currentX, 12);
            C.CanvasRenderingContext2D_methods.lineTo$2(canvas, J.$add$ansx(_box_0.currentX, width), 12);
          }
        }
        _endPath.call$0();
        t1 = row.depth;
        _box_0.currentX = J.$sub$n(this.getDepthIndent$1(t1), 16);
        if (!node.get$showExpandCollapse())
          _box_0.currentX = J.$add$ansx(_box_0.currentX, 16);
        if (renderObject == null) {
          canvas.restore();
          return;
        }
        renderObject.attach$2(this, S.Offset$(_box_0.currentX, y));
        paintBounds = renderObject.get$paintBounds();
        if (!paintBounds.overlaps$1(visible)) {
          canvas.restore();
          return;
        }
        t2 = row.isSelected;
        if (t2 || node === this.get$hover()) {
          backgroundColor = t2 ? C.Color_4291477317 : C.MaterialAccentColor_Map_iTwHq_4294967040;
          x = J.$sub$n(this.getDepthIndent$1(t1), 2.4);
          t1 = visible.get$right(visible);
          if (typeof x !== "number")
            return x.$le();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (x <= t1) {
            fillStyle = canvas.fillStyle;
            canvas.fillStyle = Y.colorToCss(backgroundColor);
            C.CanvasRenderingContext2D_methods.fillRect$4(canvas, x, 0, J.$sub$n(P.min(visible.get$right(visible), paintBounds.get$right(paintBounds), P.double), x), 24);
            canvas.fillStyle = fillStyle;
          }
        }
        C.CanvasRenderingContext2D_methods.translate$2(canvas, _box_0.currentX, 0);
        renderObject.paint$2(canvas, visible);
        canvas.restore();
      }, null, "get$paintRow", 12, 0, null, 221, 6, 287],
      getBoundingBox$1: [function(row) {
        H.interceptedTypeCheck(row, "$isInspectorTreeRow");
        return S.Rect$fromLTWH(this.getDepthIndent$1(row.depth), this.getRowY$1(row.index), J.$mul$ns(J.get$width$x(this._viewportCanvas.get$viewport()), 0.7), 24);
      }, null, "get$getBoundingBox", 4, 0, null, 152],
      scrollToRect$1: [function(targetRect) {
        H.interceptedTypeCheck(targetRect, "$isRect");
        this._viewportCanvas.scrollToRect$1(targetRect);
      }, null, "get$scrollToRect", 4, 0, null, 709],
      $isInspectorTreeWeb: 1,
      $isCoreElementView: 1,
      static: {
        InspectorTreeCanvas$: [function(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType) {
          var t1 = new E.InspectorTreeCanvas(false, onHover, onExpand, onSelectionChange, onNodeAdded, summaryTree, treeType, []);
          t1.InspectorTreeCanvas$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType);
          return t1;
        }, null, null, 0, 13, null, 0, 0, 0, 0, 0, 0, 220, 197, 200, 207, 156, 106]
      }
    },
    InspectorTreeCanvas_setState_closure: {
      "^": "Closure:51;$this,$ti",
      call$1: [function(_) {
        H.numTypeCheck(_);
        return this.$this._inspector_tree_canvas$_rebuildData$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    InspectorTreeCanvas_paintRow_isVisible: {
      "^": "Closure:118;_box_0,visible,$ti",
      call$1: [function(width) {
        var t1, t2, t3;
        H.doubleTypeCheck(width);
        t1 = this._box_0;
        t2 = this.visible;
        t3 = J.getInterceptor$x(t2);
        return J.$le$n(t1.currentX, t3.get$right(t2)) && J.$le$n(t3.get$left(t2), J.$add$ansx(t1.currentX, width));
      }, null, null, 4, 0, null, 56, "call"]
    },
    InspectorTreeCanvas_paintRow__endPath: {
      "^": "Closure:0;_box_0,canvas,$ti",
      call$0: [function() {
        var t1 = this._box_0;
        if (!t1.hasPath)
          return;
        J.stroke$0$x(this.canvas);
        t1.hasPath = false;
      }, null, null, 0, 0, null, "call"]
    },
    InspectorTreeCanvas_paintRow__maybeStart: {
      "^": "Closure:119;_box_0,_endPath,canvas,$ti",
      call$1: [function(color) {
        var t1, t2, t3;
        H.interceptedTypeCheck(color, "$isColor");
        t1 = this._box_0;
        if (!J.$eq$(color, t1.currentColor))
          this._endPath.call$0();
        if (t1.hasPath)
          return;
        t1.hasPath = true;
        t2 = this.canvas;
        t3 = J.getInterceptor$x(t2);
        t3.beginPath$0(t2);
        if (!J.$eq$(t1.currentColor, color)) {
          t1.currentColor = color;
          t3.set$strokeStyle(t2, Y.colorToCss(color));
        }
        t3.set$lineWidth(t2, 1);
      }, function() {
        return this.call$1(C.MaterialColor_Map_HFpTk_4288585374);
      }, "call$0", null, null, null, 0, 2, null, 710, 75, "call"]
    }
  }], ["inspector_tree_html", "package:devtools/src/inspector/inspector_tree_html.dart",, K, {
    "^": "",
    HtmlPaintEntry: {
      "^": "PaintEntry;0element<,$ti"
    },
    IconPaintEntry: {
      "^": "HtmlPaintEntry;iconRenderer,0element,$ti",
      get$icon: [function() {
        return this.iconRenderer.get$icon();
      }, null, null, 2, 0, null],
      paint$1: [function($parent) {
        var t1;
        H.interceptedTypeCheck($parent, "$isElement");
        t1 = H.interceptedTypeCheck(J.createElement$0$x(this.iconRenderer), "$isElement");
        this.element = t1;
        J.append$1$x($parent, t1);
      }, null, "get$paint", 4, 0, null, 24],
      attach$1: [function(owner) {
        H.interceptedTypeCheck(owner, "$isInspectorTree");
      }, null, "get$attach", 4, 0, null, 257],
      static: {
        IconPaintEntry$: [function(iconRenderer) {
          return new K.IconPaintEntry(iconRenderer, []);
        }, null, null, 0, 3, null, 0, 453]
      }
    },
    HtmlTextPaintEntry: {
      "^": "HtmlPaintEntry;text>,color>,font,0element,$ti",
      get$icon: [function() {
        return;
      }, null, null, 2, 0, null],
      paint$1: [function($parent) {
        var t1, t2;
        H.interceptedTypeCheck($parent, "$isElement");
        t1 = W.Element_Element$span();
        J.set$text$x(t1, this.text);
        H.interceptedTypeCheck(t1, "$isElement");
        this.element = t1;
        t2 = this.color;
        if (t2 != null) {
          t1 = t1.style;
          (t1 && C.CssStyleDeclaration_methods).set$color(t1, t2);
        }
        t1 = this.font;
        if (t1 != null)
          J.set$font$x(J.get$style$x(this.element), t1);
        J.append$1$x($parent, this.element);
      }, null, "get$paint", 4, 0, null, 24],
      static: {
        HtmlTextPaintEntry$: [function(color, font, text) {
          return new K.HtmlTextPaintEntry(text, color, font, []);
        }, null, null, 0, 7, null, 0, 0, 0, 75, 454, 17]
      }
    },
    InspectorTreeNodeRenderHtmlBuilder: {
      "^": "InspectorTreeNodeRenderBuilder;0lastStyle,0font,0color>,allowWrap<,_entries,level,treeStyle,$ti",
      set$font: function(_, font) {
        this.font = H.stringTypeCheck(font);
      },
      appendText$2: [function(_, text, textStyle) {
        var t1, t2;
        H.stringTypeCheck(text);
        H.interceptedTypeCheck(textStyle, "$isTextStyle");
        if (text == null || C.JSString_methods.get$isEmpty(text))
          return;
        if (!J.$eq$(textStyle, this.lastStyle)) {
          t1 = textStyle.color;
          t2 = this.lastStyle;
          if (!J.$eq$(t1, t2 == null ? null : J.get$color$x(t2)))
            this.color = H.stringTypeCheck(Y.colorToCss(t1));
          this.font = H.stringTypeCheck(Y.fontStyleToCss(textStyle));
          this.lastStyle = textStyle;
        }
        J.add$1$ax(this._entries, K.HtmlTextPaintEntry$(this.color, this.font, text));
      }, null, "get$appendText", 9, 0, null, 17, 248],
      addIcon$1: [function(icon) {
        J.add$1$ax(this._entries, K.IconPaintEntry$(Y.getIconRenderer(H.interceptedTypeCheck(icon, "$isIcon"))));
      }, null, "get$addIcon", 4, 0, null, 100],
      build$0: [function() {
        var classes = H.setRuntimeTypeInfo(["inspector-level-" + H.S(J.$index$asx($.$get$diagnosticLevelToName(), this.level)), "inspector-style-" + H.S(J.$index$asx($.$get$treeStyleToName(), this.treeStyle))], [P.String]);
        if (!this.allowWrap)
          C.JSArray_methods.add$1(classes, "inspector-no-wrap");
        return K.InspectorTreeNodeHtmlRender$(this._entries, C.Size_0_0, classes);
      }, null, "get$build", 0, 0, null],
      $asInspectorTreeNodeRenderBuilder: function() {
        return [K.InspectorTreeNodeHtmlRender];
      },
      static: {
        InspectorTreeNodeRenderHtmlBuilder$: [function(allowWrap, level, treeStyle) {
          return new K.InspectorTreeNodeRenderHtmlBuilder(allowWrap, H.setRuntimeTypeInfo([], [K.HtmlPaintEntry]), level, treeStyle, []);
        }, null, null, 0, 7, null, 0, 0, 0, 458, 218, 455]
      }
    },
    InspectorTreeNodeHtmlRender: {
      "^": "InspectorTreeNodeRender;cssClasses,0element<,entries,size,0_offset,0_owner,$ti",
      paint$1: [function(container) {
        var t1;
        H.interceptedTypeCheck(container, "$isElement");
        J.addAll$1$ax(J.get$classes$x(container), this.cssClasses);
        this.element = container;
        for (t1 = J.get$iterator$ax(this.entries); t1.moveNext$0();)
          t1.get$current().paint$1(container);
      }, null, "get$paint", 4, 0, null, 713],
      hitTest$1: [function($location) {
        H.interceptedTypeCheck($location, "$isOffset");
        throw H.wrapException("Not yet supported by HTML tree");
      }, null, "get$hitTest", 4, 0, null, 181],
      $asInspectorTreeNodeRender: function() {
        return [K.HtmlPaintEntry];
      },
      static: {
        InspectorTreeNodeHtmlRender$: [function(entries, size, cssClasses) {
          return new K.InspectorTreeNodeHtmlRender(cssClasses, entries, size, []);
        }, null, null, 12, 0, null, 206, 239, 712]
      }
    },
    InspectorTreeNodeHtml: {
      "^": "InspectorTreeNode;0_renderObject,0_diagnostic,_inspector_tree$_children,_expanded,allowExpandCollapse,_inspector_tree$_parent,0_childrenCount,$ti",
      createRenderBuilder$0: [function() {
        var t1, t2;
        t1 = this.get$diagnostic().get$level();
        t2 = J.get$style$x(this.get$diagnostic());
        return K.InspectorTreeNodeRenderHtmlBuilder$(this.get$diagnostic().get$allowWrap(), t1, t2);
      }, null, "get$createRenderBuilder", 0, 0, null],
      static: {
        InspectorTreeNodeHtml$: [function() {
          return new K.InspectorTreeNodeHtml(H.setRuntimeTypeInfo([], [K.InspectorTreeNode]), true, true, null, []);
        }, null, null, 0, 0, null]
      }
    },
    InspectorTreeHtml: {
      "^": "InspectorTree;_container,_recomputeRows,onHover,onExpand,_onSelectionChange,_onNodeAdded,0_root,0subtreeRoot,0_selection,0_hover,summaryTree,treeType,$ti",
      InspectorTreeHtml$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType: [function(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType) {
        var t1 = this._container;
        J.get$onClick$x(t1).listen$1(this.get$onMouseClick());
        J.get$onMouseMove$x(t1.get$element()).listen$1(this.get$onMouseMove(this));
        J.get$onMouseLeave$x(t1.get$element()).listen$1(this.get$onMouseLeave(this));
      }, null, null, 0, 13, null, 0, 0, 0, 0, 0, 0, 220, 197, 200, 207, 156, 106],
      _resolveTreeRow$1: [function(e) {
        var t1, index;
        H.interceptedTypeCheck(e, "$isElement");
        while (true) {
          t1 = e == null;
          if (!(!t1 && !J.contains$1$asx(J.get$classes$x(e), "inspector-tree-row")))
            break;
          e = e.parentElement;
        }
        if (t1)
          return;
        index = J.indexOf$1$asx(J.get$children$x(e.parentElement), e);
        return this.get$root(this).getRow$2$selection(index, this.get$selection());
      }, null, "get$_resolveTreeRow", 4, 0, null, 19],
      _resolveIcon$2: [function(row, e) {
        var t1, render, t2;
        H.interceptedTypeCheck(row, "$isInspectorTreeRow");
        H.interceptedTypeCheck(e, "$isElement");
        t1 = row == null ? null : row.node;
        render = H.interceptedTypeCheck(t1 == null ? null : t1.get$renderObject(), "$isInspectorTreeNodeHtmlRender");
        if (render == null)
          return;
        while (true) {
          t1 = e == null;
          if (!(!t1 && !J.contains$1$asx(J.get$classes$x(e), "flutter-icon")))
            break;
          t1 = render.element;
          if (e == null ? t1 == null : e === t1)
            return;
          e = e.parentElement;
        }
        if (t1)
          return;
        for (t1 = J.get$iterator$ax(render.entries); t1.moveNext$0();) {
          t2 = t1.get$current();
          if (J.$eq$(t2.element, e))
            return t2.get$icon();
        }
        return;
      }, null, "get$_resolveIcon", 8, 0, null, 152, 19],
      setState$1: [function(modifyState) {
        H.functionTypeCheck(modifyState, {func: 1, ret: -1}).call$0();
        if (!this._recomputeRows) {
          this._recomputeRows = true;
          J.requestAnimationFrame$1$x(W.window(), new K.InspectorTreeHtml_setState_closure(this));
        }
      }, null, "get$setState", 4, 0, null, 457],
      _rebuildData$0: [function() {
        var rowCount, t1, i;
        if (this._recomputeRows) {
          this._recomputeRows = false;
          if (this.get$root(this) == null) {
            J.clear$0$ax(this._container);
            return;
          }
          rowCount = this.get$numRows();
          t1 = this._container;
          J.clear$0$ax(t1);
          if (typeof rowCount !== "number")
            return H.iae(rowCount);
          i = 0;
          for (; i < rowCount; ++i)
            J.append$1$x(t1.get$element(), this.paintRow$2$selection(i, this.get$selection()));
        }
      }, null, "get$_rebuildData", 0, 0, null],
      onMouseClick$1: [function(mouseEvent) {
        var t1, row;
        H.interceptedTypeCheck(mouseEvent, "$isMouseEvent");
        t1 = J.getInterceptor$x(mouseEvent);
        row = this._resolveTreeRow$1(H.interceptedTypeCheck(t1.get$target(mouseEvent), "$isElement"));
        if (row == null)
          return;
        this.onTapIcon$2(row, this._resolveIcon$2(row, H.interceptedTypeCheck(t1.get$target(mouseEvent), "$isElement")));
      }, "call$1", "get$onMouseClick", 4, 0, 35, 305],
      onMouseMove$1: [function(_, mouseEvent) {
        var t1, t2;
        H.interceptedTypeCheck(mouseEvent, "$isMouseEvent");
        t1 = this.onHover;
        if (t1 != null) {
          t2 = this._resolveTreeRow$1(H.interceptedTypeCheck(J.get$target$x(mouseEvent), "$isElement"));
          t1.call$1(t2 == null ? null : t2.get$node());
        }
      }, "call$1", "get$onMouseMove", 5, 0, 35, 305],
      onMouseLeave$1: [function(_, mouseEvent) {
        var t1;
        H.interceptedTypeCheck(mouseEvent, "$isMouseEvent");
        t1 = this.onHover;
        if (t1 != null)
          t1.call$1(null);
      }, "call$1", "get$onMouseLeave", 5, 0, 35, 305],
      get$element: [function() {
        return this._container;
      }, null, null, 2, 0, null],
      createNode$0: [function() {
        return K.InspectorTreeNodeHtml$();
      }, null, "get$createNode", 0, 0, null],
      paintRow$2$selection: [function(index, selection) {
        var container, currentX, row, node, diagnostic, renderObject, rowContentContainer, rowContent, e, s, t1, exception;
        H.intTypeCheck(index);
        H.interceptedTypeCheck(selection, "$isInspectorTreeNode");
        try {
          container = W.Element_Element$div();
          J.add$1$ax(J.get$classes$x(container), "inspector-tree-row");
          currentX = 0;
          t1 = this.get$root(this);
          row = t1 == null ? null : t1.getRow$2$selection(index, selection);
          if (row == null)
            return container;
          node = row.get$node();
          diagnostic = node.get$diagnostic();
          if (diagnostic != null) {
            t1 = J.get$name$x(diagnostic);
            t1 = J.$eq$(t1 == null ? null : J.get$isNotEmpty$asx(t1), true) && diagnostic.get$showName() && diagnostic.get$showSeparator() && diagnostic.get$description() != null;
          } else
            t1 = false;
          if (t1)
            J.add$1$ax(J.get$classes$x(container), "property-value");
          renderObject = H.interceptedTypeCheck(node.get$renderObject(), "$isInspectorTreeNodeHtmlRender");
          if (renderObject == null)
            return container;
          currentX = J.$sub$n(this.getDepthIndent$1(row.get$depth()), 16);
          if (!row.get$node().get$showExpandCollapse())
            currentX = J.$add$ansx(currentX, 16);
          rowContentContainer = W.Element_Element$div();
          J.add$1$ax(J.get$classes$x(rowContentContainer), "inspector-tree-row-content");
          J.set$paddingLeft$x(J.get$style$x(rowContentContainer), H.S(currentX) + "px");
          rowContent = W.Element_Element$div();
          J.append$1$x(rowContentContainer, rowContent);
          renderObject.paint$1(rowContent);
          J.append$1$x(container, rowContentContainer);
          return container;
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P.print(s);
          t1 = W.Element_Element$div();
          J.set$text$x(t1, "Error: " + H.S(e) + ", " + H.S(s));
          return t1;
        }
      }, null, "get$paintRow", 4, 3, null, 0, 6, 134],
      animateToTargets$1: [function(targets) {
        H.assertSubtype(targets, "$isList", [K.InspectorTreeNode], "$asList");
        J.requestAnimationFrame$1$x(W.window(), new K.InspectorTreeHtml_animateToTargets_closure(targets));
      }, null, "get$animateToTargets", 4, 0, null, 452],
      $isInspectorTreeWeb: 1,
      $isCoreElementView: 1,
      static: {
        InspectorTreeHtml$: [function(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType) {
          var t1 = new K.InspectorTreeHtml(A.div(null, "inspector-tree-html", null), false, onHover, onExpand, onSelectionChange, onNodeAdded, summaryTree, treeType, []);
          t1.InspectorTreeHtml$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType);
          return t1;
        }, null, null, 0, 13, null, 0, 0, 0, 0, 0, 0, 220, 197, 200, 207, 156, 106]
      }
    },
    InspectorTreeHtml_setState_closure: {
      "^": "Closure:51;$this,$ti",
      call$1: [function(_) {
        H.numTypeCheck(_);
        return this.$this._rebuildData$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    InspectorTreeHtml_animateToTargets_closure: {
      "^": "Closure:48;targets,$ti",
      call$1: [function(_) {
        var t1, renderObject, t2;
        H.numTypeCheck(_);
        for (t1 = J.get$iterator$ax(J.get$reversed$ax(this.targets)); t1.moveNext$0();) {
          renderObject = H.interceptedTypeCheck(t1.get$current().get$renderObject(), "$isInspectorTreeNodeHtmlRender");
          t2 = renderObject == null ? null : renderObject.element;
          if (!(t2 == null))
            J.scrollIntoView$0$x(t2);
        }
      }, null, null, 4, 0, null, 12, "call"]
    }
  }], ["", "package:devtools/src/inspector/inspector_tree_web.dart",, M, {
    "^": "",
    InspectorTreeWeb: {
      "^": "Object;$ti",
      $isInspectorTree: 1,
      $isCoreElementView: 1
    }
  }], ["", "package:devtools/src/logging/logging.dart",, Y, {
    "^": "",
    _isNotNull: [function(serviceRef) {
      H.interceptedTypeCheck(serviceRef, "$isInstanceRef");
      return serviceRef != null && !J.$eq$(serviceRef.kind, "Null");
    }, null, null, 4, 0, null, 717],
    _valueAsString: [function(ref) {
      var t1, t2;
      H.interceptedTypeCheck(ref, "$isInstanceRef");
      if (ref == null)
        return;
      t1 = ref.valueAsString;
      if (t1 == null)
        return t1;
      t1 = J.$eq$(ref.valueAsStringIsTruncated, true);
      t2 = ref.valueAsString;
      if (t1)
        return H.S(t2) + "...";
      else
        return t2;
    }, null, null, 4, 0, null, 81],
    getCssClassForEventKind: [function(item) {
      var t1, t2, cssClass;
      H.interceptedTypeCheck(item, "$isLogData");
      t1 = item.kind;
      t2 = J.getInterceptor$(t1);
      if (t2.$eq(t1, "stderr") || item.isError)
        cssClass = "stderr";
      else if (t2.$eq(t1, "stdout"))
        cssClass = "stdout";
      else if (t2.$eq(t1, "flutter.error"))
        cssClass = "stderr";
      else if (t2.startsWith$1(t1, "flutter"))
        cssClass = "flutter";
      else
        cssClass = t2.$eq(t1, "gc") ? "gc" : "";
      return cssClass;
    }, null, null, 4, 0, null, 66],
    LoggingScreen: {
      "^": "Screen;0loggingTable,0logDetailsUI<,0logCountStatus,loggingStateMixin,hasPendingDomUpdates,0objectGroup,data>,0_lastScrollTime,name,id,iconClass,0framework,_visible,statusItems,$ti",
      set$loggingTable: function(loggingTable) {
        this.loggingTable = H.assertSubtype(loggingTable, "$isTable", [Y.LogData], "$asTable");
      },
      set$objectGroup: function(objectGroup) {
        this.objectGroup = H.assertSubtype(objectGroup, "$isFuture", [E.ObjectGroup], "$asFuture");
      },
      set$data: function(_, data) {
        this.data = H.assertSubtype(data, "$isList", [Y.LogData], "$asList");
      },
      LoggingScreen$0: [function() {
        var t1 = N.StatusItem$();
        this.logCountStatus = t1;
        J.set$text$x(t1.element, "");
        this.addStatusItem$1(this.logCountStatus);
        E.serviceManager().get$onConnectionAvailable().listen$1(this.get$_logging$_handleConnectionStart());
        if (E.serviceManager().get$hasConnection())
          this._logging$_handleConnectionStart$1(E.serviceManager().get$service());
        E.serviceManager().get$onConnectionClosed().listen$1(this.get$_logging$_handleConnectionStop());
      }, null, null, 0, 0, null],
      createContent$1: [function(framework) {
        var screenDiv, t1, t2, t3, t4, t5, t6;
        H.interceptedTypeCheck(framework, "$isFramework");
        screenDiv = A.div(null, "custom-scrollbar", null);
        screenDiv.layoutVertical$0();
        this.framework = framework;
        t1 = A.div(null, "section", null);
        t2 = A.form();
        t2.clazz$1("align-items-center");
        t3 = N.PButton$("Clear logs");
        t3.small$0();
        t3.click$1(0, this.get$_clear(this));
        t4 = A.span(null, null, null);
        J.flex$0$z(t4);
        t5 = [A.CoreElement];
        J.add$1$ax(t2, H.setRuntimeTypeInfo([t3, t4], t5));
        J.add$1$ax(t1, H.setRuntimeTypeInfo([t2], t5));
        t2 = A.div(null, "section log-area", null);
        t4 = J.getInterceptor$z(t2);
        t4.flex$0(t2);
        t3 = this._createTableView$0();
        t3.layoutHorizontal$0();
        t3.clazz$1("section");
        J.flex$0$z(t3);
        t6 = Y.LogDetailsUI$();
        this.logDetailsUI = t6;
        t4.add$1(t2, H.setRuntimeTypeInfo([t3, t6], t5));
        t2.layoutHorizontal$0();
        J.add$1$ax(screenDiv, H.setRuntimeTypeInfo([t1, t2], t5));
        J.set$width$x(J.get$style$x(this.logDetailsUI.get$element()), "0");
        t5 = this.loggingTable.get$element();
        t2 = this.logDetailsUI;
        t1 = [P.num];
        t6 = H.setRuntimeTypeInfo([60, 40], t1);
        A.flexSplit([t5, t2], 12, true, H.setRuntimeTypeInfo([200, 60], t1), t6);
        J.get$onSelect$z(this.loggingTable).listen$1(new Y.LoggingScreen_createContent_closure(this));
        this._updateStatus$0();
        this.loggingTable.get$onRowsChanged().listen$1(new Y.LoggingScreen_createContent_closure0(this));
        E.messageBus().onEvent$1$type("reload.end").listen$1(new Y.LoggingScreen_createContent_closure1(this));
        E.messageBus().onEvent$1$type("restart.end").listen$1(new Y.LoggingScreen_createContent_closure2(this));
        return screenDiv;
      }, null, "get$createContent", 4, 0, null, 127],
      entering$0: [function() {
        if (this.hasPendingDomUpdates) {
          this.loggingTable.setRows$1(this.data);
          this.hasPendingDomUpdates = false;
        }
      }, null, "get$entering", 0, 0, null],
      _createTableView$0: [function() {
        this.set$loggingTable(Q.Table$virtual(29, Y.LogData));
        this.loggingTable.addColumn$1(Y.LogWhenColumn$());
        this.loggingTable.addColumn$1(Y.LogKindColumn$());
        this.loggingTable.addColumn$1(Y.LogMessageColumn$());
        this.loggingTable.setRows$1(this.data);
        return this.loggingTable.get$element();
      }, null, "get$_createTableView", 0, 0, null],
      _updateStatus$0: [function() {
        var count, label;
        count = this.loggingTable.get$rowCount();
        if (typeof count !== "number")
          return count.$ge();
        label = count >= 5000 ? H.S($.$get$nf().format$1(5000)) + "+" : $.$get$nf().format$1(count);
        J.set$text$x(this.logCountStatus.get$element(), H.S(label) + " events");
      }, null, "get$_updateStatus", 0, 0, null],
      _clear$0: [function(_) {
        var t1;
        J.clear$0$ax(this.data);
        t1 = this.logDetailsUI;
        if (!(t1 == null))
          t1.setData$1(null);
        this.loggingTable.setRows$1(this.data);
      }, "call$0", "get$_clear", 1, 0, 0],
      _logging$_handleConnectionStart$1: [function(service) {
        return this._handleConnectionStart$body$LoggingScreen(H.interceptedTypeCheck(service, "$isVmServiceWrapper"));
      }, "call$1", "get$_logging$_handleConnectionStart", 4, 0, 53, 74],
      _handleConnectionStart$body$LoggingScreen: [function(service) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, stdoutHandler, stderrHandler;
        var $async$_logging$_handleConnectionStart$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                stdoutHandler = Y._StdoutEventHandler$($async$self, "stdout", false);
                service.get$onStdoutEvent().listen$1(stdoutHandler.get$handle());
                stderrHandler = Y._StdoutEventHandler$($async$self, "stderr", true);
                service.get$onStderrEvent().listen$1(stderrHandler.get$handle());
                service.get$onGCEvent().listen$1($async$self.get$_handleGCEvent());
                service.onEvent$1("_Logging").listen$1($async$self.get$_handleDeveloperLogEvent());
                service.get$onExtensionEvent().listen$1($async$self.get$_handleExtensionEvent());
                $async$goto = 2;
                return P._asyncAwait(E.ensureInspectorServiceDependencies(), $async$_logging$_handleConnectionStart$1);
              case 2:
                // returning from await.
                $async$self.set$objectGroup(E.InspectorService_createGroup(service, "console-group"));
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_logging$_handleConnectionStart$1, $async$completer);
      }, null, null, 4, 0, null, 74],
      _handleExtensionEvent$1: [function(e) {
        return this._handleExtensionEvent$body$LoggingScreen(H.interceptedTypeCheck(e, "$isEvent0"));
      }, "call$1", "get$_handleExtensionEvent", 4, 0, 11, 19],
      _handleExtensionEvent$body$LoggingScreen: [function(e) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, frame, frameInfo, div, node, t1, t2;
        var $async$_handleExtensionEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (J.$eq$(e.extensionKind, "Flutter.Frame")) {
                  frame = A.FrameInfo_from(J.get$data$x(e.extensionData));
                  frameInfo = '<span class="pre">' + ("#" + H.S(frame.number)) + " " + H.S(J.padLeft$1$s(J.toStringAsFixed$1$n(frame.elapsedMs, 1), 4)) + "ms </span>";
                  div = $async$self.createFrameDivHtml$1(frame);
                  $async$self._logging$_log$1(Y.LogData$(J.toLowerCase$0$s(e.extensionKind), P.jsonEncode(J.get$data$x(e.extensionData), null), e.timestamp, null, false, null, null, frameInfo + H.S(div)));
                } else if (J.$eq$(e.extensionKind, "Flutter.Error")) {
                  node = M.RemoteDiagnosticsNode$(H.assertSubtype(J.get$data$x(e.extensionData), "$isMap", [P.String, P.Object], "$asMap"), $async$self.objectGroup, false, null);
                  if ($._verboseDebugging)
                    P.print("node toStringDeep:######\n" + H.S(node.toStringDeep$0()) + "\n###");
                  $async$self._logging$_log$1(Y.LogData$(J.toLowerCase$0$s(e.extensionKind), P.jsonEncode(e.json, null), e.timestamp, null, false, node, J.toString$0$(node.toDiagnosticsNode$0()), null));
                } else {
                  t1 = J.toLowerCase$0$s(e.extensionKind);
                  t2 = e.json;
                  $async$self._logging$_log$1(Y.LogData$(t1, P.jsonEncode(t2, null), e.timestamp, null, false, null, J.toString$0$(t2), null));
                }
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_handleExtensionEvent$1, $async$completer);
      }, null, null, 4, 0, null, 19],
      _handleGCEvent$1: [function(e) {
        var t1, t2, t3, t4, newSpace, oldSpace, isolateRef, usedBytes, capacityBytes, time, summary;
        H.interceptedTypeCheck(e, "$isEvent0");
        t1 = e.json;
        t2 = J.getInterceptor$asx(t1);
        t3 = P.String;
        t4 = [t3, null];
        newSpace = S.HeapSpace_parse(H.assertSubtype(t2.$index(t1, "new"), "$isMap", t4, "$asMap"));
        oldSpace = S.HeapSpace_parse(H.assertSubtype(t2.$index(t1, "old"), "$isMap", t4, "$asMap"));
        isolateRef = H.interceptedTypeCheck(t2.$index(t1, "isolate"), "$isMap");
        usedBytes = J.$add$ansx(newSpace.used, oldSpace.used);
        capacityBytes = J.$add$ansx(newSpace.capacity, oldSpace.capacity);
        time = J.round$0$n(J.$mul$ns(J.$add$ansx(newSpace.time, oldSpace.time), 1000));
        summary = H.S(isolateRef.$index(0, "name")) + " \u2022 " + H.S(t2.$index(t1, "reason")) + " collection in " + H.S(time) + " ms \u2022 " + H.S(B.printMb(usedBytes, 1)) + " MB used of " + H.S(B.printMb(capacityBytes, 1)) + " MB";
        this._logging$_log$1(Y.LogData$("gc", P.jsonEncode(P.LinkedHashMap_LinkedHashMap$_literal(["reason", t2.$index(t1, "reason"), "new", newSpace.json, "old", oldSpace.json, "isolate", isolateRef], t3, null), null), e.timestamp, null, false, null, summary, null));
      }, "call$1", "get$_handleGCEvent", 4, 0, 11, 19],
      _handleDeveloperLogEvent$1: [function(e) {
        var service, logRecord, t1, t2, t3, loggerName, level, messageRef, summary, error, stackTrace, detailsComputer, isError;
        H.interceptedTypeCheck(e, "$isEvent0");
        service = E.serviceManager().get$service();
        logRecord = J.$index$asx(e.json, "logRecord");
        t1 = J.getInterceptor$asx(logRecord);
        t2 = P.String;
        t3 = [t2, null];
        loggerName = Y._valueAsString(S.InstanceRef_parse(H.assertSubtype(t1.$index(logRecord, "loggerName"), "$isMap", t3, "$asMap")));
        if (loggerName == null || C.JSString_methods.get$isEmpty(loggerName))
          loggerName = "log";
        level = H.intTypeCheck(t1.$index(logRecord, "level"));
        messageRef = S.InstanceRef_parse(H.assertSubtype(t1.$index(logRecord, "message"), "$isMap", t3, "$asMap"));
        summary = Y._valueAsString(messageRef);
        if (J.$eq$(messageRef.valueAsStringIsTruncated, true))
          summary = J.$add$ansx(summary, "...");
        error = S.InstanceRef_parse(H.assertSubtype(t1.$index(logRecord, "error"), "$isMap", t3, "$asMap"));
        stackTrace = S.InstanceRef_parse(H.assertSubtype(t1.$index(logRecord, "stackTrace"), "$isMap", t3, "$asMap"));
        detailsComputer = J.$eq$(messageRef.valueAsStringIsTruncated, true) || Y._isNotNull(error) || Y._isNotNull(stackTrace) ? P.Future_Future(new Y.LoggingScreen__handleDeveloperLogEvent_closure(this, service, e, messageRef, error, stackTrace), t2) : null;
        isError = level != null && level >= 1000 && true;
        this._logging$_log$1(Y.LogData$(loggerName, summary, e.timestamp, detailsComputer, isError, null, summary, null));
      }, "call$1", "get$_handleDeveloperLogEvent", 4, 0, 11, 19],
      _logging$_retrieveFullStringValue$3: [function(service, isolateRef, stringRef) {
        return this._retrieveFullStringValue$body$LoggingScreen(H.interceptedTypeCheck(service, "$isVmServiceWrapper"), H.interceptedTypeCheck(isolateRef, "$isIsolateRef"), H.interceptedTypeCheck(stringRef, "$isInstanceRef"));
      }, null, "get$_logging$_retrieveFullStringValue", 12, 0, null, 74, 179, 256],
      _retrieveFullStringValue$body$LoggingScreen: [function(service, isolateRef, stringRef) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, result;
        var $async$_logging$_retrieveFullStringValue$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (!J.$eq$(stringRef.valueAsStringIsTruncated, true)) {
                  $async$returnValue = stringRef.valueAsString;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait(service.getObject$4$count$offset(isolateRef.id, stringRef.id, stringRef.length, 0), $async$_logging$_retrieveFullStringValue$3);
              case 3:
                // returning from await.
                result = $async$result;
                if (result instanceof S.Instance) {
                  $async$returnValue = result.valueAsString;
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  $async$returnValue = H.S(stringRef.valueAsString) + "...";
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_logging$_retrieveFullStringValue$3, $async$completer);
      }, null, null, 12, 0, null, 74, 179, 256],
      _logging$_handleConnectionStop$1: [function($event) {
      }, "call$1", "get$_logging$_handleConnectionStop", 4, 0, 6, 22],
      _logging$_log$1: [function(log) {
        var itemsToRemove, now, t1, smoothScroll, t2;
        H.interceptedTypeCheck(log, "$isLogData");
        J.add$1$ax(this.data, log);
        if (J.$gt$n(J.get$length$asx(this.data), 5500)) {
          itemsToRemove = J.$sub$n(J.get$length$asx(this.data), 5000);
          if (typeof itemsToRemove !== "number")
            return itemsToRemove.$mod();
          if (C.JSInt_methods.$mod(itemsToRemove, 2) === 1)
            --itemsToRemove;
          this.set$data(0, J.sublist$1$ax(this.data, itemsToRemove));
        }
        if (this.get$visible() && this.loggingTable != null) {
          this.loggingTable.setRows$1(this.data);
          now = P.DateTime$now();
          t1 = this._lastScrollTime;
          smoothScroll = t1 == null || J.$gt$n(t1.difference$1(now).get$inSeconds(), 1);
          this._lastScrollTime = now;
          t1 = this.loggingTable;
          t2 = J.get$last$ax(this.data);
          J.scrollTo$2$scrollBehavior$x(t1, t2, smoothScroll ? "smooth" : "auto");
        } else
          this.hasPendingDomUpdates = true;
      }, null, "get$_logging$_log", 4, 0, null, 182],
      createFrameDivHtml$1: [function(frame) {
        var t1, t2, classes, pixelWidth;
        t1 = H.interceptedTypeCheck(frame, "$isFrameInfo").elapsedMs;
        t2 = J.getInterceptor$n(t1);
        classes = t2.$ge(t1, 16.666666666666668) ? "frame-bar over-budget" : "frame-bar";
        pixelWidth = J.round$0$n(t2.$mul(t1, 3));
        return '<div class="' + classes + '" style="width: ' + H.S(pixelWidth) + 'px"/>';
      }, null, "get$createFrameDivHtml", 4, 0, null, 73],
      static: {
        LoggingScreen$: [function() {
          var t1 = new Y.LoggingScreen(N.SetStateMixin$(), false, H.setRuntimeTypeInfo([], [Y.LogData]), "Logging", "logs", "octicon-clippy", B.Property$(false, P.bool), H.setRuntimeTypeInfo([], [N.StatusItem]), []);
          t1.LoggingScreen$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    LoggingScreen_createContent_closure: {
      "^": "Closure:122;$this,$ti",
      call$1: [function(selection) {
        H.interceptedTypeCheck(selection, "$isLogData");
        this.$this.get$logDetailsUI().setData$1(selection);
      }, null, null, 4, 0, null, 134, "call"]
    },
    LoggingScreen_createContent_closure0: {
      "^": "Closure:54;$this,$ti",
      call$1: [function(_) {
        this.$this._updateStatus$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    LoggingScreen_createContent_closure1: {
      "^": "Closure:21;$this,$ti",
      call$1: [function($event) {
        this.$this._logging$_log$1(Y.LogData$("hot.reload", H.stringTypeCheck(H.interceptedTypeCheck($event, "$isBusEvent").data), P.DateTime$now().get$millisecondsSinceEpoch(), null, false, null, null, null));
      }, null, null, 4, 0, null, 22, "call"]
    },
    LoggingScreen_createContent_closure2: {
      "^": "Closure:21;$this,$ti",
      call$1: [function($event) {
        this.$this._logging$_log$1(Y.LogData$("hot.restart", H.stringTypeCheck(H.interceptedTypeCheck($event, "$isBusEvent").data), P.DateTime$now().get$millisecondsSinceEpoch(), null, false, null, null, null));
      }, null, null, 4, 0, null, 22, "call"]
    },
    LoggingScreen__handleDeveloperLogEvent_closure: {
      "^": "Closure:124;$this,service,e,messageRef,error,stackTrace,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this, t1, t2, t3, result, t4, toStringResult, t5, $async$temp1, $async$temp2, $async$temp3;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = $async$self.service;
                t3 = $async$self.e;
                $async$goto = 3;
                return P._asyncAwait(t1._logging$_retrieveFullStringValue$3(t2, t3.get$isolate(), $async$self.messageRef), $async$call$0);
              case 3:
                // returning from await.
                result = $async$result;
                t4 = $async$self.error;
                $async$goto = Y._isNotNull(t4) ? 4 : 5;
                break;
              case 4:
                // then
                $async$goto = t4.get$valueAsString() != null ? 6 : 8;
                break;
              case 6:
                // then
                $async$temp1 = J;
                $async$temp2 = result;
                $async$temp3 = H;
                $async$goto = 9;
                return P._asyncAwait(t1._logging$_retrieveFullStringValue$3(t2, t3.get$isolate(), t4), $async$call$0);
              case 9:
                // returning from await.
                result = $async$temp1.$add$ansx($async$temp2, "\n\n" + $async$temp3.S($async$result));
                // goto join
                $async$goto = 7;
                break;
              case 8:
                // else
                $async$goto = 10;
                return P._asyncAwait(t2.invoke$4(J.get$id$z(t3.get$isolate()), J.get$id$z(t4), "toString", H.setRuntimeTypeInfo([], [P.String])), $async$call$0);
              case 10:
                // returning from await.
                toStringResult = $async$result;
                t5 = J.getInterceptor$(toStringResult);
                $async$goto = !!t5.$isErrorRef ? 11 : 13;
                break;
              case 11:
                // then
                result = J.$add$ansx(result, "\n\n" + H.S(Y._valueAsString(t4)));
                // goto join
                $async$goto = 12;
                break;
              case 13:
                // else
                $async$goto = !!t5.$isInstanceRef ? 14 : 15;
                break;
              case 14:
                // then
                $async$temp1 = J;
                $async$temp2 = result;
                $async$temp3 = H;
                $async$goto = 16;
                return P._asyncAwait(t1._logging$_retrieveFullStringValue$3(t2, t3.get$isolate(), toStringResult), $async$call$0);
              case 16:
                // returning from await.
                result = $async$temp1.$add$ansx($async$temp2, "\n\n" + $async$temp3.S($async$result));
              case 15:
                // join
              case 12:
                // join
              case 7:
                // join
              case 5:
                // join
                t1 = $async$self.stackTrace;
                $async$returnValue = Y._isNotNull(t1) ? J.$add$ansx(result, "\n\n" + H.S(Y._valueAsString(t1))) : result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    _StdoutEventHandler: {
      "^": "Object;loggingScreen<,name>,isError<,0buffer>,0timer,$ti",
      set$buffer: function(_, buffer) {
        this.buffer = H.interceptedTypeCheck(buffer, "$isLogData");
      },
      handle$1: [function(e) {
        var message, t1, t2, t3, t4, summary, data;
        H.interceptedTypeCheck(e, "$isEvent0");
        message = S.decodeBase64(e.bytes);
        if (this.buffer != null) {
          t1 = this.timer;
          if (!(t1 == null))
            t1.cancel$0();
          if (message === "\n") {
            t1 = J.get$kind$x(this.buffer);
            t2 = J.$add$ansx(this.buffer.get$details(), message);
            t3 = this.buffer.get$timestamp();
            t4 = J.$add$ansx(this.buffer.get$summary(), message);
            this.loggingScreen._logging$_log$1(Y.LogData$(t1, t2, t3, null, this.buffer.get$isError(), null, t4, null));
            this.buffer = null;
            return;
          }
          this.loggingScreen._logging$_log$1(this.buffer);
          this.buffer = null;
        }
        summary = message.length > 200 ? J.$add$ansx(J.substring$2$s(message, 0, 200), "\u2026") : message;
        data = Y.LogData$(this.name, message, e.timestamp, null, this.isError, null, summary, null);
        if (message === "\n")
          this.loggingScreen._logging$_log$1(data);
        else {
          this.buffer = data;
          this.timer = H.interceptedTypeCheck(P.Timer_Timer(C.Duration_1000, new Y._StdoutEventHandler_handle_closure(this)), "$isTimer");
        }
      }, "call$1", "get$handle", 4, 0, 11, 19],
      static: {
        _StdoutEventHandler$: [function(loggingScreen, $name, isError) {
          return new Y._StdoutEventHandler(loggingScreen, $name, isError, []);
        }, null, null, 8, 3, null, 18, 715, 8, 460]
      }
    },
    _StdoutEventHandler_handle_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = J.getInterceptor$x(t1);
        t1.get$loggingScreen()._logging$_log$1(t2.get$buffer(t1));
        t2.set$buffer(t1, null);
      }, null, null, 0, 0, null, "call"]
    },
    LogData: {
      "^": "Object;kind>,timestamp<,isError<,summary<,summaryHtml,node<,_details,detailsComputer,$ti",
      set$detailsComputer: function(detailsComputer) {
        this.detailsComputer = H.assertSubtype(detailsComputer, "$isFuture", [P.String], "$asFuture");
      },
      get$details: [function() {
        return this._details;
      }, null, null, 2, 0, null],
      get$needsComputing: [function() {
        return this.detailsComputer != null;
      }, null, null, 2, 0, null],
      compute$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, $async$temp1;
        var $async$compute$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$temp1 = H;
                $async$goto = 2;
                return P._asyncAwait($async$self.detailsComputer, $async$compute$0);
              case 2:
                // returning from await.
                $async$self._details = $async$temp1.stringTypeCheck($async$result);
                $async$self.set$detailsComputer(null);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$compute$0, $async$completer);
      }, null, "get$compute", 0, 0, null],
      static: {
        LogData$: [function(kind, _details, timestamp, detailsComputer, isError, node, summary, summaryHtml) {
          return new Y.LogData(kind, timestamp, isError, summary, summaryHtml, node, _details, detailsComputer, []);
        }, null, null, 12, 11, null, 0, 18, 0, 0, 0, 267, 718, 719, 720, 460, 23, 721, 722]
      }
    },
    LogKindColumn: {
      "^": "Column;title,wide,$ti",
      get$supportsSorting: [function() {
        return false;
      }, null, null, 2, 0, null],
      get$usesHtml: [function() {
        return true;
      }, null, null, 2, 0, null],
      get$cssClass: [function() {
        return "log-label-column";
      }, null, null, 2, 0, null],
      getValue$1: [function(item) {
        H.interceptedTypeCheck(item, "$isLogData");
        return '<span class="label ' + H.S(Y.getCssClassForEventKind(item)) + '">' + H.S(item.kind) + "</span>";
      }, null, "get$getValue", 4, 0, null, 66],
      render$1: [function(value) {
        return H.stringTypeCheck(value);
      }, null, "get$render", 4, 0, null, 1],
      $asColumn: function() {
        return [Y.LogData];
      },
      static: {
        LogKindColumn$: [function() {
          return new Y.LogKindColumn("Kind", false, []);
        }, null, null, 0, 0, null]
      }
    },
    LogWhenColumn: {
      "^": "Column;title,wide,$ti",
      get$cssClass: [function() {
        return "pre monospace";
      }, null, null, 2, 0, null],
      get$supportsSorting: [function() {
        return false;
      }, null, null, 2, 0, null],
      getValue$1: [function(item) {
        return H.interceptedTypeCheck(item, "$isLogData").timestamp;
      }, null, "get$getValue", 4, 0, null, 66],
      render$1: [function(value) {
        return $.$get$timeFormat().format$1(P.DateTime$fromMillisecondsSinceEpoch(H.intTypeCheck(value), false));
      }, null, "get$render", 4, 0, null, 1],
      $asColumn: function() {
        return [Y.LogData];
      },
      static: {
        LogWhenColumn$: [function() {
          return new Y.LogWhenColumn("When", false, []);
        }, null, null, 0, 0, null]
      }
    },
    LogMessageColumn: {
      "^": "Column;title,wide,$ti",
      get$cssClass: [function() {
        return "pre-wrap monospace";
      }, null, null, 2, 0, null],
      get$usesHtml: [function() {
        return true;
      }, null, null, 2, 0, null],
      get$supportsSorting: [function() {
        return false;
      }, null, null, 2, 0, null],
      getValue$1: [function(item) {
        return H.interceptedTypeCheck(item, "$isLogData");
      }, null, "get$getValue", 4, 0, null, 66],
      render$1: [function(value) {
        var t1;
        H.interceptedTypeCheck(value, "$isLogData");
        t1 = value.summaryHtml;
        if (t1 != null)
          return t1;
        else {
          t1 = value.summary;
          return B.escape(t1 == null ? value.get$details() : t1);
        }
      }, null, "get$render", 4, 0, null, 1],
      $asColumn: function() {
        return [Y.LogData];
      },
      static: {
        LogMessageColumn$: [function() {
          return new Y.LogMessageColumn("Message", true, []);
        }, null, null, 0, 0, null]
      }
    },
    LogDetailsUI: {
      "^": "CoreElement;0data>,0content,0message>,0tree<,element,$ti",
      LogDetailsUI$0: [function() {
        var t1, t2, t3;
        this.layoutVertical$0();
        this.flex$0(0);
        t1 = A.div(null, "log-details table-border", null);
        t2 = J.getInterceptor$z(t1);
        t2.flex$0(t1);
        t3 = H.interceptedTypeCheck(A.div(null, "pre-wrap monospace", null), "$isCoreElement");
        this.message = t3;
        t2.add$1(t1, t3);
        H.interceptedTypeCheck(t1, "$isCoreElement");
        this.content = t1;
        this.add$1(0, H.setRuntimeTypeInfo([t1], [A.CoreElement]));
      }, null, null, 0, 0, null],
      setData$1: [function(data) {
        var t1, t2, root;
        H.interceptedTypeCheck(data, "$isLogData");
        J.set$scrollTop$x(this.content.get$element(), 0);
        this.data = data;
        this.tree = null;
        if (data == null) {
          J.set$text$x(this.message, "");
          return;
        }
        t1 = data.node;
        if (t1 != null) {
          J.clear$0$ax(this.message);
          t2 = K.InspectorTreeHtml$(null, null, null, new Y.LogDetailsUI_setData_closure(this), false, C.FlutterTreeType_0);
          this.tree = t2;
          root = t2.setupInspectorTreeNode$4$expandChildren$expandProperties(t2.createNode$0(), t1, true, true);
          root.allowExpandCollapse = false;
          J.set$root$z(this.tree, root);
          J.add$1$ax(this.message, this.tree.get$element());
          return;
        }
        if (data.get$needsComputing()) {
          J.set$text$x(this.message, "");
          data.compute$0().then$1$1(new Y.LogDetailsUI_setData_closure0(this, data), null);
        } else
          this._updateUIFromData$0();
      }, null, "get$setData", 4, 0, null, 34],
      _updateUIFromData$0: [function() {
        var result, exception;
        if (J.startsWith$1$s(this.data.get$details(), "{") && J.endsWith$1$s(this.data.get$details(), "}"))
          try {
            result = P.jsonDecode(this.data.get$details(), null);
            J.set$text$x(this.message, C.JsonEncoder_yLX.convert$1(result));
          } catch (exception) {
            H.unwrapException(exception);
            J.set$text$x(this.message, this.data.get$details());
          }
        else
          J.set$text$x(this.message, this.data.get$details());
      }, null, "get$_updateUIFromData", 0, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        LogDetailsUI$: [function() {
          var t1 = new Y.LogDetailsUI(W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, null, null);
          t1.LogDetailsUI$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    LogDetailsUI_setData_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1, node;
        t1 = this.$this;
        node = t1.get$tree().get$selection();
        if (node != null)
          t1.get$tree().maybePopulateChildren$1(node);
        node.get$diagnostic().setSelectionInspector$1(false);
      }, null, null, 0, 0, null, "call"]
    },
    LogDetailsUI_setData_closure0: {
      "^": "Closure:50;$this,data,$ti",
      call$1: [function(_) {
        var t1 = this.$this;
        if (J.$eq$(J.get$data$x(t1), this.data))
          t1._updateUIFromData$0();
      }, null, null, 4, 0, null, 12, "call"]
    }
  }], ["", "package:devtools/src/main.dart",, F, {
    "^": "",
    _renderDuration: [function(duration) {
      H.interceptedTypeCheck(duration, "$isDuration");
      if (J.$lt$n(duration.get$inMilliseconds(), 1000))
        return H.S($.$get$nf().format$1(duration.get$inMilliseconds())) + "ms";
      else
        return H.S(J.toStringAsFixed$1$n(J.$div$n(duration.get$inMilliseconds(), 1000), 1)) + "s";
    }, null, null, 4, 0, null, 208],
    PerfToolFramework: {
      "^": "Framework;0isolateSelectStatus,0isolateSelect,0connectionStatus,0reloadStatus<,screens,0current,0globalStatus,0pageStatus,0auxiliaryStatus,0globalActions,_screenContents,$ti",
      set$reloadStatus: function(reloadStatus) {
        this.reloadStatus = H.interceptedTypeCheck(reloadStatus, "$isStatus");
      },
      PerfToolFramework$0: [function() {
        this.addScreen$1(D.InspectorScreen$());
        this.addScreen$1(D.TimelineScreen$());
        this.addScreen$1(X.DebuggerScreen$());
        this.addScreen$1(Y.LoggingScreen$());
        this.initGlobalUI$0();
        this.initTestingModel$0();
      }, null, null, 0, 0, null],
      initGlobalUI$0: [function() {
        var mainNav, t1, t2, t3, link;
        mainNav = A.CoreElement$from(W.querySelector("#main-nav"));
        mainNav.clear$0(0);
        for (t1 = J.get$iterator$ax(this.screens), t2 = [A.CoreElement]; t1.moveNext$0();) {
          t3 = t1.get$current();
          link = A.CoreElement$("a", null, null, null);
          J.$indexSet$ax(link.get$attributes(link), "href", t3.get$ref());
          link.get$onClick(link).listen$1(new F.PerfToolFramework_initGlobalUI_closure(this, t3));
          link.add$1(0, H.setRuntimeTypeInfo([A.span(null, "octicon " + H.S(t3.iconClass), null), A.span(null, null, " " + H.S(t3.name))], t2));
          mainNav.add$1(0, link);
        }
        t1 = N.StatusItem$();
        this.isolateSelectStatus = t1;
        J.add$1$ax(this.globalStatus, t1);
        t1 = N.PSelect$();
        t1.small$0();
        t1.change$1(this.get$_handleIsolateSelect());
        this.isolateSelect = t1;
        J.add$1$ax(this.isolateSelectStatus.get$element(), this.isolateSelect);
        this._rebuildIsolateSelect$0();
        t1 = this.get$_rebuildIsolateSelect();
        E.serviceManager().get$isolateManager().get$onIsolateCreated().listen$1(t1);
        E.serviceManager().get$isolateManager().get$onIsolateExited().listen$1(t1);
        E.serviceManager().get$isolateManager().get$onSelectedIsolateChanged().listen$1(t1);
        this._initHotReloadServiceListener$0();
        E.serviceManager().get$onStateChange().listen$1(new F.PerfToolFramework_initGlobalUI_closure0(this));
      }, null, "get$initGlobalUI", 0, 0, null],
      initTestingModel$0: [function() {
        R.App_register(this);
      }, null, "get$initTestingModel", 0, 0, null],
      _handleIsolateSelect$0: [function() {
        E.serviceManager().get$isolateManager().selectIsolate$1(J.get$value$x(this.isolateSelect));
      }, "call$0", "get$_handleIsolateSelect", 0, 0, 0],
      _rebuildIsolateSelect$1: [function(_) {
        var t1, t2;
        H.interceptedTypeCheck(_, "$isIsolateRef");
        J.clear$0$ax(this.isolateSelect);
        for (t1 = J.get$iterator$ax(E.serviceManager().get$isolateManager().get$isolates()); t1.moveNext$0();) {
          t2 = t1.get$current();
          this.isolateSelect.option$2$value(B.isolateName(t2), t2.id);
        }
        J.set$disabled$z(this.isolateSelect, J.get$isEmpty$asx(E.serviceManager().get$isolateManager().get$isolates()));
        if (E.serviceManager().get$isolateManager().get$selectedIsolate() != null)
          J.set$selectedIndex$x(this.isolateSelect, J.indexOf$1$asx(E.serviceManager().get$isolateManager().get$isolates(), E.serviceManager().get$isolateManager().get$selectedIsolate()));
      }, function() {
        return this._rebuildIsolateSelect$1(null);
      }, "_rebuildIsolateSelect$0", "call$1", "call$0", "get$_rebuildIsolateSelect", 0, 2, 125, 0, 12],
      _initHotReloadServiceListener$0: [function() {
        E.serviceManager().hasRegisteredService$2("reloadSources", new F.PerfToolFramework__initHotReloadServiceListener_closure(this));
      }, null, "get$_initHotReloadServiceListener", 0, 0, null],
      _buildReloadRestartButtons$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, reloadAction, restartAction;
        var $async$_buildReloadRestartButtons$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                reloadAction = N.ActionButton$("icons/hot-reload-white@2x.png", "Hot Reload");
                reloadAction.click$1(0, new F.PerfToolFramework__buildReloadRestartButtons_closure($async$self, reloadAction));
                restartAction = N.ActionButton$("icons/hot-restart-white@2x.png", "Hot Restart");
                restartAction.click$1(0, new F.PerfToolFramework__buildReloadRestartButtons_closure0($async$self, restartAction));
                $async$self.addGlobalAction$1(reloadAction);
                $async$self.addGlobalAction$1(restartAction);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_buildReloadRestartButtons$0, $async$completer);
      }, null, "get$_buildReloadRestartButtons", 0, 0, null],
      _rebuildConnectionStatus$0: [function() {
        if (E.serviceManager().get$hasConnection()) {
          var t1 = this.connectionStatus;
          if (t1 != null) {
            J.remove$1$ax(this.auxiliaryStatus, t1);
            this.connectionStatus = null;
          }
        } else {
          if (this.connectionStatus == null) {
            t1 = N.StatusItem$();
            this.connectionStatus = t1;
            J.add$1$ax(this.auxiliaryStatus, t1);
          }
          J.set$text$x(this.connectionStatus.get$element(), "no device connected");
        }
      }, null, "get$_rebuildConnectionStatus", 0, 0, null],
      static: {
        PerfToolFramework$: [function() {
          var t1 = N.Screen;
          t1 = new F.PerfToolFramework(H.setRuntimeTypeInfo([], [t1]), P.LinkedHashMap_LinkedHashMap$_empty(t1, A.CoreElement), []);
          t1.Framework$0();
          t1.PerfToolFramework$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    PerfToolFramework_initGlobalUI_closure: {
      "^": "Closure:19;$this,screen,$ti",
      call$1: [function(e) {
        H.interceptedTypeCheck(e, "$isMouseEvent").preventDefault();
        this.$this.navigateTo$1(J.get$id$z(this.screen));
      }, null, null, 4, 0, null, 19, "call"]
    },
    PerfToolFramework_initGlobalUI_closure0: {
      "^": "Closure:54;$this,$ti",
      call$1: [function(_) {
        var t1 = this.$this;
        t1._rebuildConnectionStatus$0();
        if (!E.serviceManager().get$hasConnection())
          t1.toast$1("Device connection lost.");
      }, null, null, 4, 0, null, 12, "call"]
    },
    PerfToolFramework__initHotReloadServiceListener_closure: {
      "^": "Closure:16;$this,$ti",
      call$1: [function(reloadServiceAvailable) {
        var t1 = this.$this;
        if (H.boolTypeCheck(reloadServiceAvailable))
          t1._buildReloadRestartButtons$0();
        else
          t1.clearGlobalActions$0();
      }, null, null, 4, 0, null, 726, "call"]
    },
    PerfToolFramework__buildReloadRestartButtons_closure: {
      "^": "Closure:32;$this,reloadAction,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, $status, timer, message, message0, t1, t2, timer0, exception, $async$exception;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = t1.get$reloadStatus();
                if (!(t2 == null))
                  t2.dispose$0();
                $status = F.Status$(t1.get$auxiliaryStatus(), "reloading...");
                t1.set$reloadStatus($status);
                timer0 = P.Stopwatch$();
                timer0.start$0(0);
                timer = timer0;
                $async$handler = 3;
                J.set$disabled$z($async$self.reloadAction, true);
                $async$goto = 6;
                return P._asyncAwait(E.serviceManager().performHotReload$0(), $async$call$0);
              case 6:
                // returning from await.
                E.messageBus().addEvent$1(A.BusEvent$("reload.start", null));
                J.stop$0$z(timer);
                message = "reloaded in " + H.S(F._renderDuration(timer.get$elapsed()));
                E.messageBus().addEvent$1(A.BusEvent$("reload.end", message));
                $status.setText$1(message);
                $async$next.push(5);
                // goto finally
                $async$goto = 4;
                break;
              case 3:
                // catch
                $async$handler = 2;
                $async$exception = $async$currentError;
                H.unwrapException($async$exception);
                message0 = "error performing reload";
                E.messageBus().addEvent$1(A.BusEvent$("reload.end", message0));
                $status.setText$1(message0);
                $async$next.push(5);
                // goto finally
                $async$goto = 4;
                break;
              case 2:
                // uncaught
                $async$next = [1];
              case 4:
                // finally
                $async$handler = 1;
                J.set$disabled$z($async$self.reloadAction, false);
                J.timeout$0$z($status);
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 5:
                // after finally
                // implicit return
                return P._asyncReturn(null, $async$completer);
              case 1:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    PerfToolFramework__buildReloadRestartButtons_closure0: {
      "^": "Closure:32;$this,restartAction,$ti",
      call$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.Null),
          $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, $status, timer, message, message0, t1, t2, timer0, exception, $async$exception;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = t1.get$reloadStatus();
                if (!(t2 == null))
                  t2.dispose$0();
                $status = F.Status$(t1.get$auxiliaryStatus(), "restarting...");
                t1.set$reloadStatus($status);
                timer0 = P.Stopwatch$();
                timer0.start$0(0);
                timer = timer0;
                $async$handler = 3;
                J.set$disabled$z($async$self.restartAction, true);
                E.messageBus().addEvent$1(A.BusEvent$("restart.start", null));
                $async$goto = 6;
                return P._asyncAwait(E.serviceManager().performHotRestart$0(), $async$call$0);
              case 6:
                // returning from await.
                J.stop$0$z(timer);
                message = "restarted in " + H.S(F._renderDuration(timer.get$elapsed()));
                E.messageBus().addEvent$1(A.BusEvent$("restart.end", message));
                $status.setText$1(message);
                $async$next.push(5);
                // goto finally
                $async$goto = 4;
                break;
              case 3:
                // catch
                $async$handler = 2;
                $async$exception = $async$currentError;
                H.unwrapException($async$exception);
                message0 = "error performing restart";
                E.messageBus().addEvent$1(A.BusEvent$("restart.end", message0));
                $status.setText$1(message0);
                $async$next.push(5);
                // goto finally
                $async$goto = 4;
                break;
              case 2:
                // uncaught
                $async$next = [1];
              case 4:
                // finally
                $async$handler = 1;
                J.set$disabled$z($async$self.restartAction, false);
                J.timeout$0$z($status);
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 5:
                // after finally
                // implicit return
                return P._asyncReturn(null, $async$completer);
              case 1:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    NotFoundScreen: {
      "^": "Screen;name,id,iconClass,0framework,_visible,statusItems,$ti",
      createContent$1: [function(framework) {
        H.interceptedTypeCheck(framework, "$isFramework");
        return A.p(null, null, "Page not found: " + H.S(J.get$pathname$x(J.get$location$x(W.window()))));
      }, null, "get$createContent", 4, 0, null, 127],
      static: {
        NotFoundScreen$: [function() {
          return new F.NotFoundScreen("Not Found", "notfound", null, B.Property$(false, P.bool), H.setRuntimeTypeInfo([], [N.StatusItem]), []);
        }, null, null, 0, 0, null]
      }
    },
    Status: {
      "^": "Object;statusLine,0item,$ti",
      Status$2: [function(statusLine, initialMessage) {
        var t1 = N.StatusItem$();
        this.item = t1;
        J.set$text$x(t1.element, initialMessage);
        J.add$1$ax(this.statusLine, this.item);
      }, null, null, 8, 0, null, 461, 462],
      setText$1: [function(newText) {
        H.stringTypeCheck(newText);
        J.set$text$x(this.item.get$element(), newText);
      }, null, "get$setText", 4, 0, null, 727],
      timeout$0: [function(_) {
        P.Timer_Timer(C.Duration_3000000, this.get$dispose());
      }, null, "get$timeout", 1, 0, null],
      dispose$0: [function() {
        J.remove$1$ax(this.statusLine, this.item);
      }, "call$0", "get$dispose", 0, 0, 0],
      static: {
        Status$: [function(statusLine, initialMessage) {
          var t1 = new F.Status(statusLine, []);
          t1.Status$2(statusLine, initialMessage);
          return t1;
        }, null, null, 8, 0, null, 461, 462]
      }
    }
  }], ["", "package:devtools/src/memory/memory.dart",, V, {
    "^": "",
    MemoryScreen: {
      "^": "Screen;$ti"
    },
    MemoryScreen_createContent_closure: {
      "^": "Closure:30;$ti"
    },
    MemoryScreen__loadAllocationProfile_closure: {
      "^": "Closure:126;$ti"
    },
    MemoryScreen__loadAllocationProfile_closure0: {
      "^": "Closure:127;$ti"
    },
    MemoryScreen__handleConnectionStart_closure: {
      "^": "Closure:27;$ti"
    },
    MemoryScreen__handleConnectionStart__closure: {
      "^": "Closure:1;$ti"
    },
    MemoryRow: {
      "^": "Object;$ti"
    },
    MemoryColumnClassName: {
      "^": "Column;$ti",
      $asColumn: function() {
        return [V.ClassHeapStats0];
      }
    },
    MemoryColumnSize: {
      "^": "Column;$ti",
      $asColumn: function() {
        return [V.ClassHeapStats0];
      }
    },
    MemoryColumnInstanceCount: {
      "^": "Column;$ti",
      $asColumn: function() {
        return [V.ClassHeapStats0];
      }
    },
    MemoryColumnSimple: {
      "^": "Column;$ti"
    },
    MemoryChart: {
      "^": "LineChart;$ti",
      $asLineChart: function() {
        return [V.MemoryTracker];
      }
    },
    MemoryChart_createPoints_closure: {
      "^": "Closure:129;$ti"
    },
    MemoryTracker: {
      "^": "Object;$ti"
    },
    MemoryTracker_maxHeapData_closure: {
      "^": "Closure:130;$ti"
    },
    MemoryTracker__pollMemory_closure: {
      "^": "Closure:131;$ti"
    },
    MemoryTracker__recalculate_closure: {
      "^": "Closure:56;$ti"
    },
    MemoryTracker__recalculate_closure0: {
      "^": "Closure:56;$ti"
    },
    MemoryTracker__addSample_closure: {
      "^": "Closure:133;$ti"
    },
    MemoryTracker_getHeaps_closure: {
      "^": "Closure:134;$ti"
    },
    HeapSample: {
      "^": "Object;$ti"
    },
    ClassHeapStats0: {
      "^": "Object;$ti"
    }
  }], ["model", "package:devtools/src/model/model.dart",, R, {
    "^": "",
    App: {
      "^": "Object;framework<,_handlers,$ti",
      App$1: [function(framework) {
        var t1, t2;
        t1 = -1;
        this._register$1$2("echo", this.get$echo(), t1);
        this._register$1$2("switchPage", this.get$switchPage(), t1);
        t2 = P.String;
        this._register$1$2("currentPageId", this.get$currentPageId(), t2);
        this._register$1$2("logs.clearLogs", this.get$logsClearLogs(), t1);
        this._register$1$2("logs.logCount", this.get$logsLogCount(), P.int);
        this._register$1$2("debugger.getState", this.get$debuggerGetState(), t2);
        this._register$1$2("debugger.getLocation", this.get$debuggerGetLocation(), t2);
        this._register$1$2("debugger.resume", this.get$debuggerResume(), t1);
        this._register$1$2("debugger.pause", this.get$debuggerPause(), t1);
        this._register$1$2("debugger.step", this.get$debuggerStep(), t1);
        this._register$1$2("debugger.clearBreakpoints", this.get$debuggerClearBreakpoints(), t1);
        this._register$1$2("debugger.addBreakpoint", this.get$debuggerAddBreakpoint(), t1);
        this._register$1$2("debugger.setExceptionPauseMode", this.get$debuggerSetExceptionPauseMode(), t1);
        t1 = [P.List, P.String];
        this._register$1$2("debugger.getBreakpoints", this.get$debuggerGetBreakpoints(), t1);
        this._register$1$2("debugger.getScripts", this.get$debuggerGetScripts(), t1);
        this._register$1$2("debugger.getCallStackFrames", this.get$debuggerGetCallStackFrames(), t1);
        this._register$1$2("debugger.getVariables", this.get$debuggerGetVariables(), t1);
        this._register$1$2("debugger.getConsoleContents", this.get$debuggerGetConsoleContents(), t2);
      }, null, null, 4, 0, null, 127],
      _bind$0: [function() {
        var binding = P.JsObject_JsObject$jsify(P.LinkedHashMap__makeEmpty());
        binding.$indexSet(0, "send", new R.App__bind_closure(this));
        J.$indexSet$ax($.$get$context(), "devtools", binding);
        this._sendNotification$1("app.inited");
      }, null, "get$_bind", 0, 0, null],
      echo$1: [function(message) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$echo$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$self._sendNotification$2("app.echo", message);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$echo$1, $async$completer);
      }, "call$1", "get$echo", 4, 0, 57, 21],
      switchPage$1: [function(pageId) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, t1, $screen;
        var $async$switchPage$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.framework;
                H.stringTypeCheck(pageId);
                $screen = t1.getScreen$1(pageId);
                if ($screen == null)
                  throw H.wrapException("page " + H.S(pageId) + " not found");
                J.load$1$x(t1, $screen);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$switchPage$1, $async$completer);
      }, "call$1", "get$switchPage", 4, 0, 57, 728],
      currentPageId$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this, t1;
        var $async$currentPageId$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.framework.get$current();
                $async$returnValue = t1 == null ? null : J.get$id$z(t1);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$currentPageId$1, $async$completer);
      }, function() {
        return this.currentPageId$1(null);
      }, "currentPageId$0", "call$1", "call$0", "get$currentPageId", 0, 2, 26, 0, 12],
      logsClearLogs$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$logsClearLogs$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                H.interceptedTypeCheck($async$self.framework.getScreen$1("logs"), "$isLoggingScreen").loggingTable.setRows$1(H.setRuntimeTypeInfo([], [Y.LogData]));
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$logsClearLogs$1, $async$completer);
      }, function() {
        return this.logsClearLogs$1(null);
      }, "logsClearLogs$0", "call$1", "call$0", "get$logsClearLogs", 0, 2, 12, 0, 12],
      logsLogCount$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.int),
          $async$returnValue, $async$self = this;
        var $async$logsLogCount$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = H.interceptedTypeCheck($async$self.framework.getScreen$1("logs"), "$isLoggingScreen").loggingTable.get$rowCount();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$logsLogCount$1, $async$completer);
      }, function() {
        return this.logsLogCount$1(null);
      }, "logsLogCount$0", "call$1", "call$0", "get$logsLogCount", 0, 2, 138, 0, 12],
      debuggerGetState$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this;
        var $async$debuggerGetState$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.get$isPaused() ? "paused" : "running";
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerGetState$1, $async$completer);
      }, function() {
        return this.debuggerGetState$1(null);
      }, "debuggerGetState$0", "call$1", "call$0", "get$debuggerGetState", 0, 2, 26, 0, 12],
      debuggerGetConsoleContents$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this;
        var $async$debuggerGetConsoleContents$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").consoleArea.getContents$0();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerGetConsoleContents$1, $async$completer);
      }, function() {
        return this.debuggerGetConsoleContents$1(null);
      }, "debuggerGetConsoleContents$0", "call$1", "call$0", "get$debuggerGetConsoleContents", 0, 2, 26, 0, 12],
      debuggerGetLocation$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(P.String),
          $async$returnValue, $async$self = this, scriptAndPos;
        var $async$debuggerGetLocation$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                scriptAndPos = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").sourceEditor.get$executionPoint();
                if (scriptAndPos == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$returnValue = H.S(scriptAndPos.get$uri()) + ":" + H.S(J.$sub$n(scriptAndPos.position.get$line(), 1));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerGetLocation$1, $async$completer);
      }, function() {
        return this.debuggerGetLocation$1(null);
      }, "debuggerGetLocation$0", "call$1", "call$0", "get$debuggerGetLocation", 0, 2, 26, 0, 12],
      debuggerResume$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$debuggerResume$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.resume$0(), $async$debuggerResume$1);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerResume$1, $async$completer);
      }, function() {
        return this.debuggerResume$1(null);
      }, "debuggerResume$0", "call$1", "call$0", "get$debuggerResume", 0, 2, 12, 0, 12],
      debuggerPause$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$debuggerPause$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(J.pause$0$z(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState), $async$debuggerPause$1);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerPause$1, $async$completer);
      }, function() {
        return this.debuggerPause$1(null);
      }, "debuggerPause$0", "call$1", "call$0", "get$debuggerPause", 0, 2, 12, 0, 12],
      debuggerStep$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$debuggerStep$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.stepOver$0(), $async$debuggerStep$1);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerStep$1, $async$completer);
      }, function() {
        return this.debuggerStep$1(null);
      }, "debuggerStep$0", "call$1", "call$0", "get$debuggerStep", 0, 2, 12, 0, 12],
      debuggerClearBreakpoints$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$debuggerClearBreakpoints$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.clearBreakpoints$0(), $async$debuggerClearBreakpoints$1);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerClearBreakpoints$1, $async$completer);
      }, function() {
        return this.debuggerClearBreakpoints$1(null);
      }, "debuggerClearBreakpoints$0", "call$1", "call$0", "get$debuggerClearBreakpoints", 0, 2, 12, 0, 12],
      debuggerGetBreakpoints$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
          $async$returnValue, $async$self = this;
        var $async$debuggerGetBreakpoints$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = J.toList$0$ax(J.map$1$1$ax(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.get$breakpoints(), new R.App_debuggerGetBreakpoints_closure(), P.String));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerGetBreakpoints$1, $async$completer);
      }, function() {
        return this.debuggerGetBreakpoints$1(null);
      }, "debuggerGetBreakpoints$0", "call$1", "call$0", "get$debuggerGetBreakpoints", 0, 2, 31, 0, 12],
      debuggerGetScripts$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
          $async$returnValue, $async$self = this;
        var $async$debuggerGetScripts$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = J.toList$0$ax(J.map$1$1$ax(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").scriptsView.get$items(), new R.App_debuggerGetScripts_closure(), P.String));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerGetScripts$1, $async$completer);
      }, function() {
        return this.debuggerGetScripts$1(null);
      }, "debuggerGetScripts$0", "call$1", "call$0", "get$debuggerGetScripts", 0, 2, 31, 0, 12],
      debuggerGetCallStackFrames$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
          $async$returnValue, $async$self = this;
        var $async$debuggerGetCallStackFrames$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = J.toList$0$ax(J.map$1$1$ax(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").callStackView.get$items(), new R.App_debuggerGetCallStackFrames_closure(), P.String));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerGetCallStackFrames$1, $async$completer);
      }, function() {
        return this.debuggerGetCallStackFrames$1(null);
      }, "debuggerGetCallStackFrames$0", "call$1", "call$0", "get$debuggerGetCallStackFrames", 0, 2, 31, 0, 12],
      debuggerGetVariables$1: [function(_) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
          $async$returnValue, $async$self = this;
        var $async$debuggerGetVariables$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = J.toList$0$ax(J.map$1$1$ax(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").variablesView.get$items(), new R.App_debuggerGetVariables_closure(), P.String));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerGetVariables$1, $async$completer);
      }, function() {
        return this.debuggerGetVariables$1(null);
      }, "debuggerGetVariables$0", "call$1", "call$0", "get$debuggerGetVariables", 0, 2, 31, 0, 12],
      debuggerAddBreakpoint$1: [function(params) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, t1, path, line;
        var $async$debuggerAddBreakpoint$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.getInterceptor$asx(params);
                path = H.stringTypeCheck(t1.$index(params, 0));
                line = H.intTypeCheck(J.$add$ansx(t1.$index(params, 1), 1));
                $async$goto = 2;
                return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.addBreakpointByPathFragment$2(path, line), $async$debuggerAddBreakpoint$1);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerAddBreakpoint$1, $async$completer);
      }, function() {
        return this.debuggerAddBreakpoint$1(null);
      }, "debuggerAddBreakpoint$0", "call$1", "call$0", "get$debuggerAddBreakpoint", 0, 2, 12, 0, 160],
      debuggerSetExceptionPauseMode$1: [function(params) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$debuggerSetExceptionPauseMode$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                H.stringTypeCheck(params);
                $async$goto = 2;
                return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.setExceptionPauseMode$1(params), $async$debuggerSetExceptionPauseMode$1);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$debuggerSetExceptionPauseMode$1, $async$completer);
      }, function() {
        return this.debuggerSetExceptionPauseMode$1(null);
      }, "debuggerSetExceptionPauseMode$0", "call$1", "call$0", "get$debuggerSetExceptionPauseMode", 0, 2, 12, 0, 160],
      _sendNotification$2: [function($event, params) {
        var map = P.LinkedHashMap_LinkedHashMap$_literal(["event", H.stringTypeCheck($event)], P.String, null);
        if (params != null)
          map.$indexSet(0, "params", params);
        P.print("[" + H.S(P.jsonEncode(map, null)) + "]");
      }, function($event) {
        return this._sendNotification$2($event, null);
      }, "_sendNotification$1", null, null, "get$_sendNotification", 4, 2, null, 0, 22, 160],
      _sendResponseResult$2: [function(id, result) {
        var map = P.LinkedHashMap_LinkedHashMap$_literal(["id", H.intTypeCheck(id)], P.String, null);
        if (result != null)
          map.$indexSet(0, "result", result);
        P.print("[" + H.S(P.jsonEncode(map, null)) + "]");
      }, null, "get$_sendResponseResult", 4, 2, null, 0, 104, 59],
      _sendReponseError$3: [function(id, error, stackTrace) {
        var t1;
        H.intTypeCheck(id);
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        t1 = P.String;
        P.print("[" + H.S(P.jsonEncode(P.LinkedHashMap_LinkedHashMap$_literal(["id", id, "error", P.LinkedHashMap_LinkedHashMap$_literal(["message", J.toString$0$(error), "stackTrace", J.toString$0$(stackTrace)], t1, t1)], t1, null), null)) + "]");
      }, null, "get$_sendReponseError", 12, 0, null, 104, 14, 20],
      _dispatch$3: [function(method, id, arg) {
        var handler;
        H.stringTypeCheck(method);
        H.intTypeCheck(id);
        handler = J.$index$asx(this._handlers, method);
        if (handler != null)
          return handler.call$1(arg);
        else {
          P.print("handler not found for " + H.S(method) + "()");
          throw H.wrapException("no handler found for " + H.S(method) + "()");
        }
      }, null, "get$_dispatch", 12, 0, null, 61, 104, 44],
      _register$1$2: [1, function(idMethod, fn, $T) {
        J.$indexSet$ax(this._handlers, H.stringTypeCheck(idMethod), H.functionTypeCheck(fn, {func: 1, ret: [P.Future, $T], args: [,]}));
      }, function(idMethod, fn) {
        return this._register$1$2(idMethod, fn, null);
      }, "_register$2", null, "call$2", "get$_register", 8, 0, null, 729, 307],
      static: {
        App$: [function(framework) {
          var t1 = new R.App(framework, P.LinkedHashMap_LinkedHashMap$_empty(P.String, {func: 1, ret: [P.Future,,], args: [,]}), []);
          t1.App$1(framework);
          return t1;
        }, null, null, 4, 0, null, 127],
        App_register: [function(framework) {
          R.App$(H.interceptedTypeCheck(framework, "$isPerfToolFramework"))._bind$0();
        }, null, null, 4, 0, null, 127]
      }
    },
    App__bind_closure: {
      "^": "Closure:140;$this,$ti",
      call$3: [function(method, id, arg) {
        var result, error, stackTrace, t1, exception;
        H.stringTypeCheck(method);
        H.intTypeCheck(id);
        try {
          t1 = this.$this;
          result = t1._dispatch$3(method, id, arg);
          P.Future_Future$value(result, null).then$1$1(new R.App__bind__closure(t1, id), null).catchError$1(new R.App__bind__closure0(t1, id));
        } catch (exception) {
          error = H.unwrapException(exception);
          stackTrace = H.getTraceFromException(exception);
          this.$this._sendReponseError$3(id, error, stackTrace);
        }
      }, null, null, 12, 0, null, 61, 104, 44, "call"]
    },
    App__bind__closure: {
      "^": "Closure:4;$this,id,$ti",
      call$1: [function(result) {
        this.$this._sendResponseResult$2(this.id, result);
      }, null, null, 4, 0, null, 59, "call"]
    },
    App__bind__closure0: {
      "^": "Closure:59;$this,id,$ti",
      call$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        this.$this._sendReponseError$3(this.id, error, stackTrace);
      }, null, null, 8, 0, null, 14, 20, "call"]
    },
    App_debuggerGetBreakpoints_closure: {
      "^": "Closure:141;$ti",
      call$1: [function(breakpoint) {
        return H.interceptedTypeCheck(breakpoint, "$isBreakpoint").id;
      }, null, null, 4, 0, null, 173, "call"]
    },
    App_debuggerGetScripts_closure: {
      "^": "Closure:142;$ti",
      call$1: [function(script) {
        return H.interceptedTypeCheck(script, "$isScriptRef").uri;
      }, null, null, 4, 0, null, 128, "call"]
    },
    App_debuggerGetCallStackFrames_closure: {
      "^": "Closure:143;$ti",
      call$1: [function(frame) {
        var t1, $name, desc;
        H.interceptedTypeCheck(frame, "$isFrame");
        t1 = frame.code;
        $name = t1 == null ? null : J.get$name$x(t1);
        if ($name == null)
          $name = "<none>";
        if (C.JSString_methods.startsWith$1($name, "[Unoptimized] "))
          $name = C.JSString_methods.substring$1($name, 14);
        if (J.$eq$(frame.kind, "AsyncSuspensionMarker")) {
          $name = "<async break>";
          desc = "";
        } else {
          desc = H.S(frame.location.get$script().get$uri());
          desc = ":" + H.S(C.JSString_methods.contains$1(desc, "/") ? C.JSString_methods.substring$1(desc, J.$add$ansx(C.JSString_methods.lastIndexOf$1(desc, "/"), 1)) : desc);
        }
        return H.S($name) + desc;
      }, null, null, 4, 0, null, 73, "call"]
    },
    App_debuggerGetVariables_closure: {
      "^": "Closure:144;$ti",
      call$1: [function(variable) {
        var value, t1, valueStr;
        H.interceptedTypeCheck(variable, "$isBoundVariable");
        value = variable.value;
        t1 = J.getInterceptor$(value);
        if (!!t1.$isInstanceRef) {
          valueStr = value.valueAsString;
          if (valueStr == null)
            valueStr = J.get$name$x(value.classRef);
        } else
          valueStr = !!t1.$isSentinel ? value.valueAsString : t1.toString$0(value);
        return H.S(variable.name) + ":" + H.S(valueStr);
      }, null, null, 4, 0, null, 261, "call"]
    }
  }], ["", "package:devtools/src/performance/performance.dart",, V, {
    "^": "",
    PerformanceScreen: {
      "^": "Screen;$ti"
    },
    PerformanceScreen_createContent_closure: {
      "^": "Closure:30;$ti"
    },
    PerformanceScreen__loadSnapshot_closure: {
      "^": "Closure:145;$ti"
    },
    PerformanceScreen__loadSnapshot_closure0: {
      "^": "Closure:4;$ti"
    },
    PerformanceScreen__loadSnapshot_closure1: {
      "^": "Closure:1;$ti"
    },
    PerformanceScreen__reset_closure: {
      "^": "Closure:146;$ti"
    },
    PerformanceScreen__reset_closure0: {
      "^": "Closure:4;$ti"
    },
    PerformanceScreen__reset_closure1: {
      "^": "Closure:1;$ti"
    },
    PerformanceScreen__createTableView_closure: {
      "^": "Closure:147;$ti"
    },
    PerformanceScreen__process_closure: {
      "^": "Closure:148;$ti"
    },
    PerformanceScreen__process_closure0: {
      "^": "Closure:149;$ti"
    },
    PerformanceScreen__handleConnectionStart_closure: {
      "^": "Closure:27;$ti"
    },
    PerformanceScreen__handleConnectionStart__closure: {
      "^": "Closure:1;$ti"
    },
    CpuChart: {
      "^": "LineChart;$ti",
      $asLineChart: function() {
        return [V.CpuTracker];
      }
    },
    CpuTracker: {
      "^": "Object;$ti"
    },
    PerfData: {
      "^": "Object;$ti"
    },
    PerfColumnInclusive: {
      "^": "Column;$ti",
      $asColumn: function() {
        return [V.PerfData];
      }
    },
    PerfColumnSelf: {
      "^": "Column;$ti",
      $asColumn: function() {
        return [V.PerfData];
      }
    },
    PerfColumnMethodName: {
      "^": "Column;$ti",
      $asColumn: function() {
        return [V.PerfData];
      }
    },
    _CalcProfile: {
      "^": "Object;$ti"
    }
  }], ["", "package:devtools/src/service.dart",, R, {
    "^": "",
    connect: [function(host, port, finishedCompleter) {
      var ws, connectedCompleter;
      H.stringTypeCheck(host);
      H.intTypeCheck(port);
      H.assertSubtype(finishedCompleter, "$isCompleter", [P.Null], "$asCompleter");
      ws = W.WebSocket_WebSocket("ws://" + H.S(host) + ":" + H.S(port) + "/ws", null);
      connectedCompleter = P.Completer_Completer(U.VmServiceWrapper);
      (ws && C.WebSocket_methods).get$onOpen(ws).listen$1(new R.connect_closure(ws, finishedCompleter, connectedCompleter));
      C.WebSocket_methods.get$onError(ws).listen$1(new R.connect_closure0(connectedCompleter));
      return connectedCompleter.get$future();
    }, null, null, 12, 0, null, 170, 224, 731],
    convertBroadcastToSingleSubscriber: [1, function(stream, $T) {
      var t1, controller;
      t1 = {};
      H.assertSubtype(stream, "$isStream", [$T], "$asStream");
      controller = P.StreamController_StreamController(null, null, null, null, false, $T);
      t1.subscription = null;
      controller.set$onListen(new R.convertBroadcastToSingleSubscriber_closure(t1, stream, controller, $T));
      controller.set$onCancel(new R.convertBroadcastToSingleSubscriber_closure0(t1));
      return controller.get$stream(controller);
    }, function(stream) {
      return R.convertBroadcastToSingleSubscriber(stream, null);
    }, null, "call$1", null, 4, 0, null, 57],
    connect_closure: {
      "^": "Closure:10;ws,finishedCompleter,connectedCompleter,$ti",
      call$1: [function(_) {
        var t1, t2, service;
        H.interceptedTypeCheck(_, "$isEvent");
        t1 = this.ws;
        t2 = J.getInterceptor$x(t1);
        service = U.VmServiceWrapper$fromNewVmService(R.convertBroadcastToSingleSubscriber(t2.get$onMessage(t1), W.MessageEvent).asyncMap$1$1(new R.connect__closure(), null), new R.connect__closure0(t1), null, null);
        t2.get$onClose(t1).listen$1(new R.connect__closure1(this.finishedCompleter, service));
        J.complete$1$z(this.connectedCompleter, service);
      }, null, null, 4, 0, null, 12, "call"]
    },
    connect__closure: {
      "^": "Closure:150;$ti",
      call$1: [function(e) {
        var t1, fileReader;
        H.interceptedTypeCheck(e, "$isMessageEvent");
        t1 = (e && C.MessageEvent_methods).get$data(e);
        if (typeof t1 === "string")
          return C.MessageEvent_methods.get$data(e);
        else {
          fileReader = W.FileReader_FileReader();
          (fileReader && C.FileReader_methods).readAsArrayBuffer$1(fileReader, H.interceptedTypeCheck(C.MessageEvent_methods.get$data(e), "$isBlob"));
          return J.get$first$ax(C.FileReader_methods.get$onLoadEnd(fileReader)).then$1$1(new R.connect___closure(fileReader), P.ByteData);
        }
      }, null, null, 4, 0, null, 19, "call"]
    },
    connect___closure: {
      "^": "Closure:151;fileReader,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isProgressEvent");
        return P.ByteData_ByteData$view(H.interceptedTypeCheck(J.get$result$x(this.fileReader), "$isUint8List").buffer, 0, null);
      }, null, null, 4, 0, null, 12, "call"]
    },
    connect__closure0: {
      "^": "Closure:152;ws,$ti",
      call$1: [function(message) {
        return J.send$1$x(this.ws, H.stringTypeCheck(message));
      }, null, null, 4, 0, null, 21, "call"]
    },
    connect__closure1: {
      "^": "Closure:153;finishedCompleter,service,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isCloseEvent");
        J.complete$0$z(this.finishedCompleter);
        this.service.dispose$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    connect_closure0: {
      "^": "Closure:4;connectedCompleter,$ti",
      call$1: [function(e) {
        var t1 = this.connectedCompleter;
        if (!t1.get$isCompleted())
          t1.completeError$1(e);
      }, null, null, 4, 0, null, 19, "call"]
    },
    convertBroadcastToSingleSubscriber_closure: {
      "^": "Closure;_box_0,stream,controller,T,$ti",
      call$0: [function() {
        var subscription = this.stream.listen$1(new R.convertBroadcastToSingleSubscriber__closure(this.controller, this.T));
        this._box_0.subscription = subscription;
        return subscription;
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        return {func: 1, ret: [P.StreamSubscription, this.T]};
      }
    },
    convertBroadcastToSingleSubscriber__closure: {
      "^": "Closure;controller,T,$ti",
      call$1: [function(e) {
        return J.add$1$ax(this.controller, H.assertSubtypeOfRuntimeType(e, this.T));
      }, null, null, 4, 0, null, 19, "call"],
      $signature: function() {
        return {func: 1, ret: -1, args: [this.T]};
      }
    },
    convertBroadcastToSingleSubscriber_closure0: {
      "^": "Closure:8;_box_0,$ti",
      call$0: [function() {
        return this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, null, "call"]
    }
  }], ["service_extensions", "package:devtools/src/service_extensions.dart",, E, {
    "^": "",
    ToggleableServiceExtensionDescription: {
      "^": "Object;extension<,description<,icon<,enabledValue<,disabledValue<,enabledTooltip<,disabledTooltip<,$ti"
    },
    closure: {
      "^": "Closure:154;$ti",
      call$1: [function(extension) {
        return H.stringTypeCheck(extension.get$extension());
      }, null, null, 4, 0, null, 254, "call"]
    },
    closure0: {
      "^": "Closure:155;$ti",
      call$1: [function(extension) {
        return H.interceptedTypeCheck(extension, "$isToggleableServiceExtensionDescription");
      }, null, null, 4, 0, null, 254, "call"]
    }
  }], ["", "package:devtools/src/service_manager.dart",, R, {
    "^": "",
    _getStreamController: [1, function($name, streamControllers, onFirstListenerSubscribed, $T) {
      H.stringTypeCheck($name);
      H.assertSubtype(streamControllers, "$isMap", [P.String, [P.StreamController, $T]], "$asMap");
      streamControllers.putIfAbsent$2($name, new R._getStreamController_closure(H.functionTypeCheck(onFirstListenerSubscribed, {func: 1, ret: -1}), $T));
      return streamControllers.$index(0, $name);
    }, function($name, streamControllers, onFirstListenerSubscribed) {
      return R._getStreamController($name, streamControllers, onFirstListenerSubscribed, null);
    }, null, "call$3$onFirstListenerSubscribed", null, 8, 3, null, 0, 8, 732, 733],
    ServiceConnectionManager: {
      "^": "Object;_stateController,_connectionAvailableController,_connectionClosedController,serviceAvailable<,_serviceRegistrationController<,_registeredMethodsForService<,0_isolateManager,0_serviceExtensionManager,0service<,0vm,0sdkVersion,$ti",
      ServiceConnectionManager$0: [function() {
        var isolateManager, serviceExtensionManager;
        isolateManager = R.IsolateManager$();
        serviceExtensionManager = R.ServiceExtensionManager$();
        isolateManager._serviceExtensionManager = serviceExtensionManager;
        serviceExtensionManager._isolateManager = isolateManager;
        this._isolateManager = isolateManager;
        this._serviceExtensionManager = serviceExtensionManager;
      }, null, null, 0, 0, null],
      get$isolateManager: [function() {
        return this._isolateManager;
      }, null, null, 2, 0, null],
      get$serviceExtensionManager: [function() {
        return this._serviceExtensionManager;
      }, null, null, 2, 0, null],
      get$hasConnection: [function() {
        return this.service != null;
      }, null, null, 2, 0, null],
      get$onStateChange: [function() {
        return J.get$stream$z(this._stateController);
      }, null, null, 2, 0, null],
      get$onConnectionAvailable: [function() {
        return J.get$stream$z(this._connectionAvailableController);
      }, null, null, 2, 0, null],
      get$onConnectionClosed: [function() {
        return J.get$stream$z(this._connectionClosedController);
      }, null, null, 2, 0, null],
      callMulticastService$3$args$isolateId: [function($name, args, isolateId) {
        H.stringTypeCheck($name);
        H.stringTypeCheck(isolateId);
        return this.callMulticastService$body$ServiceConnectionManager($name, H.interceptedTypeCheck(args, "$isMap"), isolateId);
      }, function($name, isolateId) {
        return this.callMulticastService$3$args$isolateId($name, null, isolateId);
      }, "callMulticastService$2$isolateId", null, null, "get$callMulticastService", 4, 5, null, 0, 0, 8, 71, 28],
      callMulticastService$body$ServiceConnectionManager: [function($name, args, isolateId) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.List, S.Response]),
          $async$returnValue, $async$self = this, registered, t1;
        var $async$callMulticastService$3$args$isolateId = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                registered = J.$index$asx($async$self._registeredMethodsForService, $name);
                if (registered == null)
                  registered = C.List_empty1;
                t1 = J.getInterceptor$asx(registered);
                if (t1.get$isNotEmpty(registered)) {
                  $async$returnValue = P.Future_wait(t1.map$1$1(registered, new R.ServiceConnectionManager_callMulticastService_closure($async$self, isolateId, args), [P.Future, S.Response]), null, false, S.Response);
                  // goto return
                  $async$goto = 1;
                  break;
                } else
                  throw H.wrapException(P.Exception_Exception('There are no registered methods for service "' + H.S($name) + '"'));
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$callMulticastService$3$args$isolateId, $async$completer);
      }, null, null, 4, 5, null, 0, 0, 8, 71, 28],
      hasRegisteredService$2: [function($name, onData) {
        var streamController;
        H.stringTypeCheck($name);
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [P.bool]});
        if (this._registeredMethodsForService.containsKey$1($name) && onData != null)
          onData.call$1(true);
        streamController = this._getServiceRegistrationController$1($name);
        return streamController.get$stream(streamController).listen$1(onData);
      }, null, "get$hasRegisteredService", 8, 0, null, 8, 32],
      _getServiceRegistrationController$1: [function($name) {
        H.stringTypeCheck($name);
        return R._getStreamController($name, this._serviceRegistrationController, new R.ServiceConnectionManager__getServiceRegistrationController_closure(this, $name), P.bool);
      }, null, "get$_getServiceRegistrationController", 4, 0, null, 8],
      vmServiceOpened$2$onClosed: [function(service, onClosed) {
        return this.vmServiceOpened$body$ServiceConnectionManager(H.interceptedTypeCheck(service, "$isVmServiceWrapper"), H.assertSubtype(onClosed, "$isFuture", [-1], "$asFuture"));
      }, null, "get$vmServiceOpened", 4, 3, null, 0, 74, 463],
      vmServiceOpened$body$ServiceConnectionManager: [function(service, onClosed) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, vm, t1, t2;
        var $async$vmServiceOpened$2$onClosed = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(service.getVM$0(), $async$vmServiceOpened$2$onClosed);
              case 2:
                // returning from await.
                vm = $async$result;
                $async$self.vm = vm;
                t1 = H.stringTypeCheck(vm.version);
                $async$self.sdkVersion = t1;
                if (J.contains$1$asx(t1, " ")) {
                  t1 = $async$self.sdkVersion;
                  t2 = J.getInterceptor$asx(t1);
                  $async$self.sdkVersion = H.stringTypeCheck(t2.substring$2(t1, 0, t2.indexOf$1(t1, " ")));
                }
                $async$self.service = service;
                J.complete$0$z($async$self.serviceAvailable);
                service.get$onServiceEvent().listen$1(new R.ServiceConnectionManager_vmServiceOpened_closure($async$self));
                $async$self._isolateManager.set$_service_manager$_service(service);
                $async$self._serviceExtensionManager.set$_service_manager$_service(service);
                J.add$1$ax($async$self._stateController, null);
                J.add$1$ax($async$self._connectionAvailableController, service);
                $async$goto = 3;
                return P._asyncAwait($async$self._isolateManager._initIsolates$1(vm.isolates), $async$vmServiceOpened$2$onClosed);
              case 3:
                // returning from await.
                service.get$onIsolateEvent().listen$1($async$self._isolateManager.get$_service_manager$_handleIsolateEvent());
                service.get$onExtensionEvent().listen$1($async$self._serviceExtensionManager.get$_service_manager$_handleExtensionEvent());
                T.unawaited(onClosed.then$1$1(new R.ServiceConnectionManager_vmServiceOpened_closure0($async$self), -1));
                $async$goto = 4;
                return P._asyncAwait(P.Future_wait(C.JSArray_methods.map$1$1(H.setRuntimeTypeInfo(["Stdout", "Stderr", "VM", "Isolate", "Debug", "GC", "Timeline", "Extension", "_Graph", "_Logging", "_Service"], [P.String]), new R.ServiceConnectionManager_vmServiceOpened_closure1(service), [P.Future, S.Success]), null, false, S.Success), $async$vmServiceOpened$2$onClosed);
              case 4:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$vmServiceOpened$2$onClosed, $async$completer);
      }, null, null, 4, 3, null, 0, 74, 463],
      vmServiceClosed$0: [function() {
        this.service = null;
        this.vm = null;
        this.sdkVersion = null;
        J.add$1$ax(this._stateController, null);
        J.add$1$ax(this._connectionClosedController, null);
      }, null, "get$vmServiceClosed", 0, 0, null],
      performHotReload$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$performHotReload$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait($async$self.callMulticastService$2$isolateId("reloadSources", J.get$id$z($async$self._isolateManager.get$selectedIsolate())), $async$performHotReload$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$performHotReload$0, $async$completer);
      }, null, "get$performHotReload", 0, 0, null],
      performHotRestart$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$performHotRestart$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait($async$self.callMulticastService$2$isolateId("hotRestart", J.get$id$z($async$self._isolateManager.get$selectedIsolate())), $async$performHotRestart$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$performHotRestart$0, $async$completer);
      }, null, "get$performHotRestart", 0, 0, null],
      static: {
        ServiceConnectionManager$: [function() {
          var t1, t2;
          t1 = P.Null;
          t2 = P.String;
          t2 = new R.ServiceConnectionManager(P.StreamController_StreamController$broadcast(null, null, false, t1), P.StreamController_StreamController$broadcast(null, null, false, U.VmServiceWrapper), P.StreamController_StreamController$broadcast(null, null, false, t1), P.Completer_Completer(t1), P.LinkedHashMap_LinkedHashMap$_empty(t2, [P.StreamController, P.bool]), P.LinkedHashMap_LinkedHashMap$_empty(t2, [P.List, P.String]), []);
          t2.ServiceConnectionManager$0();
          return t2;
        }, null, null, 0, 0, null]
      }
    },
    ServiceConnectionManager_callMulticastService_closure: {
      "^": "Closure:156;$this,isolateId,args,$ti",
      call$1: [function(method) {
        H.stringTypeCheck(method);
        return this.$this.get$service().callMethod$3$args$isolateId(method, this.args, this.isolateId);
      }, null, null, 4, 0, null, 61, "call"]
    },
    ServiceConnectionManager__getServiceRegistrationController_closure: {
      "^": "Closure:1;$this,name,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = this.name;
        J.add$1$ax(J.$index$asx(t1.get$_serviceRegistrationController(), t2), t1.get$_registeredMethodsForService().containsKey$1(t2));
      }, null, null, 0, 0, null, "call"]
    },
    ServiceConnectionManager_vmServiceOpened_closure: {
      "^": "Closure:23;$this,$ti",
      call$1: [function(e) {
        var t1;
        H.interceptedTypeCheck(e, "$isEvent0");
        if (J.$eq$(e.kind, "ServiceRegistered")) {
          t1 = this.$this;
          if (!t1.get$_registeredMethodsForService().containsKey$1(e.service)) {
            J.$indexSet$ax(t1.get$_registeredMethodsForService(), e.service, H.setRuntimeTypeInfo([e.method], [P.String]));
            t1._getServiceRegistrationController$1(e.service).add$1(0, true);
          } else
            J.add$1$ax(J.$index$asx(t1.get$_registeredMethodsForService(), e.service), e.method);
        }
      }, null, null, 4, 0, null, 19, "call"]
    },
    ServiceConnectionManager_vmServiceOpened_closure0: {
      "^": "Closure:157;$this,$ti",
      call$1: [function(_) {
        return this.$this.vmServiceClosed$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    ServiceConnectionManager_vmServiceOpened_closure1: {
      "^": "Closure:158;service,$ti",
      call$1: [function(id) {
        return this.service.streamListen$1(H.stringTypeCheck(id));
      }, null, null, 4, 0, null, 104, "call"]
    },
    IsolateManager: {
      "^": "Object;_isolates,0_selectedIsolate,0_service_manager$_service,0_serviceExtensionManager,_isolateCreatedController,_isolateExitedController,_selectedIsolateController,$ti",
      set$_isolates: function(_isolates) {
        this._isolates = H.assertSubtype(_isolates, "$isList", [S.IsolateRef], "$asList");
      },
      set$_service_manager$_service: function(_service) {
        this._service_manager$_service = H.interceptedTypeCheck(_service, "$isVmServiceWrapper");
      },
      get$isolates: [function() {
        return P.List_List$unmodifiable(this._isolates, S.IsolateRef);
      }, null, null, 2, 0, null],
      get$selectedIsolate: [function() {
        return this._selectedIsolate;
      }, null, null, 2, 0, null],
      get$onIsolateCreated: [function() {
        return J.get$stream$z(this._isolateCreatedController);
      }, null, null, 2, 0, null],
      get$onSelectedIsolateChanged: [function() {
        return J.get$stream$z(this._selectedIsolateController);
      }, null, null, 2, 0, null],
      get$onIsolateExited: [function() {
        return J.get$stream$z(this._isolateExitedController);
      }, null, null, 2, 0, null],
      selectIsolate$1: [function(isolateRefId) {
        H.stringTypeCheck(isolateRefId);
        this._setSelectedIsolate$1(J.firstWhere$2$orElse$ax(this._isolates, new R.IsolateManager_selectIsolate_closure(isolateRefId), new R.IsolateManager_selectIsolate_closure0()));
      }, null, "get$selectIsolate", 4, 0, null, 735],
      _initIsolates$1: [function(isolates) {
        return this._initIsolates$body$IsolateManager(H.assertSubtype(isolates, "$isList", [S.IsolateRef], "$asList"));
      }, null, "get$_initIsolates", 4, 0, null, 245],
      _initIsolates$body$IsolateManager: [function(isolates) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, t1;
        var $async$_initIsolates$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$self.set$_isolates(isolates);
                $async$goto = 2;
                return P._asyncAwait($async$self._initSelectedIsolate$1(isolates), $async$_initIsolates$1);
              case 2:
                // returning from await.
                t1 = $async$self._selectedIsolate;
                $async$goto = t1 != null ? 3 : 4;
                break;
              case 3:
                // then
                J.add$1$ax($async$self._isolateCreatedController, t1);
                J.add$1$ax($async$self._selectedIsolateController, $async$self._selectedIsolate);
                $async$goto = 5;
                return P._asyncAwait($async$self._serviceExtensionManager._addRegisteredExtensionRPCs$1($async$self._selectedIsolate), $async$_initIsolates$1);
              case 5:
                // returning from await.
              case 4:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_initIsolates$1, $async$completer);
      }, null, null, 4, 0, null, 245],
      _service_manager$_handleIsolateEvent$1: [function($event) {
        return this._handleIsolateEvent$body$IsolateManager(H.interceptedTypeCheck($event, "$isEvent0"));
      }, "call$1", "get$_service_manager$_handleIsolateEvent", 4, 0, 11, 22],
      _handleIsolateEvent$body$IsolateManager: [function($event) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, t1;
        var $async$_service_manager$_handleIsolateEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = J.$eq$($event.kind, "IsolateStart") ? 2 : 4;
                break;
              case 2:
                // then
                J.add$1$ax($async$self._isolates, $event.isolate);
                J.add$1$ax($async$self._isolateCreatedController, $event.isolate);
                if ($async$self._selectedIsolate == null)
                  $async$self._setSelectedIsolate$1($event.isolate);
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $async$goto = J.$eq$($event.kind, "ServiceExtensionAdded") ? 5 : 7;
                break;
              case 5:
                // then
                $async$goto = 8;
                return P._asyncAwait($async$self._serviceExtensionManager._maybeAddServiceExtension$1($event.extensionRPC), $async$_service_manager$_handleIsolateEvent$1);
              case 8:
                // returning from await.
                if ($async$self._selectedIsolate == null && $async$self._isFlutterExtension$1($event.extensionRPC))
                  $async$self._setSelectedIsolate$1($event.isolate);
                // goto join
                $async$goto = 6;
                break;
              case 7:
                // else
                if (J.$eq$($event.kind, "IsolateExit")) {
                  J.remove$1$ax($async$self._isolates, $event.isolate);
                  J.add$1$ax($async$self._isolateExitedController, $event.isolate);
                  if (J.$eq$($async$self._selectedIsolate, $event.isolate)) {
                    t1 = H.interceptedTypeCheck(J.get$isEmpty$asx($async$self._isolates) ? null : J.get$first$ax($async$self._isolates), "$isIsolateRef");
                    $async$self._selectedIsolate = t1;
                    J.add$1$ax($async$self._selectedIsolateController, t1);
                    $async$self._serviceExtensionManager.resetAvailableExtensions$0();
                  }
                }
              case 6:
                // join
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_service_manager$_handleIsolateEvent$1, $async$completer);
      }, null, null, 4, 0, null, 22],
      _isFlutterExtension$1: [function(extensionName) {
        return J.startsWith$1$s(H.stringTypeCheck(extensionName), "ext.flutter.");
      }, null, "get$_isFlutterExtension", 4, 0, null, 737],
      _initSelectedIsolate$1: [function(isolates) {
        return this._initSelectedIsolate$body$IsolateManager(H.assertSubtype(isolates, "$isList", [S.IsolateRef], "$asList"));
      }, null, "get$_initSelectedIsolate", 4, 0, null, 245],
      _initSelectedIsolate$body$IsolateManager: [function(isolates) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, t1, t2, t3, t4, ref, $async$temp1;
        var $async$_initSelectedIsolate$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  t1 = J.getInterceptor$asx(isolates);
                  if (t1.get$isEmpty(isolates)) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  t2 = t1.get$iterator(isolates);
                case 3:
                  // for condition
                  if (!t2.moveNext$0()) {
                    // goto after for
                    $async$goto = 4;
                    break;
                  }
                  t3 = t2.get$current();
                  $async$goto = $async$self._selectedIsolate == null ? 5 : 6;
                  break;
                case 5:
                  // then
                  $async$temp1 = H;
                  $async$goto = 7;
                  return P._asyncAwait($async$self._service_manager$_service.getIsolate$1(t3.id), $async$_initSelectedIsolate$1);
                case 7:
                  // returning from await.
                  t4 = $async$temp1.interceptedTypeCheck($async$result, "$isIsolate").extensionRPCs;
                  if (t4 != null)
                    for (t4 = J.get$iterator$ax(t4); t4.moveNext$0();)
                      if ($async$self._isFlutterExtension$1(t4.get$current())) {
                        $async$self._setSelectedIsolate$1(t3);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                case 6:
                  // join
                  // goto for condition
                  $async$goto = 3;
                  break;
                case 4:
                  // after for
                  ref = t1.firstWhere$2$orElse(isolates, new R.IsolateManager__initSelectedIsolate_closure(), new R.IsolateManager__initSelectedIsolate_closure0());
                  $async$self._setSelectedIsolate$1(ref == null ? t1.get$first(isolates) : ref);
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
        });
        return P._asyncStartSync($async$_initSelectedIsolate$1, $async$completer);
      }, null, null, 4, 0, null, 245],
      _setSelectedIsolate$1: [function(ref) {
        H.interceptedTypeCheck(ref, "$isIsolateRef");
        if (J.$eq$(this._selectedIsolate, ref))
          return;
        this._selectedIsolate = ref;
        J.add$1$ax(this._selectedIsolateController, ref);
      }, null, "get$_setSelectedIsolate", 4, 0, null, 81],
      getSelectedIsolate$1: [function(onData) {
        var t1;
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [S.IsolateRef]});
        t1 = this._selectedIsolate;
        if (t1 != null)
          onData.call$1(t1);
        return J.get$stream$z(this._selectedIsolateController).listen$1(onData);
      }, null, "get$getSelectedIsolate", 4, 0, null, 32],
      static: {
        IsolateManager$: [function() {
          var t1 = S.IsolateRef;
          return new R.IsolateManager(H.setRuntimeTypeInfo([], [t1]), P.StreamController_StreamController$broadcast(null, null, false, t1), P.StreamController_StreamController$broadcast(null, null, false, t1), P.StreamController_StreamController$broadcast(null, null, false, t1), []);
        }, null, null, 0, 0, null]
      }
    },
    IsolateManager_selectIsolate_closure: {
      "^": "Closure:61;isolateRefId,$ti",
      call$1: [function(ref) {
        return J.$eq$(H.interceptedTypeCheck(ref, "$isIsolateRef").id, this.isolateRefId);
      }, null, null, 4, 0, null, 81, "call"]
    },
    IsolateManager_selectIsolate_closure0: {
      "^": "Closure:1;$ti",
      call$0: [function() {
        return;
      }, null, null, 0, 0, null, "call"]
    },
    IsolateManager__initSelectedIsolate_closure: {
      "^": "Closure:61;$ti",
      call$1: [function(ref) {
        return J.contains$1$asx(H.interceptedTypeCheck(ref, "$isIsolateRef").name, ":main(");
      }, null, null, 4, 0, null, 81, "call"]
    },
    IsolateManager__initSelectedIsolate_closure0: {
      "^": "Closure:1;$ti",
      call$0: [function() {
        return;
      }, null, null, 0, 0, null, "call"]
    },
    ServiceExtensionManager: {
      "^": "Object;0_service_manager$_service,0_isolateManager,_firstFrameEventReceived,_serviceExtensionController<,_serviceExtensionStateController<,_serviceExtensions<,_enabledServiceExtensions<,_pendingServiceExtensions,extensionStatesUpdated,$ti",
      set$_service_manager$_service: function(_service) {
        this._service_manager$_service = H.interceptedTypeCheck(_service, "$isVmServiceWrapper");
      },
      set$extensionStatesUpdated: function(extensionStatesUpdated) {
        this.extensionStatesUpdated = H.assertSubtype(extensionStatesUpdated, "$isCompleter", [P.Null], "$asCompleter");
      },
      _service_manager$_handleExtensionEvent$1: [function($event) {
        return this._handleExtensionEvent$body$ServiceExtensionManager(H.interceptedTypeCheck($event, "$isEvent0"));
      }, "call$1", "get$_service_manager$_handleExtensionEvent", 4, 0, 160, 22],
      _handleExtensionEvent$body$ServiceExtensionManager: [function($event) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, t1, t2, $name, valueFromJson, extension, value;
        var $async$_service_manager$_handleExtensionEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
              case 2:
                // switch
                switch ($event.extensionKind) {
                  case "Flutter.FirstFrame":
                    // goto case
                    $async$goto = 4;
                    break;
                  case "Flutter.Frame":
                    // goto case
                    $async$goto = 5;
                    break;
                  case "Flutter.ServiceExtensionStateChanged":
                    // goto case
                    $async$goto = 6;
                    break;
                  default:
                    // goto after switch
                    $async$goto = 3;
                    break;
                }
                break;
              case 4:
                // case
              case 5:
                // case
                $async$goto = 7;
                return P._asyncAwait($async$self._onFrameEventReceived$0(), $async$_service_manager$_handleExtensionEvent$1);
              case 7:
                // returning from await.
                // goto after switch
                $async$goto = 3;
                break;
              case 6:
                // case
                t1 = $event.json;
                t2 = J.getInterceptor$asx(t1);
                $name = J.toString$0$(J.$index$asx(t2.$index(t1, "extensionData"), "extension"));
                valueFromJson = J.toString$0$(J.$index$asx(t2.$index(t1, "extensionData"), "value"));
                extension = J.$index$asx($.$get$toggleableExtensionsWhitelist(), $name);
                $async$goto = extension != null ? 8 : 9;
                break;
              case 8:
                // then
                value = $async$self._getExtensionValueFromJson$2($name, valueFromJson);
                $async$goto = 10;
                return P._asyncAwait($async$self.setServiceExtensionState$4$callExtension($name, J.$eq$(value, extension.enabledValue), value, false), $async$_service_manager$_handleExtensionEvent$1);
              case 10:
                // returning from await.
              case 9:
                // join
                // goto after switch
                $async$goto = 3;
                break;
              case 3:
                // after switch
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_service_manager$_handleExtensionEvent$1, $async$completer);
      }, null, null, 4, 0, null, 22],
      _getExtensionValueFromJson$2: [function($name, valueFromJson) {
        H.stringTypeCheck($name);
        H.stringTypeCheck(valueFromJson);
        switch (J.get$runtimeType$(J.$index$asx($.$get$toggleableExtensionsWhitelist(), $name).get$enabledValue())) {
          case C.Type_bool_lhE:
            return valueFromJson === "true" && true;
          case C.Type_int_tHn:
          case C.Type_double_K1J:
            return P.num_parse(valueFromJson, null);
          default:
            return valueFromJson;
        }
      }, null, "get$_getExtensionValueFromJson", 8, 0, null, 8, 738],
      _onFrameEventReceived$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, t1, t2, t3;
        var $async$_onFrameEventReceived$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._firstFrameEventReceived) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$self._firstFrameEventReceived = true;
                t1 = $async$self._pendingServiceExtensions, t2 = J.getInterceptor$ax(t1), t3 = t2.get$iterator(t1);
              case 3:
                // for condition
                if (!t3.moveNext$0()) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait($async$self._addServiceExtension$1(t3.get$current()), $async$_onFrameEventReceived$0);
              case 5:
                // returning from await.
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
                J.complete$0$z($async$self.extensionStatesUpdated);
                t2.clear$0(t1);
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_onFrameEventReceived$0, $async$completer);
      }, null, "get$_onFrameEventReceived", 0, 0, null],
      _addRegisteredExtensionRPCs$1: [function(isolateRef) {
        return this._addRegisteredExtensionRPCs$body$ServiceExtensionManager(H.interceptedTypeCheck(isolateRef, "$isIsolateRef"));
      }, null, "get$_addRegisteredExtensionRPCs", 4, 0, null, 179],
      _addRegisteredExtensionRPCs$body$ServiceExtensionManager: [function(isolateRef) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, t1, t2, value, didSendFirstFrameEvent, $async$temp1;
        var $async$_addRegisteredExtensionRPCs$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._service_manager$_service;
                if (t1 == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$temp1 = H;
                $async$goto = 3;
                return P._asyncAwait(t1.getIsolate$1(isolateRef.id), $async$_addRegisteredExtensionRPCs$1);
              case 3:
                // returning from await.
                t1 = $async$temp1.interceptedTypeCheck($async$result, "$isIsolate").extensionRPCs;
                $async$goto = t1 != null ? 4 : 5;
                break;
              case 4:
                // then
                t1 = J.get$iterator$ax(t1);
              case 6:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 7;
                  break;
                }
                $async$goto = 8;
                return P._asyncAwait($async$self._maybeAddServiceExtension$1(t1.get$current()), $async$_addRegisteredExtensionRPCs$1);
              case 8:
                // returning from await.
                // goto for condition
                $async$goto = 6;
                break;
              case 7:
                // after for
                if (J.get$isEmpty$asx($async$self._pendingServiceExtensions))
                  J.complete$0$z($async$self.extensionStatesUpdated);
                $async$goto = !$async$self._firstFrameEventReceived ? 9 : 10;
                break;
              case 9:
                // then
                t1 = $async$self.isServiceExtensionAvailable$1("ext.flutter.didSendFirstFrameEvent");
                t2 = $async$self._service_manager$_service;
                $async$goto = t1 ? 11 : 13;
                break;
              case 11:
                // then
                $async$goto = 14;
                return P._asyncAwait(t2.callServiceExtension$2$isolateId("ext.flutter.didSendFirstFrameEvent", J.get$id$z($async$self._isolateManager.get$selectedIsolate())), $async$_addRegisteredExtensionRPCs$1);
              case 14:
                // returning from await.
                value = $async$result;
                didSendFirstFrameEvent = value != null && J.$eq$(J.$index$asx(value.json, "enabled"), "true");
                // goto join
                $async$goto = 12;
                break;
              case 13:
                // else
                $async$goto = 15;
                return P._asyncAwait(B.EvalOnDartLibrary$("package:flutter/src/widgets/binding.dart", t2, null).eval$2$isAlive("WidgetsBinding.instance.debugDidSendFirstFrameEvent", null), $async$_addRegisteredExtensionRPCs$1);
              case 15:
                // returning from await.
                value = $async$result;
                didSendFirstFrameEvent = value != null && J.$eq$(value.valueAsString, "true");
              case 12:
                // join
                $async$goto = didSendFirstFrameEvent ? 16 : 17;
                break;
              case 16:
                // then
                $async$goto = 18;
                return P._asyncAwait($async$self._onFrameEventReceived$0(), $async$_addRegisteredExtensionRPCs$1);
              case 18:
                // returning from await.
              case 17:
                // join
              case 10:
                // join
              case 5:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_addRegisteredExtensionRPCs$1, $async$completer);
      }, null, null, 4, 0, null, 179],
      _maybeAddServiceExtension$1: [function($name) {
        return this._maybeAddServiceExtension$body$ServiceExtensionManager(H.stringTypeCheck($name));
      }, null, "get$_maybeAddServiceExtension", 4, 0, null, 8],
      _maybeAddServiceExtension$body$ServiceExtensionManager: [function($name) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$_maybeAddServiceExtension$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = $async$self._firstFrameEventReceived ? 2 : 4;
                break;
              case 2:
                // then
                $async$goto = 5;
                return P._asyncAwait($async$self._addServiceExtension$1($name), $async$_maybeAddServiceExtension$1);
              case 5:
                // returning from await.
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                J.add$1$ax($async$self._pendingServiceExtensions, $name);
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_maybeAddServiceExtension$1, $async$completer);
      }, null, null, 4, 0, null, 8],
      _addServiceExtension$1: [function($name) {
        return this._addServiceExtension$body$ServiceExtensionManager(H.stringTypeCheck($name));
      }, null, "get$_addServiceExtension", 4, 0, null, 8],
      _addServiceExtension$body$ServiceExtensionManager: [function($name) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, streamController, t1;
        var $async$_addServiceExtension$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                streamController = $async$self._getServiceExtensionController$1($name);
                J.add$1$ax($async$self._serviceExtensions, $name);
                streamController.add$1(0, true);
                $async$goto = 2;
                return P._asyncAwait($async$self._restoreExtensionFromDevice$1($name), $async$_addServiceExtension$1);
              case 2:
                // returning from await.
                t1 = $async$self._enabledServiceExtensions;
                $async$goto = t1.containsKey$1($name) ? 3 : 4;
                break;
              case 3:
                // then
                $async$goto = 5;
                return P._asyncAwait($async$self._service_manager$_callServiceExtension$2($name, J.get$value$x(J.$index$asx(t1, $name))), $async$_addServiceExtension$1);
              case 5:
                // returning from await.
              case 4:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_addServiceExtension$1, $async$completer);
      }, null, null, 4, 0, null, 8],
      _restoreExtensionFromDevice$1: [function($name) {
        return this._restoreExtensionFromDevice$body$ServiceExtensionManager(H.stringTypeCheck($name));
      }, null, "get$_restoreExtensionFromDevice", 4, 0, null, 8],
      _restoreExtensionFromDevice$body$ServiceExtensionManager: [function($name) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, t1, expectedValueType, response;
        var $async$_restoreExtensionFromDevice$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $.$get$toggleableExtensionsWhitelist();
                if (!t1.containsKey$1($name)) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                expectedValueType = J.get$runtimeType$(J.$index$asx(t1, $name).get$enabledValue());
                $async$goto = 3;
                return P._asyncAwait($async$self._service_manager$_service.callServiceExtension$2$isolateId($name, J.get$id$z($async$self._isolateManager.get$selectedIsolate())), $async$_restoreExtensionFromDevice$1);
              case 3:
                // returning from await.
                response = $async$result;
              case 4:
                // switch
                switch (expectedValueType) {
                  case C.Type_bool_lhE:
                    // goto case
                    $async$goto = 6;
                    break;
                  case C.Type_String_k8F:
                    // goto case
                    $async$goto = 7;
                    break;
                  case C.Type_int_tHn:
                    // goto case
                    $async$goto = 8;
                    break;
                  case C.Type_double_K1J:
                    // goto case
                    $async$goto = 9;
                    break;
                  default:
                    // goto default
                    $async$goto = 10;
                    break;
                }
                break;
              case 6:
                // case
                $async$goto = 11;
                return P._asyncAwait($async$self._maybeRestoreExtension$2($name, J.$eq$(J.$index$asx(response.json, "enabled"), "true") && true), $async$_restoreExtensionFromDevice$1);
              case 11:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 7:
                // case
                $async$goto = 12;
                return P._asyncAwait($async$self._maybeRestoreExtension$2($name, H.stringTypeCheck(J.$index$asx(response.json, "value"))), $async$_restoreExtensionFromDevice$1);
              case 12:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 8:
                // case
              case 9:
                // case
                $async$goto = 13;
                return P._asyncAwait($async$self._maybeRestoreExtension$2($name, P.num_parse(H.stringTypeCheck(J.$index$asx(response.json, C.JSString_methods.substring$1($name, J.$add$ansx(J.getInterceptor$s($name).lastIndexOf$1($name, "."), 1)))), null)), $async$_restoreExtensionFromDevice$1);
              case 13:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 10:
                // default
                // goto return
                $async$goto = 1;
                break;
              case 5:
                // after switch
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_restoreExtensionFromDevice$1, $async$completer);
      }, null, null, 4, 0, null, 8],
      _maybeRestoreExtension$2: [function($name, value) {
        return this._maybeRestoreExtension$body$ServiceExtensionManager(H.stringTypeCheck($name), value);
      }, null, "get$_maybeRestoreExtension", 8, 0, null, 8, 1],
      _maybeRestoreExtension$body$ServiceExtensionManager: [function($name, value) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this;
        var $async$_maybeRestoreExtension$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = J.$eq$(value, J.$index$asx($.$get$toggleableExtensionsWhitelist(), $name).get$enabledValue()) ? 2 : 3;
                break;
              case 2:
                // then
                $async$goto = 4;
                return P._asyncAwait($async$self.setServiceExtensionState$4$callExtension($name, true, value, false), $async$_maybeRestoreExtension$2);
              case 4:
                // returning from await.
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_maybeRestoreExtension$2, $async$completer);
      }, null, null, 8, 0, null, 8, 1],
      _service_manager$_callServiceExtension$2: [function($name, value) {
        return this._callServiceExtension$body$ServiceExtensionManager(H.stringTypeCheck($name), value);
      }, null, "get$_service_manager$_callServiceExtension", 8, 0, null, 8, 1],
      _callServiceExtension$body$ServiceExtensionManager: [function($name, value) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$returnValue, $async$self = this, t1, t2;
        var $async$_service_manager$_callServiceExtension$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._service_manager$_service;
                if (t1 == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = typeof value === "boolean" ? 3 : 5;
                break;
              case 3:
                // then
                t2 = J.get$id$z($async$self._isolateManager.get$selectedIsolate());
                $async$goto = 6;
                return P._asyncAwait(t1.callServiceExtension$3$args$isolateId($name, P.LinkedHashMap__makeLiteral(["enabled", value]), t2), $async$_service_manager$_callServiceExtension$2);
              case 6:
                // returning from await.
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$goto = typeof value === "string" ? 7 : 9;
                break;
              case 7:
                // then
                t2 = J.get$id$z($async$self._isolateManager.get$selectedIsolate());
                $async$goto = 10;
                return P._asyncAwait(t1.callServiceExtension$3$args$isolateId($name, P.LinkedHashMap__makeLiteral(["value", value]), t2), $async$_service_manager$_callServiceExtension$2);
              case 10:
                // returning from await.
                // goto join
                $async$goto = 8;
                break;
              case 9:
                // else
                $async$goto = typeof value === "number" ? 11 : 12;
                break;
              case 11:
                // then
                t2 = J.get$id$z($async$self._isolateManager.get$selectedIsolate());
                $async$goto = 13;
                return P._asyncAwait(t1.callServiceExtension$3$args$isolateId($name, P.LinkedHashMap__makeLiteral([C.JSString_methods.substring$1($name, J.$add$ansx(J.getInterceptor$s($name).lastIndexOf$1($name, "."), 1)), value]), t2), $async$_service_manager$_callServiceExtension$2);
              case 13:
                // returning from await.
              case 12:
                // join
              case 8:
                // join
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_service_manager$_callServiceExtension$2, $async$completer);
      }, null, null, 8, 0, null, 8, 1],
      resetAvailableExtensions$0: [function() {
        this.set$extensionStatesUpdated(P.Completer_Completer(P.Null));
        this._firstFrameEventReceived = false;
        J.clear$0$ax(this._serviceExtensions);
        J.forEach$1$ax(this._serviceExtensionController, new R.ServiceExtensionManager_resetAvailableExtensions_closure());
      }, null, "get$resetAvailableExtensions", 0, 0, null],
      setServiceExtensionState$4$callExtension: [function($name, enabled, value, callExtension) {
        return this.setServiceExtensionState$body$ServiceExtensionManager(H.stringTypeCheck($name), H.boolTypeCheck(enabled), value, H.boolTypeCheck(callExtension));
      }, function($name, enabled, value) {
        return this.setServiceExtensionState$4$callExtension($name, enabled, value, true);
      }, "setServiceExtensionState$3", null, null, "get$setServiceExtensionState", 12, 3, null, 27, 8, 211, 1, 464],
      setServiceExtensionState$body$ServiceExtensionManager: [function($name, enabled, value, callExtension) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, t1;
        var $async$setServiceExtensionState$4$callExtension = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = callExtension ? 2 : 3;
                break;
              case 2:
                // then
                $async$goto = 4;
                return P._asyncAwait($async$self._service_manager$_callServiceExtension$2($name, value), $async$setServiceExtensionState$4$callExtension);
              case 4:
                // returning from await.
              case 3:
                // join
                $async$self._getServiceExtensionStateController$1($name).add$1(0, R.ServiceExtensionState$(enabled, value));
                t1 = $async$self._enabledServiceExtensions;
                if (enabled)
                  J.$indexSet$ax(t1, $name, R.ServiceExtensionState$(true, value));
                else
                  J.remove$1$ax(t1, $name);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$setServiceExtensionState$4$callExtension, $async$completer);
      }, null, null, 12, 3, null, 27, 8, 211, 1, 464],
      isServiceExtensionAvailable$1: [function($name) {
        H.stringTypeCheck($name);
        return J.contains$1$asx(this._serviceExtensions, $name) || J.contains$1$asx(this._pendingServiceExtensions, $name);
      }, null, "get$isServiceExtensionAvailable", 4, 0, null, 8],
      hasServiceExtension$2: [function($name, onData) {
        var streamController;
        H.stringTypeCheck($name);
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [P.bool]});
        if (J.contains$1$asx(this._serviceExtensions, $name) && onData != null)
          onData.call$1(true);
        streamController = this._getServiceExtensionController$1($name);
        return streamController.get$stream(streamController).listen$1(onData);
      }, null, "get$hasServiceExtension", 8, 0, null, 8, 32],
      getServiceExtensionState$2: [function($name, onData) {
        var t1, streamController;
        H.stringTypeCheck($name);
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [R.ServiceExtensionState]});
        t1 = this._enabledServiceExtensions;
        if (t1.containsKey$1($name) && onData != null)
          onData.call$1(J.$index$asx(t1, $name));
        streamController = this._getServiceExtensionStateController$1($name);
        return streamController.get$stream(streamController).listen$1(onData);
      }, null, "get$getServiceExtensionState", 8, 0, null, 8, 32],
      _getServiceExtensionController$1: [function($name) {
        H.stringTypeCheck($name);
        return R._getStreamController($name, this._serviceExtensionController, new R.ServiceExtensionManager__getServiceExtensionController_closure(this, $name), P.bool);
      }, null, "get$_getServiceExtensionController", 4, 0, null, 8],
      _getServiceExtensionStateController$1: [function($name) {
        H.stringTypeCheck($name);
        return R._getStreamController($name, this._serviceExtensionStateController, new R.ServiceExtensionManager__getServiceExtensionStateController_closure(this, $name), R.ServiceExtensionState);
      }, null, "get$_getServiceExtensionStateController", 4, 0, null, 8],
      static: {
        ServiceExtensionManager$: [function() {
          var t1 = P.String;
          return new R.ServiceExtensionManager(false, P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.StreamController, P.bool]), P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.StreamController, R.ServiceExtensionState]), P.LinkedHashSet_LinkedHashSet(null, null, null, t1), P.LinkedHashMap_LinkedHashMap$_empty(t1, R.ServiceExtensionState), P.LinkedHashSet_LinkedHashSet(null, null, null, t1), P.Completer_Completer(P.Null), []);
        }, null, null, 0, 0, null]
      }
    },
    ServiceExtensionManager_resetAvailableExtensions_closure: {
      "^": "Closure:161;$ti",
      call$2: [function($name, stream) {
        H.stringTypeCheck($name);
        H.assertSubtype(stream, "$isStreamController", [P.bool], "$asStreamController").add$1(0, false);
      }, null, null, 8, 0, null, 8, 57, "call"]
    },
    ServiceExtensionManager__getServiceExtensionController_closure: {
      "^": "Closure:1;$this,name,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = this.name;
        J.add$1$ax(J.$index$asx(t1.get$_serviceExtensionController(), t2), J.contains$1$asx(t1.get$_serviceExtensions(), t2));
      }, null, null, 0, 0, null, "call"]
    },
    ServiceExtensionManager__getServiceExtensionStateController_closure: {
      "^": "Closure:1;$this,name,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.$this;
        t2 = this.name;
        if (t1.get$_enabledServiceExtensions().containsKey$1(t2))
          J.add$1$ax(J.$index$asx(t1.get$_serviceExtensionStateController(), t2), J.$index$asx(t1.get$_enabledServiceExtensions(), t2));
        else
          J.add$1$ax(J.$index$asx(t1.get$_serviceExtensionStateController(), t2), R.ServiceExtensionState$(false, null));
      }, null, null, 0, 0, null, "call"]
    },
    _getStreamController_closure: {
      "^": "Closure;onFirstListenerSubscribed,T,$ti",
      call$0: [function() {
        return P.StreamController_StreamController$broadcast(null, this.onFirstListenerSubscribed, false, this.T);
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        return {func: 1, ret: [P.StreamController, this.T]};
      }
    },
    ServiceExtensionState: {
      "^": "Object;enabled,value>,$ti",
      ServiceExtensionState$2: [function(enabled, value) {
      }, null, null, 8, 0, null, 211, 1],
      static: {
        ServiceExtensionState$: [function(enabled, value) {
          var t1 = new R.ServiceExtensionState(enabled, value, []);
          t1.ServiceExtensionState$2(enabled, value);
          return t1;
        }, null, null, 8, 0, null, 211, 1]
      }
    }
  }], ["", "package:devtools/src/service_registrations.dart",, F, {
    "^": "",
    RegisteredServiceDescription: {
      "^": "Object;$ti"
    }
  }], ["", "package:devtools/src/tables.dart",, Q, {
    "^": "",
    Column_fastIntl: [function(value) {
      H.intTypeCheck(value);
      if (typeof value === "number" && Math.floor(value) === value && value < 1000)
        return J.toString$0$(value);
      else
        return $.$get$nf().format$1(value);
    }, null, null, 4, 0, null, 1],
    Table: {
      "^": "_Table_Object_SetStateMixin;0_visibilityObserver,element<,_isVirtual,rowHeight,_hasPendingRebuild,columns,0data>,0_sortColumn,0_sortDirection<,_table,0_thead,0_tbody,0_spacerBeforeVisibleRows,0_spacerAfterVisibleRows,_dummyRowToForceAlternatingColor,_spanForColumn<,_dataForRow<,_rowForIndex,_selectController,_rowsChangedController,0_selectedObject,0_selectedObjectIndex<,$ti",
      set$_hasPendingRebuild: function(_hasPendingRebuild) {
        this._hasPendingRebuild = H.boolTypeCheck(_hasPendingRebuild);
      },
      set$data: function(_, data) {
        this.data = H.assertSubtype(data, "$isList", this.$ti, "$asList");
      },
      set$_sortColumn: function(_sortColumn) {
        this._sortColumn = H.assertSubtype(_sortColumn, "$isColumn", this.$ti, "$asColumn");
      },
      set$_selectedObject: function(_selectedObject) {
        this._selectedObject = H.assertSubtypeOfRuntimeType(_selectedObject, H.getTypeArgumentByIndex(this, 0));
      },
      Table$virtual$1$rowHeight: [function(rowHeight, $T) {
        var t1, t2;
        this._init$0();
        this._spacerBeforeVisibleRows = A.CoreElement$("tr", null, null, null);
        this._spacerAfterVisibleRows = A.CoreElement$("tr", null, null, null);
        t1 = this.element;
        t2 = H.interceptedTypeCheck(W.IntersectionObserver_IntersectionObserver(P.allowInterop(this.get$_visibilityChange(), {func: 1, ret: -1, args: [[P.List,,], W.IntersectionObserver]}), P.LinkedHashMap__makeLiteral(["root", t1.get$element()])), "$isIntersectionObserver");
        this._visibilityObserver = t2;
        (t2 && C.IntersectionObserver_methods).observe$1(t2, this._spacerBeforeVisibleRows.get$element());
        J.observe$1$x(this._visibilityObserver, this._spacerAfterVisibleRows.get$element());
        J.get$onScroll$x(t1).listen$1(new Q.Table$virtual_closure(this));
      }, null, null, 0, 3, null, 465, 466],
      get$rowCount: [function() {
        var t1 = this.data;
        t1 = t1 == null ? null : J.get$length$asx(t1);
        return t1 == null ? 0 : t1;
      }, null, null, 2, 0, null],
      _init$0: [function() {
        var t1 = this._table;
        J.add$1$ax(this.element, t1);
        J.get$onKeyDown$x(t1).listen$1(new Q.Table__init_closure(this));
      }, null, "get$_init", 0, 0, null],
      dispose$0: [function() {
        J.disconnect$0$x(this._visibilityObserver);
      }, null, "get$dispose", 0, 0, null],
      get$onSelect: [function(_) {
        return J.get$stream$z(this._selectController);
      }, null, null, 3, 0, null],
      get$onRowsChanged: [function() {
        return J.get$stream$z(this._rowsChangedController);
      }, null, null, 2, 0, null],
      addColumn$1: [function(column) {
        J.add$1$ax(this.columns, H.assertSubtype(column, "$isColumn", this.$ti, "$asColumn"));
      }, null, "get$addColumn", 4, 0, null, 99],
      setRows$1: [function(data) {
        var t1, t2, column;
        H.assertSubtype(data, "$isList", this.$ti, "$asList");
        t1 = J.getInterceptor$asx(data);
        if (!t1.contains$1(data, this._selectedObject))
          this._clearSelection$0();
        this.set$data(0, t1.toList$0(data));
        J.add$1$ax(this._rowsChangedController, null);
        if (this._thead == null) {
          t1 = A.CoreElement$("thead", null, null, null);
          t2 = A.tr();
          J.add$1$ax(t2, J.map$1$1$ax(this.columns, new Q.Table_setRows_closure(this), A.CoreElement));
          t1.add$1(0, t2);
          this._thead = t1;
          J.add$1$ax(this._table, t1);
        }
        if (this._tbody == null) {
          t1 = A.CoreElement$("tbody", null, "selectable", null);
          this._tbody = t1;
          J.add$1$ax(this._table, t1);
        }
        if (this._sortColumn == null) {
          column = J.firstWhere$2$orElse$ax(this.columns, new Q.Table_setRows_closure0(this), new Q.Table_setRows_closure1());
          if (column != null)
            this.setSortColumn$1(column);
        }
        if (this._sortColumn != null)
          this._doSort$0();
        this._scheduleRebuild$0();
      }, null, "get$setRows", 4, 0, null, 34],
      scrollTo$2$scrollBehavior: [function(_, row, scrollBehavior) {
        var index;
        H.assertSubtypeOfRuntimeType(row, H.getTypeArgumentByIndex(this, 0));
        H.stringTypeCheck(scrollBehavior);
        index = J.indexOf$1$asx(this.data, row);
        if (index === -1)
          return;
        if (this._hasPendingRebuild) {
          this.setState$1(new Q.Table_scrollTo_closure(this, index, scrollBehavior));
          return;
        }
        this._scrollToIndex$2$scrollBehavior(index, scrollBehavior);
      }, function($receiver, row) {
        return this.scrollTo$2$scrollBehavior($receiver, row, "smooth");
      }, "scrollTo$1", null, null, "get$scrollTo", 5, 3, null, 309, 152, 310],
      _scheduleRebuild$0: [function() {
        if (!this._hasPendingRebuild) {
          this._hasPendingRebuild = true;
          this.setState$1(new Q.Table__scheduleRebuild_closure(this));
        }
      }, null, "get$_scheduleRebuild", 0, 0, null],
      _doSort$0: [function() {
        var column, numeric, direction, t1, t2, t3, t4, s, t5;
        column = this._sortColumn;
        numeric = column.get$numeric();
        direction = J.$eq$(this._sortDirection, C.SortOrder_0) ? 1 : -1;
        for (t1 = J.get$iterator$ax(this.columns), t2 = this._spanForColumn, t3 = J.getInterceptor$asx(t2); t1.moveNext$0();) {
          t4 = t1.get$current();
          s = t3.$index(t2, t4);
          t5 = this._sortColumn;
          if (t4 == null ? t5 == null : t4 === t5) {
            s.toggleClass$2("up", J.$eq$(this._sortDirection, C.SortOrder_0));
            s.toggleClass$2("down", !J.$eq$(this._sortDirection, C.SortOrder_0));
          } else {
            s.toggleClass$2("up", false);
            s.toggleClass$2("down", false);
          }
        }
        J.sort$1$ax(this.data, new Q.Table__doSort_closure(this, numeric, column, direction));
      }, null, "get$_doSort", 0, 0, null],
      _rebuildTable$0: [function() {
        if (this.data == null)
          return;
        if (this._isVirtual)
          this._rebuildVirtualTable$0();
        else
          this._rebuildStaticTable$0();
      }, null, "get$_rebuildTable", 0, 0, null],
      _rebuildVirtualTable$0: [function() {
        var t1, totalRows, t2, t3, firstVisibleRow, numVisibleRows, firstRenderedRowInclusive, lastRenderedRowExclusive, spacerBeforeHeight, currentRowIndex, spacerAfterHeight;
        t1 = this.data;
        t1 == null;
        t1 = this.data;
        totalRows = t1 == null ? null : J.get$length$asx(t1);
        if (totalRows == null)
          totalRows = 0;
        t1 = this.element;
        t2 = J.getInterceptor$x(t1);
        t3 = this.rowHeight;
        firstVisibleRow = J.floor$0$n(J.$div$n(J.$sub$n(t2.get$scrollTop(t1), J.get$offsetHeight$x(this._thead)), t3));
        numVisibleRows = J.$add$ansx(J.ceil$0$n(J.$div$n(t2.get$offsetHeight(t1), t3)), 1);
        if (typeof numVisibleRows !== "number")
          return numVisibleRows.$add();
        firstRenderedRowInclusive = H.intTypeCheck(J.clamp$2$n(firstVisibleRow, 0, H.intTypeCheck(C.JSInt_methods.clamp$2(totalRows - (numVisibleRows + 1), 0, totalRows))));
        if (typeof firstRenderedRowInclusive !== "number")
          return firstRenderedRowInclusive.$add();
        lastRenderedRowExclusive = H.intTypeCheck(C.JSInt_methods.clamp$2(firstRenderedRowInclusive + numVisibleRows + 2, 0, totalRows));
        if (typeof t3 !== "number")
          return H.iae(t3);
        spacerBeforeHeight = firstRenderedRowInclusive * t3;
        J.set$height$x(this._spacerBeforeVisibleRows, H.S(spacerBeforeHeight) + "px");
        t1 = this._spacerBeforeVisibleRows;
        J.set$display$x(t1, spacerBeforeHeight === 0 ? "none" : null);
        if (J.get$isEmpty$asx(J.get$children$x(this._tbody.get$element())) || !J.$eq$(J.get$first$ax(J.get$children$x(this._tbody.get$element())), this._spacerBeforeVisibleRows.get$element()))
          J.insert$2$ax(J.get$children$x(this._tbody.get$element()), 0, this._spacerBeforeVisibleRows.get$element());
        if (J.get$isNotEmpty$asx(J.get$children$x(this._tbody.get$element())) && J.$eq$(J.get$last$ax(J.get$children$x(this._tbody.get$element())), this._spacerAfterVisibleRows.get$element()))
          J.removeLast$0$ax(J.get$children$x(this._tbody.get$element()));
        currentRowIndex = this._buildTableRows$3$currentRowIndex$firstRenderedRowInclusive$lastRenderedRowExclusive(1, firstRenderedRowInclusive, lastRenderedRowExclusive);
        if (typeof currentRowIndex !== "number")
          return currentRowIndex.$gt();
        if (currentRowIndex > 0) {
          t1 = J.get$length$asx(J.get$children$x(this._tbody.get$element()));
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = currentRowIndex < t1;
        } else
          t1 = false;
        if (t1)
          for (; J.$ge$n(J.get$length$asx(J.get$children$x(this._tbody.get$element())), currentRowIndex);)
            J.removeLast$0$ax(J.get$children$x(this._tbody.get$element()));
        spacerAfterHeight = J.$mul$ns(J.$sub$n(J.get$length$asx(this.data), lastRenderedRowExclusive), t3);
        J.set$height$x(this._spacerAfterVisibleRows, H.S(spacerAfterHeight) + "px");
        J.add$1$ax(J.get$children$x(this._tbody.get$element()), this._spacerAfterVisibleRows.get$element());
      }, null, "get$_rebuildVirtualTable", 0, 0, null],
      _rebuildStaticTable$0: [function() {
        var t1 = this.data;
        t1 = t1 == null ? null : J.get$length$asx(t1);
        return this._buildTableRows$2$firstRenderedRowInclusive$lastRenderedRowExclusive(0, t1 == null ? 0 : t1);
      }, null, "get$_rebuildStaticTable", 0, 0, null],
      _buildTableRows$3$currentRowIndex$firstRenderedRowInclusive$lastRenderedRowExclusive: [function(currentRowIndex, firstRenderedRowInclusive, lastRenderedRowExclusive) {
        var t1, t2, t3, t4, t5, t6, t7, t8, index, dataObject, t9, isReusableRow, tableRow, t10, t11, currentColumnIndex, t12, t13, t14, isReusableColumn, tableCell;
        H.intTypeCheck(firstRenderedRowInclusive);
        H.intTypeCheck(lastRenderedRowExclusive);
        H.intTypeCheck(currentRowIndex);
        t1 = this._dummyRowToForceAlternatingColor;
        J.remove$1$ax(J.get$children$x(this._tbody.get$element()), t1.get$element());
        if (typeof firstRenderedRowInclusive !== "number")
          return firstRenderedRowInclusive.$mod();
        if (C.JSInt_methods.$mod(firstRenderedRowInclusive, 2) === 1) {
          J.insert$2$ax(J.get$children$x(this._tbody.get$element()), 0, t1.get$element());
          if (typeof currentRowIndex !== "number")
            return currentRowIndex.$add();
          ++currentRowIndex;
        }
        t1 = this._rowForIndex;
        t2 = J.getInterceptor$ax(t1);
        t2.clear$0(t1);
        if (typeof lastRenderedRowExclusive !== "number")
          return H.iae(lastRenderedRowExclusive);
        t3 = this.columns;
        t4 = J.getInterceptor$ax(t3);
        t5 = this.rowHeight;
        t6 = t5 != null;
        t7 = this._dataForRow;
        t8 = J.getInterceptor$ax(t7);
        index = firstRenderedRowInclusive;
        for (; index < lastRenderedRowExclusive; ++index) {
          dataObject = J.$index$asx(this.data, index);
          t9 = J.get$length$asx(J.get$children$x(this._tbody.get$element()));
          if (typeof currentRowIndex !== "number")
            return currentRowIndex.$lt();
          if (typeof t9 !== "number")
            return H.iae(t9);
          isReusableRow = currentRowIndex < t9;
          tableRow = isReusableRow ? A.CoreElement$from(J.$index$asx(J.get$children$x(this._tbody.get$element()), currentRowIndex)) : A.tr();
          ++currentRowIndex;
          t9 = tableRow.element;
          t8.$indexSet(t7, t9, dataObject);
          t2.$indexSet(t1, index, tableRow);
          t10 = !isReusableRow;
          if (t10)
            tableRow.click$1(0, new Q.Table__buildTableRows_closure(new Q.Table__buildTableRows_selectRow(this), tableRow, index));
          if (t6) {
            tableRow.set$height(0, H.S(t5) + "px");
            tableRow.clazz$1("overflow-y");
          }
          for (t11 = t4.get$iterator(t3), currentColumnIndex = 0; t11.moveNext$0();) {
            t12 = t11.get$current();
            t13 = J.getInterceptor$x(t9);
            t14 = J.get$length$asx(t13.get$children(t9));
            if (typeof t14 !== "number")
              return H.iae(t14);
            isReusableColumn = currentColumnIndex < t14;
            tableCell = isReusableColumn ? A.CoreElement$from(J.$index$asx(t13.get$children(t9), currentColumnIndex)) : A.td(null, null);
            ++currentColumnIndex;
            J.clear$0$ax(J.get$classes$x(tableCell.element));
            if (t12.get$cssClass() != null)
              J.forEach$1$ax(J.split$1$s(t12.get$cssClass(), " "), tableCell.get$clazz());
            if (t12.get$numeric())
              tableCell.clazz$1("right");
            t12.renderToElement$2(tableCell, dataObject);
            if (!isReusableColumn)
              tableRow.add$1(0, tableCell);
          }
          if (J.$eq$(dataObject, this._selectedObject))
            this._select$3(t9, this._selectedObject, index);
          else
            J.remove$1$ax(J.get$classes$x(t9), "selected");
          if (t10)
            J.add$1$ax(J.get$children$x(this._tbody.get$element()), t9);
        }
        return currentRowIndex;
      }, function(firstRenderedRowInclusive, lastRenderedRowExclusive) {
        return this._buildTableRows$3$currentRowIndex$firstRenderedRowInclusive$lastRenderedRowExclusive(0, firstRenderedRowInclusive, lastRenderedRowExclusive);
      }, "_buildTableRows$2$firstRenderedRowInclusive$lastRenderedRowExclusive", null, null, "get$_buildTableRows", 0, 7, null, 16, 0, 0, 744, 745, 746],
      _select$3: [function(row, object, index) {
        var t1;
        H.interceptedTypeCheck(row, "$isElement");
        H.assertSubtypeOfRuntimeType(object, H.getTypeArgumentByIndex(this, 0));
        H.intTypeCheck(index);
        t1 = this._tbody;
        if (t1 != null)
          for (t1 = J.get$iterator$ax(J.querySelectorAll$1$1$x(t1.get$element(), ".selected", W.Element)); t1.moveNext$0();)
            J.remove$1$ax(J.get$classes$x(t1.get$current()), "selected");
        if (row != null)
          J.add$1$ax(J.get$classes$x(row), "selected");
        if (!J.$eq$(this._selectedObject, object))
          J.add$1$ax(this._selectController, object);
        this.set$_selectedObject(object);
        this._selectedObjectIndex = index;
      }, null, "get$_select", 12, 0, null, 152, 9, 6],
      selectByIndex$3$keepVisible$scrollBehavior: [function(newIndex, keepVisible, scrollBehavior) {
        var row, dataObject;
        H.intTypeCheck(newIndex);
        H.boolTypeCheck(keepVisible);
        H.stringTypeCheck(scrollBehavior);
        row = J.$index$asx(this._rowForIndex, newIndex);
        dataObject = J.$index$asx(this.data, newIndex);
        this._select$3(row == null ? null : row.element, dataObject, newIndex);
        if (keepVisible)
          this._scrollToIndex$2$scrollBehavior(newIndex, scrollBehavior);
      }, function(newIndex) {
        return this.selectByIndex$3$keepVisible$scrollBehavior(newIndex, true, "smooth");
      }, "selectByIndex$1", null, null, "get$selectByIndex", 4, 5, null, 27, 309, 747, 748, 310],
      _scrollToIndex$2$scrollBehavior: [function(rowIndex, scrollBehavior) {
        var rowOffsetPixels, t1, t2, visibleStartOffsetPixels, visibleEndOffsetPixels, t3, halfTableHeight, newScrollTop;
        H.intTypeCheck(rowIndex);
        H.stringTypeCheck(scrollBehavior);
        rowOffsetPixels = this._rowOffset$1(rowIndex);
        t1 = this.element;
        t2 = J.getInterceptor$x(t1);
        visibleStartOffsetPixels = t2.get$scrollTop(t1);
        visibleEndOffsetPixels = J.$add$ansx(t2.get$scrollTop(t1), t2.get$offsetHeight(t1));
        t3 = this.rowHeight;
        if (typeof visibleStartOffsetPixels !== "number")
          return visibleStartOffsetPixels.$add();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (typeof visibleEndOffsetPixels !== "number")
          return visibleEndOffsetPixels.$sub();
        if (typeof rowOffsetPixels !== "number")
          return rowOffsetPixels.$ge();
        if (rowOffsetPixels >= visibleStartOffsetPixels + t3 && rowOffsetPixels <= visibleEndOffsetPixels - t3 * 2)
          return;
        halfTableHeight = J.$div$n(t2.get$offsetHeight(t1), 2);
        if (typeof halfTableHeight !== "number")
          return H.iae(halfTableHeight);
        newScrollTop = H.intTypeCheck(J.clamp$2$n(C.JSNumber_methods.round$0(rowOffsetPixels - halfTableHeight), 0, t2.get$scrollHeight(t1)));
        J.scrollTo$1$x(t1.get$element(), P.LinkedHashMap_LinkedHashMap$_literal(["left", 0, "top", newScrollTop, "behavior", scrollBehavior], P.String, null));
      }, null, "get$_scrollToIndex", 4, 3, null, 309, 468, 310],
      _rowOffset$1: [function(rowIndex) {
        var t1, t2;
        H.intTypeCheck(rowIndex);
        t1 = this.rowHeight;
        if (typeof rowIndex !== "number")
          return rowIndex.$mul();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = J.get$offsetHeight$x(this._thead);
        if (typeof t2 !== "number")
          return H.iae(t2);
        return rowIndex * t1 + t2;
      }, null, "get$_rowOffset", 4, 0, null, 468],
      _clearSelection$0: [function() {
        return this._select$3(null, null, null);
      }, null, "get$_clearSelection", 0, 0, null],
      setSortColumn$1: [function(column) {
        H.assertSubtype(column, "$isColumn", this.$ti, "$asColumn");
        this.set$_sortColumn(column);
        this._sortDirection = column.get$numeric() ? C.SortOrder_1 : C.SortOrder_0;
      }, null, "get$setSortColumn", 4, 0, null, 99],
      _columnClicked$1: [function(column) {
        H.assertSubtype(column, "$isColumn", this.$ti, "$asColumn");
        if (!column.get$supportsSorting())
          return;
        if (J.$eq$(this._sortColumn, column))
          this._sortDirection = J.$eq$(this._sortDirection, C.SortOrder_0) ? C.SortOrder_1 : C.SortOrder_0;
        else
          this.setSortColumn$1(column);
        this._doSort$0();
        this._scheduleRebuild$0();
      }, null, "get$_columnClicked", 4, 0, null, 99],
      _visibilityChange$2: [function(entries, observer) {
        H.listTypeCheck(entries);
        H.interceptedTypeCheck(observer, "$isIntersectionObserver");
        this._scheduleRebuild$0();
      }, "call$2", "get$_visibilityChange", 8, 0, 62, 206, 469],
      $isSetStateMixin: 1,
      static: {
        Table$virtual: [function(rowHeight, $T) {
          var t1, t2, t3, t4, t5, t6, t7, t8;
          t1 = [Q.Column, $T];
          t2 = H.setRuntimeTypeInfo([], [t1]);
          t3 = A.CoreElement$("table", null, null, null);
          t3.clazz$1("full-width");
          t3.setAttribute$2(0, "tabIndex", "0");
          t4 = A.CoreElement$("tr", null, null, null);
          t4.set$display(0, "none");
          t5 = A.CoreElement;
          t1 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t5);
          t6 = P.LinkedHashMap_LinkedHashMap$_empty(W.Element, $T);
          t5 = P.LinkedHashMap_LinkedHashMap$_empty(P.int, t5);
          t7 = P.StreamController_StreamController$broadcast(null, null, false, $T);
          t8 = P.StreamController_StreamController$broadcast(null, null, false, P.Null);
          t8 = new Q.Table(A.div("flex", "overflow-y table-border table-virtual", null), true, rowHeight, false, t2, t3, t4, t1, t6, t5, t7, t8, [$T]);
          t8.Table$virtual$1$rowHeight(rowHeight, $T);
          return t8;
        }, null, null, 0, 3, null, 465, 466]
      }
    },
    Table$virtual_closure: {
      "^": "Closure:58;$this,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isEvent");
        return this.$this._rebuildTable$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    Table__init_closure: {
      "^": "Closure:163;$this,$ti",
      call$1: [function(e) {
        var t1, indexOffset, currentIndex, newIndex, t2;
        H.interceptedTypeCheck(e, "$isKeyboardEvent");
        t1 = e.keyCode;
        if (t1 === 38)
          indexOffset = -1;
        else {
          if (!(t1 === 40))
            return;
          indexOffset = 1;
        }
        e.preventDefault();
        t1 = this.$this;
        currentIndex = t1.get$_selectedObjectIndex();
        newIndex = currentIndex == null ? 0 : currentIndex + indexOffset;
        t2 = J.get$data$x(t1);
        t2 = t2 == null ? null : J.get$length$asx(t2);
        t1.selectByIndex$1(H.intTypeCheck(C.JSInt_methods.clamp$2(newIndex, 0, J.$sub$n(t2 == null ? 1 : t2, 1))));
      }, null, null, 4, 0, null, 19, "call"]
    },
    Table_setRows_closure: {
      "^": "Closure;$this,$ti",
      call$1: [function(column) {
        var t1, t2, s, header;
        t1 = this.$this;
        H.assertSubtype(column, "$isColumn", [H.getTypeArgumentByIndex(t1, 0)], "$asColumn");
        t2 = column.title;
        s = A.span(null, "interactable" + (column.get$supportsSorting() ? " sortable" : ""), t2);
        s.click$1(0, new Q.Table_setRows__closure(t1, column));
        J.$indexSet$ax(t1.get$_spanForColumn(), column, s);
        header = A.th(column.get$numeric() ? "right" : "left", null);
        J.add$1$ax(header, s);
        if (column.wide)
          header.clazz$1("wide");
        return header;
      }, null, null, 4, 0, null, 99, "call"],
      $signature: function() {
        return {func: 1, ret: A.CoreElement, args: [[Q.Column, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    Table_setRows__closure: {
      "^": "Closure:0;$this,column,$ti",
      call$0: [function() {
        return this.$this._columnClicked$1(this.column);
      }, null, null, 0, 0, null, "call"]
    },
    Table_setRows_closure0: {
      "^": "Closure;$this,$ti",
      call$1: [function(c) {
        return H.assertSubtype(c, "$isColumn", [H.getTypeArgumentByIndex(this.$this, 0)], "$asColumn").get$supportsSorting();
      }, null, null, 4, 0, null, 70, "call"],
      $signature: function() {
        return {func: 1, ret: P.bool, args: [[Q.Column, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    Table_setRows_closure1: {
      "^": "Closure:1;$ti",
      call$0: [function() {
        return;
      }, null, null, 0, 0, null, "call"]
    },
    Table_scrollTo_closure: {
      "^": "Closure:1;$this,index,scrollBehavior,$ti",
      call$0: [function() {
        this.$this._scrollToIndex$2$scrollBehavior(this.index, this.scrollBehavior);
      }, null, null, 0, 0, null, "call"]
    },
    Table__scheduleRebuild_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.set$_hasPendingRebuild(false);
        t1._rebuildTable$0();
      }, null, null, 0, 0, null, "call"]
    },
    Table__doSort_closure: {
      "^": "Closure;$this,numeric,column,direction,$ti",
      call$2: [function(a, b) {
        var t1, t2, one, two;
        t1 = this.$this;
        t2 = H.getTypeArgumentByIndex(t1, 0);
        H.assertSubtypeOfRuntimeType(a, t2);
        H.assertSubtypeOfRuntimeType(b, t2);
        t2 = this.column;
        if (this.numeric) {
          one = H.numTypeCheck(t2.getValue$1(a));
          two = H.numTypeCheck(t2.getValue$1(b));
          if (one == two)
            return 0;
          if (J.$eq$(t1.get$_sortDirection(), C.SortOrder_0)) {
            if (typeof one !== "number")
              return one.$gt();
            if (typeof two !== "number")
              return H.iae(two);
            return one > two ? 1 : -1;
          } else {
            if (typeof one !== "number")
              return one.$gt();
            if (typeof two !== "number")
              return H.iae(two);
            return one > two ? -1 : 1;
          }
        } else
          return J.$mul$ns(J.compareTo$1$ns(t2.render$1(t2.getValue$1(a)), t2.render$1(t2.getValue$1(b))), this.direction);
      }, null, null, 8, 0, null, 33, 54, "call"],
      $signature: function() {
        var t1 = H.getTypeArgumentByIndex(this.$this, 0);
        return {func: 1, ret: P.int, args: [t1, t1]};
      }
    },
    Table__buildTableRows_selectRow: {
      "^": "Closure:164;$this,$ti",
      call$2: [function(row, index) {
        var t1;
        H.interceptedTypeCheck(row, "$isElement");
        H.intTypeCheck(index);
        t1 = this.$this;
        t1._select$3(row, J.$index$asx(t1.get$_dataForRow(), row), index);
      }, null, null, 8, 0, null, 152, 6, "call"]
    },
    Table__buildTableRows_closure: {
      "^": "Closure:0;selectRow,tableRow,index,$ti",
      call$0: [function() {
        return this.selectRow.call$2(this.tableRow.get$element(), this.index);
      }, null, null, 0, 0, null, "call"]
    },
    Column: {
      "^": "Object;$ti",
      get$cssClass: [function() {
        return;
      }, null, null, 2, 0, null],
      get$numeric: [function() {
        return false;
      }, null, null, 2, 0, null],
      get$supportsSorting: [function() {
        return this.get$numeric();
      }, null, null, 2, 0, null],
      get$usesHtml: [function() {
        return false;
      }, null, null, 2, 0, null],
      render$1: [function(value) {
        if (this.get$numeric())
          return Q.Column_fastIntl(H.intTypeCheck(value));
        return J.toString$0$(value);
      }, null, "get$render", 4, 0, null, 1],
      toString$0: [function(_) {
        return this.title;
      }, null, "get$toString", 1, 0, null],
      renderToElement$2: [function(cell, dataObject) {
        var $content;
        H.interceptedTypeCheck(cell, "$isCoreElement");
        $content = this.render$1(this.getValue$1(H.assertSubtypeOfRuntimeType(dataObject, H.getRuntimeTypeArgument(this, "Column", 0))));
        if (this.get$usesHtml())
          cell.setInnerHtml$1(0, $content);
        else
          cell.set$text(0, $content);
      }, null, "get$renderToElement", 8, 0, null, 292, 751]
    },
    SortOrder: {
      "^": "Object;index>,_tables$_name,$ti",
      toString$0: [function(_) {
        return this._tables$_name;
      }, null, "get$toString", 1, 0, null]
    },
    _Table_Object_SetStateMixin: {
      "^": "Object+SetStateMixin;$ti",
      $isSetStateMixin: 1
    }
  }], ["", "package:devtools/src/timeline/frame_flame_chart.dart",, Z, {
    "^": "",
    FrameFlameChart: {
      "^": "CoreElement;0frame<,element,$ti",
      FrameFlameChart$0: [function() {
        this.flex$0(0);
        this.clazz$1("frame-timeline");
      }, null, null, 0, 0, null],
      updateFrameData$1: [function(frame) {
        var buf, t1, t2;
        H.interceptedTypeCheck(frame, "$isTimelineFrame");
        this.frame = frame;
        this.clear$0(0);
        if ($._debugEventTrace && frame != null) {
          buf = P.StringBuffer$("");
          t1 = frame.id;
          buf.writeln$1("CPU for frame " + H.S(t1) + ":");
          for (t2 = J.get$iterator$ax(frame.cpuEvents); t2.moveNext$0();)
            t2.get$current().format$2(buf, "  ");
          buf.writeln$1("GPU for frame " + H.S(t1) + ":");
          for (t1 = J.get$iterator$ax(frame.gpuEvents); t1.moveNext$0();)
            t1.get$current().format$2(buf, "  ");
          P.print(buf.toString$0(0));
        }
        if (frame != null)
          this._render$1(frame);
      }, null, "get$updateFrameData", 4, 0, null, 73],
      _render$1: [function(frame) {
        var t1, microsAdjust, t2;
        t1 = {};
        H.interceptedTypeCheck(frame, "$isTimelineFrame");
        t1.row = 0;
        microsAdjust = frame.startTime;
        t1.maxRow = 0;
        t2 = new Z.FrameFlameChart__render_drawRecursively(t1, this, microsAdjust, 16.666666666666668, 60, 25);
        new Z.FrameFlameChart__render_drawCpuEvents(t1, this, frame, t2).call$0();
        new Z.FrameFlameChart__render_drawGpuEvents(t1, this, 25, frame, t2).call$0();
      }, null, "get$_render", 4, 0, null, 73],
      _drawFlameChartItem$4: [function($event, left, width, $top) {
        var item, t1, t2;
        H.interceptedTypeCheck($event, "$isTimelineEvent0");
        H.intTypeCheck(left);
        H.intTypeCheck(width);
        H.intTypeCheck($top);
        item = A.div(null, "timeline-title", $event.name);
        t1 = item.element;
        t2 = J.getInterceptor$x(t1);
        J.set$left$x(t2.get$style(t1), H.S(left) + "px");
        if (width != null)
          J.set$width$x(t2.get$style(t1), H.S(width) + "px");
        J.set$top$x(t2.get$style(t1), H.S($top) + "px");
        this.add$1(0, item);
      }, null, "get$_drawFlameChartItem", 16, 0, null, 22, 119, 56, 186],
      static: {
        FrameFlameChart$: [function() {
          var t1 = new Z.FrameFlameChart(W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, null, null);
          t1.FrameFlameChart$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    FrameFlameChart__render_drawRecursively: {
      "^": "Closure:165;_box_0,$this,microsAdjust,pxPerMicro,leftIndent,rowHeight,$ti",
      call$2: [function($event, row) {
        var t1, t2, t3, t4, start, end;
        H.interceptedTypeCheck($event, "$isTimelineEvent0");
        H.intTypeCheck(row);
        t1 = $event.startTime;
        t2 = this.microsAdjust;
        t3 = J.getInterceptor$n(t1);
        t4 = this.pxPerMicro;
        start = J.$div$n(t3.$sub(t1, t2), t4);
        end = J.$div$n(J.$add$ansx(t3.$sub(t1, t2), $event.get$duration($event)), t4);
        t4 = J.$add$ansx(this.leftIndent, J.round$0$n(start));
        if (typeof end !== "number")
          return end.$sub();
        t2 = C.JSNumber_methods.round$0(end - start);
        t1 = this.rowHeight;
        if (typeof row !== "number")
          return row.$mul();
        if (typeof t1 !== "number")
          return H.iae(t1);
        this.$this._drawFlameChartItem$4($event, t4, t2, row * t1);
        t1 = this._box_0;
        t2 = t1.maxRow;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (row > t2)
          t1.maxRow = row;
        for (t1 = J.get$iterator$ax($event.children), t2 = row + 1; t1.moveNext$0();)
          this.call$2(t1.get$current(), t2);
      }, null, null, 8, 0, null, 22, 152, "call"]
    },
    FrameFlameChart__render_drawCpuEvents: {
      "^": "Closure:0;_box_0,$this,frame,drawRecursively,$ti",
      call$0: [function() {
        var sectionTitle, t1, t2, t3, row;
        sectionTitle = A.div(null, "timeline-title", "CPU");
        t1 = sectionTitle.element;
        t2 = J.getInterceptor$x(t1);
        J.set$left$x(t2.get$style(t1), "0");
        J.set$top$x(t2.get$style(t1), "0");
        J.add$1$ax(this.$this, sectionTitle);
        t1 = this._box_0;
        t1.maxRow = t1.row;
        for (t2 = J.get$iterator$ax(this.frame.get$cpuEvents()), t3 = this.drawRecursively; t2.moveNext$0();)
          t3.call$2(t2.get$current(), t1.row);
        row = t1.maxRow;
        t1.row = row;
        if (typeof row !== "number")
          return row.$add();
        t1.row = row + 1;
      }, null, null, 0, 0, null, "call"]
    },
    FrameFlameChart__render_drawGpuEvents: {
      "^": "Closure:0;_box_0,$this,rowHeight,frame,drawRecursively,$ti",
      call$0: [function() {
        var t1, sectionTop, sectionTitle, t2, t3, row;
        t1 = this._box_0;
        sectionTop = J.$mul$ns(t1.row, this.rowHeight);
        sectionTitle = A.div(null, "timeline-title", "GPU");
        t2 = sectionTitle.element;
        t3 = J.getInterceptor$x(t2);
        J.set$left$x(t3.get$style(t2), "0");
        J.set$top$x(t3.get$style(t2), H.S(sectionTop) + "px");
        J.add$1$ax(this.$this, sectionTitle);
        t1.maxRow = t1.row;
        for (t2 = J.get$iterator$ax(this.frame.get$gpuEvents()), t3 = this.drawRecursively; t2.moveNext$0();)
          t3.call$2(t2.get$current(), t1.row);
        row = t1.maxRow;
        t1.row = row;
        if (typeof row !== "number")
          return row.$add();
        t1.row = row + 1;
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:devtools/src/timeline/frame_rendering.dart",, A, {
    "^": "",
    FramesTracker: {
      "^": "Object;_frame_rendering$_changeController,service<,0eventStreamSubscription,samples,$ti",
      set$eventStreamSubscription: function(eventStreamSubscription) {
        this.eventStreamSubscription = H.assertSubtype(eventStreamSubscription, "$isStreamSubscription", [S.Event0], "$asStreamSubscription");
      },
      get$onChange: [function(_) {
        return J.get$stream$z(this._frame_rendering$_changeController);
      }, null, null, 3, 0, null],
      start$0: [function(_) {
        if (this.eventStreamSubscription != null)
          this.stop$0(0);
        this.set$eventStreamSubscription(this.service.get$onExtensionEvent().listen$1(new A.FramesTracker_start_closure(this)));
      }, "call$0", "get$start", 1, 0, 0],
      stop$0: [function(_) {
        this.eventStreamSubscription.cancel$0();
        this.set$eventStreamSubscription(null);
      }, null, "get$stop", 1, 0, null],
      pause$0: [function(_) {
        J.pause$0$z(this.eventStreamSubscription);
      }, null, "get$pause", 1, 0, null],
      resume$0: [function() {
        this.eventStreamSubscription.resume$0();
      }, "call$0", "get$resume", 0, 0, 0],
      _addSample$1: [function(frame) {
        var t1, t2;
        H.interceptedTypeCheck(frame, "$isFrameInfo");
        t1 = this.samples;
        t2 = J.getInterceptor$asx(t1);
        if (t2.get$isEmpty(t1))
          frame.frameGroupStart = true;
        else
          frame.calcFrameGroupStart$1(t2.get$last(t1));
        t2.add$1(t1, frame);
        for (; J.$gt$n(t2.get$length(t1), 60);)
          t2.removeAt$1(t1, 0);
        J.add$1$ax(this._frame_rendering$_changeController, null);
      }, null, "get$_addSample", 4, 0, null, 73],
      get$lastSample: [function() {
        var t1, t2;
        t1 = this.samples;
        t2 = J.getInterceptor$asx(t1);
        return t2.get$isEmpty(t1) ? null : t2.get$last(t1);
      }, null, null, 2, 0, null],
      calcRecentFPS$0: [function() {
        var t1, t2, i, frameCount, usedFrames, frame, frameTime, requiredFrames;
        t1 = this.samples;
        t2 = J.getInterceptor$asx(t1);
        i = J.$sub$n(t2.get$length(t1), 1);
        frameCount = 0;
        usedFrames = 0;
        while (true) {
          if (typeof i !== "number")
            return i.$ge();
          if (!(i >= 0))
            break;
          frame = t2.$index(t1, i);
          ++frameCount;
          frameTime = frame.elapsedMs;
          if (typeof frameTime !== "number")
            return frameTime.$div();
          requiredFrames = C.JSDouble_methods.round$0(frameTime / 16.666666666666668);
          if (typeof requiredFrames !== "number")
            return requiredFrames.$mul();
          if (frameTime - requiredFrames * 16.666666666666668 > 0)
            ++requiredFrames;
          usedFrames += requiredFrames;
          if (frame.frameGroupStart)
            break;
          --i;
        }
        return 1000 * frameCount / (usedFrames * 16.666666666666668);
      }, null, "get$calcRecentFPS", 0, 0, null],
      static: {
        FramesTracker$: [function(service) {
          return new A.FramesTracker(P.StreamController_StreamController$broadcast(null, null, false, P.Null), service, H.setRuntimeTypeInfo([], [A.FrameInfo]), []);
        }, null, null, 4, 0, null, 74]
      }
    },
    FramesTracker_start_closure: {
      "^": "Closure:23;$this,$ti",
      call$1: [function(e) {
        H.interceptedTypeCheck(e, "$isEvent0");
        if (J.$eq$(e.extensionKind, "Flutter.Frame"))
          this.$this._addSample$1(A.FrameInfo_from(e.extensionData.data));
      }, null, null, 4, 0, null, 19, "call"]
    },
    FrameInfo: {
      "^": "Object;number,elapsedMs,startTimeMs,frameGroupStart,$ti",
      get$endTimeMs: [function() {
        return J.$add$ansx(this.startTimeMs, this.elapsedMs);
      }, null, null, 2, 0, null],
      calcFrameGroupStart$1: [function(previousFrame) {
        if (J.$gt$n(this.startTimeMs, J.$add$ansx(H.interceptedTypeCheck(previousFrame, "$isFrameInfo").get$endTimeMs(), 16.666666666666668)))
          this.frameGroupStart = true;
      }, null, "get$calcFrameGroupStart", 4, 0, null, 755],
      toString$0: [function(_) {
        return "frame " + H.S(this.number) + " " + H.S(J.toStringAsFixed$1$n(this.elapsedMs, 1)) + "ms";
      }, null, "get$toString", 1, 0, null],
      static: {
        FrameInfo$: [function(number, elapsedMs, startTimeMs) {
          return new A.FrameInfo(number, elapsedMs, startTimeMs, false, []);
        }, null, null, 12, 0, null, 84, 753, 754],
        FrameInfo_from: [function(data) {
          H.interceptedTypeCheck(data, "$isMap");
          return A.FrameInfo$(H.intTypeCheck(data.$index(0, "number")), H.numTypeCheck(J.$div$n(data.$index(0, "elapsed"), 1000)), H.numTypeCheck(J.$div$n(data.$index(0, "startTime"), 1000)));
        }, null, null, 4, 0, null, 34]
      }
    }
  }], ["", "package:devtools/src/timeline/frame_rendering_chart.dart",, B, {
    "^": "",
    FramesChart: {
      "^": "LineChart;0fpsLabel,0lastFrameLabel,0_windowResizeSubscription,parent,0chartElement,0dim,_charts$_state,0data,$ti",
      FramesChart$1: [function($parent) {
        var t1;
        this.fpsLabel = H.interceptedTypeCheck($parent.add$1(0, A.div(null, "perf-label top-left", null)), "$isCoreElement");
        t1 = A.div(null, "perf-label top-right", null);
        t1.set$tooltip("Rendering time of latest frame.");
        this.lastFrameLabel = H.interceptedTypeCheck($parent.add$1(0, t1), "$isCoreElement");
      }, null, null, 4, 0, null, 24],
      update$1: [function(data) {
        var lastFrame, pixPerMs, units, svgElements, samples, i, y, dashed, x, t1, t2, frame, t3, t4, height, color, tooltip, lineX;
        H.interceptedTypeCheck(data, "$isFramesTracker");
        if (this.dim == null)
          return;
        J.set$text$x(this.fpsLabel, H.S(J.round$0$n(data.calcRecentFPS$0())) + " frames per second");
        lastFrame = data.get$lastSample();
        J.setInnerHtml$1$x(this.lastFrameLabel, "frame " + H.S(lastFrame.number) + " \u2022 " + H.S(J.toStringAsFixed$1$n(lastFrame.elapsedMs, 1)) + "ms");
        pixPerMs = J.$div$n(J.get$y$x(this.dim), 33.333333333333336);
        units = J.$div$n(J.get$x$x(this.dim), 180);
        svgElements = H.setRuntimeTypeInfo([], [P.String]);
        samples = data.samples;
        for (i = 3; i > 0; --i) {
          if (typeof pixPerMs !== "number")
            return H.iae(pixPerMs);
          y = i * 8.333333333333334 * pixPerMs;
          dashed = i === 2 ? "" : 'stroke-dasharray="10 5" ';
          C.JSArray_methods.add$1(svgElements, '<line x1="0" y1="' + H.S(y) + '" x2="' + H.S(J.get$x$x(this.dim)) + '" y2="' + H.S(y) + '" stroke-width="0.5" stroke="#ddd" ' + dashed + "/>");
        }
        x = J.toDouble$0$n(J.get$x$x(this.dim));
        t1 = J.getInterceptor$asx(samples);
        i = J.$sub$n(t1.get$length(samples), 1);
        t2 = P.num;
        while (true) {
          if (typeof i !== "number")
            return i.$ge();
          if (!(i >= 0))
            break;
          frame = t1.$index(samples, i);
          t3 = J.get$y$x(this.dim);
          t4 = frame.elapsedMs;
          height = P.min(t3, J.$mul$ns(t4, pixPerMs), t2);
          if (typeof units !== "number")
            return H.iae(units);
          if (typeof x !== "number")
            return x.$sub();
          x -= 3 * units;
          color = this._isSlowFrame$1(frame) ? C.Color_4294540412 : C.Color_4282415296;
          tooltip = this._isSlowFrame$1(frame) ? "This frame took " + H.S(t4) + "ms to render, which can cause frame rate to drop below 60 FPS." : "This frame took " + H.S(t4) + "ms to render.";
          C.JSArray_methods.add$1(svgElements, '<rect x="' + H.S(x) + '" y="' + H.S(J.$sub$n(J.get$y$x(this.dim), height)) + '" rx="1" ry="1" width="' + H.S(2 * units) + '" height="' + H.S(height) + '" style="fill:' + H.S(Y.colorToCss(color)) + '"><title>' + tooltip + "</title></rect>");
          if (frame.frameGroupStart) {
            lineX = x - units / 2;
            C.JSArray_methods.add$1(svgElements, '<line x1="' + H.S(lineX) + '" y1="0" x2="' + H.S(lineX) + '" y2="' + H.S(J.get$y$x(this.dim)) + '" stroke-width="0.5" stroke-dasharray="4 4" stroke="#ddd"/>');
          }
          --i;
        }
        J.setInnerHtml$1$x(this.chartElement, '     <svg viewBox="0 0 ' + H.S(J.get$x$x(this.dim)) + ' 98">\n     ' + H.S(C.JSArray_methods.join$1(svgElements, "\n")) + "\n     </svg>\n     ");
      }, null, "get$update", 4, 0, null, 34],
      _isSlowFrame$1: [function(frame) {
        return J.$gt$n(H.interceptedTypeCheck(frame, "$isFrameInfo").elapsedMs, 16.666666666666668);
      }, null, "get$_isSlowFrame", 4, 0, null, 73],
      $asLineChart: function() {
        return [A.FramesTracker];
      },
      static: {
        FramesChart$: [function($parent) {
          var t1 = new B.FramesChart($parent, N.SetStateMixin$(), []);
          t1.LineChart$2$classes($parent, "perf-chart", A.FramesTracker);
          t1.FramesChart$1($parent);
          return t1;
        }, null, null, 4, 0, null, 24]
      }
    }
  }], ["", "package:devtools/src/timeline/timeline.dart",, D, {
    "^": "",
    TimelineScreen: {
      "^": "Screen;timelineController<,0framesChart<,framesChartStateMixin<,0framesTracker<,0timelineFramesUI,_paused,0pauseButton,0resumeButton,name,id,iconClass,0framework,_visible,statusItems,$ti",
      createContent$1: [function(framework) {
        var t1, screenDiv, frameTabNav, t2, upperButtonSection, t3, t4, t5, t6, t7, frameDetailsContainer, t8, frameFlameChart;
        t1 = {};
        H.interceptedTypeCheck(framework, "$isFramework");
        screenDiv = A.div(null, null, null);
        screenDiv.layoutVertical$0();
        t1.frameDetailsContainer = null;
        t1.frameFlameChart = null;
        frameTabNav = N.PTabNav$(H.setRuntimeTypeInfo([N.PTabNavTab$("Frame Timeline")], [N.PTabNavTab]));
        t2 = N.PButton$icon("Pause recording", C.UrlIcon_k2W, null);
        t2.small$0();
        t2.primary$0();
        t2.click$1(0, this.get$_pauseRecording());
        this.pauseButton = t2;
        t2 = N.PButton$icon("Resume Recording", C.UrlIcon_nbd, null);
        t2.small$0();
        t2.clazz$1("margin-left");
        t2.set$disabled(0, true);
        t2.click$1(0, this.get$_resumeRecording());
        this.resumeButton = t2;
        upperButtonSection = A.div(null, "section", null);
        upperButtonSection.layoutHorizontal$0();
        t2 = A.div(null, "btn-group", null);
        J.add$1$ax(t2, H.setRuntimeTypeInfo([this.pauseButton, this.resumeButton], [N.PButton]));
        t3 = A.div(null, null, null);
        J.flex$0$z(t3);
        t4 = [A.CoreElement];
        t5 = J.getInterceptor$ax(upperButtonSection);
        t5.add$1(upperButtonSection, H.setRuntimeTypeInfo([t2, t3], t4));
        t5.add$1(upperButtonSection, Y.getServiceExtensionButtons());
        t5 = A.div(null, "section", null);
        t3 = this.createLiveChartArea$0();
        t2 = A.div(null, "section", null);
        t6 = D.TimelineFramesUI$(this.timelineController);
        this.timelineFramesUI = t6;
        J.add$1$ax(t2, H.setRuntimeTypeInfo([t6], t4));
        t6 = A.div(null, "section", null);
        t6.layoutVertical$0();
        t7 = J.getInterceptor$z(t6);
        t7.flex$0(t6);
        frameDetailsContainer = A.div(null, null, null);
        frameDetailsContainer.layoutVertical$0();
        t8 = J.getInterceptor$z(frameDetailsContainer);
        t8.flex$0(frameDetailsContainer);
        frameFlameChart = Z.FrameFlameChart$();
        t1.frameFlameChart = frameFlameChart;
        t8.add$1(frameDetailsContainer, H.setRuntimeTypeInfo([frameTabNav, frameFlameChart], t4));
        frameDetailsContainer.attribute$1("hidden");
        t1.frameDetailsContainer = frameDetailsContainer;
        t7.add$1(t6, frameDetailsContainer);
        J.add$1$ax(screenDiv, H.setRuntimeTypeInfo([upperButtonSection, t5, t3, t2, t6], t4));
        E.serviceManager().get$onConnectionAvailable().listen$1(this.get$_timeline$_handleConnectionStart());
        if (E.serviceManager().get$hasConnection())
          this._timeline$_handleConnectionStart$1(E.serviceManager().get$service());
        E.serviceManager().get$onConnectionClosed().listen$1(this.get$_timeline$_handleConnectionStop());
        this.timelineFramesUI.get$onSelectedFrame().listen$1(new D.TimelineScreen_createContent_closure(t1, this));
        return screenDiv;
      }, null, "get$createContent", 4, 0, null, 127],
      createLiveChartArea$0: [function() {
        var container, t1;
        container = A.div(null, "section perf-chart table-border", null);
        container.layoutVertical$0();
        t1 = B.FramesChart$(container);
        this.framesChart = t1;
        t1.set$disabled(0, true);
        return container;
      }, null, "get$createLiveChartArea", 0, 0, null],
      entering$0: [function() {
        this._updateListeningState$0();
      }, null, "get$entering", 0, 0, null],
      exiting$0: [function() {
        this._updateListeningState$0();
      }, null, "get$exiting", 0, 0, null],
      _timeline$_handleConnectionStart$1: [function(service) {
        var t1;
        H.interceptedTypeCheck(service, "$isVmServiceWrapper");
        J.set$disabled$z(this.framesChart, false);
        t1 = A.FramesTracker$(service);
        this.framesTracker = t1;
        t1.start$0(0);
        J.get$onChange$x(this.framesTracker).listen$1(new D.TimelineScreen__handleConnectionStart_closure(this));
        E.serviceManager().get$service().onEvent$1("Timeline").listen$1(new D.TimelineScreen__handleConnectionStart_closure0(this));
      }, "call$1", "get$_timeline$_handleConnectionStart", 4, 0, 53, 74],
      _timeline$_handleConnectionStop$1: [function($event) {
        var t1;
        J.set$disabled$z(this.framesChart, true);
        t1 = this.framesTracker;
        if (!(t1 == null))
          J.stop$0$z(t1);
        this.timelineController = null;
      }, "call$1", "get$_timeline$_handleConnectionStop", 4, 0, 6, 22],
      _pauseRecording$0: [function() {
        this._updateButtons$1$paused(true);
        this._paused = true;
        this._updateListeningState$0();
      }, "call$0", "get$_pauseRecording", 0, 0, 0],
      _resumeRecording$0: [function() {
        this._updateButtons$1$paused(false);
        this._paused = false;
        this._updateListeningState$0();
      }, "call$0", "get$_resumeRecording", 0, 0, 0],
      _updateButtons$1$paused: [function(paused) {
        var t1;
        H.boolTypeCheck(paused);
        J.set$disabled$z(this.pauseButton, paused);
        J.set$disabled$z(this.resumeButton, !paused);
        t1 = this.pauseButton;
        t1.changeIcon$1(paused ? "/icons/general/pause_white_disabled@2x.png" : "/icons/general/pause_white@2x.png");
        t1 = this.resumeButton;
        t1.changeIcon$1(paused ? "/icons/general/resume_black@2x.png" : "/icons/general/resume_black_disabled@2x.png");
      }, null, "get$_updateButtons", 0, 3, null, 0, 178],
      _updateListeningState$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, shouldBeRunning, t1, isRunning;
        var $async$_updateListeningState$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(E.serviceManager().get$serviceAvailable().get$future(), $async$_updateListeningState$0);
              case 2:
                // returning from await.
                shouldBeRunning = !$async$self._paused && $async$self.get$isCurrentScreen();
                t1 = J.get$paused$z($async$self.timelineController);
                isRunning = !t1;
                $async$goto = shouldBeRunning && isRunning && !$async$self.timelineController.get$hasStarted() ? 3 : 4;
                break;
              case 3:
                // then
                $async$goto = 5;
                return P._asyncAwait($async$self.timelineController.startTimeline$0(), $async$_updateListeningState$0);
              case 5:
                // returning from await.
              case 4:
                // join
                $async$goto = shouldBeRunning && t1 ? 6 : 8;
                break;
              case 6:
                // then
                $async$self.framesTracker.resume$0();
                $async$self.timelineController.resume$0();
                $async$goto = 9;
                return P._asyncAwait(E.serviceManager().get$service().setVMTimelineFlags$1(H.setRuntimeTypeInfo(["GC", "Dart", "Embedder"], [P.String])), $async$_updateListeningState$0);
              case 9:
                // returning from await.
                // goto join
                $async$goto = 7;
                break;
              case 8:
                // else
                $async$goto = !shouldBeRunning && isRunning ? 10 : 11;
                break;
              case 10:
                // then
                $async$goto = 12;
                return P._asyncAwait(E.serviceManager().get$service().setVMTimelineFlags$1(H.setRuntimeTypeInfo([], [P.String])), $async$_updateListeningState$0);
              case 12:
                // returning from await.
                J.pause$0$z($async$self.framesTracker);
                J.pause$0$z($async$self.timelineController);
              case 11:
                // join
              case 7:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_updateListeningState$0, $async$completer);
      }, null, "get$_updateListeningState", 0, 0, null],
      static: {
        TimelineScreen$: [function() {
          return new D.TimelineScreen(Y.TimelineController$(), N.SetStateMixin$(), false, "Timeline", "timeline", "octicon-pulse", B.Property$(false, P.bool), H.setRuntimeTypeInfo([], [N.StatusItem]), []);
        }, null, null, 0, 0, null]
      }
    },
    TimelineScreen_createContent_closure: {
      "^": "Closure:37;_box_0,$this,$ti",
      call$1: [function(frame) {
        var t1, t2;
        H.interceptedTypeCheck(frame, "$isTimelineFrame");
        t1 = this._box_0;
        t2 = frame == null;
        t1.frameDetailsContainer.attribute$2("hidden", t2);
        if (!t2 && this.$this.get$timelineController().get$hasStarted())
          t1.frameFlameChart.updateFrameData$1(frame);
      }, null, null, 4, 0, null, 73, "call"]
    },
    TimelineScreen__handleConnectionStart_closure: {
      "^": "Closure:27;$this,$ti",
      call$1: [function(_) {
        var t1;
        H.interceptedTypeCheck(_, "$isNull");
        t1 = this.$this;
        t1.get$framesChartStateMixin().setState$1(new D.TimelineScreen__handleConnectionStart__closure(t1));
      }, null, null, 4, 0, null, 12, "call"]
    },
    TimelineScreen__handleConnectionStart__closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$framesChart().updateFrom$1(t1.get$framesTracker());
      }, null, null, 0, 0, null, "call"]
    },
    TimelineScreen__handleConnectionStart_closure0: {
      "^": "Closure:23;$this,$ti",
      call$1: [function($event) {
        var t1, t2, e, t3;
        for (t1 = J.get$iterator$ax(J.cast$1$0$ax(H.listTypeCheck(J.$index$asx(H.interceptedTypeCheck($event, "$isEvent0").json, "timelineEvents")), [P.Map, P.String,,])), t2 = this.$this; t1.moveNext$0();) {
          e = O.TraceEvent_TraceEvent(t1.get$current());
          t3 = t2.get$timelineController().get$timelineData();
          if (!(t3 == null))
            t3.processTimelineEvent$1(e);
        }
      }, null, null, 4, 0, null, 22, "call"]
    },
    TimelineFramesUI: {
      "^": "CoreElement;0selectedFrame,_selectedFrameController,element,$ti",
      TimelineFramesUI$1: [function(timelineController) {
        timelineController.get$onFrameAdded().listen$1(new D.TimelineFramesUI_closure(this, timelineController));
        timelineController.get$onFramesCleared().listen$1(new D.TimelineFramesUI_closure0(this));
      }, null, null, 4, 0, null, 470],
      get$onSelectedFrame: [function() {
        return J.get$stream$z(this._selectedFrameController);
      }, null, null, 2, 0, null],
      setSelected$1: [function(frameUI) {
        var t1;
        H.interceptedTypeCheck(frameUI, "$isTimelineFrameUI");
        if (J.$eq$(this.selectedFrame, frameUI))
          frameUI = null;
        if (!J.$eq$(this.selectedFrame, frameUI)) {
          t1 = this.selectedFrame;
          if (!(t1 == null))
            t1.setSelected$1(false);
          this.selectedFrame = frameUI;
          if (!(frameUI == null))
            frameUI.setSelected$1(true);
          t1 = this.selectedFrame;
          t1 = t1 == null ? null : t1.get$frame();
          J.add$1$ax(this._selectedFrameController, t1);
        }
      }, null, "get$setSelected", 4, 0, null, 758],
      static: {
        TimelineFramesUI$: [function(timelineController) {
          var t1 = new D.TimelineFramesUI(P.StreamController_StreamController$broadcast(null, null, false, O.TimelineFrame), W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "timeline-frames", null);
          t1.TimelineFramesUI$1(timelineController);
          return t1;
        }, null, null, 4, 0, null, 470]
      }
    },
    TimelineFramesUI_closure: {
      "^": "Closure:37;$this,timelineController,$ti",
      call$1: [function(frame) {
        var t1, frameUI;
        t1 = this.$this;
        frameUI = D.TimelineFrameUI$(t1, H.interceptedTypeCheck(frame, "$isTimelineFrame"));
        if (J.get$isEmpty$asx(J.get$children$x(t1.get$element())))
          J.add$1$ax(t1, frameUI);
        else {
          if (J.$ge$n(J.get$length$asx(J.get$children$x(t1.get$element())), this.timelineController.get$maxFrames()))
            J.removeLast$0$ax(J.get$children$x(t1.get$element()));
          J.insert$2$ax(J.get$children$x(t1.get$element()), 0, frameUI.element);
        }
      }, null, null, 4, 0, null, 73, "call"]
    },
    TimelineFramesUI_closure0: {
      "^": "Closure:27;$this,$ti",
      call$1: [function(_) {
        var t1;
        H.interceptedTypeCheck(_, "$isNull");
        t1 = this.$this;
        J.clear$0$ax(t1);
        t1.setSelected$1(null);
      }, null, null, 4, 0, null, 12, "call"]
    },
    TimelineFrameUI: {
      "^": "CoreElement;framesUI<,frame<,element,$ti",
      TimelineFrameUI$2: [function(framesUI, frame) {
        var t1, dartBar, isSlow, t2, height, gpuBar;
        t1 = this.frame;
        this.add$1(0, H.setRuntimeTypeInfo([A.span(null, "perf-label", "dart " + H.S(t1.get$cpuAsMs())), A.CoreElement$("br", null, null, null), A.span(null, "perf-label", "gpu " + H.S(t1.get$gpuAsMs()))], [A.CoreElement]));
        dartBar = A.div(null, "perf-bar left", null);
        if (J.$gt$n(t1.get$cpuDuration(), 16666.666666666668)) {
          dartBar.clazz$1("slow");
          isSlow = true;
        } else
          isSlow = false;
        t2 = P.int;
        height = P.min(J.round$0$n(J.$div$n(J.$mul$ns(t1.get$cpuDuration(), 2.2199999999999998), 1000)), 74, t2);
        J.set$height$x(J.get$style$x(dartBar.element), H.S(height) + "px");
        this.add$1(0, dartBar);
        gpuBar = A.div(null, "perf-bar right", null);
        if (J.$gt$n(t1.get$gpuDuration(), 16666.666666666668)) {
          gpuBar.clazz$1("slow");
          isSlow = true;
        }
        height = P.min(J.round$0$n(J.$div$n(J.$mul$ns(t1.get$gpuDuration(), 2.2199999999999998), 1000)), 74, t2);
        J.set$height$x(J.get$style$x(gpuBar.element), H.S(height) + "px");
        this.add$1(0, gpuBar);
        if (isSlow)
          this.clazz$1("slow");
        this.click$1(0, new D.TimelineFrameUI_closure(this));
      }, null, null, 8, 0, null, 471, 73],
      setSelected$1: [function(selected) {
        this.toggleClass$2("selected", H.boolTypeCheck(selected));
      }, null, "get$setSelected", 4, 0, null, 759],
      static: {
        TimelineFrameUI$: [function(framesUI, frame) {
          var t1 = new D.TimelineFrameUI(framesUI, frame, W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "timeline-frame", null);
          t1.TimelineFrameUI$2(framesUI, frame);
          return t1;
        }, null, null, 8, 0, null, 471, 73]
      }
    },
    TimelineFrameUI_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$framesUI().setSelected$1(t1);
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:devtools/src/timeline/timeline_controller.dart",, Y, {
    "^": "",
    TimelineController: {
      "^": "Object;maxFrames<,_frameAddedController<,_framesClearedController,dartEvents,gpuEvents<,0_timelineData,_timeline_controller$_paused,$ti",
      get$onFrameAdded: [function() {
        return J.get$stream$z(this._frameAddedController);
      }, null, null, 2, 0, null],
      get$onFramesCleared: [function() {
        return J.get$stream$z(this._framesClearedController);
      }, null, null, 2, 0, null],
      get$timelineData: [function() {
        return this._timelineData;
      }, null, null, 2, 0, null],
      get$hasStarted: [function() {
        return this.get$timelineData() != null;
      }, null, null, 2, 0, null],
      get$paused: [function(_) {
        return this._timeline_controller$_paused;
      }, null, null, 3, 0, null],
      pause$0: [function(_) {
        this._timeline_controller$_paused = true;
        J.clear$0$ax(this.dartEvents);
        J.clear$0$ax(this.gpuEvents);
      }, null, "get$pause", 1, 0, null],
      resume$0: [function() {
        this._timeline_controller$_paused = false;
      }, "call$0", "get$resume", 0, 0, 0],
      startTimeline$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(-1),
          $async$self = this, t1, cpuThreadId, gpuThreadId, t2, t3, t4, timelineData, $async$temp1, $async$temp2, $async$temp3, $async$temp4, $async$temp5, $async$temp6, $async$temp7;
        var $async$startTimeline$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait(E.serviceManager().get$service().setVMTimelineFlags$1(H.setRuntimeTypeInfo(["GC", "Dart", "Embedder"], [P.String])), $async$startTimeline$0);
              case 2:
                // returning from await.
                $async$goto = 3;
                return P._asyncAwait(E.serviceManager().get$service().clearVMTimeline$0(), $async$startTimeline$0);
              case 3:
                // returning from await.
                $async$temp1 = J;
                $async$temp2 = J;
                $async$temp3 = J;
                $async$temp4 = J;
                $async$temp5 = J;
                $async$temp6 = H;
                $async$temp7 = J;
                $async$goto = 4;
                return P._asyncAwait(E.serviceManager().get$service().getVMTimeline$0(), $async$startTimeline$0);
              case 4:
                // returning from await.
                t1 = $async$temp1.get$iterator$ax($async$temp2.toList$0$ax($async$temp3.where$1$ax($async$temp4.map$1$1$ax($async$temp5.cast$1$0$ax($async$temp6.listTypeCheck($async$temp7.$index$asx($async$result.json, "traceEvents")), [P.Map, P.String,,]), new Y.TimelineController_startTimeline_closure(), O.TraceEvent), new Y.TimelineController_startTimeline_closure0()))), cpuThreadId = null, gpuThreadId = null;
              case 5:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 6;
                  break;
                }
                t2 = t1.get$current();
                t3 = t2.args;
                t4 = J.getInterceptor$asx(t3);
                if (H.boolTypeCheck(J.startsWith$1$s(t4.$index(t3, "name"), "io.flutter.1.ui")))
                  cpuThreadId = t2.threadId;
                if (H.boolTypeCheck(J.startsWith$1$s(t4.$index(t3, "name"), "io.flutter.1.gpu")))
                  gpuThreadId = t2.threadId;
                // goto for condition
                $async$goto = 5;
                break;
              case 6:
                // after for
                timelineData = O.TimelineData$(cpuThreadId, gpuThreadId);
                timelineData.get$onFrameCompleted().listen$1(new Y.TimelineController_startTimeline_closure1($async$self));
                $async$self._timelineData = timelineData;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$startTimeline$0, $async$completer);
      }, null, "get$startTimeline", 0, 0, null],
      static: {
        TimelineController$: [function() {
          var t1 = [O.TimelineEvent0];
          return new Y.TimelineController(120, P.StreamController_StreamController$broadcast(null, null, false, O.TimelineFrame), P.StreamController_StreamController$broadcast(null, null, false, P.Null), H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), false, []);
        }, null, null, 0, 0, null]
      }
    },
    TimelineController_startTimeline_closure: {
      "^": "Closure:167;$ti",
      call$1: [function($event) {
        return O.TraceEvent_TraceEvent(H.assertSubtype($event, "$isMap", [P.String, null], "$asMap"));
      }, null, null, 4, 0, null, 22, "call"]
    },
    TimelineController_startTimeline_closure0: {
      "^": "Closure:168;$ti",
      call$1: [function($event) {
        return J.$eq$(H.interceptedTypeCheck($event, "$isTraceEvent").name, "thread_name");
      }, null, null, 4, 0, null, 22, "call"]
    },
    TimelineController_startTimeline_closure1: {
      "^": "Closure:37;$this,$ti",
      call$1: [function(frame) {
        H.interceptedTypeCheck(frame, "$isTimelineFrame");
        J.add$1$ax(this.$this.get$_frameAddedController(), frame);
      }, null, null, 4, 0, null, 73, "call"]
    }
  }], ["", "package:devtools/src/timeline/timeline_protocol.dart",, O, {
    "^": "",
    TimelineEventType: {
      "^": "Object;index>,_timeline_protocol$_name,$ti",
      toString$0: [function(_) {
        return this._timeline_protocol$_name;
      }, null, "get$toString", 1, 0, null]
    },
    TimelineData: {
      "^": "Object;cpuThreadId,gpuThreadId,0frameId,_listeningForFrameEvents,frames,_frameCompleteController,_asyncEvents,0durationStack,$ti",
      get$onFrameCompleted: [function() {
        return J.get$stream$z(this._frameCompleteController);
      }, null, null, 2, 0, null],
      processTimelineEvent$1: [function($event) {
        var t1, t2;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        $event.set$type(0, this._inferEventType$1($event));
        t1 = $event.phase;
        t2 = J.getInterceptor$(t1);
        if (t2.$eq(t1, "s")) {
          this._handleFrameStartEvent$1($event);
          return;
        } else if (t2.$eq(t1, "f")) {
          this._handleFrameEndEvent$1($event);
          return;
        }
        if (this._listeningForFrameEvents) {
          if ($event.get$frameId() == null)
            $event.set$frameId(this.frameId);
          if (!J.$eq$($event.get$type($event), C.TimelineEventType_0) && !J.$eq$($event.get$type($event), C.TimelineEventType_1))
            return;
          if (this.frames.containsKey$1($event.get$frameId()))
            switch (t1) {
              case "B":
                this._handleDurationBeginEvent$1($event);
                break;
              case "E":
                this._handleDurationEndEvent$1($event);
                break;
              case "X":
                this._handleDurationCompleteEvent$1($event);
                break;
              case "b":
                this._handleAsyncBeginEvent$1($event);
                break;
              case "n":
                this._handleAsyncInstantEvent$1($event);
                break;
              case "e":
                this._handleAsyncEndEvent$1($event);
                break;
            }
        }
      }, null, "get$processTimelineEvent", 4, 0, null, 22],
      _inferEventType$1: [function($event) {
        var t1, t2;
        t1 = H.interceptedTypeCheck($event, "$isTraceEvent").threadId;
        t2 = J.getInterceptor$(t1);
        if (t2.$eq(t1, this.cpuThreadId))
          return C.TimelineEventType_0;
        else if (t2.$eq(t1, this.gpuThreadId))
          return C.TimelineEventType_1;
        else
          return C.TimelineEventType_2;
      }, null, "get$_inferEventType", 4, 0, null, 22],
      _handleFrameStartEvent$1: [function($event) {
        H.interceptedTypeCheck($event, "$isTraceEvent");
        if (!this._listeningForFrameEvents) {
          this.frameId = H.stringTypeCheck($event.get$id($event));
          $event.set$frameId(H.stringTypeCheck($event.get$id($event)));
          J.$indexSet$ax(this.frames, $event.get$frameId(), O.TimelineFrame$($event.get$frameId(), $event.timestampMicros));
          this._listeningForFrameEvents = true;
        }
      }, null, "get$_handleFrameStartEvent", 4, 0, null, 22],
      _handleFrameEndEvent$1: [function($event) {
        var t1, frame;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        t1 = this.frames;
        if (t1.containsKey$1($event.get$id($event))) {
          frame = J.$index$asx(t1, $event.get$id($event));
          frame.endTime = H.intTypeCheck($event.timestampMicros);
          J.add$1$ax(this._frameCompleteController, frame);
          this._listeningForFrameEvents = false;
        }
      }, null, "get$_handleFrameEndEvent", 4, 0, null, 22],
      _handleDurationBeginEvent$1: [function($event) {
        var e, t1;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        e = O.TimelineEvent$($event.name, $event.timestampMicros, this._getTimelineEventType$1($event));
        t1 = this.durationStack;
        if (t1 == null)
          this.durationStack = e;
        else {
          J.add$1$ax(J.get$children$x(t1), e);
          e.parent = H.interceptedTypeCheck(this.durationStack, "$isTimelineEvent0");
          this.durationStack = e;
        }
      }, null, "get$_handleDurationBeginEvent", 4, 0, null, 22],
      _handleDurationEndEvent$1: [function($event) {
        var t1, t2;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        t1 = this.durationStack;
        if (t1 != null) {
          t1.endTime = H.intTypeCheck($event.timestampMicros);
          t2 = H.interceptedTypeCheck(J.get$parent$x(this.durationStack), "$isTimelineEvent0");
          this.durationStack = t2;
          if (t2 == null)
            J.$index$asx(this.frames, $event.get$frameId()).addEvent$1(t1);
        }
      }, null, "get$_handleDurationEndEvent", 4, 0, null, 22],
      _handleDurationCompleteEvent$1: [function($event) {
        var t1, t2, e;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        t1 = $event.name;
        t2 = $event.timestampMicros;
        e = O.TimelineEvent$(t1, t2, this._getTimelineEventType$1($event));
        e.endTime = H.intTypeCheck(J.$add$ansx(t2, $event.duration));
        t1 = this.durationStack;
        if (t1 != null)
          J.add$1$ax(J.get$children$x(t1), e);
      }, null, "get$_handleDurationCompleteEvent", 4, 0, null, 22],
      _handleAsyncBeginEvent$1: [function($event) {
        var asyncUID, t1, t2, parentEvent, t3, t4, e;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        asyncUID = $event.get$asyncUID();
        t1 = this._asyncEvents;
        t2 = J.getInterceptor$asx(t1);
        parentEvent = t2.$index(t1, asyncUID);
        t3 = $event.name;
        t4 = $event.timestampMicros;
        if (parentEvent == null)
          t2.$indexSet(t1, asyncUID, O.TimelineEvent$(t3, t4, this._getTimelineEventType$1($event)));
        else {
          e = O.TimelineEvent$(t3, t4, this._getTimelineEventType$1($event));
          e.parent = parentEvent;
          t2.$indexSet(t1, asyncUID, e);
        }
      }, null, "get$_handleAsyncBeginEvent", 4, 0, null, 22],
      _handleAsyncInstantEvent$1: [function($event) {
        var asyncUID, t1, t2, e, $parent;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        asyncUID = $event.get$asyncUID();
        t1 = $event.name;
        t2 = $event.timestampMicros;
        e = O.TimelineEvent$(t1, t2, this._getTimelineEventType$1($event));
        e.endTime = H.intTypeCheck(J.$add$ansx(t2, $event.duration));
        $parent = J.$index$asx(this._asyncEvents, asyncUID);
        if ($parent != null)
          e.parent = $parent;
      }, null, "get$_handleAsyncInstantEvent", 4, 0, null, 22],
      _handleAsyncEndEvent$1: [function($event) {
        var asyncUID, t1, t2, current;
        H.interceptedTypeCheck($event, "$isTraceEvent");
        asyncUID = $event.get$asyncUID();
        t1 = this._asyncEvents;
        t2 = J.getInterceptor$asx(t1);
        current = t2.$index(t1, asyncUID);
        if (current != null) {
          current.endTime = H.intTypeCheck($event.timestampMicros);
          t2.$indexSet(t1, asyncUID, current.parent);
          if (t2.$index(t1, asyncUID) == null)
            J.$index$asx(this.frames, $event.get$frameId()).addEvent$1(current);
        }
      }, null, "get$_handleAsyncEndEvent", 4, 0, null, 22],
      _getTimelineEventType$1: [function($event) {
        if (H.interceptedTypeCheck($event, "$isTraceEvent").get$isCpuEvent())
          return C.TimelineEventType_0;
        else
          return C.TimelineEventType_1;
      }, null, "get$_getTimelineEventType", 4, 0, null, 22],
      static: {
        TimelineData$: [function(cpuThreadId, gpuThreadId) {
          var t1, t2;
          t1 = P.String;
          t2 = O.TimelineFrame;
          return new O.TimelineData(cpuThreadId, gpuThreadId, false, P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), P.StreamController_StreamController$broadcast(null, null, false, t2), P.LinkedHashMap_LinkedHashMap$_empty(t1, O.TimelineEvent0), []);
        }, null, null, 0, 5, null, 0, 0, 760, 761]
      }
    },
    TimelineFrame: {
      "^": "Object;id>,cpuEvents<,gpuEvents<,startTime<,0endTime,$ti",
      get$duration: [function(_) {
        return J.$sub$n(this.endTime, this.startTime);
      }, null, null, 3, 0, null],
      get$cpuStartTime: [function() {
        var t1, t2;
        t1 = this.cpuEvents;
        t2 = J.getInterceptor$asx(t1);
        return t2.get$isNotEmpty(t1) ? t2.get$first(t1).get$startTime() : 0;
      }, null, null, 2, 0, null],
      get$cpuDuration: [function() {
        var t1, t2;
        t1 = this.cpuEvents;
        t2 = J.getInterceptor$asx(t1);
        return t2.get$isNotEmpty(t1) ? J.$sub$n(J.$add$ansx(t2.get$last(t1).get$startTime(), J.get$duration$z(t2.get$last(t1))), this.get$cpuStartTime()) : 0;
      }, null, null, 2, 0, null],
      get$gpuStartTime: [function() {
        var t1, t2;
        t1 = this.gpuEvents;
        t2 = J.getInterceptor$asx(t1);
        return t2.get$isNotEmpty(t1) ? t2.get$first(t1).get$startTime() : 0;
      }, null, null, 2, 0, null],
      get$gpuDuration: [function() {
        var t1, t2;
        t1 = this.gpuEvents;
        t2 = J.getInterceptor$asx(t1);
        return t2.get$isNotEmpty(t1) ? J.$sub$n(J.$add$ansx(t2.get$last(t1).get$startTime(), J.get$duration$z(t2.get$last(t1))), this.get$gpuStartTime()) : 0;
      }, null, null, 2, 0, null],
      get$cpuAsMs: [function() {
        return this._durationAsMsText$1(this.get$cpuDuration());
      }, null, null, 2, 0, null],
      get$gpuAsMs: [function() {
        return this._durationAsMsText$1(this.get$gpuDuration());
      }, null, null, 2, 0, null],
      _durationAsMsText$1: [function(durationMicros) {
        H.intTypeCheck(durationMicros);
        if (typeof durationMicros !== "number")
          return durationMicros.$div();
        return H.S(C.JSDouble_methods.toStringAsFixed$1(durationMicros / 1000, 1)) + "ms";
      }, null, "get$_durationAsMsText", 4, 0, null, 768],
      toString$0: [function(_) {
        return "Frame " + H.S(this.id) + " - total duration: " + H.S(this.get$duration(this)) + " cpu: " + H.S(this.get$cpuDuration()) + " gpu: " + H.S(this.get$gpuDuration());
      }, null, "get$toString", 1, 0, null],
      addEvent$1: [function($event) {
        H.interceptedTypeCheck($event, "$isTimelineEvent0");
        if (!$event.get$wellFormed())
          return;
        if ($event.get$isCpuEvent())
          J.add$1$ax(this.cpuEvents, $event);
        else if ($event.get$isGpuEvent())
          J.add$1$ax(this.gpuEvents, $event);
      }, null, "get$addEvent", 4, 0, null, 22],
      static: {
        TimelineFrame$: [function(id, startTime) {
          var t1 = [O.TimelineEvent0];
          return new O.TimelineFrame(id, H.setRuntimeTypeInfo([], t1), H.setRuntimeTypeInfo([], t1), startTime, []);
        }, null, null, 8, 0, null, 104, 472]
      }
    },
    TimelineEvent0: {
      "^": "Object;name>,startTime<,type,0endTime,0parent>,children>,$ti",
      get$duration: [function(_) {
        return J.$sub$n(this.endTime, this.startTime);
      }, null, null, 3, 0, null],
      get$wellFormed: [function() {
        return this.startTime != null && this.get$duration(this) != null;
      }, null, null, 2, 0, null],
      get$isCpuEvent: [function() {
        return J.$eq$(this.type, C.TimelineEventType_0);
      }, null, null, 2, 0, null],
      get$isGpuEvent: [function() {
        return J.$eq$(this.type, C.TimelineEventType_1);
      }, null, null, 2, 0, null],
      format$2: [function(buf, indent) {
        var t1;
        H.interceptedTypeCheck(buf, "$isStringBuffer");
        H.stringTypeCheck(indent);
        buf.writeln$1(H.S(indent) + H.S(this.name) + " [" + H.S(this.startTime) + "u]");
        for (t1 = J.get$iterator$ax(this.children); t1.moveNext$0();)
          t1.get$current().format$2(buf, "  " + H.S(indent));
      }, null, "get$format", 8, 0, null, 769, 195],
      toString$0: [function(_) {
        return H.S(this.name) + ", start=" + H.S(this.startTime) + " duration=" + H.S(this.get$duration(this));
      }, null, "get$toString", 1, 0, null],
      static: {
        TimelineEvent$: [function($name, startTime, type) {
          return new O.TimelineEvent0($name, startTime, type, H.setRuntimeTypeInfo([], [O.TimelineEvent0]), []);
        }, null, null, 12, 0, null, 8, 472, 29]
      }
    },
    TraceEvent: {
      "^": "Object;json,name>,category,phase,processId,threadId,duration>,timestampMicros,args,0_frameId,0_type,$ti",
      get$id: [function(_) {
        return J.$index$asx(this.json, "id");
      }, null, null, 3, 0, null],
      get$scope: [function(_) {
        return H.stringTypeCheck(J.$index$asx(this.json, "scope"));
      }, null, null, 3, 0, null],
      get$asyncUID: [function() {
        var t1 = this.category;
        if (this.get$scope(this) == null)
          return H.S(t1) + ":" + H.S(this.get$id(this));
        else
          return H.S(t1) + ":" + H.S(this.get$scope(this)) + ":" + H.S(this.get$id(this));
      }, null, null, 2, 0, null],
      get$frameId: [function() {
        var t1 = this._frameId;
        return H.stringTypeCheck(t1 == null ? J.$index$asx(this.args, "frameId") : t1);
      }, null, null, 2, 0, null],
      set$frameId: [function(id) {
        H.stringTypeCheck(id);
        this._frameId = id;
        return id;
      }, null, null, 6, 0, null, 104],
      get$type: [function(_) {
        var t1, t2;
        t1 = this._type;
        if (t1 == null) {
          t1 = this.args;
          t2 = J.getInterceptor$asx(t1);
          if (J.$eq$(t2.$index(t1, "type"), "ui")) {
            this._type = C.TimelineEventType_0;
            t1 = C.TimelineEventType_0;
          } else if (J.$eq$(t2.$index(t1, "type"), "gpu")) {
            this._type = C.TimelineEventType_1;
            t1 = C.TimelineEventType_1;
          } else {
            this._type = C.TimelineEventType_2;
            t1 = C.TimelineEventType_2;
          }
        }
        return t1;
      }, null, null, 3, 0, null],
      set$type: [function(_, t) {
        H.interceptedTypeCheck(t, "$isTimelineEventType");
        this._type = t;
        return t;
      }, null, null, 7, 0, null, 102],
      get$isCpuEvent: [function() {
        return J.$eq$(this.get$type(this), C.TimelineEventType_0);
      }, null, null, 2, 0, null],
      toString$0: [function(_) {
        return H.S(this.get$type(this)) + " event [frameId: " + H.S(this.get$frameId()) + "] [id: " + H.S(this.get$id(this)) + "] [cat: " + H.S(this.category) + "] [ph: " + H.S(this.phase) + "] " + H.S(this.name) + " - [timestamp: " + H.S(this.timestampMicros) + "] [duration: " + H.S(this.duration) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        TraceEvent_TraceEvent: [function(json) {
          var t1 = [P.String, null];
          H.assertSubtype(json, "$isMap", t1, "$asMap");
          return O.TraceEvent$_(json, H.stringTypeCheck(json.$index(0, "name")), H.stringTypeCheck(json.$index(0, "cat")), H.stringTypeCheck(json.$index(0, "ph")), H.intTypeCheck(json.$index(0, "pid")), H.intTypeCheck(json.$index(0, "tid")), H.intTypeCheck(json.$index(0, "dur")), H.intTypeCheck(json.$index(0, "ts")), H.assertSubtype(json.$index(0, "args"), "$isMap", t1, "$asMap"));
        }, null, null, 4, 0, null, 2],
        TraceEvent$_: [function(json, $name, category, phase, processId, threadId, duration, timestampMicros, args) {
          return new O.TraceEvent(json, $name, category, phase, processId, threadId, duration, timestampMicros, args, []);
        }, null, null, 36, 0, null, 2, 8, 763, 764, 765, 766, 208, 767, 71]
      }
    }
  }], ["", "package:devtools/src/ui/custom.dart",, N, {
    "^": "",
    _defaultRenderer: [1, function(item, $T) {
      return A.li(null, "list-item", J.toString$0$(H.assertSubtypeOfRuntimeType(item, $T)));
    }, function(item) {
      return N._defaultRenderer(item, null);
    }, "call$1$1", "call$1", "custom___defaultRenderer$closure", 4, 0, 216, 66],
    ProgressElement: {
      "^": "CoreElement;_custom$_value,_max,0completeElement,element,$ti",
      ProgressElement$0: [function() {
        this.clazz$1("progress-element");
        var t1 = H.interceptedTypeCheck(A.div(null, "complete", null), "$isCoreElement");
        this.completeElement = t1;
        this.add$1(0, t1);
      }, null, null, 0, 0, null],
      static: {
        ProgressElement$: [function() {
          var t1 = new N.ProgressElement(0, 100, W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, null, null);
          t1.ProgressElement$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    Spinner: {
      "^": "CoreElement;element,$ti",
      Spinner$0: [function() {
        this.clazz$1("spinner");
      }, null, null, 0, 0, null],
      static: {
        Spinner$: [function() {
          var t1 = new N.Spinner(W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, null, null);
          t1.Spinner$0();
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    SelectableList: {
      "^": "CoreElement;items<,0renderer,0_selectedElement,_selectionController,_doubleClickController<,_itemsChangedController,canDeselect<,element,$ti",
      set$items: function(items) {
        this.items = H.assertSubtype(items, "$isList", this.$ti, "$asList");
      },
      set$renderer: function(renderer) {
        this.renderer = H.functionTypeCheck(renderer, {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this, 0)]});
      },
      get$onSelectionChanged: [function() {
        return J.get$stream$z(this._selectionController);
      }, null, null, 2, 0, null],
      get$onDoubleClick: [function(_) {
        return J.get$stream$z(this._doubleClickController);
      }, null, null, 3, 0, null],
      get$onItemsChanged: [function() {
        return J.get$stream$z(this._itemsChangedController);
      }, null, null, 2, 0, null],
      setRenderer$1: [function(renderer) {
        this.set$renderer(H.functionTypeCheck(renderer, {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this, 0)]}));
      }, null, "get$setRenderer", 4, 0, null, 476],
      setItems$2$selection: [function(items, selection) {
        var t1, t2, renderer;
        H.assertSubtype(items, "$isList", this.$ti, "$asList");
        t1 = H.getTypeArgumentByIndex(this, 0);
        H.assertSubtypeOfRuntimeType(selection, t1);
        this.set$items(items);
        t2 = this._selectedElement;
        this._selectedElement = null;
        renderer = this.renderer;
        if (renderer == null)
          renderer = H.instantiate1(N.custom___defaultRenderer$closure(), t1);
        this.clear$0(0);
        this.add$1(0, J.toList$0$ax(J.map$1$1$ax(items, new N.SelectableList_setItems_closure(this, renderer, selection), A.CoreElement)));
        if (t2 != null && this._selectedElement == null)
          J.add$1$ax(this._selectionController, null);
        J.add$1$ax(this._itemsChangedController, null);
      }, function(items) {
        return this.setItems$2$selection(items, null);
      }, "setItems$1", null, null, "get$setItems", 4, 3, null, 0, 189, 134],
      clearItems$0: [function() {
        this.setItems$1(H.setRuntimeTypeInfo([], this.$ti));
      }, null, "get$clearItems", 0, 0, null],
      _custom$_select$3$clear: [function(element, item, clear) {
        var t1;
        H.interceptedTypeCheck(element, "$isCoreElement");
        H.assertSubtypeOfRuntimeType(item, H.getTypeArgumentByIndex(this, 0));
        H.boolTypeCheck(clear);
        t1 = this._selectedElement;
        if (!(t1 == null))
          t1.toggleClass$2("selected", false);
        if (clear) {
          element = null;
          item = null;
        }
        this._selectedElement = element;
        if (!(element == null))
          element.toggleClass$2("selected", true);
        J.add$1$ax(this._selectionController, item);
      }, function(element, item) {
        return this._custom$_select$3$clear(element, item, false);
      }, "_custom$_select$2", null, null, "get$_custom$_select", 8, 3, null, 18, 10, 66, 477],
      static: {
        SelectableList$: [function($T) {
          var t1 = new N.SelectableList(H.setRuntimeTypeInfo([], [$T]), P.StreamController_StreamController$broadcast(null, null, false, $T), P.StreamController_StreamController$broadcast(null, null, false, $T), P.StreamController_StreamController$broadcast(null, null, false, -1), false, W.Element_Element$tag("div", null), [$T]);
          t1.CoreElement$4$attributes$classes$text("div", null, null, null);
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    SelectableList_setItems_closure: {
      "^": "Closure;$this,renderer,selection,$ti",
      call$1: [function(item) {
        var t1, element;
        t1 = this.$this;
        H.assertSubtypeOfRuntimeType(item, H.getTypeArgumentByIndex(t1, 0));
        element = this.renderer.call$1(item);
        element.click$1(0, new N.SelectableList_setItems__closure(t1, element, item));
        element.dblclick$1(new N.SelectableList_setItems__closure0(t1, item));
        if (J.$eq$(this.selection, item))
          t1._custom$_select$2(element, item);
        return element;
      }, null, null, 4, 0, null, 66, "call"],
      $signature: function() {
        return {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
      }
    },
    SelectableList_setItems__closure: {
      "^": "Closure:1;$this,element,item,$ti",
      call$0: [function() {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = this.element;
        t3 = t1.get$canDeselect() && t2.hasClass$1("selected");
        t1._custom$_select$3$clear(t2, this.item, t3);
      }, null, null, 0, 0, null, "call"]
    },
    SelectableList_setItems__closure0: {
      "^": "Closure:1;$this,item,$ti",
      call$0: [function() {
        J.add$1$ax(this.$this.get$_doubleClickController(), this.item);
      }, null, null, 0, 0, null, "call"]
    },
    ChildProvider: {
      "^": "Object;$ti"
    },
    SelectableTree: {
      "^": "CoreElement;items<,0renderer,0childProvider<,0_selectedElement,_selectionController,element,$ti",
      set$items: function(items) {
        this.items = H.assertSubtype(items, "$isList", this.$ti, "$asList");
      },
      set$renderer: function(renderer) {
        this.renderer = H.functionTypeCheck(renderer, {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this, 0)]});
      },
      set$childProvider: function(childProvider) {
        this.childProvider = H.assertSubtype(childProvider, "$isChildProvider", this.$ti, "$asChildProvider");
      },
      setRenderer$1: [function(renderer) {
        this.set$renderer(H.functionTypeCheck(renderer, {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this, 0)]}));
      }, null, "get$setRenderer", 4, 0, null, 476],
      setChildProvider$1: [function(childProvider) {
        this.set$childProvider(H.assertSubtype(childProvider, "$isChildProvider", this.$ti, "$asChildProvider"));
      }, null, "get$setChildProvider", 4, 0, null, 775],
      setItems$1: [function(items) {
        var t1, t2;
        H.assertSubtype(items, "$isList", this.$ti, "$asList");
        this.set$items(items);
        t1 = this._selectedElement;
        this._selectedElement = null;
        this.clear$0(0);
        for (t2 = J.get$iterator$ax(items); t2.moveNext$0();)
          this._populateInto$2(this, t2.get$current());
        if (t1 != null && this._selectedElement == null)
          J.add$1$ax(this._selectionController, null);
      }, null, "get$setItems", 4, 0, null, 189],
      _populateInto$2: [function($parent, item) {
        var t1, t2, renderer, obj, element, t3, toggle, children;
        t1 = {};
        H.interceptedTypeCheck($parent, "$isCoreElement");
        t2 = H.getTypeArgumentByIndex(this, 0);
        H.assertSubtypeOfRuntimeType(item, t2);
        renderer = this.renderer;
        obj = (renderer == null ? H.instantiate1(N.custom___defaultRenderer$closure(), t2) : renderer).call$1(item);
        obj.click$1(0, new N.SelectableTree__populateInto_closure(this, obj, item));
        element = A.div(null, null, null);
        element.add$1(0, obj);
        t2 = this.childProvider.hasChildren$1(item);
        t3 = obj.element;
        if (t2) {
          toggle = N.TreeToggle$(false);
          J.insert$2$ax(J.get$children$x(t3), 0, toggle.element);
          t1.hasPopulated = false;
          children = A.ul(null, "tree-list", null);
          element.add$1(0, children);
          children.hidden$1(0, true);
          toggle.get$onOpen(toggle).listen$1(new N.SelectableTree__populateInto_closure0(t1, this, children, item));
        } else
          J.insert$2$ax(J.get$children$x(t3), 0, N.TreeToggle$(true).element);
        $parent.add$1(0, element);
      }, null, "get$_populateInto", 8, 0, null, 24, 66],
      _custom$_select$3$clear: [function(element, item, clear) {
        var t1;
        H.interceptedTypeCheck(element, "$isCoreElement");
        H.assertSubtypeOfRuntimeType(item, H.getTypeArgumentByIndex(this, 0));
        H.boolTypeCheck(clear);
        t1 = this._selectedElement;
        if (!(t1 == null))
          t1.toggleClass$2("selected", false);
        if (clear) {
          element = null;
          item = null;
        }
        this._selectedElement = element;
        if (!(element == null))
          element.toggleClass$2("selected", true);
        J.add$1$ax(this._selectionController, item);
      }, function(element, item) {
        return this._custom$_select$3$clear(element, item, false);
      }, "_custom$_select$2", null, null, "get$_custom$_select", 8, 3, null, 18, 10, 66, 477],
      static: {
        SelectableTree$: [function($T) {
          var t1 = new N.SelectableTree(H.setRuntimeTypeInfo([], [$T]), P.StreamController_StreamController$broadcast(null, null, false, $T), W.Element_Element$tag("ul", null), [$T]);
          t1.CoreElement$4$attributes$classes$text("ul", null, null, null);
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    SelectableTree__populateInto_closure: {
      "^": "Closure:1;$this,obj,item,$ti",
      call$0: [function() {
        var t1 = this.obj;
        this.$this._custom$_select$3$clear(t1, this.item, t1.hasClass$1("selected"));
      }, null, null, 0, 0, null, "call"]
    },
    SelectableTree__populateInto_closure0: {
      "^": "Closure:16;_box_0,$this,children,item,$ti",
      call$1: [function($open) {
        var t1, t2;
        t1 = this.children;
        J.hidden$1$z(t1, !H.boolTypeCheck($open));
        t2 = this._box_0;
        if (!t2.hasPopulated) {
          t2.hasPopulated = true;
          t2 = this.$this;
          t2.get$childProvider().getChildren$1(this.item).then$1$1(new N.SelectableTree__populateInto__closure(t2, t1), null).catchError$1(new N.SelectableTree__populateInto__closure0());
        }
      }, null, null, 4, 0, null, 776, "call"]
    },
    SelectableTree__populateInto__closure: {
      "^": "Closure;$this,children,$ti",
      call$1: [function(results) {
        var t1, t2, t3;
        t1 = this.$this;
        for (t2 = J.get$iterator$ax(H.assertSubtype(results, "$isList", [H.getTypeArgumentByIndex(t1, 0)], "$asList")), t3 = this.children; t2.moveNext$0();)
          t1._populateInto$2(t3, t2.get$current());
      }, null, null, 4, 0, null, 777, "call"],
      $signature: function() {
        return {func: 1, ret: P.Null, args: [[P.List, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    SelectableTree__populateInto__closure0: {
      "^": "Closure:4;$ti",
      call$1: [function(e) {
      }, null, null, 4, 0, null, 19, "call"]
    },
    TreeToggle: {
      "^": "CoreElement;_isOpen<,_openController<,element,$ti",
      set$_isOpen: function(_isOpen) {
        this._isOpen = H.boolTypeCheck(_isOpen);
      },
      TreeToggle$1$empty: [function(empty) {
        var t1 = !empty;
        if (t1)
          this.click$1(0, new N.TreeToggle_closure(this));
        if (t1)
          this.clazz$1("octicon-triangle-right");
      }, null, null, 0, 3, null, 18, 473],
      get$onOpen: [function(_) {
        return J.get$stream$z(this._openController);
      }, null, null, 3, 0, null],
      static: {
        TreeToggle$: [function(empty) {
          var t1 = new N.TreeToggle(false, P.StreamController_StreamController$broadcast(null, null, false, P.bool), W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "tree-toggle octicon", null);
          t1.TreeToggle$1$empty(empty);
          return t1;
        }, null, null, 0, 3, null, 18, 473]
      }
    },
    TreeToggle_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.set$_isOpen(!t1.get$_isOpen());
        J.add$1$ax(t1.get$_openController(), t1.get$_isOpen());
        t1.toggleClass$2("octicon-triangle-right", !t1.get$_isOpen());
        t1.toggleClass$2("octicon-triangle-down", t1.get$_isOpen());
      }, null, null, 0, 0, null, "call"]
    },
    ActionButton: {
      "^": "Object;iconPath,tooltip,0_custom$_element,$ti",
      ActionButton$2: [function(iconPath, tooltip) {
        var t1, t2;
        t1 = A.div(null, "masthead-item action-button", null);
        t2 = A.img(null, null, this.iconPath, null);
        t2.set$tooltip(this.tooltip);
        J.add$1$ax(t1, t2);
        this._custom$_element = H.interceptedTypeCheck(t1, "$isCoreElement");
      }, null, null, 8, 0, null, 474, 312],
      click$1: [function(_, handle) {
        H.functionTypeCheck(handle, {func: 1, ret: -1});
        return J.click$1$z(this._custom$_element, handle);
      }, null, "get$click", 5, 0, null, 243],
      set$disabled: [function(_, value) {
        H.boolTypeCheck(value);
        J.set$disabled$z(this._custom$_element, value);
        return value;
      }, null, null, 7, 0, null, 1],
      get$element: [function() {
        return this._custom$_element;
      }, null, null, 2, 0, null],
      $isCoreElementView: 1,
      static: {
        ActionButton$: [function(iconPath, tooltip) {
          var t1 = new N.ActionButton(iconPath, tooltip, []);
          t1.ActionButton$2(iconPath, tooltip);
          return t1;
        }, null, null, 8, 0, null, 474, 312]
      }
    }
  }], ["", "package:devtools/src/ui/elements.dart",, A, {
    "^": "",
    label: [function(a, c, text) {
      H.stringTypeCheck(text);
      H.stringTypeCheck(c);
      return A.CoreElement$("label", H.stringTypeCheck(a), c, text);
    }, null, null, 0, 7, null, 0, 0, 0, 33, 70, 17],
    div: [function(a, c, text) {
      H.stringTypeCheck(text);
      H.stringTypeCheck(c);
      return A.CoreElement$("div", H.stringTypeCheck(a), c, text);
    }, null, null, 0, 7, null, 0, 0, 0, 33, 70, 17],
    span: [function(a, c, text) {
      H.stringTypeCheck(text);
      H.stringTypeCheck(c);
      return A.CoreElement$("span", H.stringTypeCheck(a), c, text);
    }, null, null, 0, 7, null, 0, 0, 0, 33, 70, 17],
    p: [function(a, c, text) {
      H.stringTypeCheck(text);
      H.stringTypeCheck(c);
      return A.CoreElement$("p", H.stringTypeCheck(a), c, text);
    }, null, null, 0, 7, null, 0, 0, 0, 33, 70, 17],
    img: [function(a, c, src, text) {
      var img;
      H.stringTypeCheck(text);
      H.stringTypeCheck(c);
      H.stringTypeCheck(a);
      H.stringTypeCheck(src);
      img = A.CoreElement$("img", a, c, text);
      H.interceptedTypeCast(img.element, "$isImageElement").src = src;
      return img;
    }, null, null, 0, 9, null, 0, 0, 0, 0, 33, 70, 386, 17],
    ul: [function(a, c, text) {
      H.stringTypeCheck(text);
      H.stringTypeCheck(c);
      return A.CoreElement$("ul", H.stringTypeCheck(a), c, text);
    }, null, null, 0, 7, null, 0, 0, 0, 33, 70, 17],
    li: [function(a, c, text) {
      H.stringTypeCheck(text);
      H.stringTypeCheck(c);
      return A.CoreElement$("li", H.stringTypeCheck(a), c, text);
    }, null, null, 0, 7, null, 0, 0, 0, 33, 70, 17],
    tr: [function() {
      return A.CoreElement$("tr", null, null, null);
    }, null, null, 0, 0, null],
    th: [function(c, text) {
      H.stringTypeCheck(text);
      return A.CoreElement$("th", null, H.stringTypeCheck(c), text);
    }, null, null, 0, 5, null, 0, 0, 70, 17],
    td: [function(c, text) {
      H.stringTypeCheck(text);
      return A.CoreElement$("td", null, H.stringTypeCheck(c), text);
    }, null, null, 0, 5, null, 0, 0, 70, 17],
    form: [function() {
      return A.CoreElement$("form", null, null, null);
    }, null, null, 0, 0, null],
    CoreElement: {
      "^": "Object;element<,$ti",
      CoreElement$4$attributes$classes$text: [function(tag, attributes, classes, text) {
        if (text != null)
          J.set$text$x(this.element, text);
        if (classes != null)
          J.addAll$1$ax(J.get$classes$x(this.element), H.setRuntimeTypeInfo(classes.split(" "), [P.String]));
        if (attributes != null)
          C.JSArray_methods.forEach$1(H.setRuntimeTypeInfo(attributes.split(" "), [P.String]), this.get$attribute());
      }, null, null, 4, 7, null, 0, 0, 0, 109, 479, 190, 17],
      hasAttribute$1: [function($name) {
        H.stringTypeCheck($name);
        return J.get$attributes$x(this.element).containsKey$1($name);
      }, null, "get$hasAttribute", 4, 0, null, 8],
      attribute$2: [function($name, value) {
        var t1;
        H.stringTypeCheck($name);
        H.boolTypeCheck(value);
        if (value == null)
          value = !J.get$attributes$x(this.element).containsKey$1($name);
        t1 = this.element;
        if (value)
          J.setAttribute$2$x(t1, $name, "");
        else
          J.remove$1$ax(J.get$attributes$x(t1), $name);
      }, function($name) {
        return this.attribute$2($name, null);
      }, "attribute$1", "call$2", "call$1", "get$attribute", 4, 2, 169, 0, 8, 1],
      toggleAttribute$2: [function($name, value) {
        return this.attribute$2(H.stringTypeCheck($name), H.boolTypeCheck(value));
      }, function($name) {
        return this.toggleAttribute$2($name, null);
      }, "toggleAttribute$1", null, null, "get$toggleAttribute", 4, 2, null, 0, 8, 1],
      get$attributes: [function(_) {
        return J.get$attributes$x(this.element);
      }, null, null, 3, 0, null],
      setAttribute$2: [function(_, $name, value) {
        return J.setAttribute$2$x(this.element, H.stringTypeCheck($name), H.stringTypeCheck(value));
      }, function($receiver, $name) {
        return this.setAttribute$2($receiver, $name, "");
      }, "setAttribute$1", null, null, "get$setAttribute", 5, 2, null, 39, 8, 1],
      hasClass$1: [function($name) {
        H.stringTypeCheck($name);
        return J.contains$1$asx(J.get$classes$x(this.element), $name);
      }, null, "get$hasClass", 4, 0, null, 8],
      clazz$2$removeOthers: [function(_class, removeOthers) {
        H.stringTypeCheck(_class);
        H.boolTypeCheck(removeOthers);
        if (J.contains$1$asx(_class, " "))
          throw H.wrapException(P.ArgumentError$("spaces not allowed in class names"));
        if (removeOthers)
          J.clear$0$ax(J.get$classes$x(this.element));
        J.add$1$ax(J.get$classes$x(this.element), _class);
      }, function(_class) {
        return this.clazz$2$removeOthers(_class, false);
      }, "clazz$1", "call$2$removeOthers", "call$1", "get$clazz", 4, 3, 170, 18, 780, 781],
      toggleClass$2: [function($name, value) {
        H.stringTypeCheck($name);
        H.boolTypeCheck(value);
        J.toggle$2$z(J.get$classes$x(this.element), $name, value);
      }, function($name) {
        return this.toggleClass$2($name, null);
      }, "toggleClass$1", null, null, "get$toggleClass", 4, 2, null, 0, 8, 1],
      set$text: [function(_, value) {
        J.set$text$x(this.element, H.stringTypeCheck(value));
      }, null, null, 7, 0, null, 1],
      add$1: [function(_, child) {
        var t1 = J.getInterceptor$(child);
        if (!!t1.$isIterable)
          return J.toList$0$ax(t1.map$1$1(child, new A.CoreElement_add_closure(this), null));
        else if (!!t1.$isCoreElement)
          J.add$1$ax(J.get$children$x(this.element), child.element);
        else if (!!t1.$isElement)
          J.add$1$ax(J.get$children$x(this.element), child);
        else
          throw H.wrapException(P.ArgumentError$("argument type not supported"));
        return child;
      }, "call$1", "get$add", 5, 0, 3, 130],
      hidden$1: [function(_, value) {
        return this.attribute$2("hidden", H.boolTypeCheck(value));
      }, null, "get$hidden", 1, 2, null, 0, 1],
      get$disabled: [function(_) {
        return this.hasAttribute$1("disabled");
      }, null, null, 3, 0, null],
      set$disabled: [function(_, value) {
        return this.attribute$2("disabled", H.boolTypeCheck(value));
      }, null, null, 7, 0, null, 1],
      set$enabled: [function(value) {
        return this.attribute$2("disabled", !H.boolTypeCheck(value));
      }, null, null, 6, 0, null, 1],
      layoutHorizontal$0: [function() {
        this.setAttribute$1(0, "layout");
        this.setAttribute$1(0, "horizontal");
      }, null, "get$layoutHorizontal", 0, 0, null],
      layoutVertical$0: [function() {
        this.setAttribute$1(0, "layout");
        this.setAttribute$1(0, "vertical");
      }, null, "get$layoutVertical", 0, 0, null],
      flex$1: [function(_, flexAmount) {
        H.intTypeCheck(flexAmount);
        this.attribute$2("flex", true);
        if (flexAmount != null)
          if (flexAmount === 1)
            this.attribute$2("one", true);
          else if (flexAmount === 2)
            this.attribute$2("two", true);
          else if (flexAmount === 3)
            this.attribute$2("three", true);
          else if (flexAmount === 4)
            this.attribute$2("four", true);
          else if (flexAmount === 5)
            this.attribute$2("five", true);
      }, function($receiver) {
        return this.flex$1($receiver, null);
      }, "flex$0", null, null, "get$flex", 1, 2, null, 0, 782],
      set$tooltip: [function(value) {
        J.set$title$x(this.element, H.stringTypeCheck(value));
      }, null, null, 6, 0, null, 1],
      set$display: [function(_, value) {
        H.stringTypeCheck(value);
        J.set$display$x(J.get$style$x(this.element), value);
      }, null, null, 7, 0, null, 1],
      get$scrollHeight: [function(_) {
        return J.get$scrollHeight$x(this.element);
      }, null, null, 3, 0, null],
      get$scrollTop: [function(_) {
        return J.get$scrollTop$x(this.element);
      }, null, null, 3, 0, null],
      get$offsetHeight: [function(_) {
        return J.get$offsetHeight$x(this.element);
      }, null, null, 3, 0, null],
      get$height: [function(_) {
        return J.get$height$x(J.get$style$x(this.element));
      }, null, null, 3, 0, null],
      set$height: [function(_, value) {
        H.stringTypeCheck(value);
        J.set$height$x(J.get$style$x(this.element), value);
      }, null, null, 7, 0, null, 1],
      get$onClick: [function(_) {
        return J.where$1$ax(J.get$onClick$x(this.element), new A.CoreElement_onClick_closure(this));
      }, null, null, 3, 0, null],
      get$onScroll: [function(_) {
        return J.get$onScroll$x(this.element);
      }, null, null, 3, 0, null],
      get$onKeyDown: [function(_) {
        return J.get$onKeyDown$x(this.element);
      }, null, null, 3, 0, null],
      click$2: [function(_, handle, shiftHandle) {
        var t1 = {func: 1, ret: -1};
        H.functionTypeCheck(handle, t1);
        H.functionTypeCheck(shiftHandle, t1);
        return this.get$onClick(this).listen$1(new A.CoreElement_click_closure(shiftHandle, handle));
      }, function($receiver, handle) {
        return this.click$2($receiver, handle, null);
      }, "click$1", null, null, "get$click", 5, 2, null, 0, 243, 783],
      dblclick$1: [function(handle) {
        H.functionTypeCheck(handle, {func: 1, ret: -1});
        return J.get$onDoubleClick$x(this.element).listen$1(new A.CoreElement_dblclick_closure(handle));
      }, null, "get$dblclick", 4, 0, null, 243],
      clear$0: [function(_) {
        return J.clear$0$ax(J.get$children$x(this.element));
      }, null, "get$clear", 1, 0, null],
      setInnerHtml$1: [function(_, str) {
        J.setInnerHtml$2$treeSanitizer$x(this.element, H.stringTypeCheck(str), C.C_TrustedHtmlTreeSanitizer);
      }, null, "get$setInnerHtml", 5, 0, null, 82],
      dispose$0: [function() {
        var t1, t2, exception;
        t1 = this.element;
        t2 = J.getInterceptor$x(t1);
        if (t2.get$parent(t1) == null)
          return;
        if (J.contains$1$asx(J.get$children$x(t2.get$parent(t1)), t1))
          try {
            J.remove$1$ax(J.get$children$x(t2.get$parent(t1)), t1);
          } catch (exception) {
            H.unwrapException(exception);
          }
      }, "call$0", "get$dispose", 0, 0, 0],
      toString$0: [function(_) {
        return J.toString$0$(this.element);
      }, null, "get$toString", 1, 0, null],
      static: {
        CoreElement$: [function(tag, attributes, classes, text) {
          var t1 = new A.CoreElement(W.Element_Element$tag(tag, null), []);
          t1.CoreElement$4$attributes$classes$text(tag, attributes, classes, text);
          return t1;
        }, null, null, 4, 7, null, 0, 0, 0, 109, 479, 190, 17],
        CoreElement$from: [function(element) {
          return new A.CoreElement(element, []);
        }, null, null, 4, 0, null, 10]
      }
    },
    CoreElement_add_closure: {
      "^": "Closure:3;$this,$ti",
      call$1: [function(c) {
        return J.add$1$ax(this.$this, c);
      }, null, null, 4, 0, null, 70, "call"]
    },
    CoreElement_onClick_closure: {
      "^": "Closure:171;$this,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isMouseEvent");
        return !J.get$disabled$z(this.$this);
      }, null, null, 4, 0, null, 12, "call"]
    },
    CoreElement_click_closure: {
      "^": "Closure:19;shiftHandle,handle,$ti",
      call$1: [function(e) {
        var t1;
        H.interceptedTypeCheck(e, "$isMouseEvent");
        e.stopImmediatePropagation();
        t1 = this.shiftHandle;
        if (t1 != null && e.shiftKey)
          t1.call$0();
        else
          this.handle.call$0();
      }, null, null, 4, 0, null, 19, "call"]
    },
    CoreElement_dblclick_closure: {
      "^": "Closure:10;handle,$ti",
      call$1: [function($event) {
        H.interceptedTypeCheck($event, "$isEvent").stopImmediatePropagation();
        this.handle.call$0();
      }, null, null, 4, 0, null, 22, "call"]
    },
    CloseButton: {
      "^": "CoreElement;$ti"
    },
    TrustedHtmlTreeSanitizer: {
      "^": "Object;$ti",
      sanitizeTree$1: [function(node) {
        H.interceptedTypeCheck(node, "$isNode");
      }, null, "get$sanitizeTree", 4, 0, null, 23],
      $isNodeTreeSanitizer: 1
    },
    CoreElementView: {
      "^": "Object;$ti"
    }
  }], ["", "package:devtools/src/ui/fake_flutter/dart_ui/dart_ui.dart",, S, {
    "^": "",
    _Jenkins_combine: [function(hash, o) {
      var t1;
      H.intTypeCheck(hash);
      t1 = J.get$hashCode$(o);
      if (typeof hash !== "number")
        return hash.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      hash = 536870911 & hash + t1;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    }, null, null, 8, 0, null, 155, 25],
    _Jenkins_finish: [function(hash) {
      H.intTypeCheck(hash);
      if (typeof hash !== "number")
        return H.iae(hash);
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    }, null, null, 4, 0, null, 155],
    hashValues: [function(arg01, arg02, arg03, arg04, arg05, arg06, arg07, arg08, arg09, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20) {
      var result = S._Jenkins_combine(S._Jenkins_combine(0, arg01), arg02);
      if (!J.$eq$(arg03, C.C__HashEnd)) {
        result = S._Jenkins_combine(result, arg03);
        if (!J.$eq$(arg04, C.C__HashEnd)) {
          result = S._Jenkins_combine(result, arg04);
          if (!J.$eq$(arg05, C.C__HashEnd)) {
            result = S._Jenkins_combine(result, arg05);
            if (!J.$eq$(arg06, C.C__HashEnd)) {
              result = S._Jenkins_combine(result, arg06);
              if (!J.$eq$(arg07, C.C__HashEnd)) {
                result = S._Jenkins_combine(result, arg07);
                if (!J.$eq$(arg08, C.C__HashEnd)) {
                  result = S._Jenkins_combine(result, arg08);
                  if (!J.$eq$(arg09, C.C__HashEnd)) {
                    result = S._Jenkins_combine(result, arg09);
                    if (!J.$eq$(arg10, C.C__HashEnd)) {
                      result = S._Jenkins_combine(result, arg10);
                      if (!J.$eq$(arg11, C.C__HashEnd)) {
                        result = S._Jenkins_combine(result, arg11);
                        if (!J.$eq$(arg12, C.C__HashEnd)) {
                          result = S._Jenkins_combine(result, arg12);
                          if (!J.$eq$(arg13, C.C__HashEnd)) {
                            result = S._Jenkins_combine(result, arg13);
                            if (!J.$eq$(arg14, C.C__HashEnd)) {
                              result = S._Jenkins_combine(result, arg14);
                              if (!J.$eq$(arg15, C.C__HashEnd)) {
                                result = S._Jenkins_combine(result, arg15);
                                if (!J.$eq$(arg16, C.C__HashEnd)) {
                                  result = S._Jenkins_combine(result, arg16);
                                  if (!J.$eq$(arg17, C.C__HashEnd)) {
                                    result = S._Jenkins_combine(result, arg17);
                                    if (!J.$eq$(arg18, C.C__HashEnd)) {
                                      result = S._Jenkins_combine(result, arg18);
                                      if (!J.$eq$(arg19, C.C__HashEnd)) {
                                        result = S._Jenkins_combine(result, arg19);
                                        if (!J.$eq$(arg20, C.C__HashEnd))
                                          result = S._Jenkins_combine(result, arg20);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return S._Jenkins_finish(result);
    }, null, null, 8, 36, null, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808],
    hashList: [function($arguments) {
      var t1, result;
      H.assertSubtype($arguments, "$isIterable", [P.Object], "$asIterable");
      if ($arguments != null)
        for (t1 = J.get$iterator$ax($arguments), result = 0; t1.moveNext$0();)
          result = S._Jenkins_combine(result, t1.get$current());
      else
        result = 0;
      return S._Jenkins_finish(result);
    }, null, null, 4, 0, null, 94],
    Color: {
      "^": "Object;value>,$ti",
      get$alpha: [function(_) {
        var t1 = this.value;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return (4278190080 & t1) >>> 24;
      }, null, null, 3, 0, null],
      $eq: ["super$Color$$eq", function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!J.$eq$(J.get$runtimeType$(other), this.get$runtimeType(this)))
          return false;
        return J.$eq$(this.value, H.interceptedTypeCheck(other, "$isColor").value);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.value);
      }, null, null, 3, 0, null],
      toString$0: ["super$Color$toString", function(_) {
        return H.throwExpression("Warning: do not add colors directly to HTML");
      }, null, "get$toString", 1, 0, null],
      static: {
        Color$fromARGB: [function(a, r, g, b) {
          if (typeof a !== "number")
            return a.$and();
          if (typeof r !== "number")
            return r.$and();
          if (typeof g !== "number")
            return g.$and();
          if (typeof b !== "number")
            return b.$and();
          return new S.Color((((a & 255) << 24 | (r & 255) << 16 | (g & 255) << 8 | (b & 255) << 0) & 4294967295) >>> 0, []);
        }, null, null, 16, 0, null, 33, 784, 391, 54]
      }
    },
    MaterialColor: {
      "^": "ColorSwatch;_swatch,value,$ti",
      get$shade500: [function() {
        return this.$index(0, 500);
      }, null, null, 2, 0, null],
      $asColorSwatch: function() {
        return [P.int];
      }
    },
    MaterialAccentColor: {
      "^": "ColorSwatch;_swatch,value,$ti",
      $asColorSwatch: function() {
        return [P.int];
      }
    },
    Colors: {
      "^": "Object;$ti"
    },
    HSVColor: {
      "^": "Object;$ti"
    },
    HSLColor: {
      "^": "Object;$ti"
    },
    ColorSwatch: {
      "^": "Color;$ti",
      $index: [function(_, index) {
        return J.$index$asx(this._swatch, H.assertSubtypeOfRuntimeType(index, H.getRuntimeTypeArgument(this, "ColorSwatch", 0)));
      }, null, "get$[]", 5, 0, null, 6],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!J.$eq$(J.get$runtimeType$(other), this.get$runtimeType(this)))
          return false;
        H.assertSubtype(other, "$isColorSwatch", [H.getRuntimeTypeArgument(this, "ColorSwatch", 0)], "$asColorSwatch");
        return this.super$Color$$eq(0, other) && J.$eq$(this._swatch, other._swatch);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return S.hashValues(this.get$runtimeType(this), this.value, this._swatch, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return H.S(this.get$runtimeType(this)) + "(primary value: " + H.S(this.super$Color$toString(0)) + ")";
      }, null, "get$toString", 1, 0, null]
    },
    OffsetBase: {
      "^": "Object;$ti",
      $lt: [function(_, other) {
        H.interceptedTypeCheck(other, "$isOffsetBase");
        return J.$lt$n(this._dx, other._dx) && J.$lt$n(this._dy, other._dy);
      }, null, "get$<", 5, 0, null, 3],
      $le: [function(_, other) {
        H.interceptedTypeCheck(other, "$isOffsetBase");
        return J.$le$n(this._dx, other._dx) && J.$le$n(this._dy, other._dy);
      }, null, "get$<=", 5, 0, null, 3],
      $gt: [function(_, other) {
        H.interceptedTypeCheck(other, "$isOffsetBase");
        return J.$gt$n(this._dx, other._dx) && J.$gt$n(this._dy, other._dy);
      }, null, "get$>", 5, 0, null, 3],
      $ge: [function(_, other) {
        H.interceptedTypeCheck(other, "$isOffsetBase");
        return J.$gt$n(this._dx, other._dx) && J.$ge$n(this._dy, other._dy);
      }, null, "get$>=", 5, 0, null, 3],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof S.OffsetBase))
          return false;
        return J.$eq$(this._dx, other._dx) && J.$eq$(this._dy, other._dy);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return S.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        var t1, t2;
        t1 = H.S(this.get$runtimeType(this)) + "(";
        t2 = this._dx;
        t1 = t1 + H.S(t2 == null ? null : J.toStringAsFixed$1$n(t2, 1)) + ", ";
        t2 = this._dy;
        return t1 + H.S(t2 == null ? null : J.toStringAsFixed$1$n(t2, 1)) + ")";
      }, null, "get$toString", 1, 0, null]
    },
    Offset: {
      "^": "OffsetBase;_dx,_dy,$ti",
      get$dx: [function(_) {
        return this._dx;
      }, null, null, 3, 0, null],
      get$dy: [function(_) {
        return this._dy;
      }, null, null, 3, 0, null],
      $sub: [function(_, other) {
        H.interceptedTypeCheck(other, "$isOffset");
        return S.Offset$(J.$sub$n(this.get$dx(this), other.get$dx(other)), J.$sub$n(this.get$dy(this), other.get$dy(other)));
      }, null, "get$-", 5, 0, null, 3],
      $add: [function(_, other) {
        H.interceptedTypeCheck(other, "$isOffset");
        return S.Offset$(J.$add$ansx(this.get$dx(this), other.get$dx(other)), J.$add$ansx(this.get$dy(this), other.get$dy(other)));
      }, null, "get$+", 5, 0, null, 3],
      $mul: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Offset$(J.$mul$ns(this.get$dx(this), operand), J.$mul$ns(this.get$dy(this), operand));
      }, null, "get$*", 5, 0, null, 129],
      $div: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Offset$(J.$div$n(this.get$dx(this), operand), J.$div$n(this.get$dy(this), operand));
      }, null, "get$/", 5, 0, null, 129],
      $tdiv: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Offset$(J.toDouble$0$n(J.$tdiv$n(this.get$dx(this), operand)), J.toDouble$0$n(J.$tdiv$n(this.get$dy(this), operand)));
      }, null, "get$~/", 5, 0, null, 129],
      $mod: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Offset$(J.$mod$n(this.get$dx(this), operand), J.$mod$n(this.get$dy(this), operand));
      }, null, "get$%", 5, 0, null, 129],
      $and: [function(_, other) {
        H.interceptedTypeCheck(other, "$isSize");
        return S.Rect$fromLTWH(this.get$dx(this), this.get$dy(this), other.get$width(other), other.get$height(other));
      }, null, "get$&", 5, 0, null, 3],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof S.Offset))
          return false;
        return J.$eq$(this._dx, other._dx) && J.$eq$(this._dy, other._dy);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return S.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        var t1, t2;
        t1 = this.get$dx(this);
        t1 = "Offset(" + H.S(t1 == null ? null : J.toStringAsFixed$1$n(t1, 1)) + ", ";
        t2 = this.get$dy(this);
        return t1 + H.S(t2 == null ? null : J.toStringAsFixed$1$n(t2, 1)) + ")";
      }, null, "get$toString", 1, 0, null],
      static: {
        Offset$: [function(dx, dy) {
          return new S.Offset(dx, dy, []);
        }, null, null, 8, 0, null, 785, 786]
      }
    },
    Size: {
      "^": "OffsetBase;_dx,_dy,$ti",
      get$width: [function(_) {
        return this._dx;
      }, null, null, 3, 0, null],
      get$height: [function(_) {
        return this._dy;
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$le$n(this.get$width(this), 0) || J.$le$n(this.get$height(this), 0);
      }, null, null, 3, 0, null],
      $sub: [function(_, other) {
        var t1;
        H.interceptedTypeCheck(other, "$isOffsetBase");
        t1 = J.getInterceptor$(other);
        if (!!t1.$isSize)
          return S.Offset$(J.$sub$n(this.get$width(this), other.get$width(other)), J.$sub$n(this.get$height(this), other.get$height(other)));
        if (!!t1.$isOffset)
          return S.Size$(J.$sub$n(this.get$width(this), other.get$dx(other)), J.$sub$n(this.get$height(this), other.get$dy(other)));
        throw H.wrapException(P.ArgumentError$(other));
      }, null, "get$-", 5, 0, null, 3],
      $add: [function(_, other) {
        H.interceptedTypeCheck(other, "$isOffset");
        return S.Size$(J.$add$ansx(this.get$width(this), other.get$dx(other)), J.$add$ansx(this.get$height(this), other.get$dy(other)));
      }, null, "get$+", 5, 0, null, 3],
      $mul: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Size$(J.$mul$ns(this.get$width(this), operand), J.$mul$ns(this.get$height(this), operand));
      }, null, "get$*", 5, 0, null, 129],
      $div: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Size$(J.$div$n(this.get$width(this), operand), J.$div$n(this.get$height(this), operand));
      }, null, "get$/", 5, 0, null, 129],
      $tdiv: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Size$(J.toDouble$0$n(J.$tdiv$n(this.get$width(this), operand)), J.toDouble$0$n(J.$tdiv$n(this.get$height(this), operand)));
      }, null, "get$~/", 5, 0, null, 129],
      $mod: [function(_, operand) {
        H.doubleTypeCheck(operand);
        return S.Size$(J.$mod$n(this.get$width(this), operand), J.$mod$n(this.get$height(this), operand));
      }, null, "get$%", 5, 0, null, 129],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof S.Size))
          return false;
        return J.$eq$(this._dx, other._dx) && J.$eq$(this._dy, other._dy);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return S.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        var t1, t2;
        t1 = this.get$width(this);
        t1 = "Size(" + H.S(t1 == null ? null : J.toStringAsFixed$1$n(t1, 1)) + ", ";
        t2 = this.get$height(this);
        return t1 + H.S(t2 == null ? null : J.toStringAsFixed$1$n(t2, 1)) + ")";
      }, null, "get$toString", 1, 0, null],
      static: {
        Size$: [function(width, height) {
          return new S.Size(width, height, []);
        }, null, null, 8, 0, null, 56, 96]
      }
    },
    Rect: {
      "^": "Object;_dart_ui$_value,$ti",
      Rect$fromLTRB$4: [function(left, $top, right, bottom) {
        var t1, t2;
        t1 = this._dart_ui$_value;
        t2 = J.getInterceptor$ax(t1);
        t2.$indexSet(t1, 0, left);
        t2.$indexSet(t1, 1, $top);
        t2.$indexSet(t1, 2, right);
        t2.$indexSet(t1, 3, bottom);
      }, null, null, 16, 0, null, 119, 186, 214, 480],
      Rect$fromLTWH$4: [function(left, $top, width, height) {
        var t1, t2;
        t1 = this._dart_ui$_value;
        t2 = J.getInterceptor$ax(t1);
        t2.$indexSet(t1, 0, left);
        t2.$indexSet(t1, 1, $top);
        if (typeof left !== "number")
          return left.$add();
        if (typeof width !== "number")
          return H.iae(width);
        t2.$indexSet(t1, 2, left + width);
        if (typeof $top !== "number")
          return $top.$add();
        if (typeof height !== "number")
          return H.iae(height);
        t2.$indexSet(t1, 3, $top + height);
      }, null, null, 16, 0, null, 119, 186, 56, 96],
      get$left: [function(_) {
        return J.$index$asx(this._dart_ui$_value, 0);
      }, null, null, 3, 0, null],
      get$top: [function(_) {
        return J.$index$asx(this._dart_ui$_value, 1);
      }, null, null, 3, 0, null],
      get$right: [function(_) {
        return J.$index$asx(this._dart_ui$_value, 2);
      }, null, null, 3, 0, null],
      get$bottom: [function(_) {
        return J.$index$asx(this._dart_ui$_value, 3);
      }, null, null, 3, 0, null],
      get$width: [function(_) {
        return J.$sub$n(this.get$right(this), this.get$left(this));
      }, null, null, 3, 0, null],
      get$height: [function(_) {
        return J.$sub$n(this.get$bottom(this), this.get$top(this));
      }, null, null, 3, 0, null],
      get$isEmpty: [function(_) {
        return J.$ge$n(this.get$left(this), this.get$right(this)) || J.$ge$n(this.get$top(this), this.get$bottom(this));
      }, null, null, 3, 0, null],
      inflate$1: [function(delta) {
        H.doubleTypeCheck(delta);
        return S.Rect$fromLTRB(J.$sub$n(this.get$left(this), delta), J.$sub$n(this.get$top(this), delta), J.$add$ansx(this.get$right(this), delta), J.$add$ansx(this.get$bottom(this), delta));
      }, null, "get$inflate", 4, 0, null, 810],
      intersect$1: [function(other) {
        var t1;
        H.interceptedTypeCheck(other, "$isRect");
        t1 = P.double;
        return S.Rect$fromLTRB(P.max(this.get$left(this), other.get$left(other), t1), P.max(this.get$top(this), other.get$top(other), t1), P.min(this.get$right(this), other.get$right(other), t1), P.min(this.get$bottom(this), other.get$bottom(other), t1));
      }, null, "get$intersect", 4, 0, null, 3],
      expandToInclude$1: [function(other) {
        var t1;
        H.interceptedTypeCheck(other, "$isRect");
        t1 = P.double;
        return S.Rect$fromLTRB(P.min(this.get$left(this), other.get$left(other), t1), P.min(this.get$top(this), other.get$top(other), t1), P.max(this.get$right(this), other.get$right(other), t1), P.max(this.get$bottom(this), other.get$bottom(other), t1));
      }, null, "get$expandToInclude", 4, 0, null, 3],
      overlaps$1: [function(other) {
        H.interceptedTypeCheck(other, "$isRect");
        if (J.$le$n(this.get$right(this), other.get$left(other)) || J.$le$n(other.get$right(other), this.get$left(this)))
          return false;
        if (J.$le$n(this.get$bottom(this), other.get$top(other)) || J.$le$n(other.get$bottom(other), this.get$top(this)))
          return false;
        return true;
      }, null, "get$overlaps", 4, 0, null, 3],
      get$topLeft: [function(_) {
        return S.Offset$(this.get$left(this), this.get$top(this));
      }, null, null, 3, 0, null],
      get$bottomLeft: [function(_) {
        return S.Offset$(this.get$left(this), this.get$bottom(this));
      }, null, null, 3, 0, null],
      get$bottomRight: [function(_) {
        return S.Offset$(this.get$right(this), this.get$bottom(this));
      }, null, null, 3, 0, null],
      contains$1: [function(_, offset) {
        H.interceptedTypeCheck(offset, "$isOffset");
        return J.$ge$n(offset.get$dx(offset), this.get$left(this)) && J.$lt$n(offset.get$dx(offset), this.get$right(this)) && J.$ge$n(offset.get$dy(offset), this.get$top(this)) && J.$lt$n(offset.get$dy(offset), this.get$bottom(this));
      }, null, "get$contains", 5, 0, null, 52],
      $eq: [function(_, other) {
        var t1, t2, t3, t4, i;
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!J.$eq$(this.get$runtimeType(this), J.get$runtimeType$(other)))
          return false;
        for (t1 = this._dart_ui$_value, t2 = J.getInterceptor$asx(t1), t3 = H.interceptedTypeCheck(other, "$isRect")._dart_ui$_value, t4 = J.getInterceptor$asx(t3), i = 0; i < 4; ++i)
          if (!J.$eq$(t2.$index(t1, i), t4.$index(t3, i)))
            return false;
        return true;
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return S.hashList(this._dart_ui$_value);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return "Rect.fromLTRB(" + H.S(J.toStringAsFixed$1$n(this.get$left(this), 1)) + ", " + H.S(J.toStringAsFixed$1$n(this.get$top(this), 1)) + ", " + H.S(J.toStringAsFixed$1$n(this.get$right(this), 1)) + ", " + H.S(J.toStringAsFixed$1$n(this.get$bottom(this), 1)) + ")";
      }, null, "get$toString", 1, 0, null],
      static: {
        Rect$_: [function() {
          return new S.Rect(H.NativeFloat32List_NativeFloat32List(4), []);
        }, null, null, 0, 0, null],
        Rect$fromLTRB: [function(left, $top, right, bottom) {
          var t1 = new S.Rect(H.NativeFloat32List_NativeFloat32List(4), []);
          t1.Rect$fromLTRB$4(left, $top, right, bottom);
          return t1;
        }, null, null, 16, 0, null, 119, 186, 214, 480],
        Rect$fromLTWH: [function(left, $top, width, height) {
          var t1 = new S.Rect(H.NativeFloat32List_NativeFloat32List(4), []);
          t1.Rect$fromLTWH$4(left, $top, width, height);
          return t1;
        }, null, null, 16, 0, null, 119, 186, 56, 96]
      }
    },
    Radius: {
      "^": "Object;$ti"
    },
    RRect: {
      "^": "Object;$ti"
    },
    RSTransform: {
      "^": "Object;$ti"
    },
    _HashEnd: {
      "^": "Object;$ti"
    },
    _Jenkins: {
      "^": "Object;$ti"
    },
    FontStyle: {
      "^": "Object;index>,_dart_ui$_name,$ti",
      toString$0: [function(_) {
        return this._dart_ui$_name;
      }, null, "get$toString", 1, 0, null]
    },
    FontWeight: {
      "^": "Object;index>,$ti",
      toString$0: [function(_) {
        return C.Map_yXAeS.$index(0, this.index);
      }, null, "get$toString", 1, 0, null]
    },
    TextAlign: {
      "^": "Object;$ti"
    },
    TextBaseline: {
      "^": "Object;$ti"
    },
    TextDecoration: {
      "^": "Object;$ti"
    },
    TextDecorationStyle: {
      "^": "Object;$ti"
    },
    TextStyle0: {
      "^": "Object;$ti"
    },
    ParagraphStyle: {
      "^": "Object;$ti"
    },
    TextDirection: {
      "^": "Object;$ti"
    },
    TextAffinity: {
      "^": "Object;$ti"
    },
    TextPosition: {
      "^": "Object;$ti"
    },
    ParagraphConstraints: {
      "^": "Object;$ti"
    },
    BoxHeightStyle: {
      "^": "Object;$ti"
    },
    BoxWidthStyle: {
      "^": "Object;$ti"
    }
  }], ["fake_flutter", "package:devtools/src/ui/fake_flutter/fake_flutter.dart",, U, {
    "^": "",
    TextRenderer_renderToString: [function(node, minLevel, parentConfiguration, prefixLineOne, prefixOtherLines, wrapWidth, wrapWidthProperties) {
      var _box_0, t1, t2, config, descendants, information, builder, children, description, properties, t3, t4, t5, i, t6, property, propertyStyle, message, lines, j, line, prefixChildren, prefix, child, childConfig, lastChildPrefixLineOne, nextChildStyle, childPrefixLineOne;
      _box_0 = {};
      _box_0.prefixOtherLines = prefixOtherLines;
      H.interceptedTypeCheck(node, "$isDiagnosticsNode");
      H.stringTypeCheck(prefixLineOne);
      H.stringTypeCheck(prefixOtherLines);
      H.interceptedTypeCheck(parentConfiguration, "$isTextTreeConfiguration");
      H.interceptedTypeCheck(minLevel, "$isDiagnosticLevel");
      H.intTypeCheck(wrapWidth);
      H.intTypeCheck(wrapWidthProperties);
      if (prefixOtherLines == null) {
        _box_0.prefixOtherLines = prefixLineOne;
        t1 = prefixLineOne;
      } else
        t1 = prefixOtherLines;
      t2 = node.linePrefix;
      if (t2 != null) {
        prefixLineOne = J.$add$ansx(prefixLineOne, t2);
        prefixOtherLines = J.$add$ansx(t1, t2);
        _box_0.prefixOtherLines = prefixOtherLines;
        t1 = prefixOtherLines;
      }
      config = node.get$textTreeConfiguration();
      if (J.get$isEmpty$asx(t1)) {
        prefixOtherLines = C.JSString_methods.$add(t1, config.prefixOtherLinesRootNode);
        _box_0.prefixOtherLines = prefixOtherLines;
        t1 = prefixOtherLines;
      }
      if (J.$eq$(node.get$style(node), C.DiagnosticsTreeStyle_11)) {
        descendants = H.setRuntimeTypeInfo([], [P.String]);
        _box_0.depth = 0;
        _box_0.lines = 0;
        new U.TextRenderer_renderToString_visitor(_box_0, 25, descendants, 5).call$1(node);
        information = P.StringBuffer$(prefixLineOne);
        if (J.$gt$n(_box_0.lines, 1))
          information.writeln$1("This " + H.S(node.name) + " had the following descendants (showing up to depth 5):");
        else {
          t1 = descendants.length;
          t2 = node.name;
          if (t1 === 1)
            information.writeln$1("This " + H.S(t2) + " had the following child:");
          else
            information.writeln$1("This " + H.S(t2) + " has no descendants.");
        }
        information.writeAll$2(descendants, "\n");
        return information.toString$0(0);
      }
      builder = U._PrefixedStringBuilder$(prefixLineOne, t1);
      children = node.getChildren$0();
      description = node.toDescription$1$parentConfiguration(parentConfiguration);
      t1 = config.beforeName;
      if (J.get$isNotEmpty$asx(t1))
        builder.write$1(t1);
      if (description == null || C.JSString_methods.get$isEmpty(description)) {
        if (node.showName && node.name != null)
          builder.write$1(node.name);
      } else {
        t1 = node.name;
        if (t1 != null && J.get$isNotEmpty$asx(t1) && node.showName) {
          builder.write$1(t1);
          if (node.showSeparator)
            builder.write$1(config.afterName);
          builder.write$1(config.isNameOnOwnLine || J.contains$1$asx(description, "\n") ? "\n" : " ");
          if (J.contains$1$asx(description, "\n") && J.$eq$(node.get$style(node), C.DiagnosticsTreeStyle_7))
            builder.prefixOtherLines = H.stringTypeCheck(J.$add$ansx(builder.prefixOtherLines, "  "));
        }
        t1 = builder.prefixOtherLines;
        builder.prefixOtherLines = H.stringTypeCheck(J.$add$ansx(t1, J.get$isEmpty$asx(children) ? config.propertyPrefixNoChildren : config.propertyPrefixIfChildren));
        builder.write$1(description);
      }
      t1 = config.suffixLineOne;
      if (J.get$isNotEmpty$asx(t1))
        builder.writeStretched$2(t1, wrapWidth);
      properties = J.toList$0$ax(J.where$1$ax(node.getProperties$0(), new U.TextRenderer_renderToString_closure(minLevel)));
      builder.write$1(config.afterDescription);
      t1 = J.getInterceptor$asx(properties);
      if (t1.get$isNotEmpty(properties) || J.get$isNotEmpty$asx(children) || node.get$emptyBodyDescription() != null)
        builder.write$1(config.afterDescriptionIfBody);
      t2 = config.lineBreakProperties;
      if (t2)
        builder.write$1(config.lineBreak);
      if (t1.get$isNotEmpty(properties))
        builder.write$1(config.beforeProperties);
      t3 = builder.prefixOtherLines;
      t4 = config.bodyIndent;
      builder.prefixOtherLines = H.stringTypeCheck(J.$add$ansx(t3, t4));
      if (node.get$emptyBodyDescription() != null && t1.get$isEmpty(properties) && J.get$isEmpty$asx(children) && J.get$isNotEmpty$asx(prefixLineOne)) {
        builder.write$1(node.get$emptyBodyDescription());
        if (t2)
          builder.write$1(config.lineBreak);
      }
      t3 = [P.String];
      t5 = config.lineBreak;
      i = 0;
      while (true) {
        t6 = t1.get$length(properties);
        if (typeof t6 !== "number")
          return H.iae(t6);
        if (!(i < t6))
          break;
        c$0: {
          property = t1.$index(properties, i);
          if (i > 0)
            builder.write$1(config.propertySeparator);
          if (!J.$eq$(property.get$style(property), C.DiagnosticsTreeStyle_7)) {
            propertyStyle = property.get$textTreeConfiguration();
            builder.writeRaw$1(U.TextRenderer_renderToString(property, minLevel, config, H.S(builder.prefixOtherLines) + H.S(propertyStyle.prefixLineOne), H.S(builder.prefixOtherLines) + H.S(propertyStyle.linkCharacter) + H.S(propertyStyle.prefixOtherLines), wrapWidth, wrapWidthProperties));
            break c$0;
          }
          message = property.toString$2$minLevel$parentConfiguration(0, minLevel, config);
          if (t2) {
            t6 = message.length;
            if (typeof wrapWidth !== "number")
              return H.iae(wrapWidth);
            t6 = t6 < wrapWidth || !property.get$allowWrap();
          } else
            t6 = true;
          if (t6)
            builder.write$1(message);
          else {
            lines = H.setRuntimeTypeInfo(message.split("\n"), t3);
            for (j = 0; j < lines.length; ++j) {
              line = lines[j];
              if (j > 0)
                builder.write$1(t5);
              builder.write$1(J.join$1$ax(U.debugWordWrap(line, wrapWidthProperties, "  "), "\n"));
            }
          }
          if (t2)
            builder.write$1(t5);
        }
        ++i;
      }
      if (t1.get$isNotEmpty(properties))
        builder.write$1(config.afterProperties);
      if (!t2)
        builder.write$1(t5);
      prefixChildren = H.S(_box_0.prefixOtherLines) + H.S(t4);
      t2 = J.getInterceptor$asx(children);
      if (t2.get$isEmpty(children) && config.addBlankLineIfNoChildren && builder.get$hasMultipleLines()) {
        prefix = C.JSString_methods.trimRight$0(prefixChildren);
        if (J.get$isNotEmpty$asx(prefix))
          builder.writeRaw$1(prefix + H.S(t5));
      }
      if (t2.get$isNotEmpty(children) && config.showChildren) {
        if (config.isBlankLineBetweenPropertiesAndChildren && t1.get$isNotEmpty(properties) && t2.get$first(children).get$textTreeConfiguration().get$isBlankLineBetweenPropertiesAndChildren())
          builder.write$1(t5);
        t1 = config.manditoryFooter;
        i = 0;
        while (true) {
          t3 = t2.get$length(children);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          child = t2.$index(children, i);
          childConfig = node._childTextConfiguration$2(child, config);
          if (i === J.$sub$n(t2.get$length(children), 1)) {
            lastChildPrefixLineOne = prefixChildren + H.S(childConfig.prefixLastChildLineOne);
            t3 = childConfig.childLinkSpace;
            builder.writeRawLine$1(U.TextRenderer_renderToString(child, minLevel, config, lastChildPrefixLineOne, prefixChildren + H.S(t3) + H.S(childConfig.prefixOtherLines), wrapWidth, wrapWidthProperties));
            t4 = childConfig.footer;
            if (J.get$isNotEmpty$asx(t4)) {
              builder.writeRaw$1(prefixChildren + H.S(t3) + H.S(t4));
              if (J.get$isNotEmpty$asx(childConfig.manditoryFooter))
                builder.writeStretched$2(t1, wrapWidth);
              builder.write$1(t5);
            }
          } else {
            nextChildStyle = node._childTextConfiguration$2(t2.$index(children, i + 1), config);
            childPrefixLineOne = prefixChildren + H.S(childConfig.prefixLineOne);
            t3 = nextChildStyle.linkCharacter;
            builder.writeRawLine$1(U.TextRenderer_renderToString(child, minLevel, config, childPrefixLineOne, prefixChildren + H.S(t3) + H.S(childConfig.prefixOtherLines), wrapWidth, wrapWidthProperties));
            t4 = childConfig.footer;
            if (J.get$isNotEmpty$asx(t4)) {
              builder.writeRaw$1(prefixChildren + H.S(t3) + H.S(t4));
              if (J.get$isNotEmpty$asx(childConfig.manditoryFooter))
                builder.writeStretched$2(t1, wrapWidth);
              builder.write$1(t5);
            }
          }
          ++i;
        }
      }
      if (parentConfiguration == null && J.get$isNotEmpty$asx(config.manditoryFooter))
        builder.writeStretched$2(config.manditoryFooter, wrapWidth);
      return builder.toString$0(0);
    }, null, null, 4, 13, null, 233, 0, 39, 0, 0, 0, 23, 169, 171, 192, 203, 840, 841],
    shortHash: [function(object) {
      return J.padLeft$2$s(J.toRadixString$1$n(J.toUnsigned$1$i(J.get$hashCode$(object), 20), 16), 5, "0");
    }, null, null, 4, 0, null, 9],
    describeIdentity: [function(object) {
      return H.S(J.get$runtimeType$(object)) + "#" + H.S(U.shortHash(object));
    }, null, null, 4, 0, null, 9],
    debugWordWrap: [function(message, width, wrapIndent) {
      return U.debugWordWrap$body(H.stringTypeCheck(message), H.intTypeCheck(width), H.stringTypeCheck(wrapIndent));
    }, null, null, 8, 3, null, 39, 21, 56, 483],
    debugWordWrap$body: [function($async$message, $async$width, $async$wrapIndent) {
      return P._makeSyncStarIterable(function() {
        var message = $async$message,
          width = $async$width,
          wrapIndent = $async$wrapIndent;
        var $async$goto = 0, $async$handler = 2, $async$currentError, t1, prefix, index, t2, t3, index0, start, startForLengthCalculations, addPrefix, mode, lastWordStart, lastWordEnd, t4;
        return function $async$debugWordWrap($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  t1 = message.length;
                  if (typeof width !== "number") {
                    H.iae(width);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  $async$goto = t1 < width || J.$eq$(J.$index$asx(J.trimLeft$0$s(message), 0), "#") ? 3 : 4;
                  break;
                case 3:
                  // then
                  $async$goto = 5;
                  return message;
                case 5:
                  // after yield
                  // goto return
                  $async$goto = 1;
                  break;
                case 4:
                  // join
                  prefix = J.$add$ansx(wrapIndent, C.JSString_methods.$mul(" ", J.get$length$asx(J.matchAsPrefix$1$s($.$get$_indentPattern(), message).group$1(0))));
                  index = prefix.length;
                  t2 = J.getInterceptor$s(message), t3 = J.getInterceptor$ansx(prefix), index0 = index, start = 0, startForLengthCalculations = 0, addPrefix = false, mode = C._WordWrapParseMode_0, lastWordStart = null, lastWordEnd = null;
                case 6:
                  // for condition
                  // trivial condition
                case 8:
                  // switch
                  switch (mode) {
                    case C._WordWrapParseMode_0:
                      // goto case
                      $async$goto = 10;
                      break;
                    case C._WordWrapParseMode_1:
                      // goto case
                      $async$goto = 11;
                      break;
                    case C._WordWrapParseMode_2:
                      // goto case
                      $async$goto = 12;
                      break;
                    default:
                      // goto after switch
                      $async$goto = 9;
                      break;
                  }
                  break;
                case 10:
                  // case
                  while (true) {
                    if (index0 < t1) {
                      if (index0 < 0) {
                        H.ioore(message, index0);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t4 = J.$eq$(message[index0], " ");
                    } else
                      t4 = false;
                    if (!t4)
                      break;
                    ++index0;
                  }
                  lastWordStart = index0;
                  mode = C._WordWrapParseMode_1;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 11:
                  // case
                  while (true) {
                    if (index0 < t1) {
                      if (index0 < 0) {
                        H.ioore(message, index0);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t4 = !J.$eq$(message[index0], " ");
                    } else
                      t4 = false;
                    if (!t4)
                      break;
                    ++index0;
                  }
                  mode = C._WordWrapParseMode_2;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 12:
                  // case
                  t4 = index0 - startForLengthCalculations;
                  $async$goto = t4 > width || index0 === t1 ? 13 : 15;
                  break;
                case 13:
                  // then
                  if (t4 <= width || lastWordEnd == null)
                    lastWordEnd = index0;
                  $async$goto = addPrefix ? 16 : 18;
                  break;
                case 16:
                  // then
                  $async$goto = 19;
                  return t3.$add(prefix, t2.substring$2(message, start, lastWordEnd));
                case 19:
                  // after yield
                  // goto join
                  $async$goto = 17;
                  break;
                case 18:
                  // else
                  $async$goto = 20;
                  return t2.substring$2(message, start, lastWordEnd);
                case 20:
                  // after yield
                  addPrefix = true;
                case 17:
                  // join
                  if (lastWordEnd >= t1) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  if (lastWordEnd === index0) {
                    while (true) {
                      if (index0 < t1) {
                        if (index0 < 0) {
                          H.ioore(message, index0);
                          // goto return
                          $async$goto = 1;
                          break $async$outer;
                        }
                        t4 = J.$eq$(message[index0], " ");
                      } else
                        t4 = false;
                      if (!t4)
                        break;
                      ++index0;
                    }
                    start = index0;
                    mode = C._WordWrapParseMode_1;
                  } else {
                    start = lastWordStart;
                    mode = C._WordWrapParseMode_2;
                  }
                  if (typeof start !== "number") {
                    start.$sub();
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  startForLengthCalculations = start - index;
                  lastWordEnd = null;
                  // goto join
                  $async$goto = 14;
                  break;
                case 15:
                  // else
                  lastWordEnd = index0;
                  mode = C._WordWrapParseMode_0;
                case 14:
                  // join
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 9:
                  // after switch
                  // goto for condition
                  $async$goto = 6;
                  break;
                case 7:
                  // after for
                case 1:
                  // return
                  return P._IterationMarker_endOfIteration();
                case 2:
                  // rethrow
                  return P._IterationMarker_uncaughtError($async$currentError);
              }
        };
      }, P.String);
    }, null, null, 8, 3, null, 39, 21, 56, 483],
    FlutterError: {
      "^": "AssertionError;$ti"
    },
    DiagnosticLevel: {
      "^": "Object;index>,_fake_flutter$_name,$ti",
      toString$0: [function(_) {
        return this._fake_flutter$_name;
      }, null, "get$toString", 1, 0, null],
      static: {
        "^": "DiagnosticLevel_error<"
      }
    },
    DiagnosticsTreeStyle: {
      "^": "Object;index>,_fake_flutter$_name,$ti",
      toString$0: [function(_) {
        return this._fake_flutter$_name;
      }, null, "get$toString", 1, 0, null],
      static: {
        "^": "DiagnosticsTreeStyle_error<"
      }
    },
    TextTreeConfiguration: {
      "^": "Object;prefixLineOne,beforeName,suffixLineOne,prefixOtherLines,prefixLastChildLineOne,prefixOtherLinesRootNode,propertyPrefixIfChildren,propertyPrefixNoChildren,linkCharacter,childLinkSpace,lineBreak,lineBreakProperties,afterName,afterDescriptionIfBody,afterDescription,beforeProperties,afterProperties,propertySeparator,bodyIndent,showChildren,addBlankLineIfNoChildren,isNameOnOwnLine,footer,manditoryFooter,isBlankLineBetweenPropertiesAndChildren<,$ti",
      static: {
        TextTreeConfiguration$: [function(addBlankLineIfNoChildren, afterDescription, afterDescriptionIfBody, afterName, afterProperties, beforeName, beforeProperties, bodyIndent, footer, isBlankLineBetweenPropertiesAndChildren, isNameOnOwnLine, lineBreak, lineBreakProperties, linkCharacter, manditoryFooter, prefixLastChildLineOne, prefixLineOne, prefixOtherLines, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, propertySeparator, showChildren, suffixLineOne) {
          return new U.TextTreeConfiguration(prefixLineOne, beforeName, suffixLineOne, prefixOtherLines, prefixLastChildLineOne, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, linkCharacter, C.JSString_methods.$mul(" ", linkCharacter.length), lineBreak, lineBreakProperties, afterName, afterDescriptionIfBody, afterDescription, beforeProperties, afterProperties, propertySeparator, bodyIndent, showChildren, addBlankLineIfNoChildren, isNameOnOwnLine, footer, manditoryFooter, isBlankLineBetweenPropertiesAndChildren, []);
        }, null, null, 0, 49, null, 27, 39, 39, 1045, 39, 39, 39, 39, 39, 27, 18, 812, 27, 0, 39, 0, 0, 0, 0, 0, 0, 39, 27, 39, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 192, 203, 831, 832, 833, 834, 835, 836]
      }
    },
    _PrefixedStringBuilder: {
      "^": "Object;prefixLineOne,prefixOtherLines,_fake_flutter$_buffer,_hasMultipleLines,_lineIndex,$ti",
      get$_currentLineLength: [function() {
        return J.$add$ansx(J.get$length$asx(this._hasMultipleLines ? this.prefixOtherLines : this.prefixLineOne), this._lineIndex);
      }, null, null, 2, 0, null],
      get$hasMultipleLines: [function() {
        return this._hasMultipleLines;
      }, null, null, 2, 0, null],
      write$1: [function(s) {
        var t1, lineTerminated, parts, i;
        H.stringTypeCheck(s);
        if (J.getInterceptor$asx(s).get$isEmpty(s))
          return;
        if (s === "\n") {
          t1 = this._fake_flutter$_buffer;
          if (J.get$isEmpty$asx(t1))
            t1.write$1(J.trimRight$0$s(this.prefixLineOne));
          else if (J.$eq$(this._lineIndex, 0)) {
            t1.write$1(J.trimRight$0$s(this.prefixOtherLines));
            this._hasMultipleLines = true;
          }
          t1.write$1("\n");
          this._lineIndex = 0;
          return;
        }
        t1 = this._fake_flutter$_buffer;
        if (J.get$isEmpty$asx(t1))
          t1.write$1(this.prefixLineOne);
        else if (J.$eq$(this._lineIndex, 0)) {
          t1.write$1(this.prefixOtherLines);
          this._hasMultipleLines = true;
        }
        if (C.JSString_methods.endsWith$1(s, "\n")) {
          s = C.JSString_methods.substring$2(s, 0, s.length - 1);
          lineTerminated = true;
        } else
          lineTerminated = false;
        parts = s.split("\n");
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        t1.write$1(parts[0]);
        for (i = 1; i < parts.length; ++i) {
          t1.write$1("\n");
          t1.write$1(this.prefixOtherLines);
          if (i >= parts.length)
            return H.ioore(parts, i);
          t1.write$1(parts[i]);
        }
        if (lineTerminated)
          t1.write$1("\n");
        if (lineTerminated)
          this._lineIndex = 0;
        else
          this._lineIndex = H.intTypeCheck(J.$add$ansx(this._lineIndex, J.get$length$asx(J.get$last$ax(parts))));
      }, null, "get$write", 4, 0, null, 50],
      writeRaw$1: [function(text) {
        var lastLineBreakIndex, t1;
        H.stringTypeCheck(text);
        if (J.get$isEmpty$asx(text))
          return;
        this._fake_flutter$_buffer.write$1(text);
        lastLineBreakIndex = C.JSString_methods.lastIndexOf$1(text, "\n");
        t1 = text.length;
        if (lastLineBreakIndex !== -1) {
          if (typeof lastLineBreakIndex !== "number")
            return H.iae(lastLineBreakIndex);
          this._lineIndex = t1 - lastLineBreakIndex - 1;
        } else
          this._lineIndex = H.intTypeCheck(J.$add$ansx(this._lineIndex, t1));
      }, null, "get$writeRaw", 4, 0, null, 17],
      writeRawLine$1: [function(line) {
        var t1;
        H.stringTypeCheck(line);
        if (J.getInterceptor$asx(line).get$isEmpty(line))
          return;
        t1 = this._fake_flutter$_buffer;
        t1.write$1(line);
        if (!C.JSString_methods.endsWith$1(line, "\n"))
          t1.write$1("\n");
        this._lineIndex = 0;
      }, null, "get$writeRawLine", 4, 0, null, 49],
      writeStretched$2: [function(text, lineLength) {
        var t1, targetLength, t2, lastChar;
        H.stringTypeCheck(text);
        H.intTypeCheck(lineLength);
        this.write$1(text);
        t1 = this.get$_currentLineLength();
        if (typeof lineLength !== "number")
          return lineLength.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        targetLength = lineLength - t1;
        if (targetLength > 0) {
          t1 = text.length;
          t2 = t1 - 1;
          if (t2 < 0)
            return H.ioore(text, t2);
          lastChar = text[t2];
          if (J.$lt$n(this.get$_currentLineLength(), targetLength))
            this.writeRaw$1(J.$mul$ns(lastChar, targetLength));
        }
      }, null, "get$writeStretched", 8, 0, null, 17, 868],
      toString$0: [function(_) {
        return J.toString$0$(this._fake_flutter$_buffer);
      }, null, "get$toString", 1, 0, null],
      static: {
        _PrefixedStringBuilder$: [function(prefixLineOne, prefixOtherLines) {
          return new U._PrefixedStringBuilder(prefixLineOne, prefixOtherLines, P.StringBuffer$(""), false, 0, []);
        }, null, null, 8, 0, null, 192, 203]
      }
    },
    _NoDefaultValue: {
      "^": "Object;$ti"
    },
    TerminalColor: {
      "^": "Object;$ti"
    },
    TextRenderer: {
      "^": "Object;$ti"
    },
    TextRenderer_renderToString_visitor: {
      "^": "Closure:64;_box_0,maxLines,descendants,maxDepth,$ti",
      call$1: [function(node) {
        var t1, t2, t3, t4, t5, t6, t7;
        for (t1 = J.get$iterator$ax(H.interceptedTypeCheck(node, "$isDiagnosticsNode").getChildren$0()), t2 = this._box_0, t3 = this.maxLines, t4 = this.descendants, t5 = J.getInterceptor$ax(t4), t6 = this.maxDepth; t1.moveNext$0();) {
          t7 = t1.get$current();
          if (J.$lt$n(t2.lines, t3)) {
            t2.depth = J.$add$ansx(t2.depth, 1);
            t5.add$1(t4, H.S(t2.prefixOtherLines) + H.S(C.JSString_methods.$mul("  ", t2.depth)) + H.S(t7));
            if (J.$lt$n(t2.depth, t6))
              this.call$1(t7);
            t2.depth = J.$sub$n(t2.depth, 1);
          } else if (J.$eq$(t2.lines, t3))
            t5.add$1(t4, H.S(t2.prefixOtherLines) + "  ...(descendants list truncated after " + H.S(t2.lines) + " lines)");
          t2.lines = J.$add$ansx(t2.lines, 1);
        }
      }, null, null, 4, 0, null, 23, "call"]
    },
    TextRenderer_renderToString_closure: {
      "^": "Closure:173;minLevel,$ti",
      call$1: [function(n) {
        return !H.interceptedTypeCheck(n, "$isDiagnosticsNode").isFiltered$1(this.minLevel);
      }, null, null, 4, 0, null, 72, "call"]
    },
    DiagnosticsNode: {
      "^": "Object;name>,showSeparator<,showName<,style>,$ti",
      isFiltered$1: [function(minLevel) {
        H.interceptedTypeCheck(minLevel, "$isDiagnosticLevel");
        return J.$lt$n(J.get$index$z(this.get$level()), minLevel.index);
      }, null, "get$isFiltered", 4, 0, null, 169],
      get$level: [function() {
        return C.DiagnosticLevel_3;
      }, null, null, 2, 0, null],
      get$emptyBodyDescription: [function() {
        return;
      }, null, null, 2, 0, null],
      get$allowWrap: [function() {
        return true;
      }, null, null, 2, 0, null],
      get$_separator: [function() {
        return this.showSeparator ? ":" : "";
      }, null, null, 2, 0, null],
      toString$2$minLevel$parentConfiguration: [function(_, minLevel, parentConfiguration) {
        var description, t1;
        H.interceptedTypeCheck(parentConfiguration, "$isTextTreeConfiguration");
        H.interceptedTypeCheck(minLevel, "$isDiagnosticLevel");
        if (J.$eq$(this.get$style(this), C.DiagnosticsTreeStyle_7))
          return this.toStringDeep$2$minLevel$parentConfiguration(minLevel, parentConfiguration);
        description = this.toDescription$1$parentConfiguration(parentConfiguration);
        t1 = this.name;
        if (t1 == null || J.get$isEmpty$asx(t1) || !this.showName)
          return description;
        return J.contains$1$asx(description, "\n") ? H.S(t1) + H.S(this.get$_separator()) + "\n" + description : H.S(t1) + H.S(this.get$_separator()) + " " + description;
      }, function($receiver) {
        return this.toString$2$minLevel$parentConfiguration($receiver, C.DiagnosticLevel_3, null);
      }, "toString$0", function($receiver, minLevel) {
        return this.toString$2$minLevel$parentConfiguration($receiver, minLevel, null);
      }, "toString$1$minLevel", null, null, null, "get$toString", 1, 5, null, 482, 0, 169, 171],
      get$textTreeConfiguration: [function() {
        switch (this.get$style(this)) {
          case C.DiagnosticsTreeStyle_2:
            return $.$get$denseTextConfiguration();
          case C.DiagnosticsTreeStyle_0:
            return $.$get$sparseTextConfiguration();
          case C.DiagnosticsTreeStyle_1:
            return $.$get$dashedTextConfiguration();
          case C.DiagnosticsTreeStyle_5:
            return $.$get$whitespaceTextConfiguration();
          case C.DiagnosticsTreeStyle_3:
            return $.$get$transitionTextConfiguration();
          case C.DiagnosticsTreeStyle_7:
            return $.$get$singleLineTextConfiguration();
          case C.DiagnosticsTreeStyle_8:
            return $.$get$headerLineTextConfiguration();
          case C.DiagnosticsTreeStyle_9:
            return $.$get$singleLineTextConfigurationIndented();
          case C.DiagnosticsTreeStyle_10:
            return $.$get$shallowTextConfiguration();
          case C.DiagnosticsTreeStyle_4:
            return $.$get$errorTextConfiguration();
          case C.DiagnosticsTreeStyle_11:
            return $.$get$whitespaceTextConfiguration();
          case C.DiagnosticsTreeStyle_6:
            return $.$get$flatTextConfiguration();
        }
        return;
      }, null, null, 2, 0, null],
      _childTextConfiguration$2: [function(child, textStyle) {
        H.interceptedTypeCheck(child, "$isDiagnosticsNode");
        H.interceptedTypeCheck(textStyle, "$isTextTreeConfiguration");
        return child != null && !J.$eq$(child.get$style(child), C.DiagnosticsTreeStyle_7) ? child.get$textTreeConfiguration() : textStyle;
      }, null, "get$_childTextConfiguration", 8, 0, null, 130, 248],
      toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines: [function(minLevel, parentConfiguration, prefixLineOne, prefixOtherLines) {
        H.stringTypeCheck(prefixLineOne);
        H.stringTypeCheck(prefixOtherLines);
        H.interceptedTypeCheck(parentConfiguration, "$isTextTreeConfiguration");
        return U.TextRenderer_renderToString(this, H.interceptedTypeCheck(minLevel, "$isDiagnosticLevel"), parentConfiguration, prefixLineOne, prefixOtherLines, 100, 65);
      }, function(minLevel, parentConfiguration) {
        return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, parentConfiguration, "", null);
      }, "toStringDeep$2$minLevel$parentConfiguration", function(minLevel, prefixLineOne, prefixOtherLines) {
        return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, null, prefixLineOne, prefixOtherLines);
      }, "toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines", null, null, null, "get$toStringDeep", 0, 9, null, 233, 0, 39, 0, 169, 171, 192, 203]
    },
    MessageProperty: {
      "^": "DiagnosticsProperty;$ti",
      $asDiagnosticsProperty: function() {
        return [-1];
      }
    },
    UrlProperty: {
      "^": "DiagnosticsProperty;$ti",
      $asDiagnosticsProperty: function() {
        return [P.String];
      }
    },
    StringProperty: {
      "^": "DiagnosticsProperty;$ti",
      $asDiagnosticsProperty: function() {
        return [P.String];
      }
    },
    LinkProperty: {
      "^": "DiagnosticsProperty;$ti",
      $asDiagnosticsProperty: function() {
        return [P.String];
      }
    },
    _NumProperty: {
      "^": "DiagnosticsProperty;$ti"
    },
    DoubleProperty: {
      "^": "_NumProperty;$ti",
      $as_NumProperty: function() {
        return [P.double];
      },
      $asDiagnosticsProperty: function() {
        return [P.double];
      }
    },
    IntProperty: {
      "^": "_NumProperty;$ti",
      $as_NumProperty: function() {
        return [P.int];
      },
      $asDiagnosticsProperty: function() {
        return [P.int];
      }
    },
    PercentProperty: {
      "^": "DoubleProperty;$ti"
    },
    FlagProperty: {
      "^": "DiagnosticsProperty;$ti",
      $asDiagnosticsProperty: function() {
        return [P.bool];
      }
    },
    IterableProperty: {
      "^": "DiagnosticsProperty;$ti",
      $asDiagnosticsProperty: function($T) {
        return [[P.Iterable, $T]];
      }
    },
    EnumProperty: {
      "^": "DiagnosticsProperty;$ti"
    },
    ObjectFlagProperty: {
      "^": "DiagnosticsProperty;$ti"
    },
    DiagnosticsProperty: {
      "^": "DiagnosticsNode;_description,expandableValue,allowWrap<,ifNull,ifEmpty,tooltip,missingIfNull,_fake_flutter$_value,_valueComputed,0_fake_flutter$_exception,defaultValue,_defaultLevel,_computeValue,name,showSeparator,showName,linePrefix,style,$ti",
      set$_fake_flutter$_value: function(_value) {
        this._fake_flutter$_value = H.assertSubtypeOfRuntimeType(_value, H.getTypeArgumentByIndex(this, 0));
      },
      valueToString$1$parentConfiguration: [function(parentConfiguration) {
        var v, t1;
        H.interceptedTypeCheck(parentConfiguration, "$isTextTreeConfiguration");
        v = this.get$value(this);
        t1 = J.getInterceptor$(v);
        t1 = !!t1.$isDiagnosticableTree ? v.toStringShort$0() : t1.toString$0(v);
        return t1 == null ? "" : t1;
      }, null, "get$valueToString", 0, 3, null, 0, 171],
      toDescription$1$parentConfiguration: [function(parentConfiguration) {
        var t1, result;
        H.interceptedTypeCheck(parentConfiguration, "$isTextTreeConfiguration");
        t1 = this._description;
        if (t1 != null)
          return this._addTooltip$1(t1);
        if (this.get$exception() != null)
          return "EXCEPTION (" + H.S(J.get$runtimeType$(this.get$exception())) + ")";
        t1 = this.ifNull;
        if (t1 != null && this.get$value(this) == null)
          return this._addTooltip$1(t1);
        result = this.valueToString$1$parentConfiguration(parentConfiguration);
        return this._addTooltip$1(J.get$isEmpty$asx(result) && this.ifEmpty != null ? this.ifEmpty : result);
      }, null, "get$toDescription", 0, 3, null, 0, 171],
      _addTooltip$1: [function(text) {
        var t1;
        H.stringTypeCheck(text);
        t1 = this.tooltip;
        return t1 == null ? text : H.S(text) + " (" + H.S(t1) + ")";
      }, null, "get$_addTooltip", 4, 0, null, 17],
      get$value: [function(_) {
        this._maybeCacheValue$0();
        return this._fake_flutter$_value;
      }, null, null, 3, 0, null],
      get$exception: [function() {
        this._maybeCacheValue$0();
        return this._fake_flutter$_exception;
      }, null, null, 2, 0, null],
      _maybeCacheValue$0: [function() {
        var exception, exception0;
        if (this._valueComputed)
          return;
        this._valueComputed = true;
        try {
          this.set$_fake_flutter$_value(this._computeValue.call$0());
        } catch (exception0) {
          exception = H.unwrapException(exception0);
          this._fake_flutter$_exception = exception;
          this.set$_fake_flutter$_value(null);
        }
      }, null, "get$_maybeCacheValue", 0, 0, null],
      get$level: [function() {
        var t1, t2;
        t1 = this._defaultLevel;
        if (J.$eq$(t1, C.DiagnosticLevel_0))
          return t1;
        if (this.get$exception() != null)
          return C.DiagnosticLevel_9;
        if (this.get$value(this) == null && this.missingIfNull)
          return C.DiagnosticLevel_4;
        t2 = this.defaultValue;
        if (!J.$eq$(t2, C.C__NoDefaultValue) && J.$eq$(this.get$value(this), t2))
          return C.DiagnosticLevel_1;
        return t1;
      }, null, null, 2, 0, null],
      getProperties$0: [function() {
        var object, t1;
        if (this.expandableValue) {
          object = this.get$value(this);
          t1 = J.getInterceptor$(object);
          if (!!t1.$isDiagnosticsNode)
            return object.getProperties$0();
          if (!!t1.$isDiagnosticable)
            return object.toDiagnosticsNode$1$style(this.style).getProperties$0();
        }
        return C.List_empty;
      }, null, "get$getProperties", 0, 0, null],
      getChildren$0: [function() {
        var object, t1;
        if (this.expandableValue) {
          object = this.get$value(this);
          t1 = J.getInterceptor$(object);
          if (!!t1.$isDiagnosticsNode)
            return object.getChildren$0();
          if (!!t1.$isDiagnosticable)
            return object.toDiagnosticsNode$1$style(this.style).getChildren$0();
        }
        return C.List_empty;
      }, null, "get$getChildren", 0, 0, null],
      static: {
        DiagnosticsProperty$: [function($name, value, allowWrap, defaultValue, description, expandableValue, ifEmpty, ifNull, level, linePrefix, missingIfNull, showName, showSeparator, showSeperatorAfter, style, tooltip, $T) {
          var t1;
          if (ifNull == null)
            t1 = missingIfNull ? "MISSING" : null;
          else
            t1 = ifNull;
          return new U.DiagnosticsProperty(description, expandableValue, allowWrap, t1, ifEmpty, tooltip, missingIfNull, value, true, defaultValue, level, null, $name, showSeparator, showName, linePrefix, style, [$T]);
        }, null, null, 8, 29, null, 27, 842, 0, 18, 0, 0, 482, 0, 18, 27, 27, 18, 844, 0, 8, 1, 458, 268, 845, 846, 847, 848, 218, 849, 850, 851, 852, 853, 140, 312]
      }
    },
    DiagnosticableNode: {
      "^": "DiagnosticsNode;value>,$ti",
      get$_builder: [function() {
        var t1, t2;
        if (this._cachedBuilder == null) {
          t1 = U.DiagnosticPropertiesBuilder$();
          this._cachedBuilder = t1;
          t2 = this.value;
          if (!(t2 == null))
            t2.debugFillProperties$1(t1);
        }
        return this._cachedBuilder;
      }, null, null, 2, 0, null],
      get$style: [function(_) {
        var t1 = this.style;
        return t1 == null ? this.get$_builder().get$defaultDiagnosticsTreeStyle() : t1;
      }, null, null, 3, 0, null],
      get$emptyBodyDescription: [function() {
        return this.get$_builder().get$emptyBodyDescription();
      }, null, null, 2, 0, null],
      getProperties$0: [function() {
        return this.get$_builder().get$properties();
      }, null, "get$getProperties", 0, 0, null],
      getChildren$0: [function() {
        return C.List_empty;
      }, null, "get$getChildren", 0, 0, null],
      toDescription$1$parentConfiguration: [function(parentConfiguration) {
        H.interceptedTypeCheck(parentConfiguration, "$isTextTreeConfiguration");
        return this.value.toStringShort$0();
      }, null, "get$toDescription", 0, 3, null, 0, 171],
      get$level: [function() {
        return this.value.get$debugDiagnosticLevel();
      }, null, null, 2, 0, null]
    },
    _DiagnosticableTreeNode: {
      "^": "DiagnosticableNode;value,0_cachedBuilder,name,showSeparator,showName,linePrefix,style,$ti",
      getChildren$0: [function() {
        var t1 = this.value;
        if (t1 != null)
          return t1.debugDescribeChildren$0();
        return C.List_empty;
      }, null, "get$getChildren", 0, 0, null],
      $asDiagnosticableNode: function() {
        return [U.DiagnosticableTree];
      },
      static: {
        _DiagnosticableTreeNode$: [function($name, style, value) {
          return new U._DiagnosticableTreeNode(value, $name, true, true, null, style, []);
        }, null, null, 0, 7, null, 0, 0, 0, 8, 140, 1]
      }
    },
    DiagnosticPropertiesBuilder: {
      "^": "Object;properties<,defaultDiagnosticsTreeStyle<,0emptyBodyDescription<,$ti",
      add$1: [function(_, property) {
        J.add$1$ax(this.properties, H.interceptedTypeCheck(property, "$isDiagnosticsNode"));
      }, "call$1", "get$add", 5, 0, 64, 67],
      static: {
        DiagnosticPropertiesBuilder$: [function() {
          return new U.DiagnosticPropertiesBuilder(H.setRuntimeTypeInfo([], [U.DiagnosticsNode]), C.DiagnosticsTreeStyle_0, []);
        }, null, null, 0, 0, null]
      }
    },
    Diagnosticable: {
      "^": "Object;$ti",
      toStringShort$0: [function() {
        return U.describeIdentity(this);
      }, null, "get$toStringShort", 0, 0, null],
      toString$1$minLevel: [function(_, minLevel) {
        H.interceptedTypeCheck(minLevel, "$isDiagnosticLevel");
        return J.toString$1$minLevel$(this.toDiagnosticsNode$1$style(C.DiagnosticsTreeStyle_7), minLevel);
      }, function($receiver) {
        return this.toString$1$minLevel($receiver, C.DiagnosticLevel_2);
      }, "toString$0", null, null, "get$toString", 1, 3, null, 233, 169],
      debugFillProperties$1: ["super$Diagnosticable$debugFillProperties", function(properties) {
        H.interceptedTypeCheck(properties, "$isDiagnosticPropertiesBuilder");
      }, null, "get$debugFillProperties", 4, 0, null, 433],
      get$debugDiagnosticLevel: [function() {
        return C.DiagnosticLevel_3;
      }, null, null, 2, 0, null]
    },
    DiagnosticableTree: {
      "^": "Diagnosticable;$ti",
      toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines: [function(minLevel, prefixLineOne, prefixOtherLines) {
        H.stringTypeCheck(prefixLineOne);
        H.stringTypeCheck(prefixOtherLines);
        H.interceptedTypeCheck(minLevel, "$isDiagnosticLevel");
        return this.toDiagnosticsNode$0().toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(minLevel, prefixLineOne, prefixOtherLines);
      }, function() {
        return this.toStringDeep$3$minLevel$prefixLineOne$prefixOtherLines(C.DiagnosticLevel_2, "", null);
      }, "toStringDeep$0", null, null, "get$toStringDeep", 0, 7, null, 233, 39, 0, 169, 192, 203],
      toStringShort$0: [function() {
        return U.describeIdentity(this);
      }, null, "get$toStringShort", 0, 0, null],
      toDiagnosticsNode$2$name$style: ["super$DiagnosticableTree$toDiagnosticsNode", function($name, style) {
        return U._DiagnosticableTreeNode$(H.stringTypeCheck($name), H.interceptedTypeCheck(style, "$isDiagnosticsTreeStyle"), this);
      }, null, "get$toDiagnosticsNode", 0, 5, null, 0, 0, 8, 140],
      debugDescribeChildren$0: [function() {
        return C.List_empty;
      }, null, "get$debugDescribeChildren", 0, 0, null]
    },
    DiagnosticableTreeMixin: {
      "^": "Object;$ti",
      $isDiagnosticable: 1,
      $isDiagnosticableTree: 1
    },
    DiagnosticsBlock: {
      "^": "DiagnosticsNode;$ti"
    },
    _WordWrapParseMode: {
      "^": "Object;index>,_fake_flutter$_name,$ti",
      toString$0: [function(_) {
        return this._fake_flutter$_name;
      }, null, "get$toString", 1, 0, null]
    },
    TextStyle: {
      "^": "Object;inherit,color>,fontFamily,fontSize>,fontWeight,fontStyle,letterSpacing,wordSpacing,textBaseline,height>,decoration,decorationColor,decorationStyle,debugLabel,$ti",
      copyWith$13$color$debugLabel$decoration$decorationColor$decorationStyle$fontFamily$fontSize$fontStyle$fontWeight$height$letterSpacing$textBaseline$wordSpacing: [function(color, debugLabel, decoration, decorationColor, decorationStyle, fontFamily, fontSize, fontStyle, fontWeight, height, letterSpacing, textBaseline, wordSpacing) {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
        H.interceptedTypeCheck(color, "$isColor");
        H.stringTypeCheck(fontFamily);
        H.doubleTypeCheck(fontSize);
        H.interceptedTypeCheck(fontWeight, "$isFontWeight");
        H.interceptedTypeCheck(fontStyle, "$isFontStyle");
        H.doubleTypeCheck(letterSpacing);
        H.doubleTypeCheck(wordSpacing);
        H.interceptedTypeCheck(textBaseline, "$isTextBaseline");
        H.doubleTypeCheck(height);
        H.interceptedTypeCheck(decoration, "$isTextDecoration");
        H.interceptedTypeCheck(decorationColor, "$isColor");
        H.interceptedTypeCheck(decorationStyle, "$isTextDecorationStyle");
        H.stringTypeCheck(debugLabel);
        t1 = color == null ? this.color : color;
        t2 = fontFamily == null ? this.fontFamily : fontFamily;
        t3 = fontSize == null ? this.fontSize : fontSize;
        t4 = fontWeight == null ? this.fontWeight : fontWeight;
        t5 = fontStyle == null ? this.fontStyle : fontStyle;
        t6 = letterSpacing == null ? this.letterSpacing : letterSpacing;
        t7 = wordSpacing == null ? this.wordSpacing : wordSpacing;
        t8 = height == null ? this.height : height;
        t9 = decoration == null ? this.decoration : decoration;
        t10 = decorationColor == null ? this.decorationColor : decorationColor;
        return U.TextStyle$(t1, null, t9, t10, this.decorationStyle, t2, t3, t5, t4, t8, this.inherit, t6, null, this.textBaseline, t7);
      }, null, "get$copyWith", 0, 27, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 484, 485, 486, 487, 488, 321, 490, 491, 96, 492, 493, 494],
      merge$1: [function(other) {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9;
        H.interceptedTypeCheck(other, "$isTextStyle");
        if (other == null)
          return this;
        if (!other.inherit)
          return other;
        t1 = other.color;
        t2 = other.fontFamily;
        t3 = other.fontSize;
        t4 = other.fontWeight;
        t5 = other.fontStyle;
        t6 = other.letterSpacing;
        t7 = other.wordSpacing;
        t8 = other.textBaseline;
        t9 = other.height;
        return this.copyWith$13$color$debugLabel$decoration$decorationColor$decorationStyle$fontFamily$fontSize$fontStyle$fontWeight$height$letterSpacing$textBaseline$wordSpacing(t1, null, other.decoration, other.decorationColor, other.decorationStyle, t2, t3, t5, t4, t9, t6, t8, t7);
      }, null, "get$merge", 4, 0, null, 3],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!J.$eq$(J.get$runtimeType$(other), this.get$runtimeType(this)))
          return false;
        H.interceptedTypeCheck(other, "$isTextStyle");
        return J.$eq$(this.inherit, other.inherit) && J.$eq$(this.color, other.color) && J.$eq$(this.fontFamily, other.fontFamily) && J.$eq$(this.fontSize, other.fontSize) && J.$eq$(this.fontWeight, other.fontWeight) && J.$eq$(this.fontStyle, other.fontStyle) && J.$eq$(this.letterSpacing, other.letterSpacing) && J.$eq$(this.wordSpacing, other.wordSpacing) && J.$eq$(this.textBaseline, other.textBaseline) && J.$eq$(this.height, other.height) && J.$eq$(this.decoration, other.decoration) && J.$eq$(this.decorationColor, other.decorationColor) && J.$eq$(this.decorationStyle, other.decorationStyle);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return S.hashValues(this.inherit, this.color, this.fontFamily, this.fontSize, this.fontWeight, this.fontStyle, this.letterSpacing, this.wordSpacing, this.textBaseline, this.height, this.decoration, this.decorationColor, this.decorationStyle, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
      }, null, null, 3, 0, null],
      toStringShort$0: [function() {
        return H.S(this.get$runtimeType(this));
      }, null, "get$toStringShort", 0, 0, null],
      static: {
        TextStyle$: [function(color, debugLabel, decoration, decorationColor, decorationStyle, fontFamily, fontSize, fontStyle, fontWeight, height, inherit, letterSpacing, $package, textBaseline, wordSpacing) {
          var t1 = $package == null ? fontFamily : "packages/" + $package + "/" + H.S(fontFamily);
          return new U.TextStyle(inherit, color, t1, fontSize, fontWeight, fontStyle, letterSpacing, wordSpacing, textBaseline, height, decoration, decorationColor, decorationStyle, debugLabel, []);
        }, null, null, 0, 31, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 75, 484, 485, 486, 487, 488, 321, 490, 491, 96, 863, 492, 865, 493, 494]
      }
    },
    TextStyle_copyWith_closure: {
      "^": "Closure:65;$ti"
    },
    TextStyle_merge_closure: {
      "^": "Closure:65;$ti"
    },
    TextSpan: {
      "^": "Object;$ti"
    }
  }], ["", "package:devtools/src/ui/flutter_html_shim.dart",, Y, {
    "^": "",
    fontStyleToCss: [function(textStyle) {
      var sb, t1;
      H.interceptedTypeCheck(textStyle, "$isTextStyle");
      sb = P.StringBuffer$("");
      if (J.$eq$(textStyle.fontStyle, C.FontStyle_1))
        sb.write$1("italic ");
      t1 = textStyle.fontWeight;
      if (t1 != null)
        sb.write$1(H.S(J.$mul$ns(J.$add$ansx(J.get$index$z(t1), 1), 100)) + " ");
      t1 = textStyle.fontSize;
      sb.write$1(H.S(t1 == null ? 14 : t1) + "px ");
      t1 = textStyle.fontFamily;
      sb.write$1(H.S(t1 == null ? "Arial" : t1) + " ");
      return sb.toString$0(0);
    }, null, null, 4, 0, null, 248],
    colorToCss: [function(color) {
      H.interceptedTypeCheck(color, "$isColor");
      return "#" + H.S(J.padLeft$2$s(J.toRadixString$1$n(J.$or$n(J.$shl$n(J.$and$bn(color.value, 16777215), 8), color.get$alpha(color)), 16), 8, "0"));
    }, null, null, 4, 0, null, 75]
  }], ["icon_renderer", "package:devtools/src/ui/html_icon_renderer.dart",, Y, {
    "^": "",
    createIconElement: [function(icon) {
      return Y.getIconRenderer(H.interceptedTypeCheck(icon, "$isIcon")).createCoreElement$0();
    }, null, null, 4, 0, null, 100],
    getIconRenderer: [function(icon) {
      var t1, renderer, t2;
      H.interceptedTypeCheck(icon, "$isIcon");
      t1 = $.$get$rendererExpando();
      renderer = J.$index$asx(t1, icon);
      if (renderer != null)
        return renderer;
      t2 = J.getInterceptor$(icon);
      if (!!t2.$isUrlIcon)
        renderer = Y._UrlIconRenderer$(icon);
      else if (!!t2.$isColorIcon)
        renderer = Y._ColorIconRenderer$(icon);
      else if (!!t2.$isCustomIcon)
        renderer = Y._CustomIconRenderer$(icon);
      else if (!!t2.$isMaterialIcon)
        renderer = Y._MaterialIconRenderer$(icon);
      else
        throw H.wrapException(P.UnimplementedError$("No icon renderer defined for " + H.S(icon) + " of type " + H.S(t2.get$runtimeType(icon))));
      J.$indexSet$ax(t1, icon, renderer);
      return renderer;
    }, null, null, 4, 0, null, 100],
    HtmlIconRenderer: {
      "^": "Object;icon<,$ti",
      createCoreElement$0: [function() {
        return A.CoreElement$from(this.createElement$0(0));
      }, null, "get$createCoreElement", 0, 0, null],
      createElement$0: [function(_) {
        var canvasSource, t1, t2;
        canvasSource = H.interceptedTypeCheck(this.createCanvasSource$0(), "$isElement");
        t1 = canvasSource.style;
        t2 = this.icon;
        (t1 && C.CssStyleDeclaration_methods).set$width(t1, H.S(t2.get$iconWidth()) + "px");
        C.CssStyleDeclaration_methods.set$height(t1, H.S(t2.get$iconHeight()) + "px");
        J.add$1$ax(J.get$classes$x(canvasSource), "flutter-icon");
        return canvasSource;
      }, null, "get$createElement", 1, 0, null],
      get$iconWidth: [function() {
        return this.icon.get$iconWidth();
      }, null, null, 2, 0, null],
      get$iconHeight: [function() {
        return this.icon.get$iconHeight();
      }, null, null, 2, 0, null]
    },
    _UrlIconRenderer: {
      "^": "HtmlIconRenderer;src,0_image<,0_imageFuture,icon,$ti",
      set$_image: function(_image) {
        this._image = H.interceptedTypeCheck(_image, "$isImageElement");
      },
      set$_imageFuture: function(_imageFuture) {
        this._imageFuture = H.assertSubtype(_imageFuture, "$isFuture", [W.CanvasImageSource], "$asFuture");
      },
      get$image: [function() {
        return this._image;
      }, null, null, 2, 0, null],
      createCanvasSource$0: [function() {
        return W.ImageElement_ImageElement(null, this.src, null);
      }, null, "get$createCanvasSource", 0, 0, null],
      createElement$0: [function(_) {
        var element, t1, t2;
        element = W.Element_Element$div();
        J.add$1$ax(J.get$classes$x(element), "flutter-icon");
        t1 = element.style;
        t2 = this.icon;
        (t1 && C.CssStyleDeclaration_methods).set$width(t1, H.S(t2.get$iconWidth()) + "px");
        C.CssStyleDeclaration_methods.set$height(t1, H.S(t2.get$iconHeight()) + "px");
        C.CssStyleDeclaration_methods.set$backgroundImage(t1, "url(" + H.S(this.src) + ")");
        return element;
      }, null, "get$createElement", 1, 0, null],
      loadImage$0: [function() {
        var t1, completer, imageElement;
        t1 = this._imageFuture;
        if (t1 != null)
          return t1;
        completer = P.Completer_Completer(W.CanvasImageSource);
        imageElement = this.createCanvasSource$0();
        (imageElement && C.ImageElement_methods).get$onLoad(imageElement).listen$1(new Y._UrlIconRenderer_loadImage_closure(this, imageElement, completer));
        J.append$1$x(J.get$head$x(W.document()), imageElement);
        this.set$_imageFuture(completer.get$future());
        return this._imageFuture;
      }, null, "get$loadImage", 0, 0, null],
      $asHtmlIconRenderer: function() {
        return [S.UrlIcon];
      },
      static: {
        _UrlIconRenderer$: [function(icon) {
          return new Y._UrlIconRenderer(Y._UrlIconRenderer__maybeRewriteIconUrl(icon.src), icon, []);
        }, null, null, 4, 0, null, 100],
        _UrlIconRenderer__maybeRewriteIconUrl: [function(url) {
          H.stringTypeCheck(url);
          if (J.$gt$n(J.get$devicePixelRatio$x(W.window()), 1) && J.getInterceptor$s(url).endsWith$1(url, ".png") && !C.JSString_methods.endsWith$1(url, "@2x.png"))
            return H.S(J.substring$2$s(url, 0, url.length - 4)) + "@2x.png";
          return url;
        }, null, null, 4, 0, null, 62]
      }
    },
    _UrlIconRenderer_loadImage_closure: {
      "^": "Closure:10;$this,imageElement,completer,$ti",
      call$1: [function(e) {
        var t1;
        H.interceptedTypeCheck(e, "$isEvent");
        t1 = this.imageElement;
        this.$this.set$_image(t1);
        J.complete$1$z(this.completer, t1);
      }, null, null, 4, 0, null, 19, "call"]
    },
    _ColorIconRenderer: {
      "^": "HtmlIconRenderer;0_image<,icon,$ti",
      set$_image: function(_image) {
        this._image = H.interceptedTypeCheck(_image, "$isCanvasElement");
      },
      get$color: [function(_) {
        return J.get$color$x(this.icon);
      }, null, null, 3, 0, null],
      createCanvasSource$0: [function() {
        var devicePixelRatio, t1, canvas, context;
        devicePixelRatio = J.get$devicePixelRatio$x(W.window());
        t1 = H.intTypeCheck(J.$mul$ns(this.get$iconWidth(), devicePixelRatio));
        canvas = W.CanvasElement_CanvasElement(H.intTypeCheck(J.$mul$ns(this.get$iconHeight(), devicePixelRatio)), t1);
        t1 = canvas.style;
        (t1 && C.CssStyleDeclaration_methods).set$width(t1, H.S(this.get$iconWidth()) + "px");
        C.CssStyleDeclaration_methods.set$height(t1, H.S(this.get$iconHeight()) + "px");
        context = (canvas && C.CanvasElement_methods).get$context2D(canvas);
        (context && C.CanvasRenderingContext2D_methods).scale$2(context, devicePixelRatio, devicePixelRatio);
        C.CanvasRenderingContext2D_methods.clearRect$4(context, 0, 0, this.get$iconWidth(), this.get$iconHeight());
        context.fillStyle = "white";
        C.CanvasRenderingContext2D_methods.fillRect$4(context, 1, 1, J.$sub$n(this.get$iconWidth(), 2), J.$sub$n(this.get$iconHeight(), 2));
        context.fillStyle = "gray";
        C.CanvasRenderingContext2D_methods.fillRect$4(context, 1, 1, J.$sub$n(J.$div$n(this.get$iconWidth(), 2), 1), J.$sub$n(J.$div$n(this.get$iconHeight(), 2), 1));
        C.CanvasRenderingContext2D_methods.fillRect$4(context, J.$div$n(this.get$iconWidth(), 2), J.$div$n(this.get$iconHeight(), 2), J.$sub$n(J.$div$n(this.get$iconWidth(), 2), 1), J.$sub$n(J.$div$n(this.get$iconHeight(), 2), 1));
        context.fillStyle = Y.colorToCss(this.get$color(this));
        C.CanvasRenderingContext2D_methods.fillRect$4(context, 1, 1, J.$sub$n(this.get$iconWidth(), 2), J.$sub$n(this.get$iconHeight(), 2));
        context.strokeStyle = "black";
        C.CanvasRenderingContext2D_methods.rect$4(context, 1, 1, J.$sub$n(this.get$iconWidth(), 2), J.$sub$n(this.get$iconHeight(), 2));
        context.stroke();
        return canvas;
      }, null, "get$createCanvasSource", 0, 0, null],
      get$image: [function() {
        var t1 = this._image;
        if (t1 != null)
          return t1;
        t1 = H.interceptedTypeCheck(this.createCanvasSource$0(), "$isCanvasElement");
        this._image = t1;
        return t1;
      }, null, null, 2, 0, null],
      loadImage$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(W.CanvasImageSource),
          $async$returnValue, $async$self = this;
        var $async$loadImage$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = $async$self.get$image();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$loadImage$0, $async$completer);
      }, null, "get$loadImage", 0, 0, null],
      get$iconWidth: [function() {
        return 18;
      }, null, null, 2, 0, null],
      get$iconHeight: [function() {
        return 18;
      }, null, null, 2, 0, null],
      $asHtmlIconRenderer: function() {
        return [S.ColorIcon];
      },
      static: {
        _ColorIconRenderer$: [function(icon) {
          return new Y._ColorIconRenderer(icon, []);
        }, null, null, 4, 0, null, 100]
      }
    },
    _CustomIconRenderer: {
      "^": "HtmlIconRenderer;baseIconRenderer,0_image<,icon,$ti",
      set$_image: function(_image) {
        this._image = H.interceptedTypeCheck(_image, "$isCanvasElement");
      },
      createCanvasSource$0: [function() {
        var baseImage = this.baseIconRenderer.get$image();
        if (baseImage == null)
          return this._buildImageAsync$0();
        return this._buildImage$1(baseImage);
      }, null, "get$createCanvasSource", 0, 0, null],
      get$image: [function() {
        var t1 = this._image;
        if (t1 != null)
          return t1;
        if (this.baseIconRenderer.get$image() == null)
          return;
        t1 = H.interceptedTypeCheck(this.createCanvasSource$0(), "$isCanvasElement");
        this._image = t1;
        return t1;
      }, null, null, 2, 0, null],
      loadImage$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(W.CanvasImageSource),
          $async$returnValue, $async$self = this;
        var $async$loadImage$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self.baseIconRenderer.loadImage$0(), $async$loadImage$0);
              case 3:
                // returning from await.
                $async$returnValue = $async$self._buildImage$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$loadImage$0, $async$completer);
      }, null, "get$loadImage", 0, 0, null],
      _buildImageAsync$0: [function() {
        var canvas = this._createCanvas$0();
        this.baseIconRenderer.loadImage$0().then$1$1(new Y._CustomIconRenderer__buildImageAsync_closure(this, canvas), null);
        return canvas;
      }, null, "get$_buildImageAsync", 0, 0, null],
      _createCanvas$0: [function() {
        var devicePixelRatio, t1, canvas;
        devicePixelRatio = J.get$devicePixelRatio$x(W.window());
        t1 = H.intTypeCheck(J.$mul$ns(this.get$iconWidth(), devicePixelRatio));
        canvas = W.CanvasElement_CanvasElement(H.intTypeCheck(J.$mul$ns(this.get$iconHeight(), devicePixelRatio)), t1);
        t1 = canvas.style;
        (t1 && C.CssStyleDeclaration_methods).set$width(t1, H.S(this.get$iconWidth()) + "px");
        C.CssStyleDeclaration_methods.set$height(t1, H.S(this.get$iconHeight()) + "px");
        return canvas;
      }, null, "get$_createCanvas", 0, 0, null],
      _buildImage$1: [function(source) {
        var canvas;
        H.interceptedTypeCheck(source, "$isCanvasImageSource");
        canvas = this._createCanvas$0();
        this._drawIcon$2(canvas, source);
        return canvas;
      }, null, "get$_buildImage", 4, 0, null, 11],
      _drawIcon$2: [function(canvas, source) {
        var devicePixelRatio, t1, t2;
        H.interceptedTypeCheck(canvas, "$isCanvasElement");
        H.interceptedTypeCheck(source, "$isCanvasImageSource");
        devicePixelRatio = J.get$devicePixelRatio$x(W.window());
        t1 = (canvas && C.CanvasElement_methods).get$context2D(canvas);
        t2 = J.getInterceptor$x(t1);
        t2.scale$2(t1, devicePixelRatio, devicePixelRatio);
        t2.drawImageScaled$5(t1, source, 0, 0, this.get$iconWidth(), this.get$iconHeight());
        t2.set$strokeStyle(t1, "#231F20");
        t2.set$font(t1, "arial 8px");
        t2.set$textBaseline(t1, "middle");
        t2.set$textAlign(t1, "center");
        t2.fillText$4(t1, J.get$text$x(this.icon), J.$div$n(this.get$iconWidth(), 2), J.$div$n(this.get$iconHeight(), 2), this.get$iconWidth());
      }, null, "get$_drawIcon", 8, 0, null, 221, 11],
      $asHtmlIconRenderer: function() {
        return [S.CustomIcon];
      },
      static: {
        _CustomIconRenderer$: [function(icon) {
          return new Y._CustomIconRenderer(Y.getIconRenderer(icon.get$baseIcon()), icon, []);
        }, null, null, 4, 0, null, 100]
      }
    },
    _CustomIconRenderer__buildImageAsync_closure: {
      "^": "Closure:39;$this,canvas,$ti",
      call$1: [function(source) {
        this.$this._drawIcon$2(this.canvas, H.interceptedTypeCheck(source, "$isCanvasImageSource"));
      }, null, null, 4, 0, null, 11, "call"]
    },
    _MaterialIconRenderer: {
      "^": "HtmlIconRenderer;0_image<,0_imageFuture,icon,$ti",
      set$_image: function(_image) {
        this._image = H.interceptedTypeCheck(_image, "$isCanvasElement");
      },
      get$image: [function() {
        var t1 = this._image;
        if (t1 != null)
          return t1;
        if (!$._MaterialIconRenderer__fontLoaded)
          return;
        t1 = H.interceptedTypeCheck(this.createCanvasSource$0(), "$isCanvasElement");
        this._image = t1;
        return t1;
      }, null, null, 2, 0, null],
      loadImage$0: [function() {
        var t1, imageCompleter;
        t1 = this._imageFuture;
        if (t1 != null)
          return t1;
        if ($._MaterialIconRenderer__fontLoaded)
          return P.Future_Future$value(this.get$image(), W.CanvasImageSource);
        imageCompleter = P.Completer_Completer(W.CanvasElement);
        if (!$._MaterialIconRenderer__fontLoaded) {
          if ($._MaterialIconRenderer__iconsFont == null) {
            $._MaterialIconRenderer__iconsFont = W.FontFace_FontFace("Material Icons", "url(packages/devtools/src/ui/MaterialIcons-Regular.woff2)", null);
            J.add$1$ax(J.get$fonts$x(W.document()), $._MaterialIconRenderer__iconsFont);
            t1 = J.load$0$x($._MaterialIconRenderer__iconsFont);
            $._MaterialIconRenderer__iconsFontFuture = t1;
            t1.then$1$1(new Y._MaterialIconRenderer_loadImage_closure(), null);
          }
          $._MaterialIconRenderer__iconsFontFuture.then$1$1(new Y._MaterialIconRenderer_loadImage_closure0(this, imageCompleter), null);
        }
        return imageCompleter.get$future();
      }, null, "get$loadImage", 0, 0, null],
      createCanvasSource$0: [function() {
        var t1, canvas, context2D, t2;
        t1 = H.intTypeCheck(J.$mul$ns(this.get$iconWidth(), J.get$devicePixelRatio$x(W.window())));
        canvas = W.CanvasElement_CanvasElement(H.intTypeCheck(J.$mul$ns(this.get$iconHeight(), J.get$devicePixelRatio$x(W.window()))), t1);
        context2D = (canvas && C.CanvasElement_methods).get$context2D(canvas);
        t1 = J.getInterceptor$x(context2D);
        t1.scale$2(context2D, J.get$devicePixelRatio$x(W.window()), J.get$devicePixelRatio$x(W.window()));
        t1.translate$2(context2D, J.$div$n(this.get$iconWidth(), 2), J.$div$n(this.get$iconHeight(), 2));
        t2 = this.icon;
        if (!J.$eq$(t2.get$angle(), 0))
          t1.rotate$1(context2D, t2.get$angle());
        t1 = new Y._MaterialIconRenderer_createCanvasSource__drawIcon(this, context2D);
        if ($._MaterialIconRenderer__fontLoaded)
          t1.call$0();
        else
          this.loadImage$0().then$1$1(new Y._MaterialIconRenderer_createCanvasSource_closure(t1), null);
        return canvas;
      }, null, "get$createCanvasSource", 0, 0, null],
      $asHtmlIconRenderer: function() {
        return [K.MaterialIcon];
      },
      static: {
        _MaterialIconRenderer$: [function(icon) {
          return new Y._MaterialIconRenderer(icon, []);
        }, null, null, 4, 0, null, 100]
      }
    },
    _MaterialIconRenderer_loadImage_closure: {
      "^": "Closure:66;$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isFontFace");
        $._MaterialIconRenderer__fontLoaded = true;
      }, null, null, 4, 0, null, 12, "call"]
    },
    _MaterialIconRenderer_loadImage_closure0: {
      "^": "Closure:66;$this,imageCompleter,$ti",
      call$1: [function(_) {
        var t1;
        H.interceptedTypeCheck(_, "$isFontFace");
        t1 = this.$this;
        t1.set$_image(H.interceptedTypeCheck(t1.createCanvasSource$0(), "$isCanvasElement"));
        J.complete$1$z(this.imageCompleter, t1.get$_image());
      }, null, null, 4, 0, null, 12, "call"]
    },
    _MaterialIconRenderer_createCanvasSource__drawIcon: {
      "^": "Closure:0;$this,context2D,$ti",
      call$0: [function() {
        var t1, t2, t3;
        t1 = this.context2D;
        t2 = this.$this;
        t3 = J.getInterceptor$x(t1);
        t3.set$font(t1, H.S(J.get$fontSize$z(t2.get$icon())) + "px Material Icons");
        t3.set$fillStyle(t1, Y.colorToCss(J.get$color$x(t2.get$icon())));
        t3.set$textBaseline(t1, "middle");
        t3.set$textAlign(t1, "center");
        t3.fillText$4(t1, J.get$text$x(t2.get$icon()), 0, 0, J.$add$ansx(t2.get$iconWidth(), 10));
      }, null, null, 0, 0, null, "call"]
    },
    _MaterialIconRenderer_createCanvasSource_closure: {
      "^": "Closure:39;_drawIcon,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isCanvasImageSource");
        this._drawIcon.call$0();
      }, null, null, 4, 0, null, 12, "call"]
    }
  }], ["icons", "package:devtools/src/ui/icons.dart",, S, {
    "^": "",
    Icon: {
      "^": "Object;$ti",
      get$iconWidth: [function() {
        return 18;
      }, null, null, 2, 0, null],
      get$iconHeight: [function() {
        return 18;
      }, null, null, 2, 0, null]
    },
    UrlIcon: {
      "^": "Icon;src,$ti"
    },
    FlutterIcons: {
      "^": "Object;$ti"
    },
    CustomIcon: {
      "^": "Icon;kind>,text>,isAbstract,$ti",
      get$baseIcon: [function() {
        var t1 = this.kind;
        return this.isAbstract ? t1.get$abstractIcon() : t1.get$icon();
      }, null, null, 2, 0, null],
      get$iconWidth: [function() {
        return this.get$baseIcon().get$iconWidth();
      }, null, null, 2, 0, null],
      get$iconHeight: [function() {
        return this.get$baseIcon().get$iconHeight();
      }, null, null, 2, 0, null],
      static: {
        CustomIcon$: [function(isAbstract, kind, text) {
          return new S.CustomIcon(kind, text, isAbstract, []);
        }, null, null, 0, 7, null, 18, 0, 0, 495, 267, 17]
      }
    },
    CustomIconMaker: {
      "^": "Object;iconCache,$ti",
      getCustomIcon$3$isAbstract$kind: [function(fromText, isAbstract, kind) {
        var t1, t2, text;
        t1 = {};
        t1.kind = kind;
        H.stringTypeCheck(fromText);
        H.interceptedTypeCheck(kind, "$isIconKind");
        H.boolTypeCheck(isAbstract);
        if (kind == null) {
          t1.kind = C.IconKind_int;
          t2 = C.IconKind_int;
        } else
          t2 = kind;
        if (!J.$eq$(fromText == null ? null : C.JSString_methods.get$isEmpty(fromText), false))
          return;
        if (0 >= fromText.length)
          return H.ioore(fromText, 0);
        text = J.toUpperCase$0$s(fromText[0]);
        return this.iconCache.putIfAbsent$2(H.S(text) + "_" + H.S(t2.name) + "_" + H.S(isAbstract), new S.CustomIconMaker_getCustomIcon_closure(t1, text, isAbstract));
      }, function(fromText) {
        return this.getCustomIcon$3$isAbstract$kind(fromText, false, null);
      }, "getCustomIcon$1", function(fromText, kind) {
        return this.getCustomIcon$3$isAbstract$kind(fromText, false, kind);
      }, "getCustomIcon$2$kind", null, null, null, "get$getCustomIcon", 4, 5, null, 18, 0, 870, 495, 267],
      fromWidgetName$1: [function($name) {
        var isPrivate;
        H.stringTypeCheck($name);
        if ($name == null)
          return;
        isPrivate = C.JSString_methods.startsWith$1($name, "_");
        while (true) {
          if (!(J.getInterceptor$asx($name).get$isNotEmpty($name) && !this.isAlphabetic$1(C.JSString_methods._codeUnitAt$1($name, 0))))
            break;
          $name = C.JSString_methods.substring$1($name, 1);
        }
        if (C.JSString_methods.get$isEmpty($name))
          return;
        return this.getCustomIcon$2$kind($name, isPrivate ? C.IconKind_hSO : C.IconKind_int);
      }, null, "get$fromWidgetName", 4, 0, null, 8],
      fromInfo$1: [function($name) {
        H.stringTypeCheck($name);
        if ($name == null)
          return;
        if (C.JSString_methods.get$isEmpty($name))
          return;
        return this.getCustomIcon$2$kind($name, C.IconKind_Kv2);
      }, null, "get$fromInfo", 4, 0, null, 8],
      isAlphabetic$1: [function(char) {
        H.intTypeCheck(char);
        if (typeof char !== "number")
          return char.$lt();
        return (char < 48 || char > 57) && char !== 95 && char !== 36;
      }, null, "get$isAlphabetic", 4, 0, null, 164],
      static: {
        CustomIconMaker$: [function() {
          return new S.CustomIconMaker(P.LinkedHashMap_LinkedHashMap$_empty(P.String, S.CustomIcon), []);
        }, null, null, 0, 0, null]
      }
    },
    CustomIconMaker_getCustomIcon_closure: {
      "^": "Closure:176;_box_0,text,isAbstract,$ti",
      call$0: [function() {
        return S.CustomIcon$(this.isAbstract, this._box_0.kind, this.text);
      }, null, null, 0, 0, null, "call"]
    },
    IconKind: {
      "^": "Object;name>,icon<,abstractIcon<,$ti"
    },
    ColorIcon: {
      "^": "Icon;color>,$ti",
      static: {
        ColorIcon$: [function(color) {
          return new S.ColorIcon(color, []);
        }, null, null, 4, 0, null, 75]
      }
    },
    ColorIconMaker: {
      "^": "Object;iconCache,$ti",
      getCustomIcon$1: [function(color) {
        H.interceptedTypeCheck(color, "$isColor");
        return this.iconCache.putIfAbsent$2(color, new S.ColorIconMaker_getCustomIcon_closure(color));
      }, null, "get$getCustomIcon", 4, 0, null, 75],
      static: {
        ColorIconMaker$: [function() {
          return new S.ColorIconMaker(P.LinkedHashMap_LinkedHashMap$_empty(S.Color, S.Icon), []);
        }, null, null, 0, 0, null]
      }
    },
    ColorIconMaker_getCustomIcon_closure: {
      "^": "Closure:177;color,$ti",
      call$0: [function() {
        return S.ColorIcon$(this.color);
      }, null, null, 0, 0, null, "call"]
    }
  }], ["material_icons", "package:devtools/src/ui/material_icons.dart",, K, {
    "^": "",
    FlutterMaterialIcons_getIconForCodePoint: [function(charCode) {
      var code = P.String_String$fromCharCode(H.intTypeCheck(charCode));
      return $.$get$FlutterMaterialIcons__iconCache().putIfAbsent$2(code, new K.FlutterMaterialIcons_getIconForCodePoint_closure(code));
    }, null, null, 4, 0, null, 93],
    MaterialIcon: {
      "^": "Icon;text>,color>,fontSize>,angle<,iconWidth<,$ti",
      static: {
        MaterialIcon$: [function(text, color, angle, fontSize, iconWidth) {
          return new K.MaterialIcon(text, color, fontSize, angle, iconWidth, []);
        }, null, null, 8, 7, null, 16, 496, 496, 17, 75, 393, 321, 872]
      }
    },
    FlutterMaterialIcons: {
      "^": "Object;$ti"
    },
    FlutterMaterialIcons_getIconForCodePoint_closure: {
      "^": "Closure:178;code,$ti",
      call$0: [function() {
        return K.MaterialIcon$(this.code, C.Color_4278190080, 0, 18, 18);
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:devtools/src/ui/primer.dart",, N, {
    "^": "",
    PSelect: {
      "^": "CoreElement;element,$ti",
      small$0: [function() {
        return this.clazz$1("select-sm");
      }, null, "get$small", 0, 0, null],
      option$2$value: [function($name, value) {
        var e;
        H.stringTypeCheck($name);
        H.stringTypeCheck(value);
        e = A.CoreElement$("option", null, null, $name);
        if (value != null)
          H.interceptedTypeCheck(e.element, "$isOptionElement").value = value;
        this.add$1(0, e);
      }, null, "get$option", 4, 3, null, 0, 8, 1],
      get$value: [function(_) {
        return H.interceptedTypeCheck(this.element, "$isSelectElement").value;
      }, null, null, 3, 0, null],
      set$selectedIndex: [function(_, index) {
        H.intTypeCheck(index);
        H.interceptedTypeCheck(this.element, "$isSelectElement").selectedIndex = index;
      }, null, null, 7, 0, null, 6],
      get$onChange: [function(_) {
        return J.where$1$ax(J.get$onChange$x(this.element), new N.PSelect_onChange_closure(this));
      }, null, null, 3, 0, null],
      change$1: [function(handle) {
        H.functionTypeCheck(handle, {func: 1, ret: -1});
        return this.get$onChange(this).listen$1(new N.PSelect_change_closure(handle));
      }, null, "get$change", 4, 0, null, 243],
      static: {
        PSelect$: [function() {
          var t1 = new N.PSelect(W.Element_Element$tag("select", null), []);
          t1.CoreElement$4$attributes$classes$text("select", null, "form-select", null);
          return t1;
        }, null, null, 0, 0, null]
      }
    },
    PSelect_onChange_closure: {
      "^": "Closure:179;$this,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isEvent");
        return !J.get$disabled$z(this.$this);
      }, null, null, 4, 0, null, 12, "call"]
    },
    PSelect_change_closure: {
      "^": "Closure:10;handle,$ti",
      call$1: [function(e) {
        H.interceptedTypeCheck(e, "$isEvent").stopImmediatePropagation();
        this.handle.call$0();
      }, null, null, 4, 0, null, 19, "call"]
    },
    PTooltip: {
      "^": "Object;$ti"
    },
    PButton: {
      "^": "CoreElement;0_icon,element,$ti",
      PButton$1: [function(text) {
        this.setAttribute$2(0, "type", "button");
      }, null, null, 0, 2, null, 0, 17],
      PButton$icon$3$title: [function(text, icon, title) {
        this.setAttribute$2(0, "type", "button");
        this.setAttribute$2(0, "title", title == null ? text : title);
        if (icon != null) {
          this._icon = icon;
          this.add$1(0, Y.createIconElement(icon));
          if (text != null)
            this.add$1(0, A.span(null, null, text));
        } else
          J.set$text$x(this.element, text);
      }, null, null, 8, 3, null, 0, 17, 100, 86],
      changeIcon$1: [function(url) {
        H.stringTypeCheck(url);
        if (this._icon != null)
          J.set$backgroundImage$x(J.get$style$x(J.get$first$ax(J.get$children$x(this.element))), 'url("' + H.S(url) + '")');
      }, null, "get$changeIcon", 4, 0, null, 62],
      primary$0: [function() {
        return this.clazz$1("btn-primary");
      }, null, "get$primary", 0, 0, null],
      small$0: [function() {
        return this.clazz$1("btn-sm");
      }, null, "get$small", 0, 0, null],
      static: {
        PButton$: [function(text) {
          var t1 = new N.PButton(W.Element_Element$tag("button", null), []);
          t1.CoreElement$4$attributes$classes$text("button", null, "btn", text);
          t1.PButton$1(text);
          return t1;
        }, null, null, 0, 2, null, 0, 17],
        PButton$icon: [function(text, icon, title) {
          var t1 = new N.PButton(W.Element_Element$tag("button", null), []);
          t1.CoreElement$4$attributes$classes$text("button", null, "btn optional-text", null);
          t1.PButton$icon$3$title(text, icon, title);
          return t1;
        }, null, null, 8, 3, null, 0, 17, 100, 86]
      }
    },
    PFlash: {
      "^": "CoreElement;element,$ti",
      warning$0: [function() {
        this.clazz$1("flash-warn");
      }, null, "get$warning", 0, 0, null],
      error$0: [function(_) {
        this.clazz$1("flash-error");
      }, "call$0", "get$error", 1, 0, 0],
      addClose$0: [function() {
        return H.interceptedTypeCheck(this.add$1(0, A.span(null, "octicon octicon-x flash-close js-flash-close", null)), "$isCoreElement");
      }, null, "get$addClose", 0, 0, null],
      static: {
        PFlash$: [function(text) {
          var t1 = new N.PFlash(W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "flash", text);
          return t1;
        }, null, null, 0, 3, null, 0, 17]
      }
    },
    PTabNav: {
      "^": "CoreElement;0selectedTab,element,$ti",
      PTabNav$1: [function(tabs) {
        var t1, t2;
        H.interceptedTypeCheck(this.add$1(0, A.CoreElement$("nav", null, "tabnav-tabs", null)), "$isCoreElement").add$1(0, tabs);
        t1 = J.getInterceptor$asx(tabs);
        if (t1.get$isNotEmpty(tabs))
          this.selectTab$1(t1.get$first(tabs));
        for (t1 = t1.get$iterator(tabs); t1.moveNext$0();) {
          t2 = t1.get$current();
          t2.click$1(0, new N.PTabNav_closure(this, t2));
        }
      }, null, null, 4, 0, null, 497],
      selectTab$1: [function(tab) {
        var t1;
        H.interceptedTypeCheck(tab, "$isPTabNavTab");
        t1 = this.selectedTab;
        if (!(t1 == null))
          t1.toggleClass$2("selected", false);
        this.selectedTab = tab;
        if (!(tab == null))
          tab.toggleClass$2("selected", true);
      }, null, "get$selectTab", 4, 0, null, 875],
      static: {
        PTabNav$: [function(tabs) {
          var t1 = new N.PTabNav(W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "tabnav", null);
          t1.PTabNav$1(tabs);
          return t1;
        }, null, null, 4, 0, null, 497]
      }
    },
    PTabNav_closure: {
      "^": "Closure:0;$this,tab,$ti",
      call$0: [function() {
        return this.$this.selectTab$1(this.tab);
      }, null, null, 0, 0, null, "call"]
    },
    PTabNavTab: {
      "^": "CoreElement;element,$ti",
      static: {
        PTabNavTab$: [function($name) {
          var t1 = new N.PTabNavTab(W.Element_Element$tag("div", null), []);
          t1.CoreElement$4$attributes$classes$text("div", null, "tabnav-tab", $name);
          return t1;
        }, null, null, 4, 0, null, 8]
      }
    },
    PNavMenu: {
      "^": "CoreElement;0selectedItem,element,$ti",
      PNavMenu$2$supportsSelection: [function(items, supportsSelection) {
        var t1, t2;
        this.add$1(0, items);
        if (supportsSelection) {
          t1 = J.getInterceptor$asx(items);
          if (t1.get$isNotEmpty(items) && t1.get$first(items) instanceof N.PNavMenuItem)
            this.selectItem$1(H.interceptedTypeCheck(t1.get$first(items), "$isPNavMenuItem"));
          for (t1 = t1.get$iterator(items); t1.moveNext$0();) {
            t2 = t1.get$current();
            if (t2 instanceof N.PNavMenuItem)
              t2.click$1(0, new N.PNavMenu_closure(this, t2));
          }
        }
      }, null, null, 4, 3, null, 27, 189, 498],
      selectItem$1: [function(item) {
        var t1;
        H.interceptedTypeCheck(item, "$isPNavMenuItem");
        t1 = this.selectedItem;
        if (!(t1 == null))
          t1.toggleClass$2("selected", false);
        this.selectedItem = item;
        if (!(item == null))
          item.toggleClass$2("selected", true);
      }, null, "get$selectItem", 4, 0, null, 66],
      static: {
        PNavMenu$: [function(items, supportsSelection) {
          var t1 = new N.PNavMenu(W.Element_Element$tag("nav", null), []);
          t1.CoreElement$4$attributes$classes$text("nav", null, "menu", null);
          t1.PNavMenu$2$supportsSelection(items, supportsSelection);
          return t1;
        }, null, null, 4, 3, null, 27, 189, 498]
      }
    },
    PNavMenu_closure: {
      "^": "Closure:0;$this,item,$ti",
      call$0: [function() {
        return this.$this.selectItem$1(this.item);
      }, null, null, 0, 0, null, "call"]
    },
    PNavMenuItem: {
      "^": "CoreElement;element,$ti",
      static: {
        PNavMenuItem$: [function($name) {
          var t1 = new N.PNavMenuItem(W.Element_Element$tag("a", null), []);
          t1.CoreElement$4$attributes$classes$text("a", null, "menu-item", $name);
          return t1;
        }, null, null, 4, 0, null, 8]
      }
    }
  }], ["splitter", "package:devtools/src/ui/split.dart",, A, {
    "^": "",
    flexSplit: [function(parts, gutterSize, horizontal, minSize, sizes) {
      var t1, t2, t3, t4;
      H.listTypeCheck(parts);
      H.boolTypeCheck(horizontal);
      t1 = [P.num];
      H.assertSubtype(sizes, "$isList", t1, "$asList");
      H.assertSubtype(minSize, "$isList", t1, "$asList");
      t1 = J.toList$0$ax(J.map$1$1$ax(parts, new A.flexSplit_closure(), null));
      t2 = P.allowInterop(new A.flexSplit_closure0(), {func: 1, args: [P.Object, P.Object, P.num, P.int]});
      t3 = P.allowInterop(new A.flexSplit_closure1(), {func: 1, args: [P.Object, P.num, P.int]});
      t4 = horizontal ? "horizontal" : "vertical";
      t3 = {direction: t4, elementStyle: t2, gutterSize: H.numTypeCheck(gutterSize), gutterStyle: t3, minSize: minSize, sizes: sizes};
      return self.Split(t1, t3);
    }, null, null, 4, 9, null, 499, 27, 0, 0, 154, 272, 878, 501, 880],
    flexSplitBidirectional: [function(parts, gutterSize, horizontalSizes, minSize, verticalSizes) {
      var t1, t2, mediaQueryList;
      t1 = {};
      H.listTypeCheck(parts);
      t2 = [P.num];
      H.assertSubtype(verticalSizes, "$isList", t2, "$asList");
      H.assertSubtype(horizontalSizes, "$isList", t2, "$asList");
      H.assertSubtype(minSize, "$isList", t2, "$asList");
      mediaQueryList = J.matchMedia$1$x(W.window(), "(min-aspect-ratio: 1/1)");
      t1.splitter = null;
      t2 = new A.flexSplitBidirectional_createSplitter(t1, mediaQueryList, parts, gutterSize, minSize, horizontalSizes, verticalSizes);
      t2.call$0();
      return (mediaQueryList && C.MediaQueryList_methods).get$onChange(mediaQueryList).listen$1(new A.flexSplitBidirectional_closure(t1, t2));
    }, null, null, 4, 9, null, 499, 0, 0, 0, 154, 272, 881, 501, 882],
    _SplitOptions: {
      "^": "JavaScriptObject;$ti",
      "%": ""
    },
    Splitter: {
      "^": "JavaScriptObject;$ti",
      "%": ""
    },
    flexSplit_closure: {
      "^": "Closure:3;$ti",
      call$1: [function(o) {
        return o instanceof A.CoreElement ? o.element : o;
      }, null, null, 4, 0, null, 25, "call"]
    },
    flexSplit_closure0: {
      "^": "Closure:180;$ti",
      call$4: [function(dimension, size, gutterSize, index) {
        var t1;
        H.numTypeCheck(gutterSize);
        H.intTypeCheck(index);
        t1 = P.String;
        return P.jsify(P.LinkedHashMap_LinkedHashMap$_literal(["flex-basis", "calc(" + H.S(size) + "% - " + H.S(gutterSize) + "px)"], t1, t1));
      }, null, null, 16, 0, null, 502, 239, 272, 6, "call"]
    },
    flexSplit_closure1: {
      "^": "Closure:181;$ti",
      call$3: [function(dimension, gutterSize, index) {
        var t1;
        H.numTypeCheck(gutterSize);
        H.intTypeCheck(index);
        t1 = P.String;
        return P.jsify(P.LinkedHashMap_LinkedHashMap$_literal(["flex-basis", H.S(gutterSize) + "px"], t1, t1));
      }, null, null, 12, 0, null, 502, 272, 6, "call"]
    },
    flexSplitBidirectional_createSplitter: {
      "^": "Closure:0;_box_0,mediaQueryList,parts,gutterSize,minSize,horizontalSizes,verticalSizes,$ti",
      call$0: [function() {
        var horizontal, t1;
        horizontal = J.get$matches$x(this.mediaQueryList);
        t1 = horizontal ? this.horizontalSizes : this.verticalSizes;
        this._box_0.splitter = A.flexSplit(this.parts, this.gutterSize, horizontal, this.minSize, t1);
      }, null, null, 0, 0, null, "call"]
    },
    flexSplitBidirectional_closure: {
      "^": "Closure:10;_box_0,createSplitter,$ti",
      call$1: [function(e) {
        H.interceptedTypeCheck(e, "$isEvent");
        J.destroy$2$x(this._box_0.splitter, true, false);
        this.createSplitter.call$0();
      }, null, null, 4, 0, null, 19, "call"]
    }
  }], ["", "package:devtools/src/ui/ui_utils.dart",, Y, {
    "^": "",
    getServiceExtensionButtons: [function() {
      var t1, t2, t3, t4, t5;
      t1 = A.div(null, "btn-group collapsible", null);
      t2 = [A.CoreElement];
      J.add$1$ax(t1, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_Zyt).button, Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_M2D).button], t2));
      t3 = A.div(null, "btn-group collapsible margin-left", null);
      J.add$1$ax(t3, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_kyk).button, Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_RH1).button], t2));
      t4 = A.div(null, "btn-group collapsible margin-left", null);
      J.add$1$ax(t4, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_0).button], t2));
      t5 = A.div(null, "btn-group collapsible overflow margin-left", null);
      J.add$1$ax(t5, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_GFE).button, Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_Kp8).button], t2));
      return H.setRuntimeTypeInfo([t1, t3, t4, t5], t2);
    }, null, null, 0, 0, null],
    ServiceExtensionButton: {
      "^": "Object;extensionDescription<,0button>,$ti",
      ServiceExtensionButton$1: [function(extensionDescription) {
        var t1, t2, extensionName;
        t1 = this.extensionDescription;
        t2 = N.PButton$icon(t1.get$description(), t1.get$icon(), t1.get$disabledTooltip());
        t2.small$0();
        this.button = t2;
        extensionName = t1.get$extension();
        J.set$disabled$z(this.button, !E.serviceManager().get$serviceExtensionManager().isServiceExtensionAvailable$1(extensionName));
        E.serviceManager().get$serviceExtensionManager().hasServiceExtension$2(extensionName, new Y.ServiceExtensionButton_closure(this));
        J.click$1$z(this.button, new Y.ServiceExtensionButton_closure0(this));
        this._updateState$0();
      }, null, null, 4, 0, null, 503],
      _click$0: [function() {
        var wasSelected, t1, t2, t3;
        wasSelected = J.contains$1$asx(J.get$classes$x(this.button.get$element()), "selected");
        t1 = E.serviceManager().get$serviceExtensionManager();
        t2 = this.extensionDescription;
        t3 = t2.get$extension();
        t2 = wasSelected ? t2.get$disabledValue() : t2.get$enabledValue();
        t1.setServiceExtensionState$3(t3, !wasSelected, t2);
      }, null, "get$_click", 0, 0, null],
      _updateState$0: [function() {
        E.serviceManager().get$serviceExtensionManager().getServiceExtensionState$2(this.extensionDescription.get$extension(), new Y.ServiceExtensionButton__updateState_closure(this));
      }, null, "get$_updateState", 0, 0, null],
      static: {
        ServiceExtensionButton$: [function(extensionDescription) {
          var t1 = new Y.ServiceExtensionButton(extensionDescription, []);
          t1.ServiceExtensionButton$1(extensionDescription);
          return t1;
        }, null, null, 4, 0, null, 503]
      }
    },
    ServiceExtensionButton_closure: {
      "^": "Closure:182;$this,$ti",
      call$1: [function(available) {
        var t1 = !H.boolTypeCheck(available);
        J.set$disabled$z(J.get$button$z(this.$this), t1);
        return t1;
      }, null, null, 4, 0, null, 885, "call"]
    },
    ServiceExtensionButton_closure0: {
      "^": "Closure:0;$this,$ti",
      call$0: [function() {
        return this.$this._click$0();
      }, null, null, 0, 0, null, "call"]
    },
    ServiceExtensionButton__updateState_closure: {
      "^": "Closure:183;$this,$ti",
      call$1: [function(state) {
        var t1, extensionEnabled, t2;
        t1 = this.$this;
        extensionEnabled = J.$eq$(H.interceptedTypeCheck(state, "$isServiceExtensionState").value, t1.get$extensionDescription().get$enabledValue());
        t2 = J.getInterceptor$z(t1);
        t2.get$button(t1).toggleClass$2("selected", extensionEnabled);
        t2 = t2.get$button(t1);
        t2.set$tooltip(extensionEnabled ? t1.get$extensionDescription().get$enabledTooltip() : t1.get$extensionDescription().get$disabledTooltip());
      }, null, null, 4, 0, null, 78, "call"]
    },
    RegisteredServiceExtensionButton: {
      "^": "Object;$ti"
    }
  }], ["", "package:devtools/src/ui/viewport_canvas.dart",, T, {
    "^": "",
    _CanvasChunk: {
      "^": "Object;canvas>,0_context,_empty,0_dirty,attached,_lastFrameRendered,0rect>,0_viewport_canvas$_position,$ti",
      set$_lastFrameRendered: function(_lastFrameRendered) {
        this._lastFrameRendered = H.intTypeCheck(_lastFrameRendered);
      },
      _CanvasChunk$1: [function(position) {
        var t1, t2, t3, t4;
        t1 = this.canvas;
        t2 = J.getInterceptor$x(t1);
        t3 = t2.get$style(t1);
        t4 = J.getInterceptor$x(t3);
        t4.set$position(t3, "absolute");
        t4.set$width(t3, "512px");
        t4.set$height(t3, "512px");
        t1 = t2.get$context2D(t1);
        t2 = $.$get$_devicePixelRatio();
        t3 = J.getInterceptor$x(t1);
        t3.scale$2(t1, t2, t2);
        t3.save$0(t1);
        this._context = H.interceptedTypeCheck(t1, "$isCanvasRenderingContext2D");
        this.set$position(0, position);
        this._dirty = true;
      }, null, null, 4, 0, null, 69],
      get$context: [function() {
        return this._context;
      }, null, null, 2, 0, null],
      get$dirty: [function() {
        return this._dirty;
      }, null, null, 2, 0, null],
      get$position: [function(_) {
        return this._viewport_canvas$_position;
      }, null, null, 3, 0, null],
      set$position: [function(_, p) {
        var t1, t2;
        H.interceptedTypeCheck(p, "$is_ChunkPosition");
        if (J.$eq$(this._viewport_canvas$_position, p))
          return;
        this._viewport_canvas$_position = p;
        this.rect = S.Rect$fromLTWH(J.toDouble$0$n(J.$mul$ns(J.get$x$x(this.get$position(this)), 512)), J.toDouble$0$n(J.$mul$ns(J.get$y$x(this.get$position(this)), 512)), C.JSInt_methods.toDouble$0(512), C.JSInt_methods.toDouble$0(512));
        J.set$transform$x(J.get$style$x(this.canvas), "translate(" + H.S(J.get$left$x(this.rect)) + "px, " + H.S(J.get$top$x(this.rect)) + "px)");
        t1 = this.get$context();
        t2 = J.getInterceptor$x(t1);
        t2.restore$0(t1);
        t2.save$0(t1);
        t2.translate$2(t1, J.$negate$in(J.get$left$x(this.rect)), J.$negate$in(J.get$top$x(this.rect)));
        this._debugPaint$0();
        this.markNeedsPaint$0();
      }, null, null, 7, 0, null, 509],
      markNeedsPaint$0: [function() {
        this._dirty = true;
      }, null, "get$markNeedsPaint", 0, 0, null],
      markPainted$0: [function() {
        this._dirty = false;
        this._empty = false;
      }, null, "get$markPainted", 0, 0, null],
      clear$0: [function(_) {
        if (this._empty)
          return;
        J.clearRect$4$x(this._context, J.get$left$x(this.rect), J.get$top$x(this.rect), 512, 512);
        this._debugPaint$0();
        this._empty = true;
      }, null, "get$clear", 1, 0, null],
      _debugPaint$0: [function() {
      }, null, "get$_debugPaint", 0, 0, null],
      dirty$0: function() {
        return this.get$dirty().call$0();
      },
      static: {
        _CanvasChunk$: [function(position) {
          var t1, t2;
          t1 = $.$get$_devicePixelRatio();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t2 = H.intTypeCheck(512 * t1);
          t2 = new T._CanvasChunk(W.CanvasElement_CanvasElement(H.intTypeCheck(512 * t1), t2), true, false, -1, []);
          t2._CanvasChunk$1(position);
          return t2;
        }, null, null, 4, 0, null, 69]
      }
    },
    _ChunkPosition: {
      "^": "Object;x>,y>,$ti",
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof T._ChunkPosition))
          return false;
        return J.$eq$(this.y, other.y) && J.$eq$(this.x, other.x);
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.$add$ansx(J.$mul$ns(this.y, 37), this.x);
      }, null, null, 3, 0, null],
      static: {
        _ChunkPosition$: [function(x, y) {
          return new T._ChunkPosition(x, y, []);
        }, null, null, 8, 0, null, 37, 77]
      }
    },
    ViewportCanvas: {
      "^": "_ViewportCanvas_Object_SetStateMixin;0_currentMouseHover<,_viewport_canvas$_frameId,_viewport_canvas$_paintCallback,_onTap,_onMouseMove,_onMouseLeave<,_chunks,0_viewport_canvas$_visibilityObserver,_viewport_canvas$_element<,_content,_spaceTop,_spaceBottom,_spaceLeft,_spaceRight,_contentWidth,_contentHeight,_contentSizeChanged,_viewport_canvas$_hasPendingRebuild,addBuffer,0_renderedViewport,_viewport<,$ti",
      set$_currentMouseHover: function(_currentMouseHover) {
        this._currentMouseHover = H.assertSubtype(_currentMouseHover, "$isPoint", [P.num], "$asPoint");
      },
      set$_viewport_canvas$_hasPendingRebuild: function(_hasPendingRebuild) {
        this._viewport_canvas$_hasPendingRebuild = H.boolTypeCheck(_hasPendingRebuild);
      },
      ViewportCanvas$6$addBuffer$classes$onMouseLeave$onMouseMove$onTap$paintCallback: [function(addBuffer, classes, onMouseLeave, onMouseMove, onTap, paintCallback) {
        var t1, t2, t3, t4, t5, t6, spacers, t7, t8, t9;
        t1 = this._viewport_canvas$_element;
        J.set$overflow$x(J.get$style$x(t1.get$element()), "scroll");
        t2 = this._content;
        t3 = J.get$style$x(t2.get$element());
        t4 = J.getInterceptor$x(t3);
        t4.set$position(t3, "relative");
        t4.set$width(t3, "0");
        t4.set$height(t3, "0");
        t4.set$overflow(t3, "hidden");
        J.add$1$ax(t1, t2);
        t3 = this._spaceTop;
        t4 = this._spaceBottom;
        t5 = this._spaceLeft;
        t6 = this._spaceRight;
        spacers = H.setRuntimeTypeInfo([t3, t4, t5, t6], [A.CoreElement]);
        for (t7 = C.JSArray_methods.get$iterator(spacers); t7.moveNext$0();) {
          t8 = J.get$style$x(t7.get$current().element);
          t9 = J.getInterceptor$x(t8);
          t9.set$position(t8, "absolute");
          t9.set$overflow(t8, "hidden");
        }
        t5 = J.get$style$x(t5.get$element());
        t7 = J.getInterceptor$x(t5);
        t7.set$top(t5, "0");
        t7.set$bottom(t5, "0");
        t7.set$left(t5, "0");
        t7.set$width(t5, "0");
        t6 = J.get$style$x(t6.get$element());
        t5 = J.getInterceptor$x(t6);
        t5.set$top(t6, "0");
        t5.set$bottom(t6, "0");
        t5.set$right(t6, "0");
        t5.set$width(t6, "0");
        t3 = J.get$style$x(t3.get$element());
        t6 = J.getInterceptor$x(t3);
        t6.set$top(t3, "0");
        t6.set$left(t3, "0");
        t6.set$right(t3, "0");
        t6.set$height(t3, "0");
        t4 = J.get$style$x(t4.get$element());
        t3 = J.getInterceptor$x(t4);
        t3.set$bottom(t4, "0");
        t3.set$left(t4, "0");
        t3.set$right(t4, "0");
        t3.set$height(t4, "0");
        t4 = J.getInterceptor$ax(t2);
        t4.add$1(t2, spacers);
        this._viewport_canvas$_visibilityObserver = H.interceptedTypeCheck(W.IntersectionObserver_IntersectionObserver(P.allowInterop(this.get$_onVisibilityChange(), {func: 1, ret: -1, args: [[P.List,,], W.IntersectionObserver]}), P.LinkedHashMap__makeLiteral(["root", t1.get$element()])), "$isIntersectionObserver");
        for (t1 = C.JSArray_methods.get$iterator(spacers); t1.moveNext$0();) {
          t3 = t1.get$current();
          J.observe$1$x(this._viewport_canvas$_visibilityObserver, t3.element);
        }
        J.get$onScroll$x(this.get$element()).listen$1(new T.ViewportCanvas_closure(this));
        if (this._onTap != null)
          t4.get$onClick(t2).listen$1(new T.ViewportCanvas_closure0(this));
        J.get$onMouseLeave$x(t2.get$element()).listen$1(new T.ViewportCanvas_closure1(this));
        J.get$onMouseMove$x(t2.get$element()).listen$1(new T.ViewportCanvas_closure2(this));
      }, null, null, 0, 13, null, 27, 0, 0, 0, 0, 0, 504, 190, 505, 506, 507, 508],
      get$element: [function() {
        return this._viewport_canvas$_element;
      }, null, null, 2, 0, null],
      get$viewport: [function() {
        return this._viewport;
      }, null, null, 2, 0, null],
      _dispatchMouseMoveEvent$0: [function() {
        var t1 = this._onMouseMove;
        if (t1 != null)
          t1.call$1(this._clientToGlobal$1(this._currentMouseHover));
      }, null, "get$_dispatchMouseMoveEvent", 0, 0, null],
      _clientToGlobal$1: [function(client) {
        var elementRect;
        H.assertSubtype(client, "$isPoint", [P.num], "$asPoint");
        elementRect = J.getBoundingClientRect$0$x(this._content.get$element());
        return S.Offset$(H.doubleTypeCheck(J.$sub$n(client.x, (elementRect && C._DomRect_methods).get$left(elementRect))), H.doubleTypeCheck(J.$sub$n(client.y, C._DomRect_methods.get$top(elementRect))));
      }, null, "get$_clientToGlobal", 4, 0, null, 295],
      _onVisibilityChange$2: [function(entries, observer) {
        H.listTypeCheck(entries);
        H.interceptedTypeCheck(observer, "$isIntersectionObserver");
        this._viewport_canvas$_scheduleRebuild$0();
      }, "call$2", "get$_onVisibilityChange", 8, 0, 62, 206, 469],
      _viewport_canvas$_scheduleRebuild$0: [function() {
        if (!this._viewport_canvas$_hasPendingRebuild) {
          this._viewport_canvas$_hasPendingRebuild = true;
          this.setState$1(new T.ViewportCanvas__scheduleRebuild_closure(this));
        }
      }, null, "get$_viewport_canvas$_scheduleRebuild", 0, 0, null],
      rebuild$1$force: [function(force) {
        var lastViewport, rawElement, t1;
        H.boolTypeCheck(force);
        lastViewport = this._viewport;
        rawElement = this._viewport_canvas$_element.get$element();
        t1 = J.getInterceptor$x(rawElement);
        t1 = S.Rect$fromLTWH(J.toDouble$0$n(t1.get$scrollLeft(rawElement)), J.toDouble$0$n(t1.get$scrollTop(rawElement)), J.toDouble$0$n(t1.get$offsetWidth(rawElement)), J.toDouble$0$n(t1.get$offsetHeight(rawElement)));
        this._viewport = t1;
        if (this.addBuffer)
          this._renderedViewport = H.interceptedTypeCheck(t1.inflate$1(C.JSInt_methods.toDouble$0(512)).intersect$1(S.Rect$fromLTWH(0, 0, this._contentWidth, this._contentHeight)), "$isRect");
        else
          this._renderedViewport = t1;
        if (!J.$eq$(lastViewport.get$left(lastViewport), J.get$left$x(this._renderedViewport)) || this._contentSizeChanged)
          J.set$width$x(J.get$style$x(this._spaceLeft.get$element()), H.S(J.$sub$n(J.get$left$x(this._renderedViewport), 1)) + "px");
        if (!J.$eq$(lastViewport.get$right(lastViewport), J.get$right$x(this._renderedViewport)) || this._contentSizeChanged)
          J.set$width$x(J.get$style$x(this._spaceRight.get$element()), H.S(J.$sub$n(J.$sub$n(this._contentWidth, J.get$right$x(this._renderedViewport)), 1)) + "px");
        if (!J.$eq$(lastViewport.get$top(lastViewport), J.get$top$x(this._renderedViewport)) || this._contentSizeChanged)
          J.set$height$x(J.get$style$x(this._spaceTop.get$element()), H.S(J.$sub$n(J.get$top$x(this._renderedViewport), 1)) + "px");
        if (!J.$eq$(lastViewport.get$bottom(lastViewport), J.get$bottom$x(this._renderedViewport)) || this._contentSizeChanged)
          J.set$height$x(J.get$style$x(this._spaceBottom.get$element()), H.S(J.$sub$n(J.$sub$n(this._contentHeight, J.get$bottom$x(this._renderedViewport)), 1)) + "px");
        this._contentSizeChanged = false;
        this._viewport_canvas$_render$1(force);
      }, null, "get$rebuild", 0, 3, null, 0, 510],
      setContentSize$2: [function(width, height) {
        var t1, t2;
        H.doubleTypeCheck(width);
        H.doubleTypeCheck(height);
        t1 = this._contentWidth;
        if (width == null ? t1 == null : width === t1) {
          t1 = this._contentHeight;
          t1 = height == null ? t1 == null : height === t1;
        } else
          t1 = false;
        if (t1)
          return;
        this._contentWidth = width;
        this._contentHeight = height;
        t1 = J.get$style$x(this._content.get$element());
        t2 = J.getInterceptor$x(t1);
        t2.set$width(t1, H.S(width) + "px");
        t2.set$height(t1, H.S(height) + "px");
        if (!this._contentSizeChanged) {
          this._contentSizeChanged = true;
          this._viewport_canvas$_scheduleRebuild$0();
        }
      }, null, "get$setContentSize", 8, 0, null, 56, 96],
      _getChunkPosition$1: [function(offset) {
        H.interceptedTypeCheck(offset, "$isOffset");
        return T._ChunkPosition$(J.$tdiv$n(offset.get$dx(offset), 512), J.$tdiv$n(offset.get$dy(offset), 512));
      }, null, "get$_getChunkPosition", 4, 0, null, 52],
      _getChunk$1: [function(position) {
        var t1, t2, existing, t3, t4, chunk;
        H.interceptedTypeCheck(position, "$is_ChunkPosition");
        t1 = this._chunks;
        t2 = J.getInterceptor$asx(t1);
        existing = t2.$index(t1, position);
        if (existing != null) {
          if (existing.get$dirty())
            existing.clear$0(0);
          return existing;
        }
        for (t3 = J.get$iterator$ax(t2.get$values(t1)); t3.moveNext$0();) {
          t4 = t3.get$current();
          if (!this._isVisible$1(t4)) {
            t2.remove$1(t1, t4.get$position(t4));
            t4.set$position(0, position);
            t2.$indexSet(t1, position, t4);
            if (t4.get$dirty())
              t4.clear$0(0);
            return t4;
          }
        }
        chunk = T._CanvasChunk$(position);
        t2.$indexSet(t1, position, chunk);
        return chunk;
      }, null, "get$_getChunk", 4, 0, null, 69],
      _viewport_canvas$_render$1: [function(force) {
        var chunk, e, st, t1, t2, start, end, y, t3, x, exception, t4, t5, attach;
        if (H.boolTypeCheck(force))
          for (t1 = J.get$iterator$ax(J.get$values$z(this._chunks)); t1.moveNext$0();) {
            t2 = t1.get$current();
            t2.markNeedsPaint$0();
            t2.clear$0(0);
          }
        this._viewport_canvas$_frameId = H.intTypeCheck(J.$add$ansx(this._viewport_canvas$_frameId, 1));
        start = this._getChunkPosition$1(J.get$topLeft$z(this._renderedViewport));
        end = this._getChunkPosition$1(J.get$bottomRight$z(this._renderedViewport));
        y = start.y;
        t1 = end.y;
        t2 = end.x;
        t3 = this._viewport_canvas$_paintCallback;
        while (true) {
          if (typeof y !== "number")
            return y.$le();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(y <= t1))
            break;
          x = start.x;
          while (true) {
            if (typeof x !== "number")
              return x.$le();
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(x <= t2))
              break;
            chunk = this._getChunk$1(T._ChunkPosition$(x, y));
            if (chunk.get$dirty()) {
              try {
                t3.call$2(J.get$context2D$x(J.get$canvas$z(chunk)), J.get$rect$x(chunk));
              } catch (exception) {
                e = H.unwrapException(exception);
                st = H.getTraceFromException(exception);
                t4 = J.get$console$x(W.window());
                t5 = J.getInterceptor$z(t4);
                t5.error$1(t4, e);
                t5.error$1(t4, st);
              }
              chunk.markPainted$0();
            }
            chunk.set$_lastFrameRendered(this._viewport_canvas$_frameId);
            ++x;
          }
          ++y;
        }
        for (t1 = J.get$iterator$ax(J.get$values$z(this._chunks)), t2 = this._content; t1.moveNext$0();) {
          t3 = t1.get$current();
          attach = J.$eq$(t3._lastFrameRendered, this._viewport_canvas$_frameId);
          t4 = t3.attached;
          if (attach == null ? t4 != null : attach !== t4) {
            if (attach)
              J.append$1$x(t2.get$element(), t3.canvas);
            else
              J.remove$0$ax(t3.canvas);
            t3.attached = attach;
          }
        }
      }, null, "get$_viewport_canvas$_render", 4, 0, null, 510],
      _isVisible$1: [function(chunk) {
        return H.interceptedTypeCheck(chunk, "$is_CanvasChunk").rect.overlaps$1(this._renderedViewport);
      }, null, "get$_isVisible", 4, 0, null, 116],
      scrollToRect$1: [function(target) {
        this.setState$1(new T.ViewportCanvas_scrollToRect_closure(this, H.interceptedTypeCheck(target, "$isRect")));
      }, null, "get$scrollToRect", 4, 0, null, 89],
      _onTap$1: function(arg0) {
        return this._onTap.call$1(arg0);
      },
      _onMouseLeave$0: function() {
        return this._onMouseLeave.call$0();
      },
      $isSetStateMixin: 1,
      static: {
        ViewportCanvas$: [function(addBuffer, classes, onMouseLeave, onMouseMove, onTap, paintCallback) {
          var t1, t2;
          t1 = P.LinkedHashMap_LinkedHashMap$_empty(T._ChunkPosition, T._CanvasChunk);
          t2 = $.$get$Rect_zero();
          t2 = new T.ViewportCanvas(0, paintCallback, onTap, onMouseMove, onMouseLeave, t1, A.div("flex", classes, null), A.div(null, null, null), A.div(null, null, null), A.div(null, null, null), A.div(null, null, null), A.div(null, null, null), 0, 0, true, false, addBuffer, t2, []);
          t2.ViewportCanvas$6$addBuffer$classes$onMouseLeave$onMouseMove$onTap$paintCallback(addBuffer, classes, onMouseLeave, onMouseMove, onTap, paintCallback);
          return t2;
        }, null, null, 0, 13, null, 27, 0, 0, 0, 0, 0, 504, 190, 505, 506, 507, 508]
      }
    },
    ViewportCanvas_closure: {
      "^": "Closure:10;$this,$ti",
      call$1: [function(_) {
        var t1;
        H.interceptedTypeCheck(_, "$isEvent");
        t1 = this.$this;
        if (t1.get$_currentMouseHover() != null)
          t1._dispatchMouseMoveEvent$0();
        t1.rebuild$1$force(false);
      }, null, null, 4, 0, null, 12, "call"]
    },
    ViewportCanvas_closure0: {
      "^": "Closure:19;$this,$ti",
      call$1: [function(e) {
        var t1 = this.$this;
        t1._onTap$1(t1._clientToGlobal$1(J.get$client$x(H.interceptedTypeCheck(e, "$isMouseEvent"))));
      }, null, null, 4, 0, null, 19, "call"]
    },
    ViewportCanvas_closure1: {
      "^": "Closure:19;$this,$ti",
      call$1: [function(_) {
        var t1;
        H.interceptedTypeCheck(_, "$isMouseEvent");
        t1 = this.$this;
        t1.set$_currentMouseHover(null);
        if (t1.get$_onMouseLeave() != null)
          t1._onMouseLeave$0();
      }, null, null, 4, 0, null, 12, "call"]
    },
    ViewportCanvas_closure2: {
      "^": "Closure:19;$this,$ti",
      call$1: [function(e) {
        var t1 = this.$this;
        t1.set$_currentMouseHover(J.get$client$x(H.interceptedTypeCheck(e, "$isMouseEvent")));
        t1._dispatchMouseMoveEvent$0();
      }, null, null, 4, 0, null, 19, "call"]
    },
    ViewportCanvas__scheduleRebuild_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.set$_viewport_canvas$_hasPendingRebuild(false);
        t1.rebuild$1$force(false);
      }, null, null, 0, 0, null, "call"]
    },
    ViewportCanvas_scrollToRect_closure: {
      "^": "Closure:1;$this,target,$ti",
      call$0: [function() {
        var t1, t2, t3, overlaps, x, y;
        t1 = this.$this;
        t1.rebuild$1$force(false);
        t2 = this.target;
        t3 = J.getInterceptor$z(t2);
        if (J.contains$1$asx(t1.get$_viewport(), t3.get$topLeft(t2)) && J.contains$1$asx(t1.get$_viewport(), t3.get$bottomLeft(t2)))
          return;
        overlaps = t1.get$_viewport().overlaps$1(t2);
        x = J.get$left$x(t1.get$_viewport());
        y = J.get$top$x(t1.get$_viewport());
        if (J.$gt$n(J.get$top$x(t1.get$viewport()), t3.get$top(t2)))
          y = J.toInt$0$n(t3.get$top(t2));
        else if (J.$lt$n(J.get$bottom$x(t1.get$viewport()), t3.get$bottom(t2)))
          y = overlaps ? J.$sub$n(t3.get$bottom(t2), J.get$height$x(t1.get$viewport())) : t3.get$top(t2);
        if (J.$gt$n(J.get$left$x(t1.get$viewport()), t3.get$left(t2)))
          x = J.toInt$0$n(t3.get$left(t2));
        else if (J.$lt$n(J.get$right$x(t1.get$viewport()), t3.get$right(t2)))
          x = J.toInt$0$n(J.$sub$n(t3.get$right(t2), J.get$width$x(t1.get$viewport())));
        J.scrollTo$2$x(t1.get$_viewport_canvas$_element().get$element(), x, y);
      }, null, null, 0, 0, null, "call"]
    },
    _ViewportCanvas_Object_SetStateMixin: {
      "^": "Object+SetStateMixin;$ti",
      $isSetStateMixin: 1
    }
  }], ["", "package:devtools/src/utils.dart",, B, {
    "^": "",
    escape: [function(text) {
      H.stringTypeCheck(text);
      return text == null ? "" : C.HtmlEscape_gsm.convert$1(text);
    }, null, null, 4, 0, null, 17],
    printMb: [function(bytes, fractionDigits) {
      H.numTypeCheck(bytes);
      H.intTypeCheck(fractionDigits);
      if (typeof bytes !== "number")
        return bytes.$div();
      return C.JSDouble_methods.toStringAsFixed$1(bytes / 1048576, fractionDigits);
    }, null, null, 4, 2, null, 205, 103, 370],
    isolateName: [function(ref) {
      var $name = J.replaceFirst$2$s(H.interceptedTypeCheck(ref, "$isIsolateRef").name, ".snapshot", "");
      return J.contains$1$asx($name, ".dart$") ? $name + "()" : $name;
    }, null, null, 4, 0, null, 81],
    JsonUtils_getStringMember: [function(json, memberName) {
      return H.stringTypeCheck(H.assertSubtype(json, "$isMap", [P.String, P.Object], "$asMap").$index(0, H.stringTypeCheck(memberName)));
    }, null, null, 8, 0, null, 2, 142],
    JsonUtils_getIntMember: [function(json, memberName) {
      var t1 = H.assertSubtype(json, "$isMap", [P.String, P.Object], "$asMap").$index(0, H.stringTypeCheck(memberName));
      return H.intTypeCheck(t1 == null ? -1 : t1);
    }, null, null, 8, 0, null, 2, 142],
    Property: {
      "^": "Object;_changeController,_value,$ti",
      set$_value: function(_value) {
        this._value = H.assertSubtypeOfRuntimeType(_value, H.getTypeArgumentByIndex(this, 0));
      },
      get$value: [function(_) {
        return this._value;
      }, null, null, 3, 0, null],
      set$value: [function(_, newValue) {
        H.assertSubtypeOfRuntimeType(newValue, H.getTypeArgumentByIndex(this, 0));
        if (!J.$eq$(newValue, this._value)) {
          this.set$_value(newValue);
          J.add$1$ax(this._changeController, newValue);
        }
      }, null, null, 7, 0, null, 896],
      static: {
        Property$: [function(_value, $T) {
          return new B.Property(P.StreamController_StreamController$broadcast(null, null, false, $T), _value, [$T]);
        }, null, null, 4, 0, null, 372]
      }
    },
    DelayedTimer: {
      "^": "Object;minDelay,maxDelay,0_closure,0_minTimer,0_maxTimer,$ti",
      set$_closure: function(_closure) {
        this._closure = H.functionTypeCheck(_closure, {func: 1, ret: -1});
      },
      invoke$1: [function(closure) {
        var t1, t2, t3;
        this.set$_closure(H.functionTypeCheck(closure, {func: 1, ret: -1}));
        t1 = this._minTimer;
        t2 = this.get$_fire();
        t3 = this.minDelay;
        if (t1 == null) {
          this._minTimer = H.interceptedTypeCheck(P.Timer_Timer(t3, t2), "$isTimer");
          this._maxTimer = H.interceptedTypeCheck(P.Timer_Timer(this.maxDelay, t2), "$isTimer");
        } else {
          t1.cancel$0();
          this._minTimer = H.interceptedTypeCheck(P.Timer_Timer(t3, t2), "$isTimer");
        }
      }, null, "get$invoke", 4, 0, null, 193],
      _fire$0: [function() {
        var t1 = this._minTimer;
        if (!(t1 == null))
          t1.cancel$0();
        this._minTimer = null;
        t1 = this._maxTimer;
        if (!(t1 == null))
          t1.cancel$0();
        this._maxTimer = null;
        this._closure.call$0();
        this.set$_closure(null);
      }, "call$0", "get$_fire", 0, 0, 0],
      static: {
        DelayedTimer$: [function(minDelay, maxDelay) {
          return new B.DelayedTimer(minDelay, maxDelay, []);
        }, null, null, 8, 0, null, 893, 894]
      }
    },
    JsonUtils: {
      "^": "Object;$ti"
    },
    RateLimiter: {
      "^": "Object;callback,0_pendingRequest,requestScheduledButNotStarted,0_lastRequestTime,delayBetweenRequests,0_activeTimer,$ti",
      set$_pendingRequest: function(_pendingRequest) {
        this._pendingRequest = H.assertSubtype(_pendingRequest, "$isCompleter", [-1], "$asCompleter");
      },
      set$requestScheduledButNotStarted: function(requestScheduledButNotStarted) {
        this.requestScheduledButNotStarted = H.boolTypeCheck(requestScheduledButNotStarted);
      },
      set$_activeTimer: function(_activeTimer) {
        this._activeTimer = H.interceptedTypeCheck(_activeTimer, "$isTimer");
      },
      scheduleRequest$0: [function() {
        var t1, currentTime, t2;
        if (this.requestScheduledButNotStarted)
          return;
        t1 = this._pendingRequest;
        if (t1 != null && !t1.get$isCompleted()) {
          this.requestScheduledButNotStarted = true;
          this._pendingRequest.get$future().whenComplete$1(new B.RateLimiter_scheduleRequest_closure(this));
          return;
        }
        currentTime = P.DateTime$now().get$millisecondsSinceEpoch();
        t1 = this._lastRequestTime;
        if (t1 == null || J.$le$n(J.$add$ansx(t1, this.delayBetweenRequests), currentTime)) {
          this._performRequest$0();
          return;
        }
        this.requestScheduledButNotStarted = true;
        t1 = this._lastRequestTime;
        if (typeof currentTime !== "number")
          return currentTime.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = this.delayBetweenRequests;
        if (typeof t2 !== "number")
          return H.iae(t2);
        this._activeTimer = H.interceptedTypeCheck(P.Timer_Timer(P.Duration$(0, 0, 0, currentTime - t1 + t2, 0, 0), new B.RateLimiter_scheduleRequest_closure0(this)), "$isTimer");
      }, null, "get$scheduleRequest", 0, 0, null],
      _performRequest$0: [function() {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$handler = 1, $async$currentError, $async$next = [], $async$self = this;
        var $async$_performRequest$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$handler = 2;
                $async$self._lastRequestTime = H.intTypeCheck(P.DateTime$now().get$millisecondsSinceEpoch());
                $async$goto = 5;
                return P._asyncAwait($async$self.callback.call$0(), $async$_performRequest$0);
              case 5:
                // returning from await.
                $async$next.push(4);
                // goto finally
                $async$goto = 3;
                break;
              case 2:
                // uncaught
                $async$next = [1];
              case 3:
                // finally
                $async$handler = 1;
                J.complete$1$z($async$self._pendingRequest, null);
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 4:
                // after finally
                // implicit return
                return P._asyncReturn(null, $async$completer);
              case 1:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_performRequest$0, $async$completer);
      }, null, "get$_performRequest", 0, 0, null],
      static: {
        RateLimiter$: [function(requestsPerSecond, callback) {
          if (typeof requestsPerSecond !== "number")
            return H.iae(requestsPerSecond);
          return new B.RateLimiter(callback, false, C.JSInt_methods.$tdiv(1000, requestsPerSecond), []);
        }, null, null, 8, 0, null, 895, 43]
      }
    },
    RateLimiter_scheduleRequest_closure: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.set$_pendingRequest(null);
        t1.set$requestScheduledButNotStarted(false);
        t1.scheduleRequest$0();
      }, null, null, 0, 0, null, "call"]
    },
    RateLimiter_scheduleRequest_closure0: {
      "^": "Closure:1;$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.set$_activeTimer(null);
        t1.set$requestScheduledButNotStarted(false);
        t1._performRequest$0();
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:devtools/src/vm_service_wrapper.dart",, U, {
    "^": "",
    VmServiceWrapper: {
      "^": "Object;_vmService,_activeStreams,_activeFutures<,allFuturesCompleted<,$ti",
      set$allFuturesCompleted: function(allFuturesCompleted) {
        this.allFuturesCompleted = H.assertSubtype(allFuturesCompleted, "$isCompleter", [P.bool], "$asCompleter");
      },
      VmServiceWrapper$fromNewVmService$4$disposeHandler$log: [function(inStream, writeMessage, disposeHandler, log) {
        this._vmService = S.VmService$(inStream, writeMessage, disposeHandler, log);
      }, null, null, 8, 5, null, 0, 0, 229, 228, 227, 182],
      addBreakpoint$4$column: [function(isolateId, scriptId, line, column) {
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(scriptId);
        H.intTypeCheck(line);
        H.intTypeCheck(column);
        return this._trackFuture$1$1(this._vmService.addBreakpoint$4$column(isolateId, scriptId, line, column), S.Breakpoint);
      }, function(isolateId, scriptId, line) {
        return this.addBreakpoint$4$column(isolateId, scriptId, line, null);
      }, "addBreakpoint$3", null, null, "get$addBreakpoint", 12, 3, null, 0, 28, 288, 49, 99],
      callMethod$3$args$isolateId: [function(method, args, isolateId) {
        H.stringTypeCheck(method);
        H.stringTypeCheck(isolateId);
        H.interceptedTypeCheck(args, "$isMap");
        return this._trackFuture$1$1(this._vmService.callMethod$3$args$isolateId(method, args, isolateId), S.Response);
      }, function(method) {
        return this.callMethod$3$args$isolateId(method, null, null);
      }, "callMethod$1", null, null, "get$callMethod", 4, 5, null, 0, 0, 61, 71, 28],
      callServiceExtension$3$args$isolateId: [function(method, args, isolateId) {
        H.stringTypeCheck(method);
        H.stringTypeCheck(isolateId);
        H.interceptedTypeCheck(args, "$isMap");
        return this._trackFuture$1$1(this._vmService.callServiceExtension$3$args$isolateId(method, args, isolateId), S.Response);
      }, function(method, isolateId) {
        return this.callServiceExtension$3$args$isolateId(method, null, isolateId);
      }, "callServiceExtension$2$isolateId", null, null, "get$callServiceExtension", 4, 5, null, 0, 0, 61, 71, 28],
      clearVMTimeline$0: [function() {
        return this._trackFuture$1$1(this._vmService.clearVMTimeline$0(), S.Success);
      }, null, "get$clearVMTimeline", 0, 0, null],
      dispose$0: [function() {
        return this._vmService.dispose$0();
      }, null, "get$dispose", 0, 0, null],
      evaluate$4$scope: [function(isolateId, targetId, expression, scope) {
        var t1;
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(targetId);
        H.stringTypeCheck(expression);
        t1 = P.String;
        H.assertSubtype(scope, "$isMap", [t1, t1], "$asMap");
        return this._trackFuture$1$1(this._vmService.evaluate$4$scope(isolateId, targetId, expression, scope), null);
      }, null, "get$evaluate", 12, 3, null, 0, 28, 226, 147, 184],
      getIsolate$1: [function(isolateId) {
        H.stringTypeCheck(isolateId);
        return this._trackFuture$1$1(this._vmService.getIsolate$1(isolateId), null);
      }, null, "get$getIsolate", 4, 0, null, 28],
      getObject$4$count$offset: [function(isolateId, objectId, count, offset) {
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(objectId);
        H.intTypeCheck(offset);
        H.intTypeCheck(count);
        return this._trackFuture$1$1(this._vmService.getObject$2(isolateId, objectId), P.Object);
      }, function(isolateId, objectId) {
        return this.getObject$4$count$offset(isolateId, objectId, null, null);
      }, "getObject$2", null, null, "get$getObject", 8, 5, null, 0, 0, 28, 514, 42, 52],
      getScripts$1: [function(isolateId) {
        H.stringTypeCheck(isolateId);
        return this._trackFuture$1$1(this._vmService.getScripts$1(isolateId), S.ScriptList);
      }, null, "get$getScripts", 4, 0, null, 28],
      getStack$1: [function(isolateId) {
        H.stringTypeCheck(isolateId);
        return this._trackFuture$1$1(this._vmService.getStack$1(isolateId), S.Stack);
      }, null, "get$getStack", 4, 0, null, 28],
      getVM$0: [function() {
        return this._trackFuture$1$1(this._vmService.getVM$0(), S.VM);
      }, null, "get$getVM", 0, 0, null],
      getVMTimeline$0: [function() {
        return this._trackFuture$1$1(this._vmService.getVMTimeline$0(), S.Response);
      }, null, "get$getVMTimeline", 0, 0, null],
      invoke$4: [function(isolateId, targetId, selector, argumentIds) {
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(targetId);
        H.stringTypeCheck(selector);
        H.assertSubtype(argumentIds, "$isList", [P.String], "$asList");
        return this._trackFuture$1$1(this._vmService.invoke$4(isolateId, targetId, selector, argumentIds), null);
      }, null, "get$invoke", 16, 0, null, 28, 226, 515, 516],
      get$onDebugEvent: [function() {
        return this._vmService.get$onDebugEvent();
      }, null, null, 2, 0, null],
      onEvent$1: [function(streamName) {
        H.stringTypeCheck(streamName);
        return this._vmService.onEvent$1(streamName);
      }, null, "get$onEvent", 4, 0, null, 517],
      get$onExtensionEvent: [function() {
        return this._vmService.get$onExtensionEvent();
      }, null, null, 2, 0, null],
      get$onGCEvent: [function() {
        return this._vmService.get$onGCEvent();
      }, null, null, 2, 0, null],
      get$onIsolateEvent: [function() {
        return this._vmService.get$onIsolateEvent();
      }, null, null, 2, 0, null],
      get$onServiceEvent: [function() {
        return this._vmService.get$onServiceEvent();
      }, null, null, 2, 0, null],
      get$onStderrEvent: [function() {
        return this._vmService.get$onStderrEvent();
      }, null, null, 2, 0, null],
      get$onStdoutEvent: [function() {
        return this._vmService.get$onStdoutEvent();
      }, null, null, 2, 0, null],
      pause$1: [function(_, isolateId) {
        H.stringTypeCheck(isolateId);
        return this._trackFuture$1$1(J.pause$1$z(this._vmService, isolateId), S.Success);
      }, null, "get$pause", 5, 0, null, 28],
      removeBreakpoint$2: [function(isolateId, breakpointId) {
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(breakpointId);
        return this._trackFuture$1$1(this._vmService.removeBreakpoint$2(isolateId, breakpointId), S.Success);
      }, null, "get$removeBreakpoint", 8, 0, null, 28, 518],
      resume$3$frameIndex$step: [function(isolateId, frameIndex, step) {
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(step);
        H.intTypeCheck(frameIndex);
        return this._trackFuture$1$1(this._vmService.resume$3$frameIndex$step(isolateId, frameIndex, step), S.Success);
      }, function(isolateId) {
        return this.resume$3$frameIndex$step(isolateId, null, null);
      }, "resume$1", function(isolateId, step) {
        return this.resume$3$frameIndex$step(isolateId, null, step);
      }, "resume$2$step", "call$3$frameIndex$step", "call$1", "call$2$step", "get$resume", 4, 5, 60, 0, 0, 28, 519, 520],
      setExceptionPauseMode$2: [function(isolateId, mode) {
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(mode);
        return this._trackFuture$1$1(this._vmService.setExceptionPauseMode$2(isolateId, mode), S.Success);
      }, null, "get$setExceptionPauseMode", 8, 0, null, 28, 177],
      setVMTimelineFlags$1: [function(recordedStreams) {
        H.assertSubtype(recordedStreams, "$isList", [P.String], "$asList");
        return this._trackFuture$1$1(this._vmService.setVMTimelineFlags$1(recordedStreams), S.Success);
      }, null, "get$setVMTimelineFlags", 4, 0, null, 521],
      streamListen$1: [function(streamId) {
        var t1, t2, future;
        H.stringTypeCheck(streamId);
        t1 = this._activeStreams;
        t2 = J.getInterceptor$asx(t1);
        if (!t1.containsKey$1(streamId)) {
          future = this._trackFuture$1$1(this._vmService.streamListen$1(streamId), S.Success);
          t2.$indexSet(t1, streamId, future);
          return future;
        } else
          return t2.$index(t1, streamId);
      }, null, "get$streamListen", 4, 0, null, 522],
      _trackFuture$1$1: [1, function(future, $T) {
        H.assertSubtype(future, "$isFuture", [$T], "$asFuture");
        if (this.allFuturesCompleted.get$isCompleted())
          this.set$allFuturesCompleted(P.Completer_Completer(P.bool));
        J.add$1$ax(this._activeFutures, future);
        future.whenComplete$1(new U.VmServiceWrapper__trackFuture_closure(this, future));
        return future;
      }, function(future) {
        return this._trackFuture$1$1(future, null);
      }, "_trackFuture$1", null, "call$1", "get$_trackFuture", 4, 0, null, 318],
      $isVmService: 1,
      static: {
        VmServiceWrapper$fromNewVmService: [function(inStream, writeMessage, disposeHandler, log) {
          var t1 = new U.VmServiceWrapper(null, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.Future, S.Success]), P.LinkedHashSet_LinkedHashSet(null, null, null, [P.Future, P.Object]), P.Completer_Completer(P.bool), []);
          t1.VmServiceWrapper$fromNewVmService$4$disposeHandler$log(inStream, writeMessage, disposeHandler, log);
          return t1;
        }, null, null, 8, 5, null, 0, 0, 229, 228, 227, 182]
      }
    },
    VmServiceWrapper__trackFuture_closure: {
      "^": "Closure:1;$this,future,$ti",
      call$0: [function() {
        var t1 = this.$this;
        J.remove$1$ax(t1.get$_activeFutures(), this.future);
        if (J.get$isEmpty$asx(t1.get$_activeFutures()) && !t1.get$allFuturesCompleted().get$isCompleted())
          J.complete$1$z(t1.get$allFuturesCompleted(), true);
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:http/http.dart",, G, {
    "^": "",
    get: [function(url, headers) {
      var t1 = P.String;
      return G._withClient(new G.get_closure(url, H.assertSubtype(headers, "$isMap", [t1, t1], "$asMap")), U.Response0);
    }, null, null, 4, 3, null, 0, 62, 108],
    _withClient: [1, function(fn, $T) {
      H.functionTypeCheck(fn, {func: 1, ret: [P.Future, $T], args: [U.Client]});
      return G._withClient$body(fn, $T, $T);
    }, function(fn) {
      return G._withClient(fn, null);
    }, null, "call$1", null, 4, 0, null, 307],
    _withClient$body: [1, function(fn, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], client, t1;
      var $async$_withClient = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              client = U.Client_Client();
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait(fn.call$1(client), $async$_withClient);
            case 6:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              J.close$0$z(client);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_withClient, $async$completer);
    }, null, null, 4, 0, null, 307],
    get_closure: {
      "^": "Closure:185;url,headers,$ti",
      call$1: [function(client) {
        return H.interceptedTypeCheck(client, "$isClient").$get$2$headers(this.url, this.headers);
      }, null, null, 4, 0, null, 295, "call"]
    }
  }], ["", "package:http/src/base_client.dart",, E, {
    "^": "",
    BaseClient: {
      "^": "Object;$ti",
      $get$2$headers: [function(url, headers) {
        var t1 = P.String;
        return this._sendUnstreamed$3("GET", url, H.assertSubtype(headers, "$isMap", [t1, t1], "$asMap"));
      }, null, "get$get", 4, 3, null, 0, 62, 108],
      _sendUnstreamed$5: [function(method, url, headers, body, encoding) {
        var t1 = P.String;
        return this._sendUnstreamed$body$BaseClient(H.stringTypeCheck(method), url, H.assertSubtype(headers, "$isMap", [t1, t1], "$asMap"), body, H.interceptedTypeCheck(encoding, "$isEncoding"));
      }, function(method, url, headers) {
        return this._sendUnstreamed$5(method, url, headers, null, null);
      }, "_sendUnstreamed$3", null, null, "get$_sendUnstreamed", 12, 4, null, 0, 0, 61, 62, 108, 201, 131],
      _sendUnstreamed$body$BaseClient: [function(method, url, headers, body, encoding) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(U.Response0),
          $async$returnValue, $async$self = this, request, t1, $async$temp1;
        var $async$_sendUnstreamed$5 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                request = O.Request$(method, H.interceptedTypeCheck(typeof url === "string" ? P.Uri_parse(url, 0, null) : url, "$isUri"));
                if (headers != null)
                  J.addAll$1$ax(request.headers, headers);
                if (encoding != null)
                  request.set$encoding(0, encoding);
                if (body != null)
                  if (typeof body === "string")
                    request.set$body(0, body);
                  else {
                    t1 = J.getInterceptor$(body);
                    if (!!t1.$isList)
                      request.set$bodyBytes(t1.cast$1$0(body, P.int));
                    else if (!!t1.$isMap) {
                      t1 = P.String;
                      request.set$bodyFields(body.cast$2$0(0, t1, t1));
                    } else
                      throw H.wrapException(P.ArgumentError$('Invalid request body "' + H.S(body) + '".'));
                  }
                $async$temp1 = U;
                $async$goto = 3;
                return P._asyncAwait($async$self.send$1(0, request), $async$_sendUnstreamed$5);
              case 3:
                // returning from await.
                $async$returnValue = $async$temp1.Response_fromStream($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_sendUnstreamed$5, $async$completer);
      }, null, null, 12, 4, null, 0, 0, 61, 62, 108, 201, 131],
      close$0: [function(_) {
      }, "call$0", "get$close", 1, 0, 0],
      $isClient: 1
    }
  }], ["", "package:http/src/base_request.dart",, G, {
    "^": "",
    BaseRequest: {
      "^": "Object;url>,headers>,$ti",
      get$finalized: [function() {
        return this._finalized;
      }, null, null, 2, 0, null],
      finalize$0: ["super$BaseRequest$finalize", function() {
        if (this.get$finalized())
          throw H.wrapException(P.StateError$("Can't finalize a finalized Request."));
        this._finalized = true;
        return;
      }, null, "get$finalize", 0, 0, null],
      toString$0: [function(_) {
        return H.S(this.method) + " " + H.S(this.url);
      }, null, "get$toString", 1, 0, null]
    },
    BaseRequest_closure: {
      "^": "Closure:186;$ti",
      call$2: [function(key1, key2) {
        H.stringTypeCheck(key1);
        H.stringTypeCheck(key2);
        return J.$eq$(J.toLowerCase$0$s(key1), J.toLowerCase$0$s(key2));
      }, null, null, 8, 0, null, 911, 912, "call"]
    },
    BaseRequest_closure0: {
      "^": "Closure:187;$ti",
      call$1: [function(key) {
        return J.get$hashCode$(J.toLowerCase$0$s(H.stringTypeCheck(key)));
      }, null, null, 4, 0, null, 4, "call"]
    }
  }], ["", "package:http/src/base_response.dart",, T, {
    "^": "",
    BaseResponse: {
      "^": "Object;request>,statusCode>,reasonPhrase<,headers>,isRedirect<,persistentConnection<,$ti",
      BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request: [function(statusCode, contentLength, headers, isRedirect, persistentConnection, reasonPhrase, request) {
        var t1 = this.statusCode;
        if (J.$lt$n(t1, 100))
          throw H.wrapException(P.ArgumentError$("Invalid status code " + H.S(t1) + "."));
        else {
          t1 = this.contentLength;
          if (t1 != null && J.$lt$n(t1, 0))
            throw H.wrapException(P.ArgumentError$("Invalid content length " + H.S(t1) + "."));
        }
      }, null, null, 4, 13, null, 0, 328, 18, 27, 0, 0, 329, 524, 108, 330, 331, 332, 123]
    }
  }], ["", "package:http/src/browser_client.dart",, O, {
    "^": "",
    createClient: [function() {
      return O.BrowserClient$();
    }, null, null, 0, 0, null],
    BrowserClient: {
      "^": "BaseClient;_xhrs,withCredentials,$ti",
      set$withCredentials: function(_, withCredentials) {
        this.withCredentials = H.boolTypeCheck(withCredentials);
      },
      send$1: [function(_, request) {
        return this.send$body$BrowserClient(_, H.interceptedTypeCheck(request, "$isBaseRequest"));
      }, null, "get$send", 5, 0, null, 123],
      send$body$BrowserClient: [function(_, request) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(X.StreamedResponse),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, xhr, completer, bytes, t1, t2, t3;
        var $async$send$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait(request.finalize$0().toBytes$0(), $async$send$1);
              case 3:
                // returning from await.
                bytes = $async$result;
                xhr = W.HttpRequest_HttpRequest();
                t1 = $async$self._xhrs;
                t2 = J.getInterceptor$ax(t1);
                t2.add$1(t1, xhr);
                $async$self._openHttpRequest$4$asynch(xhr, request.method, J.toString$0$(request.url), true);
                J.set$responseType$x(xhr, "blob");
                J.set$withCredentials$x(xhr, $async$self.withCredentials);
                J.forEach$1$ax(request.headers, J.get$setRequestHeader$x(xhr));
                completer = P.Completer_Completer(X.StreamedResponse);
                J.get$first$ax(J.get$onLoad$x(xhr)).then$1$1(new O.BrowserClient_send_closure(xhr, completer, request), null);
                J.get$first$ax(J.get$onError$x(xhr)).then$1$1(new O.BrowserClient_send_closure0(completer, request), null);
                J.send$1$x(xhr, bytes);
                $async$handler = 4;
                $async$goto = 7;
                return P._asyncAwait(completer.get$future(), $async$send$1);
              case 7:
                // returning from await.
                t3 = $async$result;
                $async$returnValue = t3;
                $async$next = [1];
                // goto finally
                $async$goto = 5;
                break;
                $async$next.push(6);
                // goto finally
                $async$goto = 5;
                break;
              case 4:
                // uncaught
                $async$next = [2];
              case 5:
                // finally
                $async$handler = 2;
                t2.remove$1(t1, xhr);
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$send$1, $async$completer);
      }, null, null, 5, 0, null, 123],
      _openHttpRequest$6$asynch$password$user: [function(request, method, url, asynch, password, user) {
        H.interceptedTypeCheck(request, "$isHttpRequest");
        H.stringTypeCheck(method);
        H.stringTypeCheck(url);
        H.boolTypeCheck(asynch);
        H.stringTypeCheck(user);
        (request && C.HttpRequest_methods).open$5$async$password$user(request, method, url, asynch, H.stringTypeCheck(password), user);
      }, function(request, method, url, asynch) {
        return this._openHttpRequest$6$asynch$password$user(request, method, url, asynch, null, null);
      }, "_openHttpRequest$4$asynch", null, null, "get$_openHttpRequest", 12, 7, null, 0, 0, 0, 123, 61, 62, 919, 397, 398],
      close$0: [function(_) {
        var t1;
        for (t1 = J.get$iterator$ax(this._xhrs); t1.moveNext$0();)
          t1.get$current().abort();
      }, "call$0", "get$close", 1, 0, 0],
      static: {
        BrowserClient$: [function() {
          return new O.BrowserClient(P.LinkedHashSet_LinkedHashSet(null, null, null, W.HttpRequest), false, []);
        }, null, null, 0, 0, null]
      }
    },
    BrowserClient_send_closure: {
      "^": "Closure:28;xhr,completer,request,$ti",
      call$1: [function(_) {
        var t1, t2, blob, reader, t3;
        H.interceptedTypeCheck(_, "$isProgressEvent");
        t1 = this.xhr;
        t2 = J.getInterceptor$x(t1);
        blob = t2.get$response(t1) == null ? W.Blob_Blob([], null, null) : t2.get$response(t1);
        reader = W.FileReader_FileReader();
        t2 = this.completer;
        t3 = this.request;
        J.get$first$ax((reader && C.FileReader_methods).get$onLoad(reader)).then$1$1(new O.BrowserClient_send__closure(reader, t2, t1, t3), null);
        J.get$first$ax(C.FileReader_methods.get$onError(reader)).then$1$1(new O.BrowserClient_send__closure0(t2, t3), null);
        C.FileReader_methods.readAsArrayBuffer$1(reader, H.interceptedTypeCheck(blob, "$isBlob"));
      }, null, null, 4, 0, null, 12, "call"]
    },
    BrowserClient_send__closure: {
      "^": "Closure:28;reader,completer,xhr,request,$ti",
      call$1: [function(_) {
        var body, t1, t2;
        H.interceptedTypeCheck(_, "$isProgressEvent");
        body = H.interceptedTypeCast(J.get$result$x(this.reader), "$isUint8List");
        t1 = this.xhr;
        t2 = J.getInterceptor$x(t1);
        J.complete$1$z(this.completer, X.StreamedResponse$(Z.ByteStream_ByteStream$fromBytes(body), t2.get$status(t1), body.length, t2.get$responseHeaders(t1), false, true, t2.get$statusText(t1), this.request));
      }, null, null, 4, 0, null, 12, "call"]
    },
    BrowserClient_send__closure0: {
      "^": "Closure:28;completer,request,$ti",
      call$1: [function(error) {
        this.completer.completeError$2(E.ClientException$(J.toString$0$(H.interceptedTypeCheck(error, "$isProgressEvent")), J.get$url$z(this.request)), P.StackTrace_current());
      }, null, null, 4, 0, null, 14, "call"]
    },
    BrowserClient_send_closure0: {
      "^": "Closure:28;completer,request,$ti",
      call$1: [function(_) {
        H.interceptedTypeCheck(_, "$isProgressEvent");
        this.completer.completeError$2(E.ClientException$("XMLHttpRequest error.", J.get$url$z(this.request)), P.StackTrace_current());
      }, null, null, 4, 0, null, 12, "call"]
    }
  }], ["", "package:http/src/byte_stream.dart",, Z, {
    "^": "",
    ByteStream: {
      "^": "StreamView;_stream,$ti",
      toBytes$0: [function() {
        var completer, sink;
        completer = P.Completer_Completer(P.Uint8List);
        sink = P._ByteCallbackSink$(new Z.ByteStream_toBytes_closure(completer));
        this.listen$4$cancelOnError$onDone$onError(sink.get$add(sink), true, sink.get$close(sink), completer.get$completeError());
        return completer.get$future();
      }, null, "get$toBytes", 0, 0, null],
      $asStream: function() {
        return [[P.List, P.int]];
      },
      $asStreamView: function() {
        return [[P.List, P.int]];
      },
      static: {
        ByteStream$: [function(stream) {
          return new Z.ByteStream(stream, []);
        }, null, null, 4, 0, null, 57],
        ByteStream_ByteStream$fromBytes: [function(bytes) {
          var t1 = [P.List, P.int];
          return Z.ByteStream$(P.Stream_Stream$fromIterable(H.setRuntimeTypeInfo([H.assertSubtype(bytes, "$isList", [P.int], "$asList")], [t1]), t1));
        }, null, null, 4, 0, null, 103]
      }
    },
    ByteStream_toBytes_closure: {
      "^": "Closure:189;completer,$ti",
      call$1: [function(bytes) {
        return J.complete$1$z(this.completer, H.NativeUint8List_NativeUint8List$fromList(H.assertSubtype(bytes, "$isList", [P.int], "$asList")));
      }, null, null, 4, 0, null, 103, "call"]
    }
  }], ["", "package:http/src/client.dart",, U, {
    "^": "",
    Client_Client: [function() {
      return O.createClient();
    }, null, null, 0, 0, null],
    Client: {
      "^": "Object;$ti"
    }
  }], ["", "package:http/src/exception.dart",, E, {
    "^": "",
    ClientException: {
      "^": "Object;message>,uri<,$ti",
      toString$0: [function(_) {
        return this.message;
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isException: 1,
      static: {
        ClientException$: [function(message, uri) {
          return new E.ClientException(message, uri, []);
        }, null, null, 4, 2, null, 0, 21, 65]
      }
    }
  }], ["", "package:http/src/multipart_file.dart",, K, {
    "^": "",
    MultipartFile: {
      "^": "Object;$ti"
    }
  }], ["", "package:http/src/multipart_request.dart",, D, {
    "^": "",
    MultipartRequest: {
      "^": "BaseRequest;$ti"
    }
  }], ["", "package:http/src/request.dart",, O, {
    "^": "",
    Request: {
      "^": "BaseRequest;_defaultEncoding,_bodyBytes,method,url,0_contentLength,_persistentConnection,_followRedirects,_maxRedirects,headers,_finalized,$ti",
      get$encoding: [function(_) {
        if (this.get$_contentType() == null || !this.get$_contentType().get$parameters().containsKey$1("charset"))
          return this._defaultEncoding;
        return B.requiredEncodingForCharset(J.$index$asx(this.get$_contentType().get$parameters(), "charset"));
      }, null, null, 3, 0, null],
      set$encoding: [function(_, value) {
        var contentType, t1;
        H.interceptedTypeCheck(value, "$isEncoding");
        this._checkFinalized$0();
        this._defaultEncoding = value;
        contentType = this.get$_contentType();
        if (contentType == null)
          return;
        t1 = P.String;
        this.set$_contentType(contentType.change$1$parameters(P.LinkedHashMap_LinkedHashMap$_literal(["charset", value.get$name(value)], t1, t1)));
      }, null, null, 7, 0, null, 1],
      get$bodyBytes: [function() {
        return this._bodyBytes;
      }, null, null, 2, 0, null],
      set$bodyBytes: [function(value) {
        H.assertSubtype(value, "$isList", [P.int], "$asList");
        this._checkFinalized$0();
        this._bodyBytes = H.interceptedTypeCheck(B.toUint8List(value), "$isUint8List");
      }, null, null, 6, 0, null, 1],
      set$body: [function(_, value) {
        var contentType, t1;
        H.stringTypeCheck(value);
        this.set$bodyBytes(this.get$encoding(this).encode$1(value));
        contentType = this.get$_contentType();
        if (contentType == null) {
          t1 = P.String;
          this.set$_contentType(R.MediaType$("text", "plain", P.LinkedHashMap_LinkedHashMap$_literal(["charset", J.get$name$x(this.get$encoding(this))], t1, t1)));
        } else if (!contentType.parameters.containsKey$1("charset")) {
          t1 = P.String;
          this.set$_contentType(contentType.change$1$parameters(P.LinkedHashMap_LinkedHashMap$_literal(["charset", J.get$name$x(this.get$encoding(this))], t1, t1)));
        }
      }, null, null, 7, 0, null, 1],
      set$bodyFields: [function(fields) {
        var t1, contentType;
        t1 = P.String;
        H.assertSubtype(fields, "$isMap", [t1, t1], "$asMap");
        contentType = this.get$_contentType();
        if (contentType == null)
          this.set$_contentType(R.MediaType$("application", "x-www-form-urlencoded", null));
        else if (!J.$eq$(contentType.get$mimeType(), "application/x-www-form-urlencoded"))
          throw H.wrapException(P.StateError$('Cannot set the body fields of a Request with content-type "' + H.S(contentType.get$mimeType()) + '".'));
        this.set$body(0, B.mapToQuery(fields, this.get$encoding(this)));
      }, null, null, 6, 0, null, 920],
      finalize$0: [function() {
        this.super$BaseRequest$finalize();
        return Z.ByteStream_ByteStream$fromBytes(this.get$bodyBytes());
      }, null, "get$finalize", 0, 0, null],
      get$_contentType: [function() {
        var contentType = J.$index$asx(this.headers, "content-type");
        if (contentType == null)
          return;
        return R.MediaType_MediaType$parse(contentType);
      }, null, null, 2, 0, null],
      set$_contentType: [function(value) {
        J.$indexSet$ax(this.headers, "content-type", J.toString$0$(H.interceptedTypeCheck(value, "$isMediaType")));
      }, null, null, 6, 0, null, 1],
      _checkFinalized$0: [function() {
        if (!this.get$finalized())
          return;
        throw H.wrapException(P.StateError$("Can't modify a finalized Request."));
      }, null, "get$_checkFinalized", 0, 0, null],
      static: {
        Request$: [function(method, url) {
          var t1 = P.String;
          return new O.Request(C.Utf8Codec_false, H.NativeUint8List_NativeUint8List(0), method, url, true, true, 5, P.LinkedHashMap_LinkedHashMap(new G.BaseRequest_closure(), new G.BaseRequest_closure0(), null, t1, t1), false, []);
        }, null, null, 8, 0, null, 61, 62]
      }
    }
  }], ["", "package:http/src/response.dart",, U, {
    "^": "",
    _encodingForHeaders: [function(headers) {
      var t1 = P.String;
      return B.encodingForCharset(J.$index$asx(U._contentTypeForHeaders(H.assertSubtype(headers, "$isMap", [t1, t1], "$asMap")).get$parameters(), "charset"), C.Latin1Codec_false);
    }, null, null, 4, 0, null, 108],
    _contentTypeForHeaders: [function(headers) {
      var t1, contentType;
      t1 = P.String;
      contentType = H.assertSubtype(headers, "$isMap", [t1, t1], "$asMap").$index(0, "content-type");
      if (contentType != null)
        return R.MediaType_MediaType$parse(contentType);
      return R.MediaType$("application", "octet-stream", null);
    }, null, null, 4, 0, null, 108],
    Response0: {
      "^": "BaseResponse;bodyBytes,request,statusCode,reasonPhrase,contentLength,headers,isRedirect,persistentConnection,$ti",
      get$body: [function(_) {
        return J.decode$1$z(U._encodingForHeaders(this.headers), this.bodyBytes);
      }, null, null, 3, 0, null],
      static: {
        Response$bytes: [function(bodyBytes, statusCode, headers, isRedirect, persistentConnection, reasonPhrase, request) {
          var t1, t2;
          t1 = B.toUint8List(bodyBytes);
          t2 = J.get$length$asx(bodyBytes);
          t1 = new U.Response0(t1, request, statusCode, reasonPhrase, t2, headers, isRedirect, persistentConnection, []);
          t1.BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request(statusCode, t2, headers, isRedirect, persistentConnection, reasonPhrase, request);
          return t1;
        }, null, null, 8, 11, null, 328, 18, 27, 0, 0, 921, 329, 108, 330, 331, 332, 123],
        Response_fromStream: [function(response) {
          H.interceptedTypeCheck(response, "$isStreamedResponse");
          return response.stream.toBytes$0().then$1$1(new U.Response_fromStream_closure(response), U.Response0);
        }, null, null, 4, 0, null, 922]
      }
    },
    Response_fromStream_closure: {
      "^": "Closure:190;response,$ti",
      call$1: [function(body) {
        var t1, t2, t3, t4;
        H.interceptedTypeCheck(body, "$isUint8List");
        t1 = this.response;
        t2 = J.getInterceptor$z(t1);
        t3 = t2.get$statusCode(t1);
        t4 = t2.get$request(t1);
        return U.Response$bytes(body, t3, t2.get$headers(t1), t1.get$isRedirect(), t1.get$persistentConnection(), t1.get$reasonPhrase(), t4);
      }, null, null, 4, 0, null, 201, "call"]
    }
  }], ["", "package:http/src/streamed_request.dart",, F, {
    "^": "",
    StreamedRequest: {
      "^": "BaseRequest;$ti"
    }
  }], ["", "package:http/src/streamed_response.dart",, X, {
    "^": "",
    StreamedResponse: {
      "^": "BaseResponse;stream>,request,statusCode,reasonPhrase,contentLength,headers,isRedirect,persistentConnection,$ti",
      static: {
        StreamedResponse$: [function(stream, statusCode, contentLength, headers, isRedirect, persistentConnection, reasonPhrase, request) {
          var t1 = new X.StreamedResponse(B.toByteStream(stream), request, statusCode, reasonPhrase, contentLength, headers, isRedirect, persistentConnection, []);
          t1.BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request(statusCode, contentLength, headers, isRedirect, persistentConnection, reasonPhrase, request);
          return t1;
        }, null, null, 8, 13, null, 0, 328, 18, 27, 0, 0, 57, 329, 524, 108, 330, 331, 332, 123]
      }
    }
  }], ["", "package:http/src/utils.dart",, B, {
    "^": "",
    mapToQuery: [function(map, encoding) {
      var t1, pairs;
      t1 = P.String;
      H.assertSubtype(map, "$isMap", [t1, t1], "$asMap");
      H.interceptedTypeCheck(encoding, "$isEncoding");
      pairs = H.setRuntimeTypeInfo([], [[P.List, P.String]]);
      map.forEach$1(0, new B.mapToQuery_closure(pairs, encoding));
      return J.join$1$ax(C.JSArray_methods.map$1$1(pairs, new B.mapToQuery_closure0(), t1), "&");
    }, null, null, 4, 3, null, 0, 111, 131],
    encodingForCharset: [function(charset, fallback) {
      var encoding;
      H.stringTypeCheck(charset);
      H.interceptedTypeCheck(fallback, "$isEncoding");
      if (charset == null)
        return fallback;
      encoding = P.Encoding_getByName(charset);
      return encoding == null ? fallback : encoding;
    }, null, null, 4, 2, null, 923, 526, 925],
    requiredEncodingForCharset: [function(charset) {
      var encoding;
      H.stringTypeCheck(charset);
      encoding = P.Encoding_getByName(charset);
      if (encoding != null)
        return encoding;
      throw H.wrapException(P.FormatException$('Unsupported encoding "' + H.S(charset) + '".', null, null));
    }, null, null, 4, 0, null, 526],
    toUint8List: [function(input) {
      var t1;
      H.assertSubtype(input, "$isList", [P.int], "$asList");
      t1 = J.getInterceptor$(input);
      if (!!t1.$isUint8List)
        return input;
      if (!!t1.$isTypedData)
        return P.Uint8List_Uint8List$view(input.buffer, 0, null);
      return H.NativeUint8List_NativeUint8List$fromList(input);
    }, null, null, 4, 0, null, 55],
    toByteStream: [function(stream) {
      H.assertSubtype(stream, "$isStream", [[P.List, P.int]], "$asStream");
      if (stream instanceof Z.ByteStream)
        return stream;
      return Z.ByteStream$(stream);
    }, null, null, 4, 0, null, 57],
    mapToQuery_closure: {
      "^": "Closure:41;pairs,encoding,$ti",
      call$2: [function(key, value) {
        var t1;
        H.stringTypeCheck(key);
        H.stringTypeCheck(value);
        t1 = this.encoding;
        return J.add$1$ax(this.pairs, H.setRuntimeTypeInfo([P.Uri_encodeQueryComponent(key, t1), P.Uri_encodeQueryComponent(value, t1)], [P.String]));
      }, null, null, 8, 0, null, 4, 1, "call"]
    },
    mapToQuery_closure0: {
      "^": "Closure:191;$ti",
      call$1: [function(pair) {
        var t1;
        H.assertSubtype(pair, "$isList", [P.String], "$asList");
        t1 = J.getInterceptor$asx(pair);
        return H.S(t1.$index(pair, 0)) + "=" + H.S(t1.$index(pair, 1));
      }, null, null, 4, 0, null, 191, "call"]
    },
    Pair0: {
      "^": "Object;$ti"
    }
  }], ["", "package:http_parser/src/authentication_challenge.dart",, E, {
    "^": "",
    AuthenticationChallenge: {
      "^": "Object;$ti"
    }
  }], ["", "package:http_parser/src/case_insensitive_map.dart",, Z, {
    "^": "",
    CaseInsensitiveMap: {
      "^": "CanonicalizedMap;_canonicalize,_isValidKeyFn,_base,$ti",
      $asMap: function($V) {
        return [P.String, $V];
      },
      $asCanonicalizedMap: function($V) {
        return [P.String, P.String, $V];
      },
      static: {
        CaseInsensitiveMap$from: [function(other, $V) {
          var t1, t2, t3, t4;
          t1 = new Z.CaseInsensitiveMap$from_closure();
          t2 = new Z.CaseInsensitiveMap$from_closure0();
          t3 = P.String;
          t4 = new Z.CaseInsensitiveMap(t1, t2, H.JsLinkedHashMap_JsLinkedHashMap$es6(t3, [B.Pair, t3, $V]), [$V]);
          t4.CanonicalizedMap$from$3$isValidKey(other, t1, t2, t3, t3, $V);
          return t4;
        }, null, null, 4, 0, null, 3]
      }
    },
    CaseInsensitiveMap$from_closure: {
      "^": "Closure:7;$ti",
      call$1: [function(key) {
        return J.toLowerCase$0$s(H.stringTypeCheck(key));
      }, null, null, 4, 0, null, 4, "call"]
    },
    CaseInsensitiveMap$from_closure0: {
      "^": "Closure:18;$ti",
      call$1: [function(key) {
        return key != null;
      }, null, null, 4, 0, null, 4, "call"]
    }
  }], ["", "package:http_parser/src/chunked_coding.dart",, S, {
    "^": "",
    ChunkedCodingCodec: {
      "^": "Codec;$ti",
      $asCodec: function() {
        return [[P.List, P.int], [P.List, P.int]];
      }
    }
  }], ["", "package:http_parser/src/chunked_coding/decoder.dart",, B, {
    "^": "",
    ChunkedCodingDecoder: {
      "^": "Converter;$ti",
      $asStreamTransformer: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asConverter: function() {
        return [[P.List, P.int], [P.List, P.int]];
      }
    },
    _Sink: {
      "^": "ByteConversionSinkBase;$ti"
    },
    _State0: {
      "^": "Object;$ti"
    }
  }], ["", "package:http_parser/src/chunked_coding/encoder.dart",, E, {
    "^": "",
    ChunkedCodingEncoder: {
      "^": "Converter;$ti",
      $asStreamTransformer: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], [P.List, P.int]];
      },
      $asConverter: function() {
        return [[P.List, P.int], [P.List, P.int]];
      }
    },
    _Sink0: {
      "^": "ByteConversionSinkBase;$ti"
    }
  }], ["", "package:http_parser/src/media_type.dart",, R, {
    "^": "",
    MediaType: {
      "^": "Object;type,subtype,parameters<,$ti",
      get$mimeType: [function() {
        return H.S(this.type) + "/" + H.S(this.subtype);
      }, null, null, 2, 0, null],
      change$5$clearParameters$mimeType$parameters$subtype$type: [function(clearParameters, mimeType, parameters, subtype, type) {
        var t1, segments, t2, parameters0;
        H.stringTypeCheck(type);
        H.stringTypeCheck(subtype);
        H.stringTypeCheck(mimeType);
        t1 = P.String;
        H.assertSubtype(parameters, "$isMap", [t1, t1], "$asMap");
        H.boolTypeCheck(clearParameters);
        if (mimeType != null) {
          if (type != null)
            throw H.wrapException(P.ArgumentError$("You may not pass both [type] and [mimeType]."));
          else if (subtype != null)
            throw H.wrapException(P.ArgumentError$("You may not pass both [subtype] and [mimeType]."));
          segments = H.setRuntimeTypeInfo(mimeType.split("/"), [t1]);
          t2 = segments.length;
          if (t2 !== 2)
            throw H.wrapException(P.FormatException$('Invalid mime type "' + mimeType + '".', null, null));
          if (0 >= t2)
            return H.ioore(segments, 0);
          type = segments[0];
          if (1 >= t2)
            return H.ioore(segments, 1);
          subtype = segments[1];
        }
        if (type == null)
          type = this.type;
        if (subtype == null)
          subtype = this.subtype;
        if (parameters == null)
          parameters = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
        if (!clearParameters) {
          parameters0 = P.LinkedHashMap_LinkedHashMap$from(this.parameters, t1, t1);
          parameters0.addAll$1(0, parameters);
          parameters = parameters0;
        }
        return R.MediaType$(type, subtype, parameters);
      }, function(parameters) {
        return this.change$5$clearParameters$mimeType$parameters$subtype$type(false, null, parameters, null, null);
      }, "change$1$parameters", null, null, "get$change", 0, 11, null, 18, 0, 0, 0, 0, 927, 928, 137, 315, 29],
      toString$0: [function(_) {
        var buffer = P.StringBuffer$("");
        buffer.write$1(this.type);
        buffer.write$1("/");
        buffer.write$1(this.subtype);
        J.forEach$1$ax(this.parameters, new R.MediaType_toString_closure(buffer));
        return buffer.toString$0(0);
      }, null, "get$toString", 1, 0, null],
      static: {
        MediaType_MediaType$parse: [function(mediaType) {
          H.stringTypeCheck(mediaType);
          return B.wrapFormatException("media type", mediaType, new R.MediaType_MediaType$parse_closure(mediaType), R.MediaType);
        }, null, null, 4, 0, null, 926],
        MediaType$: [function(type, subtype, parameters) {
          var t1, t2, t3;
          t1 = J.toLowerCase$0$s(type);
          t2 = J.toLowerCase$0$s(subtype);
          t3 = P.String;
          return new R.MediaType(t1, t2, P.UnmodifiableMapView$(parameters == null ? P.LinkedHashMap_LinkedHashMap$_empty(t3, t3) : Z.CaseInsensitiveMap$from(parameters, t3), t3, t3), []);
        }, null, null, 8, 2, null, 0, 29, 315, 137]
      }
    },
    MediaType_MediaType$parse_closure: {
      "^": "Closure:192;mediaType,$ti",
      call$0: [function() {
        var scanner, t1, t2, type, subtype, t3, parameters, attribute, value;
        scanner = X.StringScanner$(this.mediaType, null, null);
        t1 = $.$get$whitespace();
        scanner.scan$1(t1);
        t2 = $.$get$token();
        scanner.expect$1(t2);
        type = J.$index$asx(scanner.get$lastMatch(), 0);
        scanner.expect$1("/");
        scanner.expect$1(t2);
        subtype = J.$index$asx(scanner.get$lastMatch(), 0);
        scanner.scan$1(t1);
        t3 = P.String;
        parameters = P.LinkedHashMap_LinkedHashMap$_empty(t3, t3);
        for (; scanner.scan$1(";");) {
          scanner.scan$1(t1);
          scanner.expect$1(t2);
          attribute = J.$index$asx(scanner.get$lastMatch(), 0);
          scanner.expect$1("=");
          value = scanner.scan$1(t2) ? J.$index$asx(scanner.get$lastMatch(), 0) : N.expectQuotedString(scanner, null);
          scanner.scan$1(t1);
          parameters.$indexSet(0, attribute, value);
        }
        scanner.expectDone$0();
        return R.MediaType$(type, subtype, parameters);
      }, null, null, 0, 0, null, "call"]
    },
    MediaType_toString_closure: {
      "^": "Closure:20;buffer,$ti",
      call$2: [function(attribute, value) {
        var t1;
        H.stringTypeCheck(attribute);
        H.stringTypeCheck(value);
        t1 = this.buffer;
        t1.write$1("; " + H.S(attribute) + "=");
        if ($.$get$nonToken().hasMatch$1(value)) {
          t1.write$1('"');
          t1.write$1(J.replaceAllMapped$2$s(value, $.$get$_escapedChar(), new R.MediaType_toString__closure()));
          t1.write$1('"');
        } else
          t1.write$1(value);
      }, null, null, 8, 0, null, 929, 1, "call"]
    },
    MediaType_toString__closure: {
      "^": "Closure:38;$ti",
      call$1: [function(match) {
        return C.JSString_methods.$add("\\", H.interceptedTypeCheck(match, "$isMatch").$index(0, 0));
      }, null, null, 4, 0, null, 148, "call"]
    }
  }], ["", "package:http_parser/src/scan.dart",, N, {
    "^": "",
    expectQuotedString: [function(scanner, $name) {
      var string;
      H.interceptedTypeCheck(scanner, "$isStringScanner");
      H.stringTypeCheck($name);
      if ($name == null)
        $name = "quoted string";
      scanner.expect$2$name($.$get$_quotedString(), $name);
      string = J.$index$asx(scanner.get$lastMatch(), 0);
      return J.replaceAllMapped$2$s(J.substring$2$s(string, 1, string.length - 1), $.$get$_quotedPair(), new N.expectQuotedString_closure());
    }, null, null, 4, 3, null, 0, 930, 8],
    expectQuotedString_closure: {
      "^": "Closure:38;$ti",
      call$1: [function(match) {
        return H.interceptedTypeCheck(match, "$isMatch").$index(0, 1);
      }, null, null, 4, 0, null, 148, "call"]
    }
  }], ["", "package:http_parser/src/utils.dart",, B, {
    "^": "",
    wrapFormatException: [1, function($name, value, body, $T) {
      var error, error0, t1, exception, t2;
      H.stringTypeCheck($name);
      H.stringTypeCheck(value);
      H.functionTypeCheck(body, {func: 1, ret: $T});
      try {
        t1 = body.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        t2 = J.getInterceptor$(t1);
        if (!!t2.$isSourceSpanFormatException) {
          error = t1;
          throw H.wrapException(G.SourceSpanFormatException$("Invalid " + H.S($name) + ": " + H.S(J.get$message$x(error)), J.get$span$z(error), J.get$source$z(error)));
        } else if (!!t2.$isFormatException) {
          error0 = t1;
          throw H.wrapException(P.FormatException$("Invalid " + H.S($name) + ' "' + H.S(value) + '": ' + H.S(J.get$message$x(error0)), J.get$source$z(error0), J.get$offset$z(error0)));
        } else
          throw exception;
      }
    }, function($name, value, body) {
      return B.wrapFormatException($name, value, body, null);
    }, null, "call$3", null, 12, 0, null, 8, 1, 201]
  }], ["date_symbols", "package:intl/date_symbols.dart",, B, {
    "^": "",
    DateSymbols: {
      "^": "Object;NAME,ERAS<,ERANAMES<,NARROWMONTHS<,STANDALONENARROWMONTHS<,MONTHS<,STANDALONEMONTHS<,SHORTMONTHS<,STANDALONESHORTMONTHS<,WEEKDAYS<,STANDALONEWEEKDAYS<,SHORTWEEKDAYS<,STANDALONESHORTWEEKDAYS<,NARROWWEEKDAYS,STANDALONENARROWWEEKDAYS<,SHORTQUARTERS<,QUARTERS<,AMPMS<,DATEFORMATS,TIMEFORMATS,DATETIMEFORMATS,AVAILABLEFORMATS,FIRSTDAYOFWEEK,WEEKENDRANGE,FIRSTWEEKCUTOFFDAY,ZERODIGIT<,$ti",
      toString$0: [function(_) {
        return this.NAME;
      }, null, "get$toString", 1, 0, null],
      static: {
        DateSymbols$: [function(AMPMS, AVAILABLEFORMATS, DATEFORMATS, DATETIMEFORMATS, ERANAMES, ERAS, FIRSTDAYOFWEEK, FIRSTWEEKCUTOFFDAY, MONTHS, NAME, NARROWMONTHS, NARROWWEEKDAYS, QUARTERS, SHORTMONTHS, SHORTQUARTERS, SHORTWEEKDAYS, STANDALONEMONTHS, STANDALONENARROWMONTHS, STANDALONENARROWWEEKDAYS, STANDALONESHORTMONTHS, STANDALONESHORTWEEKDAYS, STANDALONEWEEKDAYS, TIMEFORMATS, WEEKDAYS, WEEKENDRANGE, ZERODIGIT) {
          return new B.DateSymbols(NAME, ERAS, ERANAMES, NARROWMONTHS, STANDALONENARROWMONTHS, MONTHS, STANDALONEMONTHS, SHORTMONTHS, STANDALONESHORTMONTHS, WEEKDAYS, STANDALONEWEEKDAYS, SHORTWEEKDAYS, STANDALONESHORTWEEKDAYS, NARROWWEEKDAYS, STANDALONENARROWWEEKDAYS, SHORTQUARTERS, QUARTERS, AMPMS, DATEFORMATS, TIMEFORMATS, DATETIMEFORMATS, AVAILABLEFORMATS, FIRSTDAYOFWEEK, WEEKENDRANGE, FIRSTWEEKCUTOFFDAY, ZERODIGIT, []);
        }, null, null, 0, 53, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 931, 932, 933, 934, 935, 936, 937, 938, 939, 527, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956]
      }
    }
  }], ["intl", "package:intl/intl.dart",, T, {
    "^": "",
    Intl_defaultLocale: [function() {
      var zoneLocale = J.$index$asx(P.Zone_current(), C.Symbol_89P);
      return H.stringTypeCheck(zoneLocale == null ? $.Intl__defaultLocale : zoneLocale);
    }, null, null, 2, 0, null],
    Intl_defaultLocale0: [function(newLocale) {
      $.Intl__defaultLocale = H.stringTypeCheck(newLocale);
    }, null, null, 6, 0, null, 528],
    Intl_verifiedLocale: [function(newLocale, localeExists, onFailure) {
      var t1, t2;
      H.stringTypeCheck(newLocale);
      H.interceptedTypeCheck(localeExists, "$isFunction");
      H.interceptedTypeCheck(onFailure, "$isFunction");
      if (newLocale == null)
        return T.Intl_verifiedLocale(T.Intl_getCurrentLocale(), localeExists, onFailure);
      if (H.boolTypeCheck(localeExists.call$1(newLocale)))
        return newLocale;
      for (t1 = C.JSArray_methods.get$iterator(H.setRuntimeTypeInfo([T.Intl_canonicalizedLocale(newLocale), T.Intl_shortLocale(newLocale), "fallback"], [P.String])); t1.moveNext$0();) {
        t2 = t1.get$current();
        if (H.boolTypeCheck(localeExists.call$1(t2)))
          return t2;
      }
      return H.stringTypeCheck(onFailure.call$1(newLocale));
    }, null, null, 8, 3, null, 958, 528, 959, 960],
    Intl__throwLocaleError: [function(localeName) {
      throw H.wrapException(P.ArgumentError$("Invalid locale '" + H.S(H.stringTypeCheck(localeName)) + "'"));
    }, "call$1", "intl_Intl__throwLocaleError$closure", 4, 0, 7, 333],
    Intl_shortLocale: [function(aLocale) {
      H.stringTypeCheck(aLocale);
      if (aLocale.length < 2)
        return aLocale;
      return J.toLowerCase$0$s(J.substring$2$s(aLocale, 0, 2));
    }, null, null, 4, 0, null, 529],
    Intl_canonicalizedLocale: [function(aLocale) {
      var region;
      H.stringTypeCheck(aLocale);
      if (aLocale == null)
        return T.Intl_getCurrentLocale();
      if (aLocale === "C")
        return "en_ISO";
      if (aLocale.length < 5)
        return aLocale;
      if (!J.$eq$(aLocale[2], "-") && !J.$eq$(aLocale[2], "_"))
        return aLocale;
      region = C.JSString_methods.substring$1(aLocale, 3);
      if (region.length <= 3)
        region = J.toUpperCase$0$s(region);
      return H.S(aLocale[0]) + H.S(aLocale[1]) + "_" + H.S(region);
    }, null, null, 4, 0, null, 529],
    Intl_getCurrentLocale: [function() {
      if (T.Intl_defaultLocale() == null)
        T.Intl_defaultLocale0($.Intl_systemLocale);
      return T.Intl_defaultLocale();
    }, null, null, 0, 0, null],
    _dayOfYear: [function(month, day, leapYear) {
      var t1;
      H.intTypeCheck(month);
      H.intTypeCheck(day);
      H.boolTypeCheck(leapYear);
      if (month === 1)
        return day;
      if (month === 2) {
        if (typeof day !== "number")
          return day.$add();
        return day + 31;
      }
      t1 = J.$add$ansx(T.ordinalDayFromMarchFirst(month, day), 59);
      return J.$add$ansx(t1, leapYear ? 1 : 0);
    }, null, null, 12, 0, null, 238, 237, 965],
    _isLeapYear: [function(date) {
      return J.$eq$(P.DateTime$(H.interceptedTypeCheck(date, "$isDateTime").get$year(), 2, 29, 0, 0, 0, 0, 0).get$month(), 2);
    }, null, null, 4, 0, null, 40],
    ordinalDayFromMarchFirst: [function(month, day) {
      H.intTypeCheck(month);
      H.intTypeCheck(day);
      if (typeof month !== "number")
        return H.iae(month);
      return J.$add$ansx(C.JSDouble_methods.floor$0(30.6 * month - 91.4), day);
    }, null, null, 8, 0, null, 238, 237],
    _iterable: [function(s) {
      return T._StringIterable$(H.stringTypeCheck(s));
    }, null, null, 4, 0, null, 50],
    _iterator: [function(s) {
      return T._StringIterator$(H.stringTypeCheck(s));
    }, null, null, 4, 0, null, 50],
    Intl: {
      "^": "Object;$ti"
    },
    BidiFormatter: {
      "^": "Object;$ti"
    },
    TextDirection0: {
      "^": "Object;$ti"
    },
    Bidi: {
      "^": "Object;$ti"
    },
    _CompactStyleBase: {
      "^": "Object;$ti"
    },
    _CompactStyleWithNegative: {
      "^": "_CompactStyleBase;$ti"
    },
    _CompactStyle: {
      "^": "_CompactStyleBase;$ti"
    },
    _CompactFormatType: {
      "^": "Object;$ti"
    },
    _CompactNumberFormat: {
      "^": "NumberFormat;$ti"
    },
    DateFormat: {
      "^": "Object;0_dateOnly,0_locale,0_intl$_pattern,0_formatFieldsPrivate,0_useNativeDigits,0_digitMatcher,0_localeZeroCodeUnit,0_localeZero,$ti",
      set$_formatFieldsPrivate: function(_formatFieldsPrivate) {
        this._formatFieldsPrivate = H.assertSubtype(_formatFieldsPrivate, "$isList", [T._DateFormatField], "$asList");
      },
      DateFormat$2: [function(newPattern, locale) {
        this._locale = H.stringTypeCheck(T.Intl_verifiedLocale(locale, T.intl_DateFormat_localeExists$closure(), T.intl_Intl__throwLocaleError$closure()));
        this.addPattern$1(newPattern);
      }, null, null, 0, 4, null, 0, 0, 334, 180],
      format$1: [function(date) {
        var result;
        H.interceptedTypeCheck(date, "$isDateTime");
        result = P.StringBuffer$("");
        J.forEach$1$ax(this.get$_formatFields(), new T.DateFormat_format_closure(result, date));
        return result.toString$0(0);
      }, null, "get$format", 4, 0, null, 40],
      get$locale: [function(_) {
        return this._locale;
      }, null, null, 3, 0, null],
      add_yMMMMd$0: [function() {
        return this.addPattern$1("yMMMMd");
      }, null, "get$add_yMMMMd", 0, 0, null],
      add_jms$0: [function() {
        return this.addPattern$1("jms");
      }, null, "get$add_jms", 0, 0, null],
      get$_formatFields: [function() {
        if (this._formatFieldsPrivate == null) {
          if (this._intl$_pattern == null)
            this._useDefaultPattern$0();
          this.set$_formatFieldsPrivate(this.parsePattern$1(this._intl$_pattern));
        }
        return this._formatFieldsPrivate;
      }, null, null, 2, 0, null],
      _useDefaultPattern$0: [function() {
        this.add_yMMMMd$0();
        this.add_jms$0();
      }, null, "get$_useDefaultPattern", 0, 0, null],
      _appendPattern$2: [function(inputPattern, separator) {
        var t1;
        H.stringTypeCheck(inputPattern);
        H.stringTypeCheck(separator);
        t1 = this._intl$_pattern;
        this._intl$_pattern = t1 == null ? inputPattern : H.S(t1) + H.S(separator) + H.S(inputPattern);
      }, null, "get$_appendPattern", 4, 2, null, 247, 531, 90],
      addPattern$2: [function(inputPattern, separator) {
        H.stringTypeCheck(inputPattern);
        H.stringTypeCheck(separator);
        this.set$_formatFieldsPrivate(null);
        if (inputPattern == null)
          return this;
        if (!this.get$_availableSkeletons().containsKey$1(inputPattern))
          this._appendPattern$2(inputPattern, separator);
        else
          this._appendPattern$2(H.stringTypeCheck(J.$index$asx(this.get$_availableSkeletons(), inputPattern)), separator);
        return this;
      }, function(inputPattern) {
        return this.addPattern$2(inputPattern, " ");
      }, "addPattern$1", null, null, "get$addPattern", 4, 2, null, 247, 531, 90],
      get$_availableSkeletons: [function() {
        return H.interceptedTypeCheck(J.$index$asx($.$get$dateTimePatterns(), this.get$locale(this)), "$isMap");
      }, null, null, 2, 0, null],
      get$dateSymbols: [function() {
        if (!J.$eq$(this._locale, $.lastDateSymbolLocale)) {
          $.lastDateSymbolLocale = this._locale;
          $.cachedDateSymbols = H.interceptedTypeCheck(J.$index$asx(A.dateTimeSymbols(), this._locale), "$isDateSymbols");
        }
        return $.cachedDateSymbols;
      }, null, null, 2, 0, null],
      get$useNativeDigits: [function() {
        var t1 = this._useNativeDigits;
        if (t1 == null) {
          t1 = H.boolTypeCheck(T.DateFormat_shouldUseNativeDigitsByDefaultFor(this.get$locale(this)));
          this._useNativeDigits = t1;
        }
        return H.boolTypeCheck(t1);
      }, null, null, 2, 0, null],
      get$localeZeroCodeUnit: [function() {
        var t1 = this._localeZeroCodeUnit;
        if (t1 == null) {
          t1 = H.intTypeCheck(J.codeUnitAt$1$s(this.get$localeZero(), 0));
          this._localeZeroCodeUnit = t1;
        }
        return t1;
      }, null, null, 2, 0, null],
      get$localeZero: [function() {
        var t1 = this._localeZero;
        if (t1 == null) {
          if (this.get$useNativeDigits()) {
            t1 = this.get$dateSymbols().get$ZERODIGIT();
            if (t1 == null)
              t1 = "0";
          } else
            t1 = "0";
          H.stringTypeCheck(t1);
          this._localeZero = t1;
        }
        return t1;
      }, null, null, 2, 0, null],
      get$usesNativeDigits: [function() {
        return this.get$useNativeDigits() && !J.$eq$(this._localeZeroCodeUnit, $.$get$DateFormat__asciiZeroCodeUnit());
      }, null, null, 2, 0, null],
      get$usesAsciiDigits: [function() {
        return !this.get$usesNativeDigits();
      }, null, null, 2, 0, null],
      _localizeDigits$1: [function(numberString) {
        var t1, t2, newDigits, oldDigits, i;
        H.stringTypeCheck(numberString);
        if (this.get$usesAsciiDigits())
          return numberString;
        t1 = numberString.length;
        t2 = new Array(t1);
        t2.fixed$length = Array;
        newDigits = H.setRuntimeTypeInfo(t2, [P.int]);
        oldDigits = J.get$codeUnits$s(numberString);
        for (t2 = J.getInterceptor$asx(oldDigits), i = 0; i < t1; ++i)
          C.JSArray_methods.$indexSet(newDigits, i, J.$sub$n(J.$add$ansx(t2.$index(oldDigits, i), this.get$localeZeroCodeUnit()), $.$get$DateFormat__asciiZeroCodeUnit()));
        return P.String_String$fromCharCodes(newDigits, 0, null);
      }, null, "get$_localizeDigits", 4, 0, null, 970],
      parsePattern$1: [function(pattern) {
        H.stringTypeCheck(pattern);
        if (pattern == null)
          return;
        return J.toList$0$ax(J.get$reversed$ax(this._parsePatternHelper$1(pattern)));
      }, null, "get$parsePattern", 4, 0, null, 36],
      _parsePatternHelper$1: [function(pattern) {
        var matched, parsed;
        H.stringTypeCheck(pattern);
        if (J.getInterceptor$asx(pattern).get$isEmpty(pattern))
          return H.setRuntimeTypeInfo([], [T._DateFormatField]);
        matched = this._intl$_match$1(pattern);
        if (matched == null)
          return H.setRuntimeTypeInfo([], [T._DateFormatField]);
        parsed = this._parsePatternHelper$1(C.JSString_methods.substring$1(pattern, J.get$length$asx(matched.fullPattern$0())));
        J.add$1$ax(parsed, matched);
        return parsed;
      }, null, "get$_parsePatternHelper", 4, 0, null, 36],
      _intl$_match$1: [function(pattern) {
        var i, t1, match;
        H.stringTypeCheck(pattern);
        i = 0;
        while (true) {
          t1 = J.get$length$asx($.$get$DateFormat__matchers());
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          match = J.$index$asx($.$get$DateFormat__matchers(), i).firstMatch$1(pattern);
          if (match != null)
            return H.interceptedTypeCheck(J.$index$asx(T.DateFormat__fieldConstructors(), i).call$2(match.group$1(0), this), "$is_DateFormatField");
          ++i;
        }
        return;
      }, null, "get$_intl$_match", 4, 0, null, 36],
      static: {
        DateFormat$: [function(newPattern, locale) {
          var t1 = new T.DateFormat([]);
          t1.DateFormat$2(newPattern, locale);
          return t1;
        }, null, null, 0, 4, null, 0, 0, 334, 180],
        DateFormat_shouldUseNativeDigitsByDefaultFor: [function(locale) {
          var t1;
          H.stringTypeCheck(locale);
          t1 = J.$index$asx($.$get$DateFormat__useNativeDigitsByDefault(), locale);
          return t1 == null ? true : t1;
        }, null, null, 4, 0, null, 180],
        DateFormat_localeExists: [function(localeName) {
          if (localeName == null)
            return false;
          return H.boolTypeCheck(A.dateTimeSymbols().containsKey$1(localeName));
        }, "call$1", "intl_DateFormat_localeExists$closure", 4, 0, 17, 333],
        DateFormat__fieldConstructors: [function() {
          return [new T.DateFormat__fieldConstructors_closure(), new T.DateFormat__fieldConstructors_closure0(), new T.DateFormat__fieldConstructors_closure1()];
        }, null, null, 2, 0, null]
      }
    },
    DateFormat_format_closure: {
      "^": "Closure:194;result,date,$ti",
      call$1: [function(field) {
        return this.result.write$1(H.interceptedTypeCheck(field, "$is_DateFormatField").format$1(this.date));
      }, null, null, 4, 0, null, 424, "call"]
    },
    DateFormat__fieldConstructors_closure: {
      "^": "Closure:195;$ti",
      call$2: [function(pattern, $parent) {
        return T._DateFormatQuotedField$(pattern, $parent);
      }, null, null, 8, 0, null, 36, 24, "call"]
    },
    DateFormat__fieldConstructors_closure0: {
      "^": "Closure:196;$ti",
      call$2: [function(pattern, $parent) {
        return T._DateFormatPatternField$(pattern, $parent);
      }, null, null, 8, 0, null, 36, 24, "call"]
    },
    DateFormat__fieldConstructors_closure1: {
      "^": "Closure:197;$ti",
      call$2: [function(pattern, $parent) {
        return T._DateFormatLiteralField$(pattern, $parent);
      }, null, null, 8, 0, null, 36, 24, "call"]
    },
    _DateFormatField: {
      "^": "Object;pattern>,parent>,$ti",
      _DateFormatField$2: [function(pattern, $parent) {
        this._trimmedPattern = H.stringTypeCheck(J.trim$0$s(this.pattern));
      }, null, null, 8, 0, null, 36, 24],
      get$width: [function(_) {
        return J.get$length$asx(this.pattern);
      }, null, null, 3, 0, null],
      fullPattern$0: [function() {
        return this.pattern;
      }, null, "get$fullPattern", 0, 0, null],
      toString$0: [function(_) {
        return this.pattern;
      }, null, "get$toString", 1, 0, null],
      format$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.pattern;
      }, null, "get$format", 4, 0, null, 40]
    },
    _DateFormatLiteralField: {
      "^": "_DateFormatField;pattern,parent,0_trimmedPattern,$ti",
      static: {
        _DateFormatLiteralField$: [function(pattern, $parent) {
          var t1;
          H.stringTypeCheck(pattern);
          H.interceptedTypeCheck($parent, "$isDateFormat");
          t1 = new T._DateFormatLiteralField(pattern, $parent, []);
          t1._DateFormatField$2(pattern, $parent);
          return t1;
        }, null, null, 8, 0, null, 36, 24]
      }
    },
    _DateFormatQuotedField: {
      "^": "_DateFormatField;0_fullPattern,pattern,parent,0_trimmedPattern,$ti",
      fullPattern$0: [function() {
        return this._fullPattern;
      }, null, "get$fullPattern", 0, 0, null],
      _DateFormatQuotedField$2: [function(pattern, $parent) {
        this._fullPattern = H.stringTypeCheck(pattern);
      }, null, null, 8, 0, null, 36, 24],
      static: {
        _DateFormatQuotedField$: [function(pattern, $parent) {
          var t1, t2;
          H.stringTypeCheck(pattern);
          t1 = T._DateFormatQuotedField__patchQuotes(pattern);
          H.interceptedTypeCheck($parent, "$isDateFormat");
          t2 = new T._DateFormatQuotedField(t1, $parent, []);
          t2._DateFormatField$2(t1, $parent);
          t2._DateFormatQuotedField$2(pattern, $parent);
          return t2;
        }, null, null, 8, 0, null, 36, 24],
        _DateFormatQuotedField__patchQuotes: [function(pattern) {
          H.stringTypeCheck(pattern);
          if (pattern === "''")
            return "'";
          else
            return J.replaceAll$2$s(J.substring$2$s(pattern, 1, pattern.length - 1), $.$get$_DateFormatQuotedField__twoEscapedQuotes(), "'");
        }, null, null, 4, 0, null, 36]
      }
    },
    _LoosePatternField: {
      "^": "_DateFormatPatternField;$ti"
    },
    _DateFormatPatternField: {
      "^": "_DateFormatField;0_forDate,pattern,parent,0_trimmedPattern,$ti",
      format$1: [function(date) {
        return this.formatField$1(H.interceptedTypeCheck(date, "$isDateTime"));
      }, null, "get$format", 4, 0, null, 40],
      formatField$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        switch (J.$index$asx(this.pattern, 0)) {
          case "a":
            return this.formatAmPm$1(date);
          case "c":
            return this.formatStandaloneDay$1(date);
          case "d":
            return this.formatDayOfMonth$1(date);
          case "D":
            return this.formatDayOfYear$1(date);
          case "E":
            return this.formatDayOfWeek$1(date);
          case "G":
            return H.stringTypeCheck(this.formatEra$1(date));
          case "h":
            return this.format1To12Hours$1(date);
          case "H":
            return this.format0To23Hours$1(date);
          case "K":
            return this.format0To11Hours$1(date);
          case "k":
            return this.format24Hours$1(date);
          case "L":
            return this.formatStandaloneMonth$1(date);
          case "M":
            return this.formatMonth$1(date);
          case "m":
            return this.formatMinutes$1(date);
          case "Q":
            return this.formatQuarter$1(date);
          case "S":
            return this.formatFractionalSeconds$1(date);
          case "s":
            return this.formatSeconds$1(date);
          case "v":
            return this.formatTimeZoneId$1(date);
          case "y":
            return H.stringTypeCheck(this.formatYear$1(date));
          case "z":
            return this.formatTimeZone$1(date);
          case "Z":
            return this.formatTimeZoneRFC$1(date);
          default:
            return "";
        }
      }, null, "get$formatField", 4, 0, null, 40],
      get$symbols: [function() {
        return this.parent.get$dateSymbols();
      }, null, null, 2, 0, null],
      formatEra$1: [function(date) {
        var era = J.$gt$n(H.interceptedTypeCheck(date, "$isDateTime").get$year(), 0) ? 1 : 0;
        return J.$ge$n(this.get$width(this), 4) ? J.$index$asx(this.get$symbols().get$ERANAMES(), era) : J.$index$asx(this.get$symbols().get$ERAS(), era);
      }, null, "get$formatEra", 4, 0, null, 40],
      formatYear$1: [function(date) {
        var year = H.interceptedTypeCheck(date, "$isDateTime").get$year();
        if (typeof year !== "number")
          return year.$lt();
        if (year < 0)
          year = -year;
        return J.$eq$(this.get$width(this), 2) ? this.padTo$2(2, C.JSInt_methods.$mod(year, 100)) : this.padTo$2(this.get$width(this), year);
      }, null, "get$formatYear", 4, 0, null, 40],
      formatMonth$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        switch (this.get$width(this)) {
          case 5:
            return J.$index$asx(this.get$symbols().get$NARROWMONTHS(), J.$sub$n(date.get$month(), 1));
          case 4:
            return J.$index$asx(this.get$symbols().get$MONTHS(), J.$sub$n(date.get$month(), 1));
          case 3:
            return J.$index$asx(this.get$symbols().get$SHORTMONTHS(), J.$sub$n(date.get$month(), 1));
          default:
            return this.padTo$2(this.get$width(this), date.get$month());
        }
      }, null, "get$formatMonth", 4, 0, null, 40],
      format24Hours$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.padTo$2(this.get$width(this), date.get$hour());
      }, null, "get$format24Hours", 4, 0, null, 40],
      formatFractionalSeconds$1: [function(date) {
        var basic = this.padTo$2(3, H.interceptedTypeCheck(date, "$isDateTime").get$millisecond());
        if (J.$gt$n(J.$sub$n(this.get$width(this), 3), 0))
          return J.$add$ansx(basic, this.padTo$2(J.$sub$n(this.get$width(this), 3), 0));
        else
          return basic;
      }, null, "get$formatFractionalSeconds", 4, 0, null, 40],
      formatAmPm$1: [function(date) {
        var hours, index;
        hours = H.interceptedTypeCheck(date, "$isDateTime").get$hour();
        if (typeof hours !== "number")
          return hours.$ge();
        index = hours >= 12 && hours < 24 ? 1 : 0;
        return J.$index$asx(this.get$symbols().get$AMPMS(), index);
      }, null, "get$formatAmPm", 4, 0, null, 40],
      format1To12Hours$1: [function(date) {
        var hours;
        H.interceptedTypeCheck(date, "$isDateTime");
        hours = date.get$hour();
        if (J.$gt$n(date.get$hour(), 12)) {
          if (typeof hours !== "number")
            return hours.$sub();
          hours -= 12;
        }
        if (hours === 0)
          hours = 12;
        return this.padTo$2(this.get$width(this), hours);
      }, null, "get$format1To12Hours", 4, 0, null, 40],
      format0To11Hours$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.padTo$2(this.get$width(this), J.$mod$n(date.get$hour(), 12));
      }, null, "get$format0To11Hours", 4, 0, null, 40],
      format0To23Hours$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.padTo$2(this.get$width(this), date.get$hour());
      }, null, "get$format0To23Hours", 4, 0, null, 40],
      formatStandaloneDay$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        switch (this.get$width(this)) {
          case 5:
            return J.$index$asx(this.get$symbols().get$STANDALONENARROWWEEKDAYS(), J.$mod$n(date.get$weekday(), 7));
          case 4:
            return J.$index$asx(this.get$symbols().get$STANDALONEWEEKDAYS(), J.$mod$n(date.get$weekday(), 7));
          case 3:
            return J.$index$asx(this.get$symbols().get$STANDALONESHORTWEEKDAYS(), J.$mod$n(date.get$weekday(), 7));
          default:
            return this.padTo$2(1, date.get$day());
        }
      }, null, "get$formatStandaloneDay", 4, 0, null, 40],
      formatStandaloneMonth$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        switch (this.get$width(this)) {
          case 5:
            return J.$index$asx(this.get$symbols().get$STANDALONENARROWMONTHS(), J.$sub$n(date.get$month(), 1));
          case 4:
            return J.$index$asx(this.get$symbols().get$STANDALONEMONTHS(), J.$sub$n(date.get$month(), 1));
          case 3:
            return J.$index$asx(this.get$symbols().get$STANDALONESHORTMONTHS(), J.$sub$n(date.get$month(), 1));
          default:
            return this.padTo$2(this.get$width(this), date.get$month());
        }
      }, null, "get$formatStandaloneMonth", 4, 0, null, 40],
      formatQuarter$1: [function(date) {
        var quarter, t1;
        quarter = J.truncate$0$n(J.$div$n(J.$sub$n(H.interceptedTypeCheck(date, "$isDateTime").get$month(), 1), 3));
        switch (this.get$width(this)) {
          case 4:
            return J.$index$asx(this.get$symbols().get$QUARTERS(), quarter);
          case 3:
            return J.$index$asx(this.get$symbols().get$SHORTQUARTERS(), quarter);
          default:
            t1 = this.get$width(this);
            if (typeof quarter !== "number")
              return quarter.$add();
            return this.padTo$2(t1, quarter + 1);
        }
      }, null, "get$formatQuarter", 4, 0, null, 40],
      formatDayOfMonth$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.padTo$2(this.get$width(this), date.get$day());
      }, null, "get$formatDayOfMonth", 4, 0, null, 40],
      formatDayOfYear$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.padTo$2(this.get$width(this), T._dayOfYear(date.get$month(), date.get$day(), T._isLeapYear(date)));
      }, null, "get$formatDayOfYear", 4, 0, null, 40],
      formatDayOfWeek$1: [function(date) {
        var t1;
        H.interceptedTypeCheck(date, "$isDateTime");
        t1 = J.$ge$n(this.get$width(this), 4) ? this.get$symbols().get$WEEKDAYS() : this.get$symbols().get$SHORTWEEKDAYS();
        return J.$index$asx(t1, J.$mod$n(date.get$weekday(), 7));
      }, null, "get$formatDayOfWeek", 4, 0, null, 40],
      formatMinutes$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.padTo$2(this.get$width(this), date.get$minute());
      }, null, "get$formatMinutes", 4, 0, null, 40],
      formatSeconds$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        return this.padTo$2(this.get$width(this), date.get$second());
      }, null, "get$formatSeconds", 4, 0, null, 40],
      formatTimeZoneId$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        throw H.wrapException(P.UnimplementedError$(null));
      }, null, "get$formatTimeZoneId", 4, 0, null, 40],
      formatTimeZone$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        throw H.wrapException(P.UnimplementedError$(null));
      }, null, "get$formatTimeZone", 4, 0, null, 40],
      formatTimeZoneRFC$1: [function(date) {
        H.interceptedTypeCheck(date, "$isDateTime");
        throw H.wrapException(P.UnimplementedError$(null));
      }, null, "get$formatTimeZoneRFC", 4, 0, null, 40],
      padTo$2: [function(width, toBePrinted) {
        H.intTypeCheck(width);
        return this.parent._localizeDigits$1(C.JSString_methods.padLeft$2(H.S(toBePrinted), width, "0"));
      }, null, "get$padTo", 8, 0, null, 56, 971],
      static: {
        _DateFormatPatternField$: [function(pattern, $parent) {
          var t1;
          H.stringTypeCheck(pattern);
          H.interceptedTypeCheck($parent, "$isDateFormat");
          t1 = new T._DateFormatPatternField(pattern, $parent, []);
          t1._DateFormatField$2(pattern, $parent);
          return t1;
        }, null, null, 8, 0, null, 36, 24]
      }
    },
    _DateBuilder: {
      "^": "Object;$ti"
    },
    _Stream: {
      "^": "Object;$ti"
    },
    NumberFormat: {
      "^": "Object;_negativePrefix<,_positivePrefix<,_negativeSuffix<,_positiveSuffix<,_groupingSize,_finalGroupingSize<,_groupingSizeSetExplicitly<,_decimalSeparatorAlwaysShown,_useSignForPositiveExponent,_useExponentialNotation<,_isForCurrency,maximumIntegerDigits,minimumIntegerDigits<,maximumFractionDigits<,minimumFractionDigits<,minimumExponentDigits<,_significantDigits,significantDigitsInUse,_internalMultiplier,_multiplierDigits,0_intl$_pattern,_locale,0_symbols,0currencyName,0_currencySymbol,0_decimalDigits,_intl$_buffer,_localeZero,_zeroOffset,$ti",
      set$_negativePrefix: function(_negativePrefix) {
        this._negativePrefix = H.stringTypeCheck(_negativePrefix);
      },
      set$_positivePrefix: function(_positivePrefix) {
        this._positivePrefix = H.stringTypeCheck(_positivePrefix);
      },
      set$_negativeSuffix: function(_negativeSuffix) {
        this._negativeSuffix = H.stringTypeCheck(_negativeSuffix);
      },
      set$_positiveSuffix: function(_positiveSuffix) {
        this._positiveSuffix = H.stringTypeCheck(_positiveSuffix);
      },
      set$_groupingSize: function(_groupingSize) {
        this._groupingSize = H.intTypeCheck(_groupingSize);
      },
      set$_finalGroupingSize: function(_finalGroupingSize) {
        this._finalGroupingSize = H.intTypeCheck(_finalGroupingSize);
      },
      set$_groupingSizeSetExplicitly: function(_groupingSizeSetExplicitly) {
        this._groupingSizeSetExplicitly = H.boolTypeCheck(_groupingSizeSetExplicitly);
      },
      set$_decimalSeparatorAlwaysShown: function(_decimalSeparatorAlwaysShown) {
        this._decimalSeparatorAlwaysShown = H.boolTypeCheck(_decimalSeparatorAlwaysShown);
      },
      set$_useSignForPositiveExponent: function(_useSignForPositiveExponent) {
        this._useSignForPositiveExponent = H.boolTypeCheck(_useSignForPositiveExponent);
      },
      set$_useExponentialNotation: function(_useExponentialNotation) {
        this._useExponentialNotation = H.boolTypeCheck(_useExponentialNotation);
      },
      set$maximumIntegerDigits: function(maximumIntegerDigits) {
        this.maximumIntegerDigits = H.intTypeCheck(maximumIntegerDigits);
      },
      set$minimumIntegerDigits: function(minimumIntegerDigits) {
        this.minimumIntegerDigits = H.intTypeCheck(minimumIntegerDigits);
      },
      set$maximumFractionDigits: function(maximumFractionDigits) {
        this.maximumFractionDigits = H.intTypeCheck(maximumFractionDigits);
      },
      set$minimumFractionDigits: function(minimumFractionDigits) {
        this.minimumFractionDigits = H.intTypeCheck(minimumFractionDigits);
      },
      set$minimumExponentDigits: function(minimumExponentDigits) {
        this.minimumExponentDigits = H.intTypeCheck(minimumExponentDigits);
      },
      get$significantDigits: [function() {
        return this._significantDigits;
      }, null, null, 2, 0, null],
      get$_multiplier: [function() {
        return this._internalMultiplier;
      }, null, null, 2, 0, null],
      set$_multiplier: [function(x) {
        this._internalMultiplier = H.intTypeCheck(x);
        this._multiplierDigits = H.intTypeCheck(J.round$0$n(J.$div$n(P.log(this.get$_multiplier()), $.$get$NumberFormat__ln10())));
      }, null, null, 6, 0, null, 37],
      get$currencySymbol: [function() {
        var t1 = this._currencySymbol;
        return t1 == null ? this.currencyName : t1;
      }, null, null, 2, 0, null],
      get$decimalDigits: [function() {
        return this._decimalDigits;
      }, null, null, 2, 0, null],
      get$_defaultDecimalDigits: [function() {
        var t1, t2;
        t1 = $.$get$currencyFractionDigits();
        t2 = J.$index$asx(t1, J.toUpperCase$0$s(this.currencyName));
        return t2 == null ? J.$index$asx(t1, "DEFAULT") : t2;
      }, null, null, 2, 0, null],
      get$_overridesDecimalDigits: [function() {
        return this.get$decimalDigits() != null || this._isForCurrency;
      }, null, null, 2, 0, null],
      NumberFormat$_forPattern$7$computeCurrencySymbol$currencySymbol$decimalDigits$isForCurrency$name: [function(locale, getPattern, computeCurrencySymbol, currencySymbol, decimalDigits, isForCurrency, $name) {
        var t1;
        this._currencySymbol = currencySymbol;
        this._decimalDigits = decimalDigits;
        t1 = H.interceptedTypeCheck(J.$index$asx($.$get$numberFormatSymbols(), this._locale), "$isNumberSymbols");
        this._symbols = t1;
        t1 = H.intTypeCheck(J.codeUnitAt$1$s(t1.ZERO_DIGIT, 0));
        this._localeZero = t1;
        if (typeof t1 !== "number")
          return t1.$sub();
        this._zeroOffset = t1 - 48;
        this._negativePrefix = H.stringTypeCheck(this._symbols.get$MINUS_SIGN());
        this.currencyName = H.stringTypeCheck($name == null ? this._symbols.get$DEF_CURRENCY_CODE() : $name);
        if (this._currencySymbol == null && computeCurrencySymbol != null)
          this._currencySymbol = H.stringTypeCheck(computeCurrencySymbol.call$1(this));
        this._setPattern$1(getPattern.call$1(this._symbols));
      }, null, null, 8, 11, null, 0, 0, 0, 18, 0, 180, 972, 973, 336, 337, 974, 8],
      get$symbols: [function() {
        return this._symbols;
      }, null, null, 2, 0, null],
      format$1: [function(number) {
        var t1, t2, result;
        if (H.boolTypeCheck(this._isNaN$1(number)))
          return this.get$symbols().get$NAN();
        if (H.boolTypeCheck(this._isInfinite$1(number)))
          return H.S(this._signPrefix$1(number)) + H.S(this.get$symbols().get$INFINITY());
        this._intl$_add$1(this._signPrefix$1(number));
        this._formatNumber$1(J.abs$0$in(number));
        this._intl$_add$1(this._signSuffix$1(number));
        t1 = this._intl$_buffer;
        t2 = J.getInterceptor$(t1);
        result = t2.toString$0(t1);
        t2.clear$0(t1);
        return result;
      }, null, "get$format", 4, 0, null, 84],
      _formatNumber$1: [function(number) {
        if (this._useExponentialNotation)
          this._formatExponential$1(H.numTypeCheck(number));
        else
          this._formatFixed$1(number);
      }, null, "get$_formatNumber", 4, 0, null, 84],
      _formatExponential$1: [function(number) {
        var exponent, t1, mantissa;
        H.numTypeCheck(number);
        if (number === 0) {
          this._formatFixed$1(number);
          this._formatExponent$1(0);
          return;
        }
        exponent = J.floor$0$n(J.$div$n(P.log(number), $.$get$NumberFormat__ln10()));
        t1 = P.pow(10, exponent);
        if (typeof number !== "number")
          return number.$div();
        if (typeof t1 !== "number")
          return H.iae(t1);
        mantissa = number / t1;
        if (J.$gt$n(this.maximumIntegerDigits, 1) && J.$gt$n(this.maximumIntegerDigits, this.minimumIntegerDigits)) {
          t1 = this.maximumIntegerDigits;
          while (true) {
            if (typeof exponent !== "number")
              return exponent.$mod();
            if (typeof t1 !== "number")
              return H.iae(t1);
            if (!(C.JSInt_methods.$mod(exponent, t1) !== 0))
              break;
            mantissa *= 10;
            --exponent;
          }
        } else if (J.$lt$n(this.minimumIntegerDigits, 1)) {
          if (typeof exponent !== "number")
            return exponent.$add();
          ++exponent;
          mantissa /= 10;
        } else {
          t1 = J.$sub$n(this.minimumIntegerDigits, 1);
          if (typeof exponent !== "number")
            return exponent.$sub();
          if (typeof t1 !== "number")
            return H.iae(t1);
          exponent -= t1;
          t1 = P.pow(10, J.$sub$n(this.minimumIntegerDigits, 1));
          if (typeof t1 !== "number")
            return H.iae(t1);
          mantissa *= t1;
        }
        this._formatFixed$1(mantissa);
        this._formatExponent$1(exponent);
      }, null, "get$_formatExponential", 4, 0, null, 84],
      _formatExponent$1: [function(exponent) {
        H.numTypeCheck(exponent);
        this._intl$_add$1(this.get$symbols().get$EXP_SYMBOL());
        if (typeof exponent !== "number")
          return exponent.$lt();
        if (exponent < 0) {
          exponent = -exponent;
          this._intl$_add$1(this.get$symbols().get$MINUS_SIGN());
        } else if (this._useSignForPositiveExponent)
          this._intl$_add$1(this.get$symbols().get$PLUS_SIGN());
        this._pad$2(this.minimumExponentDigits, C.JSNumber_methods.toString$0(exponent));
      }, null, "get$_formatExponent", 4, 0, null, 404],
      _isInfinite$1: [function(number) {
        return typeof number === "number" && C.JSNumber_methods.get$isInfinite(number);
      }, null, "get$_isInfinite", 4, 0, null, 84],
      _isNaN$1: [function(number) {
        return typeof number === "number" && C.JSNumber_methods.get$isNaN(number);
      }, null, "get$_isNaN", 4, 0, null, 84],
      _floor$1: [function(number) {
        var t1 = J.getInterceptor$in(number);
        if (H.boolTypeCheck(t1.get$isNegative(number)) && !H.boolTypeCheck(J.get$isNegative$n(t1.abs$0(number))))
          throw H.wrapException(P.ArgumentError$("Internal error: expected positive number, got " + H.S(number)));
        return typeof number === "number" ? t1.floor$0(number) : t1.$tdiv(number, 1);
      }, null, "get$_floor", 4, 0, null, 84],
      _round$1: [function(number) {
        var t1, fraction;
        if (typeof number === "number")
          if (C.JSNumber_methods.get$isInfinite(number))
            return $.$get$NumberFormat__maxInt();
          else
            return C.JSNumber_methods.round$0(number);
        else {
          t1 = J.getInterceptor$n(number);
          if (J.$eq$(t1.remainder$1(number, 1), 0))
            return number;
          else {
            fraction = J.round$0$n(J.toDouble$0$n(t1.$sub(number, this._floor$1(number))));
            return J.$eq$(fraction, 0) ? number : t1.$add(number, fraction);
          }
        }
      }, null, "get$_round", 4, 0, null, 84],
      _fractionDigitsAfter$1: [function(remainingSignificantDigits) {
        return P.max(0, H.intTypeCheck(remainingSignificantDigits), P.int);
      }, null, "get$_fractionDigitsAfter", 4, 0, null, 975],
      _formatFixed$1: [function(number) {
        var fractionDigits, t1, integerPart, fractionPart, extraIntegerDigits, power, fraction, integerLength, remainingSignificantDigits, divideBy, digitMultiplier, remainingDigits, integerDigits, digitLength, fractionPresent, i;
        fractionDigits = this.maximumFractionDigits;
        t1 = J.getInterceptor$n(number);
        if (H.boolTypeCheck(this._isInfinite$1(number))) {
          integerPart = t1.toInt$0(number);
          fractionPart = 0;
          extraIntegerDigits = 0;
          power = 0;
        } else {
          integerPart = this._floor$1(number);
          fraction = t1.$sub(number, integerPart);
          if (!J.$eq$(J.toInt$0$n(fraction), 0)) {
            integerPart = number;
            fraction = 0;
          }
          if (this.significantDigitsInUse) {
            integerLength = T.NumberFormat_numberOfIntegerDigits(integerPart);
            remainingSignificantDigits = J.$sub$n(J.$sub$n(this.get$significantDigits(), this._multiplierDigits), integerLength);
            fractionDigits = this._fractionDigitsAfter$1(remainingSignificantDigits);
            if (typeof remainingSignificantDigits !== "number")
              return remainingSignificantDigits.$lt();
            if (remainingSignificantDigits < 0) {
              t1 = this.get$significantDigits();
              if (typeof integerLength !== "number")
                return integerLength.$sub();
              if (typeof t1 !== "number")
                return H.iae(t1);
              divideBy = P.pow(10, integerLength - t1);
              integerPart = J.$mul$ns(J.round$0$n(J.$div$n(integerPart, divideBy)), divideBy);
            }
          }
          power = H.intTypeCheck(P.pow(10, fractionDigits));
          t1 = this.get$_multiplier();
          if (typeof power !== "number")
            return power.$mul();
          if (typeof t1 !== "number")
            return H.iae(t1);
          digitMultiplier = power * t1;
          remainingDigits = J.toInt$0$n(this._round$1(J.$mul$ns(fraction, digitMultiplier)));
          t1 = J.getInterceptor$n(remainingDigits);
          if (H.boolTypeCheck(t1.$ge(remainingDigits, digitMultiplier))) {
            integerPart = J.$add$ansx(integerPart, 1);
            remainingDigits = t1.$sub(remainingDigits, digitMultiplier);
          }
          t1 = J.getInterceptor$n(remainingDigits);
          extraIntegerDigits = H.intTypeCheck(t1.$tdiv(remainingDigits, power));
          fractionPart = H.intTypeCheck(t1.$mod(remainingDigits, power));
        }
        integerDigits = this._integerDigits$2(integerPart, extraIntegerDigits);
        digitLength = integerDigits.length;
        if (typeof fractionDigits !== "number")
          return fractionDigits.$gt();
        if (fractionDigits > 0)
          if (!J.$gt$n(this.minimumFractionDigits, 0)) {
            if (typeof fractionPart !== "number")
              return fractionPart.$gt();
            t1 = fractionPart > 0;
            fractionPresent = t1;
          } else
            fractionPresent = true;
        else
          fractionPresent = false;
        if (this._hasIntegerDigits$1(integerDigits)) {
          integerDigits = H.S(C.JSString_methods.$mul("0", J.$sub$n(this.minimumIntegerDigits, digitLength))) + H.S(integerDigits);
          digitLength = integerDigits.length;
          for (i = 0; i < digitLength; ++i) {
            this._addDigit$1(C.JSString_methods._codeUnitAt$1(integerDigits, i));
            this._group$2(digitLength, i);
          }
        } else if (!fractionPresent)
          this._addZero$0();
        this._decimalSeparator$1(fractionPresent);
        if (typeof fractionPart !== "number")
          return fractionPart.$add();
        this._formatFractionPart$1(C.JSInt_methods.toString$0(fractionPart + power));
      }, null, "get$_formatFixed", 4, 0, null, 84],
      _integerDigits$2: [function(integerPart, extraIntegerDigits) {
        var t1, howManyDigitsTooBig, divisor, paddingDigits, extra, intDigits;
        if (typeof integerPart === "number") {
          t1 = $.$get$NumberFormat__maxInt();
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = integerPart > t1;
        } else
          t1 = false;
        if (t1) {
          H.numTypeCheck(integerPart);
          howManyDigitsTooBig = J.$sub$n(J.ceil$0$n(J.$div$n(P.log(integerPart), $.$get$NumberFormat__ln10())), $.$get$NumberFormat__maxDigits());
          divisor = J.round$0$n(P.pow(10, howManyDigitsTooBig));
          if (divisor === 0)
            divisor = P.pow(10, howManyDigitsTooBig);
          paddingDigits = C.JSString_methods.$mul("0", J.toInt$0$n(howManyDigitsTooBig));
          if (typeof integerPart !== "number")
            return integerPart.$div();
          if (typeof divisor !== "number")
            return H.iae(divisor);
          integerPart = C.JSDouble_methods.truncate$0(integerPart / divisor);
        } else
          paddingDigits = "";
        t1 = J.getInterceptor$(extraIntegerDigits);
        extra = t1.$eq(extraIntegerDigits, 0) ? "" : t1.toString$0(extraIntegerDigits);
        intDigits = this._mainIntegerDigits$1(integerPart);
        return intDigits + H.S(J.get$isEmpty$asx(intDigits) ? extra : J.padLeft$2$s(extra, this._multiplierDigits, "0")) + H.S(paddingDigits);
      }, null, "get$_integerDigits", 8, 0, null, 976, 977],
      _mainIntegerDigits$1: [function(integer) {
        var t1, digits, t2, t3;
        t1 = J.getInterceptor$(integer);
        if (t1.$eq(integer, 0))
          return "";
        digits = t1.toString$0(integer);
        if (this.significantDigitsInUse) {
          t1 = digits.length;
          t2 = this.get$significantDigits();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 > t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1) {
          t1 = J.substring$2$s(digits, 0, this.get$significantDigits());
          t2 = digits.length;
          t3 = this.get$significantDigits();
          if (typeof t3 !== "number")
            return H.iae(t3);
          digits = J.$add$ansx(t1, C.JSString_methods.padLeft$2("", t2 - t3, "0"));
        }
        return J.getInterceptor$s(digits).startsWith$1(digits, "-") ? C.JSString_methods.substring$1(digits, 1) : digits;
      }, null, "get$_mainIntegerDigits", 4, 0, null, 978],
      _formatFractionPart$1: [function(fractionPart) {
        var fractionLength, t1, fractionLength0, t2, i;
        H.stringTypeCheck(fractionPart);
        fractionLength = fractionPart.length;
        t1 = J.getInterceptor$s(fractionPart);
        while (true) {
          fractionLength0 = fractionLength - 1;
          if (J.$eq$(t1.codeUnitAt$1(fractionPart, fractionLength0), 48)) {
            t2 = J.$add$ansx(this.minimumFractionDigits, 1);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = fractionLength > t2;
          } else
            t2 = false;
          if (!t2)
            break;
          fractionLength = fractionLength0;
        }
        for (i = 1; i < fractionLength; ++i)
          this._addDigit$1(C.JSString_methods._codeUnitAt$1(fractionPart, i));
      }, null, "get$_formatFractionPart", 4, 0, null, 979],
      _decimalSeparator$1: [function(fractionPresent) {
        H.boolTypeCheck(fractionPresent);
        if (this._decimalSeparatorAlwaysShown || fractionPresent)
          this._intl$_add$1(this.get$symbols().get$DECIMAL_SEP());
      }, null, "get$_decimalSeparator", 4, 0, null, 980],
      _hasIntegerDigits$1: [function(digits) {
        return J.get$isNotEmpty$asx(H.stringTypeCheck(digits)) || J.$gt$n(this.minimumIntegerDigits, 0);
      }, null, "get$_hasIntegerDigits", 4, 0, null, 981],
      _intl$_add$1: [function(x) {
        this._intl$_buffer.write$1(H.stringTypeCheck(x));
      }, null, "get$_intl$_add", 4, 0, null, 37],
      _addZero$0: [function() {
        this._intl$_buffer.write$1(this.get$symbols().get$ZERO_DIGIT());
      }, null, "get$_addZero", 0, 0, null],
      _addDigit$1: [function(x) {
        var t1;
        H.intTypeCheck(x);
        t1 = this._zeroOffset;
        if (typeof x !== "number")
          return x.$add();
        if (typeof t1 !== "number")
          return H.iae(t1);
        this._intl$_buffer.writeCharCode$1(x + t1);
      }, null, "get$_addDigit", 4, 0, null, 37],
      _pad$2: [function(numberOfDigits, basic) {
        H.intTypeCheck(numberOfDigits);
        H.stringTypeCheck(basic);
        if (J.$eq$(this._zeroOffset, 0))
          this._intl$_buffer.write$1(J.padLeft$2$s(basic, numberOfDigits, "0"));
        else
          this._slowPad$2(numberOfDigits, basic);
      }, null, "get$_pad", 8, 0, null, 532, 533],
      _slowPad$2: [function(numberOfDigits, basic) {
        var t1, t2, i;
        H.intTypeCheck(numberOfDigits);
        H.stringTypeCheck(basic);
        t1 = basic.length;
        if (typeof numberOfDigits !== "number")
          return numberOfDigits.$sub();
        t2 = numberOfDigits - t1;
        i = 0;
        for (; i < t2; ++i)
          this._intl$_add$1(this.get$symbols().get$ZERO_DIGIT());
        for (i = 0; i < t1; ++i)
          this._addDigit$1(C.JSString_methods._codeUnitAt$1(basic, i));
      }, null, "get$_slowPad", 8, 0, null, 532, 533],
      _group$2: [function(totalLength, position) {
        var distanceFromEnd, t1, t2;
        H.intTypeCheck(totalLength);
        H.intTypeCheck(position);
        if (typeof totalLength !== "number")
          return totalLength.$sub();
        if (typeof position !== "number")
          return H.iae(position);
        distanceFromEnd = totalLength - position;
        if (distanceFromEnd <= 1 || J.$le$n(this._groupingSize, 0))
          return;
        if (distanceFromEnd === J.$add$ansx(this._finalGroupingSize, 1))
          this._intl$_add$1(this.get$symbols().get$GROUP_SEP());
        else {
          t1 = this._finalGroupingSize;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (distanceFromEnd > t1) {
            t2 = this._groupingSize;
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = C.JSNumber_methods.$mod(distanceFromEnd - t1, t2) === 1;
            t1 = t2;
          } else
            t1 = false;
          if (t1)
            this._intl$_add$1(this.get$symbols().get$GROUP_SEP());
        }
      }, null, "get$_group", 8, 0, null, 984, 69],
      _signPrefix$1: [function(x) {
        return H.boolTypeCheck(J.get$isNegative$n(x)) ? this._negativePrefix : this._positivePrefix;
      }, null, "get$_signPrefix", 4, 0, null, 37],
      _signSuffix$1: [function(x) {
        return H.boolTypeCheck(J.get$isNegative$n(x)) ? this._negativeSuffix : this._positiveSuffix;
      }, null, "get$_signSuffix", 4, 0, null, 37],
      _setPattern$1: [function(newPattern) {
        var t1;
        H.stringTypeCheck(newPattern);
        if (newPattern == null)
          return;
        this._intl$_pattern = H.stringTypeCheck(C.JSString_methods.replaceAll$2(newPattern, " ", "\xa0"));
        T._NumberFormatParser$(this, newPattern, this.get$currencySymbol(), this.get$decimalDigits()).parse$0();
        if (this.get$_overridesDecimalDigits()) {
          t1 = this._decimalDigits;
          if (t1 == null) {
            t1 = H.intTypeCheck(this.get$_defaultDecimalDigits());
            this._decimalDigits = t1;
          }
          H.intTypeCheck(t1);
          this.minimumFractionDigits = t1;
          this.maximumFractionDigits = t1;
        }
      }, null, "get$_setPattern", 4, 0, null, 334],
      toString$0: [function(_) {
        return "NumberFormat(" + H.S(this._locale) + ", " + H.S(this._intl$_pattern) + ")";
      }, null, "get$toString", 1, 0, null],
      static: {
        NumberFormat$decimalPattern: [function(locale) {
          var t1 = P.StringBuffer$("");
          t1 = new T.NumberFormat("-", "", "", "", 3, 3, false, false, false, false, false, 40, 1, 3, 0, 0, 0, false, 1, 0, T.Intl_verifiedLocale(locale, T.intl_NumberFormat_localeExists$closure(), T.intl_Intl__throwLocaleError$closure()), t1, 0, 0, []);
          t1.NumberFormat$_forPattern$7$computeCurrencySymbol$currencySymbol$decimalDigits$isForCurrency$name(locale, new T.NumberFormat$decimalPattern_closure(), null, null, null, false, null);
          return t1;
        }, null, null, 0, 2, null, 0, 180],
        NumberFormat_localeExists: [function(localeName) {
          if (localeName == null)
            return false;
          return $.$get$numberFormatSymbols().containsKey$1(localeName);
        }, "call$1", "intl_NumberFormat_localeExists$closure", 4, 0, 17, 333],
        NumberFormat_numberOfIntegerDigits: [function(number) {
          var simpleNumber, t1;
          simpleNumber = J.abs$0$in(J.toDouble$0$n(number));
          t1 = J.getInterceptor$n(simpleNumber);
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 10)))
            return 1;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 100)))
            return 2;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1000)))
            return 3;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 10000)))
            return 4;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 100000)))
            return 5;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1000000)))
            return 6;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 10000000)))
            return 7;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 100000000)))
            return 8;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1000000000)))
            return 9;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1e10)))
            return 10;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1e11)))
            return 11;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1e12)))
            return 12;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1e13)))
            return 13;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1e14)))
            return 14;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1e15)))
            return 15;
          if (H.boolTypeCheck(t1.$lt(simpleNumber, 1e16)))
            return 16;
          return P.max(1, J.ceil$0$n(J.$div$n(P.log(H.numTypeCheck(simpleNumber)), $.$get$NumberFormat__ln10())), P.int);
        }, null, null, 4, 0, null, 84]
      }
    },
    NumberFormat$decimalPattern_closure: {
      "^": "Closure:198;$ti",
      call$1: [function(x) {
        return H.interceptedTypeCheck(x, "$isNumberSymbols").DECIMAL_PATTERN;
      }, null, null, 4, 0, null, 37, "call"]
    },
    _NumberParser: {
      "^": "Object;$ti"
    },
    _NumberFormatParser: {
      "^": "Object;format,pattern>,currencySymbol,decimalDigits,inQuote,decimalPos,digitLeftCount,zeroDigitCount,digitRightCount,groupingCount,$ti",
      _NumberFormatParser$4: [function(format, input, currencySymbol, decimalDigits) {
        this.pattern.moveNext$0();
      }, null, null, 16, 0, null, 530, 55, 336, 337],
      get$symbols: [function() {
        return this.format.get$symbols();
      }, null, null, 2, 0, null],
      parse$0: [function() {
        var t1, trunk, t2, t3, each;
        t1 = this.format;
        t1.set$_positivePrefix(this._parseAffix$0());
        trunk = this._parseTrunk$0();
        t1.set$_positiveSuffix(this._parseAffix$0());
        t2 = this.pattern;
        if (J.$eq$(t2.get$current(), ";")) {
          t2.moveNext$0();
          t1.set$_negativePrefix(this._parseAffix$0());
          for (t3 = J.get$iterator$ax(T._iterable(trunk)); t3.moveNext$0();) {
            each = t3.get$current();
            if (!J.$eq$(t2.get$current(), each) && t2.get$current() != null)
              throw H.wrapException(P.FormatException$("Positive and negative trunks must be the same", null, null));
            t2.moveNext$0();
          }
          t1.set$_negativeSuffix(this._parseAffix$0());
        } else {
          t1.set$_negativePrefix(J.$add$ansx(t1.get$_negativePrefix(), t1.get$_positivePrefix()));
          t1.set$_negativeSuffix(J.$add$ansx(t1.get$_positiveSuffix(), t1.get$_negativeSuffix()));
        }
      }, null, "get$parse", 0, 0, null],
      _parseAffix$0: [function() {
        var affix, t1;
        affix = P.StringBuffer$("");
        this.inQuote = false;
        t1 = this.pattern;
        while (true)
          if (!(this.parseCharacterAffix$1(affix) && t1.moveNext$0()))
            break;
        return affix.toString$0(0);
      }, null, "get$_parseAffix", 0, 0, null],
      parseCharacterAffix$1: [function(affix) {
        var t1, ch;
        H.interceptedTypeCheck(affix, "$isStringBuffer");
        t1 = this.pattern;
        ch = t1.get$current();
        if (ch == null)
          return false;
        if (ch === "'") {
          if (J.$eq$(t1.get$peek(), "'")) {
            t1.moveNext$0();
            affix.write$1("'");
          } else
            this.inQuote = !this.inQuote;
          return true;
        }
        if (this.inQuote)
          affix.write$1(ch);
        else
          switch (ch) {
            case "#":
            case "0":
            case ",":
            case ".":
            case ";":
              return false;
            case "\xa4":
              affix.write$1(this.currencySymbol);
              break;
            case "%":
              t1 = this.format;
              if (!J.$eq$(t1.get$_multiplier(), 1) && !J.$eq$(t1.get$_multiplier(), 100))
                throw H.wrapException(P.FormatException$("Too many percent/permill", null, null));
              t1.set$_multiplier(100);
              affix.write$1(this.get$symbols().get$PERCENT());
              break;
            case "\u2030":
              t1 = this.format;
              if (!J.$eq$(t1.get$_multiplier(), 1) && !J.$eq$(t1.get$_multiplier(), 1000))
                throw H.wrapException(P.FormatException$("Too many percent/permill", null, null));
              t1.set$_multiplier(1000);
              affix.write$1(this.get$symbols().get$PERMILL());
              break;
            default:
              affix.write$1(ch);
          }
        return true;
      }, null, "get$parseCharacterAffix", 4, 0, null, 985],
      _parseTrunk$0: [function() {
        var trunk, t1, loop, n, t2, totalDigits, effectiveDecimalPos;
        trunk = P.StringBuffer$("");
        t1 = this.pattern;
        loop = true;
        while (true) {
          if (!(t1.get$current() != null && loop))
            break;
          loop = this.parseTrunkCharacter$1(trunk);
        }
        if (J.$eq$(this.zeroDigitCount, 0) && J.$gt$n(this.digitLeftCount, 0) && J.$ge$n(this.decimalPos, 0)) {
          n = J.$eq$(this.decimalPos, 0) ? 1 : this.decimalPos;
          this.digitRightCount = H.intTypeCheck(J.$sub$n(this.digitLeftCount, n));
          if (typeof n !== "number")
            return n.$sub();
          this.digitLeftCount = n - 1;
          this.zeroDigitCount = 1;
        }
        if (!(J.$lt$n(this.decimalPos, 0) && J.$gt$n(this.digitRightCount, 0))) {
          if (J.$ge$n(this.decimalPos, 0))
            t2 = J.$lt$n(this.decimalPos, this.digitLeftCount) || J.$gt$n(this.decimalPos, J.$add$ansx(this.digitLeftCount, this.zeroDigitCount));
          else
            t2 = false;
          t2 = t2 || J.$eq$(this.groupingCount, 0);
        } else
          t2 = true;
        if (t2)
          throw H.wrapException(P.FormatException$('Malformed pattern "' + H.S(t1.get$input()) + '"', null, null));
        totalDigits = J.$add$ansx(J.$add$ansx(this.digitLeftCount, this.zeroDigitCount), this.digitRightCount);
        t1 = this.format;
        if (J.$ge$n(this.decimalPos, 0)) {
          t2 = this.decimalPos;
          if (typeof totalDigits !== "number")
            return totalDigits.$sub();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = totalDigits - t2;
        } else
          t2 = 0;
        t1.set$maximumFractionDigits(t2);
        if (J.$ge$n(this.decimalPos, 0)) {
          t1.set$minimumFractionDigits(J.$sub$n(J.$add$ansx(this.digitLeftCount, this.zeroDigitCount), this.decimalPos));
          if (J.$lt$n(t1.get$minimumFractionDigits(), 0))
            t1.set$minimumFractionDigits(0);
        }
        effectiveDecimalPos = J.$ge$n(this.decimalPos, 0) ? this.decimalPos : totalDigits;
        t2 = this.digitLeftCount;
        if (typeof effectiveDecimalPos !== "number")
          return effectiveDecimalPos.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.set$minimumIntegerDigits(effectiveDecimalPos - t2);
        if (t1.get$_useExponentialNotation()) {
          t1.set$maximumIntegerDigits(J.$add$ansx(this.digitLeftCount, t1.get$minimumIntegerDigits()));
          if (J.$eq$(t1.get$maximumFractionDigits(), 0) && J.$eq$(t1.get$minimumIntegerDigits(), 0))
            t1.set$minimumIntegerDigits(1);
        }
        t1.set$_finalGroupingSize(P.max(0, this.groupingCount, P.int));
        if (!t1.get$_groupingSizeSetExplicitly())
          t1.set$_groupingSize(t1.get$_finalGroupingSize());
        t1.set$_decimalSeparatorAlwaysShown(J.$eq$(this.decimalPos, 0) || J.$eq$(this.decimalPos, totalDigits));
        return trunk.toString$0(0);
      }, null, "get$_parseTrunk", 0, 0, null],
      parseTrunkCharacter$1: [function(trunk) {
        var t1, ch, t2;
        t1 = this.pattern;
        ch = t1.get$current();
        switch (ch) {
          case "#":
            if (J.$gt$n(this.zeroDigitCount, 0))
              this.digitRightCount = H.intTypeCheck(J.$add$ansx(this.digitRightCount, 1));
            else
              this.digitLeftCount = H.intTypeCheck(J.$add$ansx(this.digitLeftCount, 1));
            if (J.$ge$n(this.groupingCount, 0) && J.$lt$n(this.decimalPos, 0))
              this.groupingCount = H.intTypeCheck(J.$add$ansx(this.groupingCount, 1));
            break;
          case "0":
            if (J.$gt$n(this.digitRightCount, 0))
              throw H.wrapException(P.FormatException$(J.$add$ansx(C.JSString_methods.$add('Unexpected "0" in pattern "', t1.get$input()), '"'), null, null));
            this.zeroDigitCount = H.intTypeCheck(J.$add$ansx(this.zeroDigitCount, 1));
            if (J.$ge$n(this.groupingCount, 0) && J.$lt$n(this.decimalPos, 0))
              this.groupingCount = H.intTypeCheck(J.$add$ansx(this.groupingCount, 1));
            break;
          case ",":
            if (J.$gt$n(this.groupingCount, 0)) {
              t2 = this.format;
              t2.set$_groupingSizeSetExplicitly(true);
              t2.set$_groupingSize(this.groupingCount);
            }
            this.groupingCount = 0;
            break;
          case ".":
            if (J.$ge$n(this.decimalPos, 0))
              throw H.wrapException(P.FormatException$('Multiple decimal separators in pattern "' + H.S(t1) + '"', null, null));
            this.decimalPos = H.intTypeCheck(J.$add$ansx(J.$add$ansx(this.digitLeftCount, this.zeroDigitCount), this.digitRightCount));
            break;
          case "E":
            trunk.write$1(ch);
            t2 = this.format;
            if (t2.get$_useExponentialNotation())
              throw H.wrapException(P.FormatException$('Multiple exponential symbols in pattern "' + H.S(t1) + '"', null, null));
            t2.set$_useExponentialNotation(true);
            t2.set$minimumExponentDigits(0);
            t1.moveNext$0();
            if (t1.get$current() === "+") {
              trunk.write$1(t1.get$current());
              t1.moveNext$0();
              t2.set$_useSignForPositiveExponent(true);
            }
            for (; J.$eq$(t1.get$current(), "0");) {
              trunk.write$1(t1.get$current());
              t1.moveNext$0();
              t2.set$minimumExponentDigits(J.$add$ansx(t2.get$minimumExponentDigits(), 1));
            }
            if (J.$lt$n(J.$add$ansx(this.digitLeftCount, this.zeroDigitCount), 1) || J.$lt$n(t2.get$minimumExponentDigits(), 1))
              throw H.wrapException(P.FormatException$('Malformed exponential pattern "' + H.S(t1) + '"', null, null));
            return false;
          default:
            return false;
        }
        trunk.write$1(ch);
        t1.moveNext$0();
        return true;
      }, null, "get$parseTrunkCharacter", 4, 0, null, 986],
      format$1: function(arg0) {
        return this.format.call$1(arg0);
      },
      static: {
        _NumberFormatParser$: [function(format, input, currencySymbol, decimalDigits) {
          var t1;
          H.stringTypeCheck(input);
          t1 = new T._NumberFormatParser(format, H.interceptedTypeCheck(T._iterator(input), "$is_StringIterator"), currencySymbol, decimalDigits, false, -1, 0, 0, 0, -1, []);
          t1._NumberFormatParser$4(format, input, currencySymbol, decimalDigits);
          return t1;
        }, null, null, 16, 0, null, 530, 55, 336, 337]
      }
    },
    _StringIterable: {
      "^": "IterableBase;iterator>,$ti",
      $asIterableBase: function() {
        return [P.String];
      },
      $asIterable: function() {
        return [P.String];
      },
      static: {
        _StringIterable$: [function(s) {
          return new T._StringIterable(T._iterator(s), []);
        }, null, null, 4, 0, null, 50]
      }
    },
    _StringIterator: {
      "^": "Object;input<,nextIndex,0_intl$_current,$ti",
      get$current: [function() {
        return this._intl$_current;
      }, null, null, 2, 0, null],
      moveNext$0: [function() {
        var t1, t2, t3;
        t1 = this.input;
        t2 = J.getInterceptor$asx(t1);
        if (J.$ge$n(this.nextIndex, t2.get$length(t1))) {
          this._intl$_current = null;
          return false;
        }
        t3 = this.nextIndex;
        this.nextIndex = H.intTypeCheck(J.$add$ansx(t3, 1));
        this._intl$_current = H.stringTypeCheck(t2.$index(t1, t3));
        return true;
      }, null, "get$moveNext", 0, 0, null],
      get$peek: [function() {
        var t1, t2;
        t1 = this.input;
        t2 = J.getInterceptor$asx(t1);
        return J.$ge$n(this.nextIndex, t2.get$length(t1)) ? null : t2.$index(t1, this.nextIndex);
      }, null, null, 2, 0, null],
      get$iterator: [function(_) {
        return this;
      }, null, null, 3, 0, null],
      $isIterator: 1,
      $asIterator: function() {
        return [P.String];
      },
      static: {
        _StringIterator$: [function(input) {
          return new T._StringIterator(T._StringIterator__validate(input), 0, []);
        }, null, null, 4, 0, null, 55],
        _StringIterator__validate: [function(input) {
          if (typeof input !== "string")
            throw H.wrapException(P.ArgumentError$(input));
          return input;
        }, null, null, 4, 0, null, 55]
      }
    },
    MicroMoney: {
      "^": "Object;$ti"
    },
    _MicroMoney: {
      "^": "Object;$ti",
      $isMicroMoney: 1
    }
  }], ["number_symbols", "package:intl/number_symbols.dart",, B, {
    "^": "",
    NumberSymbols: {
      "^": "Object;NAME,DECIMAL_SEP<,GROUP_SEP<,PERCENT<,ZERO_DIGIT<,PLUS_SIGN<,MINUS_SIGN<,EXP_SYMBOL<,PERMILL<,INFINITY<,NAN<,DECIMAL_PATTERN,SCIENTIFIC_PATTERN,PERCENT_PATTERN,CURRENCY_PATTERN,DEF_CURRENCY_CODE<,$ti",
      toString$0: [function(_) {
        return this.NAME;
      }, null, "get$toString", 1, 0, null],
      static: {
        NumberSymbols$: [function(CURRENCY_PATTERN, DECIMAL_PATTERN, DECIMAL_SEP, DEF_CURRENCY_CODE, EXP_SYMBOL, GROUP_SEP, INFINITY, MINUS_SIGN, NAME, NAN, PERCENT, PERCENT_PATTERN, PERMILL, PLUS_SIGN, SCIENTIFIC_PATTERN, ZERO_DIGIT) {
          return new B.NumberSymbols(NAME, DECIMAL_SEP, GROUP_SEP, PERCENT, ZERO_DIGIT, PLUS_SIGN, MINUS_SIGN, EXP_SYMBOL, PERMILL, INFINITY, NAN, DECIMAL_PATTERN, SCIENTIFIC_PATTERN, PERCENT_PATTERN, CURRENCY_PATTERN, DEF_CURRENCY_CODE, []);
        }, null, null, 0, 33, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 987, 988, 989, 990, 991, 992, 993, 994, 527, 995, 996, 997, 998, 999, 1000, 1001]
      }
    },
    CompactNumberSymbols: {
      "^": "Object;$ti"
    }
  }], ["number_symbol_data", "package:intl/number_symbols_data.dart",, F, {}], ["date_format_internal", "package:intl/src/date_format_internal.dart",, A, {
    "^": "",
    dateTimeSymbols: [function() {
      return $.$get$_dateTimeSymbols();
    }, null, null, 2, 0, null]
  }], ["intl_helpers", "package:intl/src/intl_helpers.dart",, X, {
    "^": "",
    UninitializedLocaleData: {
      "^": "Object;message>,fallbackData,_badMessages,$ti",
      $index: [function(_, key) {
        return H.stringTypeCheck(key) === "en_US" ? this.fallbackData : this._throwException$0();
      }, null, "get$[]", 5, 0, null, 4],
      containsKey$1: [function(key) {
        return H.boolTypeCheck(H.stringTypeCheck(key) === "en_US" ? true : this._throwException$0());
      }, null, "get$containsKey", 4, 0, null, 4],
      _throwException$0: [function() {
        throw H.wrapException(X.LocaleDataException$("Locale data has not been initialized, call " + H.S(this.message) + "."));
      }, null, "get$_throwException", 0, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isMessageLookup: 1,
      static: {
        UninitializedLocaleData$: [function(message, fallbackData, $F) {
          return new X.UninitializedLocaleData(message, fallbackData, H.setRuntimeTypeInfo([], [P.String]), [$F]);
        }, null, null, 8, 0, null, 21, 1002]
      }
    },
    MessageLookup: {
      "^": "Object;$ti"
    },
    LocaleDataException: {
      "^": "Object;message>,$ti",
      toString$0: [function(_) {
        return "LocaleDataException: " + H.S(this.message);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isException: 1,
      static: {
        LocaleDataException$: [function(message) {
          return new X.LocaleDataException(message, []);
        }, null, null, 4, 0, null, 21]
      }
    },
    LocaleDataReader: {
      "^": "Object;$ti"
    }
  }], ["plural_rules", "package:intl/src/plural_rules.dart",, E, {
    "^": "",
    PluralCase: {
      "^": "Object;$ti"
    }
  }], ["js", "package:js/js.dart",, Q, {
    "^": "",
    JS: {
      "^": "Object;$ti"
    },
    _Anonymous: {
      "^": "Object;$ti"
    }
  }], ["meta", "package:meta/meta.dart",, Q, {
    "^": "",
    Immutable: {
      "^": "Object;$ti"
    },
    Required: {
      "^": "Object;$ti"
    },
    _AlwaysThrows: {
      "^": "Object;$ti"
    },
    _Checked: {
      "^": "Object;$ti"
    },
    _Experimental: {
      "^": "Object;$ti"
    },
    _Factory: {
      "^": "Object;$ti"
    },
    _IsTest: {
      "^": "Object;$ti"
    },
    _IsTestGroup: {
      "^": "Object;$ti"
    },
    _Literal: {
      "^": "Object;$ti"
    },
    _MustCallSuper: {
      "^": "Object;$ti"
    },
    _OptionalTypeArgs: {
      "^": "Object;$ti"
    },
    _Protected: {
      "^": "Object;$ti"
    },
    _Sealed: {
      "^": "Object;$ti"
    },
    _Virtual: {
      "^": "Object;$ti"
    },
    _VisibleForOverriding: {
      "^": "Object;$ti"
    },
    _VisibleForTesting: {
      "^": "Object;$ti"
    }
  }], ["", "package:path/path.dart",, D, {
    "^": "",
    current: [function() {
      var uri, t1, path, lastIndex;
      uri = P.Uri_base();
      if (J.$eq$(uri, $._currentUriBase))
        return $._current;
      $._currentUriBase = uri;
      if (J.$eq$($.$get$Style_platform(), $.$get$Style_url())) {
        t1 = J.toString$0$(uri.resolve$1("."));
        $._current = t1;
        return t1;
      } else {
        path = uri.toFilePath$0();
        lastIndex = path.length - 1;
        t1 = lastIndex === 0 ? path : J.substring$2$s(path, 0, lastIndex);
        $._current = t1;
        return t1;
      }
    }, null, null, 2, 0, null],
    prettyUri: [function(uri) {
      return $.$get$context0().prettyUri$1(uri);
    }, null, null, 4, 0, null, 65]
  }], ["", "package:path/src/context.dart",, M, {
    "^": "",
    createInternal: [function() {
      return M.Context$_internal();
    }, null, null, 0, 0, null],
    _parseUri: [function(uri) {
      if (typeof uri === "string")
        return P.Uri_parse(uri, 0, null);
      if (!!J.getInterceptor$(uri).$isUri)
        return uri;
      throw H.wrapException(P.ArgumentError$value(uri, "uri", "Value must be a String or a Uri"));
    }, null, null, 4, 0, null, 65],
    _validateArgList: [function(method, args) {
      var t1, t2, i, t3, numArgs, numArgs0, message;
      H.stringTypeCheck(method);
      t1 = P.String;
      H.assertSubtype(args, "$isList", [t1], "$asList");
      t2 = J.getInterceptor$asx(args);
      i = 1;
      while (true) {
        t3 = t2.get$length(args);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        c$0: {
          if (t2.$index(args, i) == null || t2.$index(args, i - 1) != null)
            break c$0;
          numArgs = t2.get$length(args);
          while (true) {
            if (typeof numArgs !== "number")
              return numArgs.$ge();
            if (!(numArgs >= 1))
              break;
            numArgs0 = numArgs - 1;
            if (t2.$index(args, numArgs0) != null)
              break;
            numArgs = numArgs0;
          }
          message = P.StringBuffer$("");
          message.write$1(H.S(method) + "(");
          message.write$1(J.join$1$ax(J.map$1$1$ax(t2.take$1(args, numArgs), new M._validateArgList_closure(), t1), ", "));
          message.write$1("): part " + (i - 1) + " was null, but part " + i + " was not.");
          throw H.wrapException(P.ArgumentError$(message.toString$0(0)));
        }
        ++i;
      }
    }, null, null, 8, 0, null, 61, 71],
    Context0: {
      "^": "Object;style>,_context$_current,$ti",
      get$current: [function() {
        var t1 = this._context$_current;
        return t1 != null ? t1 : D.current();
      }, null, null, 2, 0, null],
      get$separator: [function() {
        return this.style.get$separator();
      }, null, null, 2, 0, null],
      absolute$7: [function(_, part1, part2, part3, part4, part5, part6, part7) {
        H.stringTypeCheck(part1);
        H.stringTypeCheck(part2);
        H.stringTypeCheck(part3);
        H.stringTypeCheck(part4);
        H.stringTypeCheck(part5);
        H.stringTypeCheck(part6);
        H.stringTypeCheck(part7);
        M._validateArgList("absolute", H.setRuntimeTypeInfo([part1, part2, part3, part4, part5, part6, part7], [P.String]));
        if (part2 == null && this.isAbsolute$1(part1) && !this.isRootRelative$1(part1))
          return part1;
        return this.join$8(0, this.get$current(), part1, part2, part3, part4, part5, part6, part7);
      }, function($receiver, part1) {
        return this.absolute$7($receiver, part1, null, null, null, null, null, null);
      }, "absolute$1", null, null, "get$absolute", 5, 12, null, 0, 0, 0, 0, 0, 0, 534, 535, 536, 537, 538, 539, 540],
      extension$1: [function(path) {
        return this._parse$1(H.stringTypeCheck(path)).get$extension();
      }, "call$1", "get$extension", 4, 0, 7, 26],
      isAbsolute$1: [function(path) {
        return J.$gt$n(this.style.rootLength$1(H.stringTypeCheck(path)), 0);
      }, null, "get$isAbsolute", 4, 0, null, 26],
      isRelative$1: [function(path) {
        return !this.isAbsolute$1(H.stringTypeCheck(path));
      }, null, "get$isRelative", 4, 0, null, 26],
      isRootRelative$1: [function(path) {
        return this.style.isRootRelative$1(H.stringTypeCheck(path));
      }, null, "get$isRootRelative", 4, 0, null, 26],
      join$8: [function(_, part1, part2, part3, part4, part5, part6, part7, part8) {
        var parts = H.setRuntimeTypeInfo([H.stringTypeCheck(part1), H.stringTypeCheck(part2), H.stringTypeCheck(part3), H.stringTypeCheck(part4), H.stringTypeCheck(part5), H.stringTypeCheck(part6), H.stringTypeCheck(part7), H.stringTypeCheck(part8)], [P.String]);
        M._validateArgList("join", parts);
        return this.joinAll$1(C.JSArray_methods.where$1(parts, new M.Context_join_closure()));
      }, function($receiver, part1) {
        return this.join$8($receiver, part1, null, null, null, null, null, null, null);
      }, "join$1", null, null, "get$join", 5, 14, null, 0, 0, 0, 0, 0, 0, 0, 534, 535, 536, 537, 538, 539, 540, 1010],
      joinAll$1: [function(parts) {
        var buffer, t1, t2, needsSeparator, isAbsoluteAndNotRootRelative, t3, parsed, path, t4;
        H.assertSubtype(parts, "$isIterable", [P.String], "$asIterable");
        buffer = P.StringBuffer$("");
        for (t1 = J.get$iterator$ax(J.where$1$ax(parts, new M.Context_joinAll_closure())), t2 = this.style, needsSeparator = false, isAbsoluteAndNotRootRelative = false; t1.moveNext$0();) {
          t3 = t1.get$current();
          if (this.isRootRelative$1(t3) && isAbsoluteAndNotRootRelative) {
            parsed = this._parse$1(t3);
            path = buffer.toString$0(0);
            t4 = H.stringTypeCheck(J.substring$2$s(path, 0, t2.rootLength$2$withDrive(path, true)));
            parsed.root = t4;
            if (t2.needsSeparator$1(t4))
              J.$indexSet$ax(parsed.separators, 0, t2.get$separator());
            buffer.clear$0(0);
            buffer.write$1(J.toString$0$(parsed));
          } else if (this.isAbsolute$1(t3)) {
            isAbsoluteAndNotRootRelative = !this.isRootRelative$1(t3);
            buffer.clear$0(0);
            buffer.write$1(t3);
          } else {
            if (!(t3.length > 0 && t2.containsSeparator$1(t3[0])))
              if (needsSeparator)
                buffer.write$1(this.get$separator());
            buffer.write$1(t3);
          }
          needsSeparator = t2.needsSeparator$1(t3);
        }
        return buffer.toString$0(0);
      }, null, "get$joinAll", 4, 0, null, 154],
      split$1: [function(_, path) {
        var parsed, t1;
        parsed = this._parse$1(H.stringTypeCheck(path));
        parsed.set$parts(J.toList$0$ax(J.where$1$ax(parsed.parts, new M.Context_split_closure())));
        t1 = parsed.root;
        if (t1 != null)
          J.insert$2$ax(parsed.parts, 0, t1);
        return parsed.parts;
      }, null, "get$split", 5, 0, null, 26],
      normalize$1: [function(path) {
        var parsed;
        H.stringTypeCheck(path);
        if (!this._needsNormalization$1(path))
          return path;
        parsed = this._parse$1(path);
        parsed.normalize$0();
        return parsed.toString$0(0);
      }, null, "get$normalize", 4, 0, null, 26],
      _needsNormalization$1: [function(path) {
        var codeUnits, t1, root, t2, i, start, previous, t3, previousPrevious, t4, codeUnit;
        H.stringTypeCheck(path);
        codeUnits = J.get$codeUnits$s(path);
        t1 = this.style;
        root = t1.rootLength$1(path);
        if (root !== 0) {
          if (J.$eq$(t1, $.$get$Style_windows())) {
            if (typeof root !== "number")
              return H.iae(root);
            t2 = J.getInterceptor$asx(codeUnits);
            i = 0;
            for (; i < root; ++i)
              if (J.$eq$(t2.$index(codeUnits, i), 47))
                return true;
          }
          start = root;
          previous = 47;
        } else {
          start = 0;
          previous = null;
        }
        t2 = J.getInterceptor$asx(codeUnits);
        t3 = J.getInterceptor$(t1);
        i = start;
        previousPrevious = null;
        while (true) {
          t4 = t2.get$length(codeUnits);
          if (typeof i !== "number")
            return i.$lt();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          codeUnit = t2.$index(codeUnits, i);
          if (t1.isSeparator$1(codeUnit)) {
            if (t3.$eq(t1, $.$get$Style_windows()) && codeUnit === 47)
              return true;
            if (previous != null && t1.isSeparator$1(previous))
              return true;
            if (previous === 46)
              t4 = previousPrevious == null || previousPrevious === 46 || t1.isSeparator$1(previousPrevious);
            else
              t4 = false;
            if (t4)
              return true;
          }
          ++i;
          previousPrevious = previous;
          previous = codeUnit;
        }
        if (previous == null)
          return true;
        if (t1.isSeparator$1(previous))
          return true;
        if (previous === 46)
          t1 = previousPrevious == null || t1.isSeparator$1(previousPrevious) || previousPrevious === 46;
        else
          t1 = false;
        if (t1)
          return true;
        return false;
      }, null, "get$_needsNormalization", 4, 0, null, 26],
      relative$2$from: [function(path, from) {
        var t1, fromParsed, pathParsed, t2;
        H.stringTypeCheck(path);
        H.stringTypeCheck(from);
        t1 = from == null;
        if (t1 && this.isRelative$1(path))
          return this.normalize$1(path);
        from = t1 ? this.get$current() : this.absolute$1(0, from);
        if (this.isRelative$1(from) && this.isAbsolute$1(path))
          return this.normalize$1(path);
        if (this.isRelative$1(path) || this.isRootRelative$1(path))
          path = this.absolute$1(0, path);
        if (this.isRelative$1(path) && this.isAbsolute$1(from))
          throw H.wrapException(X.PathException$('Unable to find a path to "' + H.S(path) + '" from "' + H.S(from) + '".'));
        fromParsed = this._parse$1(from);
        fromParsed.normalize$0();
        pathParsed = this._parse$1(path);
        pathParsed.normalize$0();
        if (J.$gt$n(J.get$length$asx(fromParsed.parts), 0) && J.$eq$(J.$index$asx(fromParsed.parts, 0), "."))
          return J.toString$0$(pathParsed);
        if (!J.$eq$(fromParsed.root, pathParsed.root)) {
          t1 = fromParsed.root;
          if (t1 != null) {
            t2 = pathParsed.root;
            t1 = t2 == null || !this.style.pathsEqual$2(t1, t2);
          } else
            t1 = true;
        } else
          t1 = false;
        if (t1)
          return J.toString$0$(pathParsed);
        t1 = this.style;
        while (true) {
          if (!(J.$gt$n(J.get$length$asx(fromParsed.get$parts()), 0) && J.$gt$n(J.get$length$asx(pathParsed.get$parts()), 0) && t1.pathsEqual$2(J.$index$asx(fromParsed.get$parts(), 0), J.$index$asx(pathParsed.get$parts(), 0))))
            break;
          J.removeAt$1$ax(fromParsed.get$parts(), 0);
          J.removeAt$1$ax(fromParsed.get$separators(), 1);
          J.removeAt$1$ax(pathParsed.get$parts(), 0);
          J.removeAt$1$ax(pathParsed.get$separators(), 1);
        }
        if (J.$gt$n(J.get$length$asx(fromParsed.get$parts()), 0) && J.$eq$(J.$index$asx(fromParsed.get$parts(), 0), ".."))
          throw H.wrapException(X.PathException$('Unable to find a path to "' + H.S(path) + '" from "' + H.S(from) + '".'));
        t2 = P.String;
        J.insertAll$2$ax(pathParsed.get$parts(), 0, P.List_List$filled(J.get$length$asx(fromParsed.get$parts()), "..", false, t2));
        J.$indexSet$ax(pathParsed.get$separators(), 0, "");
        J.insertAll$2$ax(pathParsed.get$separators(), 1, P.List_List$filled(J.get$length$asx(fromParsed.get$parts()), t1.get$separator(), false, t2));
        if (J.$eq$(J.get$length$asx(pathParsed.get$parts()), 0))
          return ".";
        if (J.$gt$n(J.get$length$asx(pathParsed.get$parts()), 1) && J.$eq$(J.get$last$ax(pathParsed.get$parts()), ".")) {
          J.removeLast$0$ax(pathParsed.get$parts());
          t1 = pathParsed.get$separators();
          t2 = J.getInterceptor$ax(t1);
          t2.removeLast$0(t1);
          t2.removeLast$0(t1);
          t2.add$1(t1, "");
        }
        t1 = J.getInterceptor$z(pathParsed);
        t1.set$root(pathParsed, "");
        pathParsed.removeTrailingSeparators$0();
        return t1.toString$0(pathParsed);
      }, function(path) {
        return this.relative$2$from(path, null);
      }, "relative$1", null, null, "get$relative", 4, 3, null, 0, 26, 121],
      fromUri$1: [function(uri) {
        return this.style.pathFromUri$1(M._parseUri(uri));
      }, null, "get$fromUri", 4, 0, null, 65],
      prettyUri$1: [function(uri) {
        var typedUri, path, rel;
        typedUri = M._parseUri(uri);
        if (J.$eq$(typedUri.get$scheme(), "file") && J.$eq$(this.style, $.$get$Style_url()))
          return typedUri.toString$0(0);
        else if (!J.$eq$(typedUri.get$scheme(), "file") && !J.$eq$(typedUri.get$scheme(), "") && !J.$eq$(this.style, $.$get$Style_url()))
          return typedUri.toString$0(0);
        path = this.normalize$1(this.fromUri$1(typedUri));
        rel = this.relative$1(path);
        return J.$gt$n(J.get$length$asx(this.split$1(0, rel)), J.get$length$asx(this.split$1(0, path))) ? path : rel;
      }, null, "get$prettyUri", 4, 0, null, 65],
      _parse$1: [function(path) {
        return X.ParsedPath_ParsedPath$parse(H.stringTypeCheck(path), this.style);
      }, null, "get$_parse", 4, 0, null, 26],
      static: {
        Context$_internal: [function() {
          return new M.Context0(H.interceptedTypeCast($.$get$Style_platform(), "$isInternalStyle"), null, []);
        }, null, null, 0, 0, null]
      }
    },
    Context_join_closure: {
      "^": "Closure:14;$ti",
      call$1: [function(part) {
        return H.stringTypeCheck(part) != null;
      }, null, null, 4, 0, null, 194, "call"]
    },
    Context_joinAll_closure: {
      "^": "Closure:14;$ti",
      call$1: [function(part) {
        return H.stringTypeCheck(part) !== "";
      }, null, null, 4, 0, null, 194, "call"]
    },
    Context_split_closure: {
      "^": "Closure:14;$ti",
      call$1: [function(part) {
        return !J.get$isEmpty$asx(H.stringTypeCheck(part));
      }, null, null, 4, 0, null, 194, "call"]
    },
    _validateArgList_closure: {
      "^": "Closure:7;$ti",
      call$1: [function(arg) {
        H.stringTypeCheck(arg);
        return arg == null ? "null" : '"' + arg + '"';
      }, null, null, 4, 0, null, 44, "call"]
    },
    _PathDirection: {
      "^": "Object;$ti"
    },
    _PathRelation: {
      "^": "Object;$ti"
    }
  }], ["", "package:path/src/internal_style.dart",, B, {
    "^": "",
    InternalStyle: {
      "^": "Style;$ti",
      getRoot$1: [function(path) {
        var $length, t1;
        H.stringTypeCheck(path);
        $length = this.rootLength$1(path);
        if (typeof $length !== "number")
          return $length.$gt();
        if ($length > 0)
          return J.substring$2$s(path, 0, $length);
        if (this.isRootRelative$1(path)) {
          if (0 >= path.length)
            return H.ioore(path, 0);
          t1 = path[0];
        } else
          t1 = null;
        return t1;
      }, null, "get$getRoot", 4, 0, null, 26],
      pathsEqual$2: [function(path1, path2) {
        return H.stringTypeCheck(path1) == H.stringTypeCheck(path2);
      }, null, "get$pathsEqual", 8, 0, null, 541, 542],
      canonicalizePart$1: [function(part) {
        return H.stringTypeCheck(part);
      }, null, "get$canonicalizePart", 4, 0, null, 194]
    }
  }], ["", "package:path/src/parsed_path.dart",, X, {
    "^": "",
    ParsedPath: {
      "^": "Object;style>,root,isRootRelative,parts<,separators<,$ti",
      set$root: function(_, root) {
        this.root = H.stringTypeCheck(root);
      },
      set$parts: function(parts) {
        this.parts = H.assertSubtype(parts, "$isList", [P.String], "$asList");
      },
      set$separators: function(separators) {
        this.separators = H.assertSubtype(separators, "$isList", [P.String], "$asList");
      },
      get$extension: [function() {
        return J.$index$asx(this._splitExtension$0(), 1);
      }, null, null, 2, 0, null],
      get$isAbsolute: [function() {
        return this.root != null;
      }, null, null, 2, 0, null],
      removeTrailingSeparators$0: [function() {
        var t1, t2;
        while (true) {
          if (!(!J.get$isEmpty$asx(this.parts) && J.$eq$(J.get$last$ax(this.parts), "")))
            break;
          J.removeLast$0$ax(this.parts);
          J.removeLast$0$ax(this.separators);
        }
        if (J.$gt$n(J.get$length$asx(this.separators), 0)) {
          t1 = this.separators;
          t2 = J.getInterceptor$asx(t1);
          t2.$indexSet(t1, J.$sub$n(t2.get$length(t1), 1), "");
        }
      }, null, "get$removeTrailingSeparators", 0, 0, null],
      normalize$1$canonicalize: [function(canonicalize) {
        var t1, newParts, t2, t3, leadingDoubles, t4, newSeparators;
        H.boolTypeCheck(canonicalize);
        t1 = P.String;
        newParts = H.setRuntimeTypeInfo([], [t1]);
        for (t2 = J.get$iterator$ax(this.parts), t3 = this.style, leadingDoubles = 0; t2.moveNext$0();) {
          t4 = t2.get$current();
          if (!(t4 === "." || t4 === ""))
            if (t4 === "..")
              if (newParts.length > 0)
                newParts.pop();
              else
                ++leadingDoubles;
            else
              C.JSArray_methods.add$1(newParts, canonicalize ? t3.canonicalizePart$1(t4) : t4);
        }
        if (!this.get$isAbsolute())
          C.JSArray_methods.insertAll$2(newParts, 0, P.List_List$filled(leadingDoubles, "..", false, t1));
        if (newParts.length === 0 && !this.get$isAbsolute())
          C.JSArray_methods.add$1(newParts, ".");
        newSeparators = P.List_List$generate(newParts.length, new X.ParsedPath_normalize_closure(this), true, t1);
        J.insert$2$ax(newSeparators, 0, this.get$isAbsolute() && newParts.length > 0 && t3.needsSeparator$1(this.root) ? t3.get$separator() : "");
        this.set$parts(newParts);
        this.set$separators(newSeparators);
        if (this.root != null && J.$eq$(t3, $.$get$Style_windows())) {
          if (canonicalize)
            this.root = H.stringTypeCheck(J.toLowerCase$0$s(this.root));
          this.root = H.stringTypeCheck(J.replaceAll$2$s(this.root, "/", "\\"));
        }
        this.removeTrailingSeparators$0();
      }, function() {
        return this.normalize$1$canonicalize(false);
      }, "normalize$0", null, null, "get$normalize", 0, 3, null, 18, 411],
      toString$0: [function(_) {
        var builder, t1, i;
        builder = P.StringBuffer$("");
        t1 = this.root;
        if (t1 != null)
          builder.write$1(t1);
        i = 0;
        while (true) {
          t1 = J.get$length$asx(this.parts);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          builder.write$1(J.$index$asx(this.separators, i));
          builder.write$1(J.$index$asx(this.parts, i));
          ++i;
        }
        builder.write$1(J.get$last$ax(this.separators));
        return builder.toString$0(0);
      }, null, "get$toString", 1, 0, null],
      _splitExtension$0: [function() {
        var file, lastDot;
        file = J.lastWhere$2$orElse$ax(this.parts, new X.ParsedPath__splitExtension_closure(), new X.ParsedPath__splitExtension_closure0());
        if (file == null)
          return H.setRuntimeTypeInfo(["", ""], [P.String]);
        if (file === "..")
          return H.setRuntimeTypeInfo(["..", ""], [P.String]);
        lastDot = C.JSString_methods.lastIndexOf$1(file, ".");
        if (typeof lastDot !== "number")
          return lastDot.$le();
        if (lastDot <= 0)
          return H.setRuntimeTypeInfo([file, ""], [P.String]);
        return H.setRuntimeTypeInfo([C.JSString_methods.substring$2(file, 0, lastDot), C.JSString_methods.substring$1(file, lastDot)], [P.String]);
      }, null, "get$_splitExtension", 0, 0, null],
      isRootRelative$1: function(arg0) {
        return this.isRootRelative.call$1(arg0);
      },
      static: {
        ParsedPath_ParsedPath$parse: [function(path, style) {
          var root, isRootRelative, t1, parts, separators, start, i;
          H.stringTypeCheck(path);
          H.interceptedTypeCheck(style, "$isInternalStyle");
          root = style.getRoot$1(path);
          isRootRelative = style.isRootRelative$1(path);
          if (root != null)
            path = J.substring$1$s(path, root.length);
          t1 = [P.String];
          parts = H.setRuntimeTypeInfo([], t1);
          separators = H.setRuntimeTypeInfo([], t1);
          if (J.get$isNotEmpty$asx(path) && style.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, 0))) {
            if (0 >= path.length)
              return H.ioore(path, 0);
            C.JSArray_methods.add$1(separators, path[0]);
            start = 1;
          } else {
            C.JSArray_methods.add$1(separators, "");
            start = 0;
          }
          for (t1 = path.length, i = start; i < t1; ++i)
            if (style.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, i))) {
              C.JSArray_methods.add$1(parts, C.JSString_methods.substring$2(path, start, i));
              C.JSArray_methods.add$1(separators, path[i]);
              start = i + 1;
            }
          if (start < t1) {
            C.JSArray_methods.add$1(parts, C.JSString_methods.substring$1(path, start));
            C.JSArray_methods.add$1(separators, "");
          }
          return X.ParsedPath$_(style, root, isRootRelative, parts, separators);
        }, null, null, 8, 0, null, 26, 140],
        ParsedPath$_: [function(style, root, isRootRelative, parts, separators) {
          return new X.ParsedPath(style, root, isRootRelative, parts, separators, []);
        }, null, null, 20, 0, null, 140, 1014, 1015, 154, 1016]
      }
    },
    ParsedPath_normalize_closure: {
      "^": "Closure:29;$this,$ti",
      call$1: [function(_) {
        H.intTypeCheck(_);
        return J.get$style$x(this.$this).get$separator();
      }, null, null, 4, 0, null, 12, "call"]
    },
    ParsedPath__splitExtension_closure: {
      "^": "Closure:14;$ti",
      call$1: [function(p) {
        return H.stringTypeCheck(p) !== "";
      }, null, null, 4, 0, null, 509, "call"]
    },
    ParsedPath__splitExtension_closure0: {
      "^": "Closure:1;$ti",
      call$0: [function() {
        return;
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:path/src/path_exception.dart",, X, {
    "^": "",
    PathException: {
      "^": "Object;message>,$ti",
      toString$0: [function(_) {
        return "PathException: " + H.S(this.message);
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      $isException: 1,
      static: {
        PathException$: [function(message) {
          return new X.PathException(message, []);
        }, null, null, 4, 0, null, 21]
      }
    }
  }], ["", "package:path/src/path_map.dart",, K, {
    "^": "",
    PathMap: {
      "^": "MapView;$ti",
      $asMapView: function($V) {
        return [P.String, $V];
      },
      $asMap: function($V) {
        return [P.String, $V];
      }
    }
  }], ["", "package:path/src/path_set.dart",, B, {
    "^": "",
    PathSet: {
      "^": "IterableBase;$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.String];
      },
      $asIterableBase: function() {
        return [P.String];
      },
      $asIterable: function() {
        return [P.String];
      },
      $isSet: 1,
      $asSet: function() {
        return [P.String];
      }
    }
  }], ["", "package:path/src/style.dart",, O, {
    "^": "",
    Style__getPlatformStyle: [function() {
      if (!J.$eq$(P.Uri_base().get$scheme(), "file"))
        return $.$get$Style_url();
      if (!J.endsWith$1$s(J.get$path$z(P.Uri_base()), "/"))
        return $.$get$Style_url();
      if (J.$eq$(P._Uri__Uri(null, null, "a/b", null, null, null, null, null, null).toFilePath$0(), "a\\b"))
        return $.$get$Style_windows();
      return $.$get$Style_posix();
    }, null, null, 0, 0, null],
    Style: {
      "^": "Object;$ti",
      toString$0: [function(_) {
        return this.get$name(this);
      }, null, "get$toString", 1, 0, null],
      static: {
        "^": "Style_url<"
      }
    }
  }], ["", "package:path/src/style/posix.dart",, E, {
    "^": "",
    PosixStyle: {
      "^": "InternalStyle;name>,separator<,separators<,separatorPattern,needsSeparatorPattern,rootPattern,0relativeRootPattern,$ti",
      containsSeparator$1: [function(path) {
        return J.contains$1$asx(H.stringTypeCheck(path), "/");
      }, null, "get$containsSeparator", 4, 0, null, 26],
      isSeparator$1: [function(codeUnit) {
        return H.intTypeCheck(codeUnit) === 47;
      }, null, "get$isSeparator", 4, 0, null, 125],
      needsSeparator$1: [function(path) {
        H.stringTypeCheck(path);
        return J.getInterceptor$asx(path).get$isNotEmpty(path) && !this.isSeparator$1(C.JSString_methods.codeUnitAt$1(path, path.length - 1));
      }, null, "get$needsSeparator", 4, 0, null, 26],
      rootLength$2$withDrive: [function(path, withDrive) {
        H.stringTypeCheck(path);
        H.boolTypeCheck(withDrive);
        if (J.getInterceptor$asx(path).get$isNotEmpty(path) && this.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, 0)))
          return 1;
        return 0;
      }, function(path) {
        return this.rootLength$2$withDrive(path, false);
      }, "rootLength$1", null, null, "get$rootLength", 4, 3, null, 18, 26, 339],
      isRootRelative$1: [function(path) {
        H.stringTypeCheck(path);
        return false;
      }, null, "get$isRootRelative", 4, 0, null, 26],
      pathFromUri$1: [function(uri) {
        H.interceptedTypeCheck(uri, "$isUri");
        if (J.$eq$(uri.get$scheme(), "") || J.$eq$(uri.get$scheme(), "file"))
          return P.Uri_decodeComponent(uri.get$path(uri));
        throw H.wrapException(P.ArgumentError$("Uri " + H.S(uri) + " must have scheme 'file:'."));
      }, null, "get$pathFromUri", 4, 0, null, 65],
      static: {
        PosixStyle$: [function() {
          return new E.PosixStyle("posix", "/", C.List_cSk, P.RegExp_RegExp("/", true, false), P.RegExp_RegExp("[^/]$", true, false), P.RegExp_RegExp("^/", true, false), []);
        }, null, null, 0, 0, null]
      }
    }
  }], ["", "package:path/src/style/url.dart",, F, {
    "^": "",
    UrlStyle: {
      "^": "InternalStyle;name>,separator<,separators<,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern,$ti",
      containsSeparator$1: [function(path) {
        return J.contains$1$asx(H.stringTypeCheck(path), "/");
      }, null, "get$containsSeparator", 4, 0, null, 26],
      isSeparator$1: [function(codeUnit) {
        return H.intTypeCheck(codeUnit) === 47;
      }, null, "get$isSeparator", 4, 0, null, 125],
      needsSeparator$1: [function(path) {
        var t1;
        H.stringTypeCheck(path);
        if (J.getInterceptor$asx(path).get$isEmpty(path))
          return false;
        t1 = path.length;
        if (!this.isSeparator$1(C.JSString_methods.codeUnitAt$1(path, t1 - 1)))
          return true;
        return C.JSString_methods.endsWith$1(path, "://") && J.$eq$(this.rootLength$1(path), t1);
      }, null, "get$needsSeparator", 4, 0, null, 26],
      rootLength$2$withDrive: [function(path, withDrive) {
        var t1, i, codeUnit, index, t2;
        H.stringTypeCheck(path);
        H.boolTypeCheck(withDrive);
        if (J.getInterceptor$asx(path).get$isEmpty(path))
          return 0;
        if (this.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, 0)))
          return 1;
        for (t1 = path.length, i = 0; i < t1; ++i) {
          codeUnit = C.JSString_methods._codeUnitAt$1(path, i);
          if (this.isSeparator$1(codeUnit))
            return 0;
          if (codeUnit === 58) {
            if (i === 0)
              return 0;
            index = C.JSString_methods.indexOf$2(path, "/", C.JSString_methods.startsWith$2(path, "//", i + 1) ? i + 3 : i);
            if (typeof index !== "number")
              return index.$le();
            if (index <= 0)
              return t1;
            if (!withDrive || t1 < index + 3)
              return index;
            if (!C.JSString_methods.startsWith$1(path, "file://"))
              return index;
            if (!B.isDriveLetter(path, index + 1))
              return index;
            t2 = index + 3;
            return t1 === t2 ? t2 : index + 4;
          }
        }
        return 0;
      }, function(path) {
        return this.rootLength$2$withDrive(path, false);
      }, "rootLength$1", null, null, "get$rootLength", 4, 3, null, 18, 26, 339],
      isRootRelative$1: [function(path) {
        H.stringTypeCheck(path);
        return J.getInterceptor$asx(path).get$isNotEmpty(path) && this.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, 0));
      }, null, "get$isRootRelative", 4, 0, null, 26],
      pathFromUri$1: [function(uri) {
        return J.toString$0$(H.interceptedTypeCheck(uri, "$isUri"));
      }, null, "get$pathFromUri", 4, 0, null, 65],
      static: {
        UrlStyle$: [function() {
          return new F.UrlStyle("url", "/", C.List_cSk, P.RegExp_RegExp("/", true, false), P.RegExp_RegExp("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])$", true, false), P.RegExp_RegExp("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*", true, false), P.RegExp_RegExp("^/", true, false), []);
        }, null, null, 0, 0, null]
      }
    }
  }], ["", "package:path/src/style/windows.dart",, L, {
    "^": "",
    WindowsStyle: {
      "^": "InternalStyle;name>,separator<,separators<,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern,$ti",
      containsSeparator$1: [function(path) {
        return J.contains$1$asx(H.stringTypeCheck(path), "/");
      }, null, "get$containsSeparator", 4, 0, null, 26],
      isSeparator$1: [function(codeUnit) {
        H.intTypeCheck(codeUnit);
        return codeUnit === 47 || codeUnit === 92;
      }, null, "get$isSeparator", 4, 0, null, 125],
      needsSeparator$1: [function(path) {
        H.stringTypeCheck(path);
        if (J.getInterceptor$asx(path).get$isEmpty(path))
          return false;
        return !this.isSeparator$1(C.JSString_methods.codeUnitAt$1(path, path.length - 1));
      }, null, "get$needsSeparator", 4, 0, null, 26],
      rootLength$2$withDrive: [function(path, withDrive) {
        var t1, t2, index;
        H.stringTypeCheck(path);
        H.boolTypeCheck(withDrive);
        if (J.getInterceptor$asx(path).get$isEmpty(path))
          return 0;
        t1 = C.JSString_methods._codeUnitAt$1(path, 0);
        t2 = J.getInterceptor$(t1);
        if (t2.$eq(t1, 47))
          return 1;
        if (t2.$eq(t1, 92)) {
          t1 = path.length;
          if (t1 < 2 || !J.$eq$(C.JSString_methods._codeUnitAt$1(path, 1), 92))
            return 1;
          index = C.JSString_methods.indexOf$2(path, "\\", 2);
          if (typeof index !== "number")
            return index.$gt();
          if (index > 0) {
            index = C.JSString_methods.indexOf$2(path, "\\", index + 1);
            if (typeof index !== "number")
              return index.$gt();
            if (index > 0)
              return index;
          }
          return t1;
        }
        if (path.length < 3)
          return 0;
        if (!B.isAlphabetic(t1))
          return 0;
        if (!J.$eq$(C.JSString_methods._codeUnitAt$1(path, 1), 58))
          return 0;
        if (!this.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, 2)))
          return 0;
        return 3;
      }, function(path) {
        return this.rootLength$2$withDrive(path, false);
      }, "rootLength$1", null, null, "get$rootLength", 4, 3, null, 18, 26, 339],
      isRootRelative$1: [function(path) {
        return J.$eq$(this.rootLength$1(H.stringTypeCheck(path)), 1);
      }, null, "get$isRootRelative", 4, 0, null, 26],
      pathFromUri$1: [function(uri) {
        var path;
        H.interceptedTypeCheck(uri, "$isUri");
        if (!J.$eq$(uri.get$scheme(), "") && !J.$eq$(uri.get$scheme(), "file"))
          throw H.wrapException(P.ArgumentError$("Uri " + H.S(uri) + " must have scheme 'file:'."));
        path = uri.get$path(uri);
        if (J.$eq$(uri.get$host(uri), "")) {
          if (path.length >= 3 && J.startsWith$1$s(path, "/") && B.isDriveLetter(path, 1))
            path = J.replaceFirst$2$s(path, "/", "");
        } else
          path = "\\\\" + H.S(uri.get$host(uri)) + H.S(path);
        return P.Uri_decodeComponent(J.replaceAll$2$s(path, "/", "\\"));
      }, null, "get$pathFromUri", 4, 0, null, 65],
      codeUnitsEqual$2: [function(codeUnit1, codeUnit2) {
        var upperCase1;
        H.intTypeCheck(codeUnit1);
        H.intTypeCheck(codeUnit2);
        if (codeUnit1 == codeUnit2)
          return true;
        if (codeUnit1 === 47)
          return codeUnit2 === 92;
        if (codeUnit1 === 92)
          return codeUnit2 === 47;
        if (typeof codeUnit1 !== "number")
          return codeUnit1.$xor();
        if (typeof codeUnit2 !== "number")
          return H.iae(codeUnit2);
        if ((codeUnit1 ^ codeUnit2) >>> 0 !== 32)
          return false;
        upperCase1 = (codeUnit1 | 32) >>> 0;
        return upperCase1 >= 97 && upperCase1 <= 122;
      }, null, "get$codeUnitsEqual", 8, 0, null, 1018, 1019],
      pathsEqual$2: [function(path1, path2) {
        var t1, t2, i;
        H.stringTypeCheck(path1);
        H.stringTypeCheck(path2);
        if (path1 == path2)
          return true;
        t1 = path1.length;
        if (t1 !== path2.length)
          return false;
        for (t2 = J.getInterceptor$s(path2), i = 0; i < t1; ++i)
          if (!this.codeUnitsEqual$2(C.JSString_methods._codeUnitAt$1(path1, i), t2._codeUnitAt$1(path2, i)))
            return false;
        return true;
      }, null, "get$pathsEqual", 8, 0, null, 541, 542],
      canonicalizePart$1: [function(part) {
        return J.toLowerCase$0$s(H.stringTypeCheck(part));
      }, null, "get$canonicalizePart", 4, 0, null, 194],
      static: {
        WindowsStyle$: [function() {
          return new L.WindowsStyle("windows", "\\", C.List_WnV, P.RegExp_RegExp("[/\\\\]", true, false), P.RegExp_RegExp("[^/\\\\]$", true, false), P.RegExp_RegExp("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])", true, false), P.RegExp_RegExp("^[/\\\\](?![/\\\\])", true, false), []);
        }, null, null, 0, 0, null]
      }
    }
  }], ["", "package:path/src/utils.dart",, B, {
    "^": "",
    isAlphabetic: [function(char) {
      var t1;
      H.intTypeCheck(char);
      if (typeof char !== "number")
        return char.$ge();
      if (!(char >= 65 && char <= 90))
        t1 = char >= 97 && char <= 122;
      else
        t1 = true;
      return t1;
    }, null, null, 4, 0, null, 164],
    isDriveLetter: [function(path, index) {
      var t1, t2;
      H.stringTypeCheck(path);
      H.intTypeCheck(index);
      t1 = path.length;
      if (typeof index !== "number")
        return index.$add();
      t2 = index + 2;
      if (t1 < t2)
        return false;
      if (!B.isAlphabetic(J.getInterceptor$s(path).codeUnitAt$1(path, index)))
        return false;
      if (!J.$eq$(C.JSString_methods.codeUnitAt$1(path, index + 1), 58))
        return false;
      if (t1 === t2)
        return true;
      return J.$eq$(C.JSString_methods.codeUnitAt$1(path, t2), 47);
    }, null, null, 8, 0, null, 26, 6]
  }], ["", "package:pedantic/pedantic.dart",, T, {
    "^": "",
    unawaited: [function(future) {
      H.assertSubtype(future, "$isFuture", [-1], "$asFuture");
    }, null, null, 4, 0, null, 318]
  }], ["", "package:rxdart/src/futures/as_observable_future.dart",, K, {
    "^": "",
    AsObservableFuture: {
      "^": "WrappedFuture;wrapped,$ti",
      static: {
        AsObservableFuture$: [function(wrapped, $T) {
          return new K.AsObservableFuture(wrapped, [$T]);
        }, null, null, 4, 0, null, 1020]
      }
    }
  }], ["", "package:rxdart/src/futures/stream_max_future.dart",, G, {
    "^": "",
    StreamMaxFuture: {
      "^": "WrappedFuture;$ti"
    }
  }], ["", "package:rxdart/src/futures/stream_min_future.dart",, L, {
    "^": "",
    StreamMinFuture: {
      "^": "WrappedFuture;$ti"
    }
  }], ["", "package:rxdart/src/futures/wrapped_future.dart",, B, {
    "^": "",
    WrappedFuture: {
      "^": "Object;$ti",
      catchError$2$test: [function(onError, test) {
        return this.wrapped.catchError$2$test(H.interceptedTypeCheck(onError, "$isFunction"), H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [P.Object]}));
      }, function(onError) {
        return this.catchError$2$test(onError, null);
      }, "catchError$1", null, null, "get$catchError", 4, 3, null, 0, 31, 41],
      then$1$2$onError: [1, function(onValue, onError, $S) {
        return this.wrapped.then$1$2$onError(H.functionTypeCheck(onValue, {func: 1, ret: {futureOr: 1, type: $S}, args: [H.getTypeArgumentByIndex(this, 0)]}), H.interceptedTypeCheck(onError, "$isFunction"), $S);
      }, function(onValue, onError) {
        return this.then$1$2$onError(onValue, onError, null);
      }, "then$2$onError", function(onValue, $S) {
        return this.then$1$2$onError(onValue, null, $S);
      }, "then$1$1", null, "call$2$onError", null, "get$then", 4, 3, null, 0, 420, 31],
      whenComplete$1: [function(action) {
        return this.wrapped.whenComplete$1(H.functionTypeCheck(action, {func: 1, ret: -1}));
      }, null, "get$whenComplete", 4, 0, null, 63],
      $isFuture: 1
    }
  }], ["", "package:rxdart/src/observables/connectable_observable.dart",, R, {
    "^": "",
    ConnectableObservable: {
      "^": "Observable;$ti"
    },
    PublishConnectableObservable: {
      "^": "ConnectableObservable;$ti"
    },
    ValueConnectableObservable: {
      "^": "ConnectableObservable;$ti",
      $isValueObservable: 1
    },
    ReplayConnectableObservable: {
      "^": "ConnectableObservable;$ti",
      $isReplayObservable: 1
    },
    ConnectableObservableStreamSubscription: {
      "^": "StreamSubscription;$ti"
    }
  }], ["", "package:rxdart/src/observables/observable.dart",, X, {
    "^": "",
    Observable: {
      "^": "Stream;_observable$_stream,$ti",
      asyncMap$1$1: [1, function(convert, $S) {
        return X.Observable$(this._observable$_stream.asyncMap$1$1(H.functionTypeCheck(convert, {func: 1, ret: {futureOr: 1, type: $S}, args: [H.getTypeArgumentByIndex(this, 0)]}), $S), $S);
      }, function(convert) {
        return this.asyncMap$1$1(convert, null);
      }, "asyncMap$1", null, "call$1", "get$asyncMap", 4, 0, null, 188],
      get$first: [function(_) {
        return K.AsObservableFuture$(J.get$first$ax(this._observable$_stream), H.getTypeArgumentByIndex(this, 0));
      }, null, null, 3, 0, null],
      get$isBroadcast: [function() {
        var t1 = this._observable$_stream;
        return t1 != null && t1.get$isBroadcast();
      }, null, null, 2, 0, null],
      get$isEmpty: [function(_) {
        return K.AsObservableFuture$(J.get$isEmpty$asx(this._observable$_stream), P.bool);
      }, null, null, 3, 0, null],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        return this._observable$_stream.listen$4$cancelOnError$onDone$onError(onData, H.boolTypeCheck(cancelOnError), onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      get$length: [function(_) {
        return K.AsObservableFuture$(J.get$length$asx(this._observable$_stream), P.int);
      }, null, null, 3, 0, null],
      map$1$1: [1, function(_, convert, $S) {
        return X.Observable$(J.map$1$1$ax(this._observable$_stream, H.functionTypeCheck(convert, {func: 1, ret: $S, args: [H.getTypeArgumentByIndex(this, 0)]}), $S), $S);
      }, function($receiver, convert) {
        return this.map$1$1($receiver, convert, null);
      }, "map$1", null, "call$1", "get$map", 5, 0, null, 188],
      startWith$1: [function(startValue) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return this.transform$1$1(0, G.StartWithStreamTransformer$(H.assertSubtypeOfRuntimeType(startValue, t1), t1), t1);
      }, null, "get$startWith", 4, 0, null, 341],
      transform$1$1: [1, function(_, streamTransformer, $S) {
        return X.Observable$(this.super$Stream$transform(0, H.assertSubtype(streamTransformer, "$isStreamTransformer", [H.getTypeArgumentByIndex(this, 0), $S], "$asStreamTransformer"), $S), $S);
      }, function($receiver, streamTransformer) {
        return this.transform$1$1($receiver, streamTransformer, null);
      }, "transform$1", null, "call$1", "get$transform", 5, 0, null, 371],
      where$1: [function(_, test) {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return X.Observable$(J.where$1$ax(this._observable$_stream, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]})), t1);
      }, null, "get$where", 5, 0, null, 41],
      static: {
        Observable$: [function(stream, $T) {
          return new X.Observable(stream, [$T]);
        }, null, null, 4, 0, null, 57],
        Observable_Observable$concat: [function(streams, $T) {
          return X.Observable$(R.ConcatStream$(H.assertSubtype(streams, "$isIterable", [[P.Stream, $T]], "$asIterable"), $T), $T);
        }, null, null, 4, 0, null, 340],
        Observable_Observable$defer: [function(streamFactory, reusable, $T) {
          return X.Observable$(D.DeferStream$(H.functionTypeCheck(streamFactory, {func: 1, ret: [P.Stream, $T]}), H.boolTypeCheck(reusable), $T), $T);
        }, null, null, 4, 3, null, 18, 1022, 543]
      }
    }
  }], ["", "package:rxdart/src/observables/replay_observable.dart",, N, {
    "^": "",
    ReplayObservable: {
      "^": "Object;$ti",
      $isStream: 1,
      $isObservable: 1
    }
  }], ["", "package:rxdart/src/observables/value_observable.dart",, X, {
    "^": "",
    ValueObservable: {
      "^": "Object;$ti",
      $isStream: 1,
      $isObservable: 1
    }
  }], ["", "package:rxdart/src/samplers/buffer_strategy.dart",, Y, {
    "^": "",
    _OnStreamSampler: {
      "^": "StreamView;$ti",
      $asStream: function($T, $S, $O) {
        return [$S];
      },
      $asStreamView: function($T, $S, $O) {
        return [$S];
      }
    },
    _OnCountSampler: {
      "^": "StreamView;$ti",
      $asStream: function($T, $S) {
        return [$S];
      },
      $asStreamView: function($T, $S) {
        return [$S];
      }
    },
    _OnTestSampler: {
      "^": "StreamView;$ti",
      $asStream: function($T, $S) {
        return [$S];
      },
      $asStreamView: function($T, $S) {
        return [$S];
      }
    }
  }], ["", "package:rxdart/src/streams/amb.dart",, B, {
    "^": "",
    AmbStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/combine_latest.dart",, F, {
    "^": "",
    CombineLatestStream: {
      "^": "StreamView;$ti",
      $asStream: function($T, $R) {
        return [$R];
      },
      $asStreamView: function($T, $R) {
        return [$R];
      }
    }
  }], ["", "package:rxdart/src/streams/concat.dart",, R, {
    "^": "",
    ConcatStream: {
      "^": "Stream;controller,$ti",
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        H.boolTypeCheck(cancelOnError);
        return J.get$stream$z(this.controller).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      static: {
        ConcatStream$: [function(streams, $T) {
          return new R.ConcatStream(R.ConcatStream__buildController(streams, $T), [$T]);
        }, null, null, 4, 0, null, 340],
        ConcatStream__buildController: [1, function(streams, $T) {
          var t1, t2, controller;
          t1 = {};
          H.assertSubtype(streams, "$isIterable", [[P.Stream, $T]], "$asIterable");
          if (streams == null)
            throw H.wrapException(P.ArgumentError$("Streams cannot be null"));
          else {
            t2 = J.getInterceptor$asx(streams);
            if (t2.get$isEmpty(streams))
              throw H.wrapException(P.ArgumentError$("At least 1 stream needs to be provided"));
            else if (t2.any$1(streams, new R.ConcatStream__buildController_closure($T)))
              throw H.wrapException(P.ArgumentError$("One of the provided streams is null"));
          }
          t1.controller = null;
          t1.subscription = null;
          controller = P.StreamController_StreamController(new R.ConcatStream__buildController_closure0(t1), new R.ConcatStream__buildController_closure1(t1, streams), new R.ConcatStream__buildController_closure2(t1), new R.ConcatStream__buildController_closure3(t1), true, $T);
          t1.controller = controller;
          return controller;
        }, function(streams) {
          return R.ConcatStream__buildController(streams, null);
        }, null, "call$1", null, 4, 0, null, 340]
      }
    },
    ConcatStream__buildController_closure: {
      "^": "Closure;T,$ti",
      call$1: [function(stream) {
        return H.assertSubtype(stream, "$isStream", [this.T], "$asStream") == null;
      }, null, null, 4, 0, null, 57, "call"],
      $signature: function() {
        return {func: 1, ret: P.bool, args: [[P.Stream, this.T]]};
      }
    },
    ConcatStream__buildController_closure1: {
      "^": "Closure:1;_box_1,streams,$ti",
      call$0: [function() {
        var t1, t2, len;
        t1 = {};
        t2 = this.streams;
        len = J.get$length$asx(t2);
        t1.index = 0;
        new R.ConcatStream__buildController_closure_moveNext(t1, this._box_1, t2, len).call$0();
      }, null, null, 0, 0, null, "call"]
    },
    ConcatStream__buildController_closure_moveNext: {
      "^": "Closure:0;_box_0,_box_1,streams,len,$ti",
      call$0: [function() {
        var t1, stream, t2, t3;
        t1 = this._box_0;
        stream = J.elementAt$1$ax(this.streams, t1.index);
        t2 = this._box_1;
        t3 = t2.subscription;
        if (!(t3 == null))
          t3.cancel$0();
        t2.subscription = stream.listen$3$onDone$onError(J.get$add$ax(t2.controller), new R.ConcatStream__buildController__moveNext_closure(t1, t2, this.len, this), t2.controller.get$addError());
      }, null, null, 0, 0, null, "call"]
    },
    ConcatStream__buildController__moveNext_closure: {
      "^": "Closure:1;_box_0,_box_1,len,moveNext,$ti",
      call$0: [function() {
        var t1, index;
        t1 = this._box_0;
        index = J.$add$ansx(t1.index, 1);
        t1.index = index;
        t1 = this.len;
        if (index == null ? t1 == null : index === t1)
          J.close$0$z(this._box_1.controller);
        else
          this.moveNext.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    ConcatStream__buildController_closure2: {
      "^": "Closure:69;_box_1,$ti",
      call$1: [function(resumeSignal) {
        var t1;
        H.interceptedTypeCheck(resumeSignal, "$isFuture");
        t1 = this._box_1.subscription;
        return t1 == null ? null : J.pause$1$z(t1, resumeSignal);
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 0, 175, "call"]
    },
    ConcatStream__buildController_closure3: {
      "^": "Closure:0;_box_1,$ti",
      call$0: [function() {
        var t1 = this._box_1.subscription;
        return t1 == null ? null : t1.resume$0();
      }, null, null, 0, 0, null, "call"]
    },
    ConcatStream__buildController_closure0: {
      "^": "Closure:8;_box_1,$ti",
      call$0: [function() {
        return this._box_1.subscription.cancel$0();
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:rxdart/src/streams/concat_eager.dart",, R, {
    "^": "",
    ConcatEagerStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/defer.dart",, D, {
    "^": "",
    DeferStream: {
      "^": "Stream;_streamFactory,_isReusable,_defer$_isUsed,$ti",
      get$isBroadcast: [function() {
        return this._isReusable;
      }, null, null, 2, 0, null],
      listen$4$cancelOnError$onDone$onError: [function(onData, cancelOnError, onDone, onError) {
        H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
        H.interceptedTypeCheck(onError, "$isFunction");
        H.functionTypeCheck(onDone, {func: 1, ret: -1});
        H.boolTypeCheck(cancelOnError);
        if (this._defer$_isUsed && !this._isReusable)
          throw H.wrapException(P.StateError$("Stream has already been listened to."));
        this._defer$_isUsed = true;
        return this._streamFactory.call$0().listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }, function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }, "listen$1", function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      }, "listen$3$onDone$onError", null, null, null, "get$listen", 4, 7, null, 0, 0, 0, 32, 45, 47, 31],
      static: {
        DeferStream$: [function(_streamFactory, reusable, $T) {
          return new D.DeferStream(_streamFactory, reusable, false, [$T]);
        }, null, null, 4, 3, null, 18, 1025, 543]
      }
    }
  }], ["", "package:rxdart/src/streams/error.dart",, V, {
    "^": "",
    ErrorStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/merge.dart",, S, {
    "^": "",
    MergeStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/never.dart",, F, {
    "^": "",
    NeverStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/race.dart",, N, {
    "^": "",
    RaceStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/range.dart",, G, {
    "^": "",
    RangeStream: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [P.int];
      }
    }
  }], ["", "package:rxdart/src/streams/repeat.dart",, V, {
    "^": "",
    RepeatStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/retry.dart",, T, {
    "^": "",
    RetryStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/retry_when.dart",, U, {
    "^": "",
    RetryWhenStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/switch_latest.dart",, Z, {
    "^": "",
    SwitchLatestStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/timer.dart",, U, {
    "^": "",
    TimerStream: {
      "^": "Stream;$ti"
    }
  }], ["", "package:rxdart/src/streams/tween.dart",, R, {
    "^": "",
    TweenStream: {
      "^": "Stream;$ti",
      $asStream: function() {
        return [P.double];
      }
    },
    Ease: {
      "^": "Object;$ti"
    }
  }], ["", "package:rxdart/src/streams/utils.dart",, B, {
    "^": "",
    RetryError: {
      "^": "Error;$ti"
    },
    ErrorAndStacktrace: {
      "^": "Object;$ti"
    }
  }], ["", "package:rxdart/src/streams/zip.dart",, S, {
    "^": "",
    ZipStream: {
      "^": "StreamView;$ti",
      $asStream: function($T, $R) {
        return [$R];
      },
      $asStreamView: function($T, $R) {
        return [$R];
      }
    }
  }], ["", "package:rxdart/src/subjects/behavior_subject.dart",, U, {
    "^": "",
    BehaviorSubject: {
      "^": "Subject;_wrapper,controller,_isAddingStreamItems,_observable$_stream,$ti",
      onAdd$1: [function($event) {
        this._wrapper.set$latestValue(H.assertSubtypeOfRuntimeType($event, H.getTypeArgumentByIndex(this, 0)));
      }, null, "get$onAdd", 4, 0, null, 22],
      get$stream: [function(_) {
        return this;
      }, null, null, 3, 0, null],
      get$value: [function(_) {
        return this._wrapper.get$latestValue();
      }, null, null, 3, 0, null],
      $isValueObservable: 1,
      static: {
        BehaviorSubject$_: [function(controller, observable, _wrapper, $T) {
          return new U.BehaviorSubject(_wrapper, controller, false, observable, [$T]);
        }, null, null, 12, 0, null, 265, 1026, 1027],
        BehaviorSubject_BehaviorSubject: [function(onCancel, onListen, seedValue, sync, $T) {
          var t1, controller, wrapper;
          H.assertSubtypeOfRuntimeType(seedValue, $T);
          t1 = {func: 1, ret: -1};
          H.functionTypeCheck(onListen, t1);
          controller = P.StreamController_StreamController$broadcast(H.functionTypeCheck(onCancel, t1), onListen, H.boolTypeCheck(sync), $T);
          wrapper = U._Wrapper$(seedValue, $T);
          return U.BehaviorSubject$_(controller, X.Observable_Observable$defer(new U.BehaviorSubject_BehaviorSubject_closure(wrapper, controller, $T), true, $T), wrapper, $T);
        }, null, null, 0, 9, null, 0, 0, 0, 18, 139, 138, 1028, 275]
      }
    },
    BehaviorSubject_BehaviorSubject_closure: {
      "^": "Closure;wrapper,controller,T,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.wrapper;
        t2 = this.controller;
        return t1.get$latestValue() == null ? J.get$stream$z(t2) : X.Observable$(J.get$stream$z(t2), this.T).startWith$1(t1.get$latestValue());
      }, null, null, 0, 0, null, "call"],
      $signature: function() {
        return {func: 1, ret: [P.Stream, this.T]};
      }
    },
    _Wrapper: {
      "^": "Object;latestValue<,$ti",
      set$latestValue: function(latestValue) {
        this.latestValue = H.assertSubtypeOfRuntimeType(latestValue, H.getTypeArgumentByIndex(this, 0));
      },
      static: {
        _Wrapper$: [function(latestValue, $T) {
          return new U._Wrapper(latestValue, [$T]);
        }, null, null, 4, 0, null, 1029]
      }
    }
  }], ["", "package:rxdart/src/subjects/publish_subject.dart",, S, {
    "^": "",
    PublishSubject: {
      "^": "Subject;$ti"
    }
  }], ["", "package:rxdart/src/subjects/replay_subject.dart",, S, {
    "^": "",
    ReplaySubject: {
      "^": "Subject;$ti",
      $isReplayObservable: 1
    }
  }], ["", "package:rxdart/src/subjects/subject.dart",, F, {
    "^": "",
    Subject: {
      "^": "Observable;$ti",
      set$onListen: [function(onListenHandler) {
        this.controller.set$onListen(H.functionTypeCheck(onListenHandler, {func: 1, ret: -1}));
      }, null, null, 6, 0, null, 1030],
      get$stream: [function(_) {
        return this;
      }, null, null, 3, 0, null],
      set$onCancel: [function(onCancelHandler) {
        this.controller.set$onCancel(H.functionTypeCheck(onCancelHandler, {func: 1, ret: -1}));
      }, null, null, 6, 0, null, 1031],
      addError$2: [function(error, stackTrace) {
        H.interceptedTypeCheck(stackTrace, "$isStackTrace");
        if (this._isAddingStreamItems)
          throw H.wrapException(P.StateError$("You cannot add an error while items are being added from addStream"));
        this.controller.addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 4, 2, 5, 0, 14, 20],
      add$1: [function(_, $event) {
        H.assertSubtypeOfRuntimeType($event, H.getTypeArgumentByIndex(this, 0));
        if (this._isAddingStreamItems)
          throw H.wrapException(P.StateError$("You cannot add items while items are being added from addStream"));
        this._subject$_add$1($event);
      }, "call$1", "get$add", 5, 0, 2, 22],
      _subject$_add$1: [function($event) {
        H.assertSubtypeOfRuntimeType($event, H.getTypeArgumentByIndex(this, 0));
        this.onAdd$1($event);
        J.add$1$ax(this.controller, $event);
      }, null, "get$_subject$_add", 4, 0, null, 22],
      close$0: [function(_) {
        if (this._isAddingStreamItems)
          throw H.wrapException(P.StateError$("You cannot close the subject while items are being added from addStream"));
        return J.close$0$z(this.controller);
      }, "call$0", "get$close", 1, 0, 8],
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isStreamController: 1,
      $isSink: 1
    },
    _StreamSinkWrapper0: {
      "^": "Object;$ti",
      $isEventSink: 1,
      $isStreamConsumer: 1,
      $isStreamSink: 1,
      $isSink: 1
    }
  }], ["", "package:rxdart/src/transformers/buffer.dart",, D, {
    "^": "",
    BufferStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, [P.List, $T]];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, [P.List, $T]];
      }
    }
  }], ["", "package:rxdart/src/transformers/buffer_with_count.dart",, N, {
    "^": "",
    BufferWithCountStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, [P.List, $T]];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, [P.List, $T]];
      }
    }
  }], ["", "package:rxdart/src/transformers/debounce.dart",, T, {
    "^": "",
    DebounceStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/default_if_empty.dart",, L, {
    "^": "",
    DefaultIfEmptyStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/delay.dart",, U, {
    "^": "",
    DelayStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/dematerialize.dart",, G, {
    "^": "",
    DematerializeStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [[D.Notification0, $T], $T];
      },
      $asStreamTransformerBase: function($T) {
        return [[D.Notification0, $T], $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/distinct_unique.dart",, U, {
    "^": "",
    DistinctUniqueStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/do.dart",, D, {
    "^": "",
    DoStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/exhaust_map.dart",, A, {
    "^": "",
    ExhaustMapStreamTransformer: {
      "^": "StreamTransformerBase;$ti"
    }
  }], ["", "package:rxdart/src/transformers/flat_map.dart",, N, {
    "^": "",
    FlatMapStreamTransformer: {
      "^": "StreamTransformerBase;$ti"
    }
  }], ["", "package:rxdart/src/transformers/flat_map_latest.dart",, X, {
    "^": "",
    FlatMapLatestStreamTransformer: {
      "^": "StreamTransformerBase;$ti"
    }
  }], ["", "package:rxdart/src/transformers/ignore_elements.dart",, F, {
    "^": "",
    IgnoreElementsStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/interval.dart",, O, {
    "^": "",
    IntervalStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/map_to.dart",, T, {
    "^": "",
    MapToStreamTransformer: {
      "^": "StreamTransformerBase;$ti"
    }
  }], ["", "package:rxdart/src/transformers/materialize.dart",, V, {
    "^": "",
    MaterializeStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, [D.Notification0, $T]];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, [D.Notification0, $T]];
      }
    }
  }], ["", "package:rxdart/src/transformers/of_type.dart",, G, {
    "^": "",
    OfTypeStreamTransformer: {
      "^": "StreamTransformerBase;$ti"
    }
  }], ["", "package:rxdart/src/transformers/on_error_resume.dart",, K, {
    "^": "",
    OnErrorResumeStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/on_error_resume_next.dart",, N, {
    "^": "",
    OnErrorResumeNextStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/sample.dart",, D, {
    "^": "",
    SampleStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/scan.dart",, N, {
    "^": "",
    ScanStreamTransformer: {
      "^": "StreamTransformerBase;$ti"
    }
  }], ["", "package:rxdart/src/transformers/skip_until.dart",, T, {
    "^": "",
    SkipUntilStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T, $S) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T, $S) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/start_with.dart",, G, {
    "^": "",
    StartWithStreamTransformer: {
      "^": "StreamTransformerBase;transformer,$ti",
      bind$1: [function(stream) {
        return this.transformer.bind$1(H.assertSubtype(stream, "$isStream", this.$ti, "$asStream"));
      }, null, "get$bind", 4, 0, null, 57],
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      },
      static: {
        StartWithStreamTransformer$: [function(startValue, $T) {
          return new G.StartWithStreamTransformer(G.StartWithStreamTransformer__buildTransformer(startValue, $T), [$T]);
        }, null, null, 4, 0, null, 341],
        StartWithStreamTransformer__buildTransformer: [1, function(startValue, $T) {
          return P._StreamSubscriptionTransformer$(new G.StartWithStreamTransformer__buildTransformer_closure(H.assertSubtypeOfRuntimeType(startValue, $T), $T), $T, $T);
        }, function(startValue) {
          return G.StartWithStreamTransformer__buildTransformer(startValue, null);
        }, null, "call$1", null, 4, 0, null, 341]
      }
    },
    StartWithStreamTransformer__buildTransformer_closure: {
      "^": "Closure;startValue,T,$ti",
      call$2: [function(input, cancelOnError) {
        var t1, t2, controller;
        t1 = {};
        t2 = this.T;
        H.assertSubtype(input, "$isStream", [t2], "$asStream");
        H.boolTypeCheck(cancelOnError);
        t1.controller = null;
        t1.subscription = null;
        controller = P.StreamController_StreamController(new G.StartWithStreamTransformer__buildTransformer__closure(t1), new G.StartWithStreamTransformer__buildTransformer__closure0(t1, this.startValue, input, cancelOnError), new G.StartWithStreamTransformer__buildTransformer__closure1(t1), new G.StartWithStreamTransformer__buildTransformer__closure2(t1), true, t2);
        t1.controller = controller;
        return controller.get$stream(controller).listen$1(null);
      }, null, null, 8, 0, null, 55, 45, "call"],
      $signature: function() {
        var t1 = this.T;
        return {func: 1, ret: [P.StreamSubscription, t1], args: [[P.Stream, t1], P.bool]};
      }
    },
    StartWithStreamTransformer__buildTransformer__closure0: {
      "^": "Closure:1;_box_0,startValue,input,cancelOnError,$ti",
      call$0: [function() {
        var e, s, exception, t1, t2, t3;
        try {
          J.add$1$ax(this._box_0.controller, this.startValue);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this._box_0.controller.addError$2(e, s);
        }
        t1 = this._box_0;
        t2 = J.get$add$ax(t1.controller);
        t3 = t1.controller.get$addError();
        t1.subscription = this.input.listen$4$cancelOnError$onDone$onError(t2, this.cancelOnError, J.get$close$z(t1.controller), t3);
      }, null, null, 0, 0, null, "call"]
    },
    StartWithStreamTransformer__buildTransformer__closure1: {
      "^": "Closure:69;_box_0,$ti",
      call$1: [function(resumeSignal) {
        H.interceptedTypeCheck(resumeSignal, "$isFuture");
        return J.pause$1$z(this._box_0.subscription, resumeSignal);
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 0, 175, "call"]
    },
    StartWithStreamTransformer__buildTransformer__closure2: {
      "^": "Closure:0;_box_0,$ti",
      call$0: [function() {
        return this._box_0.subscription.resume$0();
      }, null, null, 0, 0, null, "call"]
    },
    StartWithStreamTransformer__buildTransformer__closure: {
      "^": "Closure:8;_box_0,$ti",
      call$0: [function() {
        return this._box_0.subscription.cancel$0();
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:rxdart/src/transformers/start_with_many.dart",, F, {
    "^": "",
    StartWithManyStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/switch_if_empty.dart",, L, {
    "^": "",
    SwitchIfEmptyStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/switch_map.dart",, X, {
    "^": "",
    SwitchMapStreamTransformer: {
      "^": "StreamTransformerBase;$ti"
    }
  }], ["", "package:rxdart/src/transformers/take_until.dart",, Q, {
    "^": "",
    TakeUntilStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T, $S) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T, $S) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/throttle.dart",, Z, {
    "^": "",
    ThrottleStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, $T];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, $T];
      }
    }
  }], ["", "package:rxdart/src/transformers/time_interval.dart",, T, {
    "^": "",
    TimeIntervalStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, [T.TimeInterval, $T]];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, [T.TimeInterval, $T]];
      }
    },
    TimeInterval: {
      "^": "Object;$ti"
    }
  }], ["", "package:rxdart/src/transformers/timestamp.dart",, E, {
    "^": "",
    TimestampStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, [E.Timestamped, $T]];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, [E.Timestamped, $T]];
      }
    },
    Timestamped: {
      "^": "Object;$ti"
    }
  }], ["", "package:rxdart/src/transformers/window.dart",, T, {
    "^": "",
    WindowStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, [P.Stream, $T]];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, [P.Stream, $T]];
      }
    }
  }], ["", "package:rxdart/src/transformers/window_with_count.dart",, E, {
    "^": "",
    WindowWithCountStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T) {
        return [$T, [P.Stream, $T]];
      },
      $asStreamTransformerBase: function($T) {
        return [$T, [P.Stream, $T]];
      }
    }
  }], ["", "package:rxdart/src/transformers/with_latest_from.dart",, V, {
    "^": "",
    WithLatestFromStreamTransformer: {
      "^": "StreamTransformerBase;$ti",
      $asStreamTransformer: function($T, $S, $R) {
        return [$T, $R];
      },
      $asStreamTransformerBase: function($T, $S, $R) {
        return [$T, $R];
      }
    }
  }], ["", "package:rxdart/src/utils/composite_subscription.dart",, K, {
    "^": "",
    CompositeSubscription: {
      "^": "Object;$ti"
    }
  }], ["", "package:rxdart/src/utils/notification.dart",, D, {
    "^": "",
    Kind: {
      "^": "Object;$ti"
    },
    Notification0: {
      "^": "Object;$ti"
    }
  }], ["", "package:rxdart/src/utils/type_token.dart",, Q, {
    "^": "",
    TypeToken: {
      "^": "Object;$ti"
    }
  }], ["", "package:source_span/src/file.dart",, Y, {
    "^": "",
    SourceFile: {
      "^": "Object;url>,_lineStarts,_decodedChars,0_cachedLine,$ti",
      get$length: [function(_) {
        return J.get$length$asx(this._decodedChars);
      }, null, null, 3, 0, null],
      get$lines: [function() {
        return J.get$length$asx(this._lineStarts);
      }, null, null, 2, 0, null],
      SourceFile$decoded$2$url: [function(decodedChars, url) {
        var t1, t2, t3, t4, i, t5, c, j;
        t1 = this._decodedChars;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._lineStarts;
        t4 = J.getInterceptor$ax(t3);
        i = 0;
        while (true) {
          t5 = t2.get$length(t1);
          if (typeof t5 !== "number")
            return H.iae(t5);
          if (!(i < t5))
            break;
          c = t2.$index(t1, i);
          if (c === 13) {
            j = i + 1;
            t5 = t2.get$length(t1);
            if (typeof t5 !== "number")
              return H.iae(t5);
            if (j >= t5 || !J.$eq$(t2.$index(t1, j), 10))
              c = 10;
          }
          if (c === 10)
            t4.add$1(t3, i + 1);
          ++i;
        }
      }, null, null, 4, 3, null, 0, 1034, 62],
      span$2: [function(_, start, end) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        return Y._FileSpan$(this, start, end == null ? this.get$length(this) : end);
      }, function($receiver, start) {
        return this.span$2($receiver, start, null);
      }, "span$1", "call$2", "call$1", "get$span", 5, 2, 200, 0, 5, 7],
      getLine$1: [function(offset) {
        var t1, t2, t3;
        H.intTypeCheck(offset);
        if (typeof offset !== "number")
          return offset.$lt();
        if (offset < 0)
          throw H.wrapException(P.RangeError$("Offset may not be negative, was " + offset + "."));
        else {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (offset > t1)
            throw H.wrapException(P.RangeError$("Offset " + offset + " must not be greater than the number of characters in the file, " + H.S(this.get$length(this)) + "."));
        }
        t1 = this._lineStarts;
        t2 = J.getInterceptor$ax(t1);
        t3 = t2.get$first(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (offset < t3)
          return -1;
        t3 = t2.get$last(t1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (offset >= t3)
          return J.$sub$n(t2.get$length(t1), 1);
        if (this._isNearCachedLine$1(offset))
          return this._cachedLine;
        t1 = H.intTypeCheck(J.$sub$n(this._binarySearch$1(offset), 1));
        this._cachedLine = t1;
        return t1;
      }, null, "get$getLine", 4, 0, null, 52],
      _isNearCachedLine$1: [function(offset) {
        var t1, t2, t3;
        H.intTypeCheck(offset);
        t1 = this._cachedLine;
        if (t1 == null)
          return false;
        t2 = this._lineStarts;
        t3 = J.getInterceptor$asx(t2);
        t1 = t3.$index(t2, t1);
        if (typeof offset !== "number")
          return offset.$lt();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (offset < t1)
          return false;
        if (!J.$ge$n(this._cachedLine, J.$sub$n(t3.get$length(t2), 1))) {
          t1 = t3.$index(t2, J.$add$ansx(this._cachedLine, 1));
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = offset < t1;
        } else
          t1 = true;
        if (t1)
          return true;
        if (!J.$ge$n(this._cachedLine, J.$sub$n(t3.get$length(t2), 2))) {
          t1 = t3.$index(t2, J.$add$ansx(this._cachedLine, 2));
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = offset < t1;
        } else
          t1 = true;
        if (t1) {
          this._cachedLine = H.intTypeCheck(J.$add$ansx(this._cachedLine, 1));
          return true;
        }
        return false;
      }, null, "get$_isNearCachedLine", 4, 0, null, 52],
      _binarySearch$1: [function(offset) {
        var t1, t2, max, min, half;
        H.intTypeCheck(offset);
        t1 = this._lineStarts;
        t2 = J.getInterceptor$asx(t1);
        max = J.$sub$n(t2.get$length(t1), 1);
        min = 0;
        while (true) {
          if (typeof max !== "number")
            return H.iae(max);
          if (!(min < max))
            break;
          half = min + C.JSInt_methods._tdivFast$1(max - min, 2);
          if (J.$gt$n(t2.$index(t1, half), offset))
            max = half;
          else
            min = half + 1;
        }
        return max;
      }, null, "get$_binarySearch", 4, 0, null, 52],
      getColumn$2$line: [function(offset, line) {
        var t1, lineStart;
        H.intTypeCheck(offset);
        H.intTypeCheck(line);
        if (typeof offset !== "number")
          return offset.$lt();
        if (offset < 0)
          throw H.wrapException(P.RangeError$("Offset may not be negative, was " + offset + "."));
        else {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (offset > t1)
            throw H.wrapException(P.RangeError$("Offset " + offset + " must be not be greater than the number of characters in the file, " + H.S(this.get$length(this)) + "."));
        }
        if (line == null)
          line = this.getLine$1(offset);
        else if (line < 0)
          throw H.wrapException(P.RangeError$("Line may not be negative, was " + H.S(line) + "."));
        else {
          t1 = this.get$lines();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (line >= t1)
            throw H.wrapException(P.RangeError$("Line " + H.S(line) + " must be less than the number of lines in the file, " + H.S(this.get$lines()) + "."));
        }
        lineStart = J.$index$asx(this._lineStarts, line);
        if (typeof lineStart !== "number")
          return lineStart.$gt();
        if (lineStart > offset)
          throw H.wrapException(P.RangeError$("Line " + H.S(line) + " comes after offset " + offset + "."));
        return offset - lineStart;
      }, function(offset) {
        return this.getColumn$2$line(offset, null);
      }, "getColumn$1", null, null, "get$getColumn", 4, 3, null, 0, 52, 49],
      getOffset$2: [function(line, column) {
        var t1, t2, result, t3, t4;
        H.intTypeCheck(line);
        H.intTypeCheck(column);
        if (column == null)
          column = 0;
        if (typeof line !== "number")
          return line.$lt();
        if (line < 0)
          throw H.wrapException(P.RangeError$("Line may not be negative, was " + line + "."));
        else {
          t1 = this.get$lines();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (line >= t1)
            throw H.wrapException(P.RangeError$("Line " + line + " must be less than the number of lines in the file, " + H.S(this.get$lines()) + "."));
          else if (column < 0)
            throw H.wrapException(P.RangeError$("Column may not be negative, was " + column + "."));
        }
        t1 = this._lineStarts;
        t2 = J.getInterceptor$asx(t1);
        result = J.$add$ansx(t2.$index(t1, line), column);
        t3 = this.get$length(this);
        if (typeof result !== "number")
          return result.$gt();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(result > t3)) {
          t3 = line + 1;
          t4 = this.get$lines();
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (t3 < t4) {
            t1 = t2.$index(t1, t3);
            if (typeof t1 !== "number")
              return H.iae(t1);
            t1 = result >= t1;
          } else
            t1 = false;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.RangeError$("Line " + line + " doesn't have " + column + " columns."));
        return result;
      }, function(line) {
        return this.getOffset$2(line, null);
      }, "getOffset$1", null, null, "get$getOffset", 4, 2, null, 0, 49, 99],
      getText$2: [function(start, end) {
        return P.String_String$fromCharCodes(J.sublist$2$ax(this._decodedChars, H.intTypeCheck(start), H.intTypeCheck(end)), 0, null);
      }, null, "get$getText", 4, 2, null, 0, 5, 7],
      static: {
        SourceFile$fromString: [function(text, url) {
          var t1, t2;
          t1 = J.get$codeUnits$s(text);
          t2 = H.setRuntimeTypeInfo([0], [P.int]);
          t2 = new Y.SourceFile(H.interceptedTypeCheck(typeof url === "string" ? P.Uri_parse(url, 0, null) : url, "$isUri"), t2, H.NativeUint32List_NativeUint32List$fromList(J.toList$0$ax(t1)), []);
          t2.SourceFile$decoded$2$url(t1, url);
          return t2;
        }, null, null, 4, 3, null, 0, 17, 62]
      }
    },
    FileLocation: {
      "^": "SourceLocationMixin;file,offset>,$ti",
      get$sourceUrl: [function() {
        return J.get$url$z(this.file);
      }, null, null, 2, 0, null],
      get$line: [function() {
        return this.file.getLine$1(this.offset);
      }, null, null, 2, 0, null],
      get$column: [function() {
        return this.file.getColumn$1(this.offset);
      }, null, null, 2, 0, null],
      FileLocation$_$2: [function(file, offset) {
        var t1, t2, t3, t4;
        t1 = this.offset;
        t2 = J.getInterceptor$n(t1);
        if (t2.$lt(t1, 0))
          throw H.wrapException(P.RangeError$("Offset may not be negative, was " + H.S(t1) + "."));
        else {
          t3 = this.file;
          t4 = J.getInterceptor$asx(t3);
          if (t2.$gt(t1, t4.get$length(t3)))
            throw H.wrapException(P.RangeError$("Offset " + H.S(t1) + " must not be greater than the number of characters in the file, " + H.S(t4.get$length(t3)) + "."));
        }
      }, null, null, 8, 0, null, 263, 52],
      static: {
        FileLocation$_: [function(file, offset) {
          var t1 = new Y.FileLocation(file, offset, []);
          t1.FileLocation$_$2(file, offset);
          return t1;
        }, null, null, 8, 0, null, 263, 52]
      }
    },
    FileSpan: {
      "^": "Object;$ti",
      $isComparable: 1,
      $asComparable: function() {
        return [V.SourceSpan];
      },
      $isSourceSpan: 1,
      $isSourceSpanBase: 1,
      $isSourceSpanMixin: 1,
      $isSourceSpanWithContext: 1
    },
    _FileSpan: {
      "^": "SourceSpanMixin;file,_file$_start,_end,$ti",
      get$sourceUrl: [function() {
        return J.get$url$z(this.file);
      }, null, null, 2, 0, null],
      get$length: [function(_) {
        return J.$sub$n(this._end, this._file$_start);
      }, null, null, 3, 0, null],
      get$start: [function(_) {
        return Y.FileLocation$_(this.file, this._file$_start);
      }, null, null, 3, 0, null],
      get$end: [function() {
        return Y.FileLocation$_(this.file, this._end);
      }, null, null, 2, 0, null],
      get$text: [function(_) {
        return this.file.getText$2(this._file$_start, this._end);
      }, null, null, 3, 0, null],
      get$context: [function() {
        var t1, endOffset, endLine, t2;
        t1 = this.file;
        endOffset = this._end;
        endLine = t1.getLine$1(endOffset);
        if (t1.getColumn$1(endOffset) === 0 && endLine !== 0) {
          if (J.$eq$(this.get$length(this), 0)) {
            t2 = J.$sub$n(t1.get$lines(), 1);
            if (endLine == null ? t2 == null : endLine === t2)
              t1 = "";
            else {
              t2 = t1.getOffset$1(endLine);
              if (typeof endLine !== "number")
                return endLine.$add();
              t1 = t1.getText$2(t2, t1.getOffset$1(endLine + 1));
            }
            return t1;
          }
        } else {
          t2 = J.$sub$n(t1.get$lines(), 1);
          if (endLine == null ? t2 == null : endLine === t2)
            endOffset = J.get$length$asx(t1);
          else {
            if (typeof endLine !== "number")
              return endLine.$add();
            endOffset = t1.getOffset$1(endLine + 1);
          }
        }
        return t1.getText$2(t1.getOffset$1(t1.getLine$1(this._file$_start)), endOffset);
      }, null, null, 2, 0, null],
      _FileSpan$3: [function(file, _start, _end) {
        var t1, t2, t3, t4, t5;
        t1 = this._end;
        t2 = this._file$_start;
        t3 = J.getInterceptor$n(t1);
        if (t3.$lt(t1, t2))
          throw H.wrapException(P.ArgumentError$("End " + H.S(t1) + " must come after start " + H.S(t2) + "."));
        else {
          t4 = this.file;
          t5 = J.getInterceptor$asx(t4);
          if (t3.$gt(t1, t5.get$length(t4)))
            throw H.wrapException(P.RangeError$("End " + H.S(t1) + " must not be greater than the number of characters in the file, " + H.S(t5.get$length(t4)) + "."));
          else if (J.$lt$n(t2, 0))
            throw H.wrapException(P.RangeError$("Start may not be negative, was " + H.S(t2) + "."));
        }
      }, null, null, 12, 0, null, 263, 185, 545],
      compareTo$1: [function(_, other) {
        var result;
        H.interceptedTypeCheck(other, "$isSourceSpan");
        if (!(other instanceof Y._FileSpan))
          return this.super$SourceSpanMixin$compareTo(0, other);
        result = J.compareTo$1$ns(this._file$_start, other._file$_start);
        return result === 0 ? J.compareTo$1$ns(this._end, other._end) : result;
      }, null, "get$compareTo", 5, 0, null, 3],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        if (!J.getInterceptor$(other).$isFileSpan)
          return this.super$SourceSpanMixin$$eq(0, other);
        return J.$eq$(this._file$_start, other._file$_start) && J.$eq$(this._end, other._end) && J.$eq$(this.get$sourceUrl(), other.get$sourceUrl());
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return Y.SourceSpanMixin.prototype.get$hashCode.call(this, this);
      }, null, null, 3, 0, null],
      $isFileSpan: 1,
      $isSourceSpanBase: 1,
      $isSourceSpanWithContext: 1,
      static: {
        _FileSpan$: [function(file, _start, _end) {
          var t1 = new Y._FileSpan(file, _start, _end, []);
          t1._FileSpan$3(file, _start, _end);
          return t1;
        }, null, null, 12, 0, null, 263, 185, 545]
      }
    }
  }], ["", "package:source_span/src/highlighter.dart",, U, {
    "^": "",
    Highlighter: {
      "^": "Object;_highlighter$_span,_color,_multiline,_paddingBeforeSidebar<,_highlighter$_buffer<,$ti",
      get$_paddingAfterSidebar: [function() {
        return this._multiline ? 3 : 1;
      }, null, null, 2, 0, null],
      highlight$0: [function(_) {
        var t1, t2, t3, lineStart, context, lines, t4, lineNumber, t5, lastLineIndex;
        this._writeSidebar$1$end(K.downEnd());
        t1 = this._highlighter$_buffer;
        t1.writeln$0();
        t2 = this._highlighter$_span;
        t3 = J.getInterceptor$x(t2);
        lineStart = B.findLineStart(t2.get$context(), t3.get$text(t2), t3.get$start(t2).get$column());
        context = t2.get$context();
        if (typeof lineStart !== "number")
          return lineStart.$gt();
        if (lineStart > 0) {
          lines = J.split$1$s(J.getInterceptor$s(context).substring$2(context, 0, lineStart - 1), "\n");
          t4 = J.getInterceptor$asx(lines);
          lineNumber = J.$sub$n(t3.get$start(t2).get$line(), t4.get$length(lines));
          for (t4 = t4.get$iterator(lines); t4.moveNext$0();) {
            t5 = t4.get$current();
            this._writeSidebar$1$line(lineNumber);
            t1.write$1(C.JSString_methods.$mul(" ", this.get$_paddingAfterSidebar()));
            this._writeText$1(t5);
            t1.writeln$0();
            if (typeof lineNumber !== "number")
              return lineNumber.$add();
            ++lineNumber;
          }
          context = C.JSString_methods.substring$1(context, lineStart);
        }
        lines = H.setRuntimeTypeInfo(context.split("\n"), [P.String]);
        lastLineIndex = J.$sub$n(t2.get$end().get$line(), t3.get$start(t2).get$line());
        if (J.get$isEmpty$asx(C.JSArray_methods.get$last(lines))) {
          t2 = lines.length;
          if (typeof lastLineIndex !== "number")
            return lastLineIndex.$add();
          t2 = t2 > lastLineIndex + 1;
        } else
          t2 = false;
        if (t2) {
          if (0 >= lines.length)
            return H.ioore(lines, -1);
          lines.pop();
        }
        this._writeFirstLine$1(C.JSArray_methods.get$first(lines));
        if (this._multiline) {
          t2 = C.JSArray_methods.skip$1(lines, 1);
          if (typeof lastLineIndex !== "number")
            return lastLineIndex.$sub();
          this._writeIntermediateLines$1(J.take$1$ax(t2, lastLineIndex - 1));
          if (lastLineIndex < 0 || lastLineIndex >= lines.length)
            return H.ioore(lines, lastLineIndex);
          this._writeLastLine$1(lines[lastLineIndex]);
        }
        if (typeof lastLineIndex !== "number")
          return lastLineIndex.$add();
        this._writeTrailingLines$1(C.JSArray_methods.skip$1(lines, lastLineIndex + 1));
        this._writeSidebar$1$end(K.upEnd());
        return J.toString$0$(t1);
      }, null, "get$highlight", 1, 0, null],
      _writeFirstLine$1: [function(line) {
        var t1, t2, t3, t4, t5, t6, startColumn, endColumn, textBefore, textInside, tabsBefore, tabsInside;
        t1 = {};
        H.stringTypeCheck(line);
        t2 = this._highlighter$_span;
        t3 = J.getInterceptor$x(t2);
        this._writeSidebar$1$line(t3.get$start(t2).get$line());
        t4 = t3.get$start(t2).get$column();
        t5 = line.length;
        t6 = P.int;
        startColumn = P.min(t4, t5, t6);
        t1.startColumn = startColumn;
        t4 = J.get$offset$z(t2.get$end());
        if (typeof startColumn !== "number")
          return startColumn.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        t2 = J.get$offset$z(t3.get$start(t2));
        if (typeof t2 !== "number")
          return H.iae(t2);
        endColumn = P.min(startColumn + t4 - t2, t5, t6);
        t1.endColumn = endColumn;
        textBefore = J.substring$2$s(line, 0, startColumn);
        t2 = this._multiline;
        if (t2 && this._isOnlyWhitespace$1(textBefore)) {
          t1 = this._highlighter$_buffer;
          t1.write$1(" ");
          this._colorize$1(new U.Highlighter__writeFirstLine_closure(this, line));
          t1.writeln$0();
          return;
        }
        t3 = this._highlighter$_buffer;
        t3.write$1(C.JSString_methods.$mul(" ", this.get$_paddingAfterSidebar()));
        this._writeText$1(textBefore);
        textInside = C.JSString_methods.substring$2(line, startColumn, endColumn);
        this._colorize$1(new U.Highlighter__writeFirstLine_closure0(this, textInside));
        this._writeText$1(C.JSString_methods.substring$1(line, endColumn));
        t3.writeln$0();
        tabsBefore = this._countTabs$1(textBefore);
        tabsInside = this._countTabs$1(textInside);
        if (typeof tabsBefore !== "number")
          return tabsBefore.$mul();
        startColumn += tabsBefore * 3;
        t1.startColumn = startColumn;
        if (typeof tabsInside !== "number")
          return H.iae(tabsInside);
        if (typeof endColumn !== "number")
          return endColumn.$add();
        t1.endColumn = endColumn + (tabsBefore + tabsInside) * 3;
        this._writeSidebar$0();
        if (t2) {
          t3.write$1(" ");
          this._colorize$1(new U.Highlighter__writeFirstLine_closure1(t1, this));
        } else {
          t3.write$1(C.JSString_methods.$mul(" ", startColumn + 1));
          this._colorize$1(new U.Highlighter__writeFirstLine_closure2(t1, this));
        }
        t3.writeln$0();
      }, null, "get$_writeFirstLine", 4, 0, null, 49],
      _writeIntermediateLines$1: [function(lines) {
        var lineNumber, t1, t2, t3;
        H.assertSubtype(lines, "$isIterable", [P.String], "$asIterable");
        lineNumber = J.$add$ansx(J.get$start$x(this._highlighter$_span).get$line(), 1);
        for (t1 = J.get$iterator$ax(lines), t2 = this._highlighter$_buffer; t1.moveNext$0();) {
          t3 = t1.get$current();
          this._writeSidebar$1$line(lineNumber);
          t2.write$1(" ");
          this._colorize$1(new U.Highlighter__writeIntermediateLines_closure(this, t3));
          t2.writeln$0();
          if (typeof lineNumber !== "number")
            return lineNumber.$add();
          ++lineNumber;
        }
      }, null, "get$_writeIntermediateLines", 4, 0, null, 546],
      _writeLastLine$1: [function(line) {
        var t1, t2, t3, endColumn, textInside, tabsInside;
        t1 = {};
        H.stringTypeCheck(line);
        t2 = this._highlighter$_span;
        this._writeSidebar$1$line(t2.get$end().get$line());
        t2 = t2.get$end().get$column();
        t3 = line.length;
        endColumn = P.min(t2, t3, P.int);
        t1.endColumn = endColumn;
        if (this._multiline && endColumn === t3) {
          t1 = this._highlighter$_buffer;
          t1.write$1(" ");
          this._colorize$1(new U.Highlighter__writeLastLine_closure(this, line));
          t1.writeln$0();
          return;
        }
        t2 = this._highlighter$_buffer;
        t2.write$1(" ");
        textInside = J.substring$2$s(line, 0, endColumn);
        this._colorize$1(new U.Highlighter__writeLastLine_closure0(this, textInside));
        this._writeText$1(C.JSString_methods.substring$1(line, endColumn));
        t2.writeln$0();
        tabsInside = this._countTabs$1(textInside);
        if (typeof tabsInside !== "number")
          return tabsInside.$mul();
        if (typeof endColumn !== "number")
          return endColumn.$add();
        t1.endColumn = endColumn + tabsInside * 3;
        this._writeSidebar$0();
        t2.write$1(" ");
        this._colorize$1(new U.Highlighter__writeLastLine_closure1(t1, this));
        t2.writeln$0();
      }, null, "get$_writeLastLine", 4, 0, null, 49],
      _writeTrailingLines$1: [function(lines) {
        var lineNumber, t1, t2, t3;
        H.assertSubtype(lines, "$isIterable", [P.String], "$asIterable");
        lineNumber = J.$add$ansx(this._highlighter$_span.get$end().get$line(), 1);
        for (t1 = J.get$iterator$ax(lines), t2 = this._highlighter$_buffer; t1.moveNext$0();) {
          t3 = t1.get$current();
          this._writeSidebar$1$line(lineNumber);
          t2.write$1(C.JSString_methods.$mul(" ", this.get$_paddingAfterSidebar()));
          this._writeText$1(t3);
          t2.writeln$0();
          if (typeof lineNumber !== "number")
            return lineNumber.$add();
          ++lineNumber;
        }
      }, null, "get$_writeTrailingLines", 4, 0, null, 546],
      _writeText$1: [function(text) {
        var t1, t2, t3;
        for (t1 = J.get$iterator$ax(J.get$codeUnits$s(H.stringTypeCheck(text))), t2 = this._highlighter$_buffer; t1.moveNext$0();) {
          t3 = t1.get$current();
          if (t3 === 9)
            t2.write$1(C.JSString_methods.$mul(" ", 4));
          else
            t2.writeCharCode$1(t3);
        }
      }, null, "get$_writeText", 4, 0, null, 17],
      _writeSidebar$2$end$line: [function(end, line) {
        this._colorize$2$color(new U.Highlighter__writeSidebar_closure(this, H.intTypeCheck(line), H.stringTypeCheck(end)), "\x1b[34m");
      }, function(end) {
        return this._writeSidebar$2$end$line(end, null);
      }, "_writeSidebar$1$end", function(line) {
        return this._writeSidebar$2$end$line(null, line);
      }, "_writeSidebar$1$line", function() {
        return this._writeSidebar$2$end$line(null, null);
      }, "_writeSidebar$0", null, null, null, null, "get$_writeSidebar", 0, 5, null, 0, 0, 7, 49],
      _countTabs$1: [function(text) {
        var t1, count;
        for (t1 = J.get$iterator$ax(J.get$codeUnits$s(H.stringTypeCheck(text))), count = 0; t1.moveNext$0();)
          if (t1.get$current() === 9)
            ++count;
        return count;
      }, null, "get$_countTabs", 4, 0, null, 17],
      _isOnlyWhitespace$1: [function(text) {
        var t1, t2;
        for (t1 = J.get$iterator$ax(J.get$codeUnits$s(H.stringTypeCheck(text))); t1.moveNext$0();) {
          t2 = t1.get$current();
          if (t2 !== 32 && t2 !== 9)
            return false;
        }
        return true;
      }, null, "get$_isOnlyWhitespace", 4, 0, null, 17],
      _colorize$2$color: [function(callback, color) {
        var t1, t2;
        H.functionTypeCheck(callback, {func: 1, ret: -1});
        H.stringTypeCheck(color);
        t1 = this._color;
        t2 = t1 != null;
        if (t2) {
          t1 = color == null ? t1 : color;
          this._highlighter$_buffer.write$1(t1);
        }
        callback.call$0();
        if (t2)
          this._highlighter$_buffer.write$1("\x1b[0m");
      }, function(callback) {
        return this._colorize$2$color(callback, null);
      }, "_colorize$1", null, null, "get$_colorize", 4, 3, null, 0, 43, 75],
      static: {
        Highlighter_Highlighter: [function(span, color) {
          H.interceptedTypeCheck(span, "$isSourceSpan");
          if (J.$eq$(color, true))
            color = "\x1b[31m";
          if (J.$eq$(color, false))
            color = null;
          return U.Highlighter$_(U.Highlighter__normalizeEndOfLine(U.Highlighter__normalizeTrailingNewline(U.Highlighter__normalizeNewlines(U.Highlighter__normalizeContext(span)))), H.stringTypeCheck(color));
        }, null, null, 4, 3, null, 0, 132, 75],
        Highlighter__normalizeContext: [function(span) {
          var t1, t2, t3, t4;
          H.interceptedTypeCheck(span, "$isSourceSpan");
          if (!!J.getInterceptor$(span).$isSourceSpanWithContext && B.findLineStart(span.get$context(), span.get$text(span), span.get$start(span).get$column()) != null)
            t1 = span;
          else {
            t1 = V.SourceLocation$(J.get$offset$z(span.get$start(span)), 0, 0, span.get$sourceUrl());
            t2 = J.get$offset$z(span.get$end());
            t3 = span.get$sourceUrl();
            t4 = B.countCodeUnits(span.get$text(span), 10);
            t3 = X.SourceSpanWithContext$(t1, V.SourceLocation$(t2, U.Highlighter__lastLineLength(span.get$text(span)), t4, t3), span.get$text(span), span.get$text(span));
            t1 = t3;
          }
          return t1;
        }, null, null, 4, 0, null, 132],
        Highlighter__normalizeNewlines: [function(span) {
          var text, endOffset, t1, i, t2, t3;
          H.interceptedTypeCheck(span, "$isSourceSpanWithContext");
          text = span.get$text(span);
          if (!J.getInterceptor$asx(text).contains$1(text, "\r\n"))
            return span;
          endOffset = J.get$offset$z(span.get$end());
          for (t1 = text.length - 1, i = 0; i < t1; ++i)
            if (J.$eq$(C.JSString_methods._codeUnitAt$1(text, i), 13) && J.$eq$(C.JSString_methods._codeUnitAt$1(text, i + 1), 10)) {
              if (typeof endOffset !== "number")
                return endOffset.$sub();
              --endOffset;
            }
          t1 = span.get$start(span);
          t2 = span.get$sourceUrl();
          t3 = span.get$end().get$line();
          return X.SourceSpanWithContext$(t1, V.SourceLocation$(endOffset, span.get$end().get$column(), t3, t2), C.JSString_methods.replaceAll$2(text, "\r\n", "\n"), J.replaceAll$2$s(span.get$context(), "\r\n", "\n"));
        }, null, null, 4, 0, null, 132],
        Highlighter__normalizeTrailingNewline: [function(span) {
          var context, text, start, end, t1, t2, t3;
          H.interceptedTypeCheck(span, "$isSourceSpanWithContext");
          if (!J.endsWith$1$s(span.get$context(), "\n"))
            return span;
          context = J.substring$2$s(span.get$context(), 0, J.$sub$n(J.get$length$asx(span.get$context()), 1));
          text = span.get$text(span);
          start = span.get$start(span);
          end = span.get$end();
          if (J.endsWith$1$s(span.get$text(span), "\n") && U.Highlighter__isTextAtEndOfContext(span)) {
            text = J.substring$2$s(span.get$text(span), 0, J.$sub$n(J.get$length$asx(span.get$text(span)), 1));
            t1 = J.$sub$n(J.get$offset$z(span.get$end()), 1);
            t2 = span.get$sourceUrl();
            t3 = J.$sub$n(span.get$end().get$line(), 1);
            end = V.SourceLocation$(t1, U.Highlighter__lastLineLength(text), t3, t2);
            start = J.$eq$(J.get$offset$z(span.get$start(span)), J.get$offset$z(span.get$end())) ? end : span.get$start(span);
          }
          return X.SourceSpanWithContext$(start, end, text, context);
        }, null, null, 4, 0, null, 132],
        Highlighter__normalizeEndOfLine: [function(span) {
          var text, t1, t2, t3, t4;
          H.interceptedTypeCheck(span, "$isSourceSpanWithContext");
          if (!J.$eq$(span.get$end().get$column(), 0))
            return span;
          if (J.$eq$(span.get$end().get$line(), span.get$start(span).get$line()))
            return span;
          text = J.substring$2$s(span.get$text(span), 0, J.$sub$n(J.get$length$asx(span.get$text(span)), 1));
          t1 = span.get$start(span);
          t2 = J.$sub$n(J.get$offset$z(span.get$end()), 1);
          t3 = span.get$sourceUrl();
          t4 = J.$sub$n(span.get$end().get$line(), 1);
          return X.SourceSpanWithContext$(t1, V.SourceLocation$(t2, U.Highlighter__lastLineLength(text), t4, t3), text, span.get$context());
        }, null, null, 4, 0, null, 132],
        Highlighter__lastLineLength: [function(text) {
          var t1, t2;
          H.stringTypeCheck(text);
          if (J.getInterceptor$asx(text).get$isEmpty(text))
            return 0;
          t1 = text.length;
          if (J.$eq$(C.JSString_methods.codeUnitAt$1(text, t1 - 1), 10)) {
            t2 = C.JSString_methods.lastIndexOf$2(text, "\n", t1 - 2);
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 - t2 - 1;
            t1 = t2;
          } else {
            t2 = C.JSString_methods.lastIndexOf$1(text, "\n");
            if (typeof t2 !== "number")
              return H.iae(t2);
            t2 = t1 - t2 - 1;
            t1 = t2;
          }
          return t1;
        }, null, null, 4, 0, null, 17],
        Highlighter__isTextAtEndOfContext: [function(span) {
          H.interceptedTypeCheck(span, "$isSourceSpanWithContext");
          return J.$eq$(J.$add$ansx(J.$add$ansx(B.findLineStart(span.get$context(), span.get$text(span), span.get$start(span).get$column()), span.get$start(span).get$column()), span.get$length(span)), J.get$length$asx(span.get$context()));
        }, null, null, 4, 0, null, 132],
        Highlighter$_: [function(_span, _color) {
          var t1 = P.StringBuffer$("");
          return new U.Highlighter(_span, _color, !J.$eq$(_span.get$start(_span).get$line(), _span.get$end().get$line()), J.$add$ansx(J.get$length$asx(J.toString$0$(_span.get$end().get$line())), 1), t1, []);
        }, null, null, 8, 0, null, 1036, 1037]
      }
    },
    Highlighter__writeFirstLine_closure: {
      "^": "Closure:1;$this,line,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$_highlighter$_buffer().write$1(D.glyphOrAscii("\u250c", "/"));
        t1.get$_highlighter$_buffer().write$1(" ");
        t1._writeText$1(this.line);
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeFirstLine_closure0: {
      "^": "Closure:0;$this,textInside,$ti",
      call$0: [function() {
        return this.$this._writeText$1(this.textInside);
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeFirstLine_closure1: {
      "^": "Closure:1;_box_0,$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$_highlighter$_buffer().write$1(K.topLeftCorner());
        t1.get$_highlighter$_buffer().write$1(J.$mul$ns(K.horizontalLine(), J.$add$ansx(this._box_0.startColumn, 1)));
        t1.get$_highlighter$_buffer().write$1("^");
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeFirstLine_closure2: {
      "^": "Closure:0;_box_0,$this,$ti",
      call$0: [function() {
        var t1 = this._box_0;
        return this.$this.get$_highlighter$_buffer().write$1(C.JSString_methods.$mul("^", P.max(J.$sub$n(t1.endColumn, t1.startColumn), 1, P.int)));
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeIntermediateLines_closure: {
      "^": "Closure:1;$this,line,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$_highlighter$_buffer().write$1(K.verticalLine());
        t1.get$_highlighter$_buffer().write$1(" ");
        t1._writeText$1(this.line);
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeLastLine_closure: {
      "^": "Closure:1;$this,line,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$_highlighter$_buffer().write$1(D.glyphOrAscii("\u2514", "\\"));
        t1.get$_highlighter$_buffer().write$1(" ");
        t1._writeText$1(this.line);
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeLastLine_closure0: {
      "^": "Closure:1;$this,textInside,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$_highlighter$_buffer().write$1(K.verticalLine());
        t1.get$_highlighter$_buffer().write$1(" ");
        t1._writeText$1(this.textInside);
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeLastLine_closure1: {
      "^": "Closure:1;_box_0,$this,$ti",
      call$0: [function() {
        var t1 = this.$this;
        t1.get$_highlighter$_buffer().write$1(K.bottomLeftCorner());
        t1.get$_highlighter$_buffer().write$1(J.$mul$ns(K.horizontalLine(), this._box_0.endColumn));
        t1.get$_highlighter$_buffer().write$1("^");
      }, null, null, 0, 0, null, "call"]
    },
    Highlighter__writeSidebar_closure: {
      "^": "Closure:1;$this,line,end,$ti",
      call$0: [function() {
        var t1, t2;
        t1 = this.line;
        t2 = this.$this;
        if (t1 != null)
          t2.get$_highlighter$_buffer().write$1(J.padRight$1$s(J.toString$0$(J.$add$ansx(t1, 1)), t2.get$_paddingBeforeSidebar()));
        else
          t2.get$_highlighter$_buffer().write$1(C.JSString_methods.$mul(" ", t2.get$_paddingBeforeSidebar()));
        t1 = t2.get$_highlighter$_buffer();
        t2 = this.end;
        t1.write$1(t2 == null ? K.verticalLine() : t2);
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:source_span/src/location.dart",, V, {
    "^": "",
    SourceLocation0: {
      "^": "Object;sourceUrl<,offset>,line<,column<,$ti",
      get$toolString: [function() {
        var source = this.sourceUrl;
        return H.S(source == null ? "unknown source" : source) + ":" + H.S(J.$add$ansx(this.line, 1)) + ":" + H.S(J.$add$ansx(this.column, 1));
      }, null, null, 2, 0, null],
      SourceLocation$4$column$line$sourceUrl: [function(offset, column, line, sourceUrl) {
        if (typeof offset !== "number")
          return offset.$lt();
        if (offset < 0)
          throw H.wrapException(P.RangeError$("Offset may not be negative, was " + offset + "."));
        else if (line != null && line < 0)
          throw H.wrapException(P.RangeError$("Line may not be negative, was " + H.S(line) + "."));
        else if (column != null && column < 0)
          throw H.wrapException(P.RangeError$("Column may not be negative, was " + H.S(column) + "."));
      }, null, null, 4, 7, null, 0, 0, 0, 52, 99, 49, 240],
      distance$1: [function(other) {
        var t1;
        H.interceptedTypeCheck(other, "$isSourceLocation0");
        t1 = this.sourceUrl;
        if (!J.$eq$(t1, other.get$sourceUrl()))
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t1) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
        return J.abs$0$in(J.$sub$n(this.offset, other.get$offset(other)));
      }, null, "get$distance", 4, 0, null, 3],
      compareTo$1: [function(_, other) {
        var t1;
        H.interceptedTypeCheck(other, "$isSourceLocation0");
        t1 = this.sourceUrl;
        if (!J.$eq$(t1, other.get$sourceUrl()))
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t1) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
        return J.$sub$n(this.offset, other.get$offset(other));
      }, null, "get$compareTo", 5, 0, null, 3],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return !!J.getInterceptor$(other).$isSourceLocation0 && J.$eq$(this.sourceUrl, other.get$sourceUrl()) && J.$eq$(this.offset, other.get$offset(other));
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.$add$ansx(J.get$hashCode$(this.sourceUrl), this.offset);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return "<" + H.S(this.get$runtimeType(this)) + ": " + H.S(this.offset) + " " + H.S(this.get$toolString()) + ">";
      }, null, "get$toString", 1, 0, null],
      $isComparable: 1,
      $asComparable: function() {
        return [V.SourceLocation0];
      },
      static: {
        SourceLocation$: [function(offset, column, line, sourceUrl) {
          var t1, t2, t3;
          t1 = H.interceptedTypeCheck(typeof sourceUrl === "string" ? P.Uri_parse(sourceUrl, 0, null) : sourceUrl, "$isUri");
          t2 = line == null ? 0 : line;
          t3 = column == null ? offset : column;
          t3 = new V.SourceLocation0(t1, offset, t2, t3, []);
          t3.SourceLocation$4$column$line$sourceUrl(offset, column, line, sourceUrl);
          return t3;
        }, null, null, 4, 7, null, 0, 0, 0, 52, 99, 49, 240]
      }
    },
    SourceLocationBase: {
      "^": "SourceLocation0;$ti"
    }
  }], ["", "package:source_span/src/location_mixin.dart",, D, {
    "^": "",
    SourceLocationMixin: {
      "^": "Object;$ti",
      get$toolString: [function() {
        return H.S(this.get$sourceUrl() == null ? "unknown source" : this.get$sourceUrl()) + ":" + H.S(J.$add$ansx(this.get$line(), 1)) + ":" + H.S(J.$add$ansx(this.get$column(), 1));
      }, null, null, 2, 0, null],
      distance$1: [function(other) {
        H.interceptedTypeCheck(other, "$isSourceLocation0");
        if (!J.$eq$(this.get$sourceUrl(), other.get$sourceUrl()))
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
        return J.abs$0$in(J.$sub$n(this.offset, other.get$offset(other)));
      }, null, "get$distance", 4, 0, null, 3],
      compareTo$1: [function(_, other) {
        H.interceptedTypeCheck(other, "$isSourceLocation0");
        if (!J.$eq$(this.get$sourceUrl(), other.get$sourceUrl()))
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
        return J.$sub$n(this.offset, other.get$offset(other));
      }, null, "get$compareTo", 5, 0, null, 3],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return !!J.getInterceptor$(other).$isSourceLocation0 && J.$eq$(this.get$sourceUrl(), other.get$sourceUrl()) && J.$eq$(this.offset, other.get$offset(other));
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        return J.$add$ansx(J.get$hashCode$(this.get$sourceUrl()), this.offset);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return "<" + H.S(this.get$runtimeType(this)) + ": " + H.S(this.offset) + " " + H.S(this.get$toolString()) + ">";
      }, null, "get$toString", 1, 0, null],
      $isComparable: 1,
      $asComparable: function() {
        return [V.SourceLocation0];
      },
      $isSourceLocation0: 1
    }
  }], ["", "package:source_span/src/span.dart",, V, {
    "^": "",
    SourceSpan: {
      "^": "Object;$ti",
      $isComparable: 1,
      $asComparable: function() {
        return [V.SourceSpan];
      }
    },
    SourceSpanBase: {
      "^": "SourceSpanMixin;start>,end<,text>,$ti",
      SourceSpanBase$3: [function(start, end, text) {
        var t1, t2, t3;
        t1 = this.end;
        t2 = this.start;
        if (!J.$eq$(t1.get$sourceUrl(), t2.get$sourceUrl()))
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t2.get$sourceUrl()) + '" and  "' + H.S(t1.get$sourceUrl()) + "\" don't match."));
        else if (J.$lt$n(J.get$offset$z(t1), J.get$offset$z(t2)))
          throw H.wrapException(P.ArgumentError$("End " + H.S(t1) + " must come after start " + H.S(t2) + "."));
        else {
          t3 = this.text;
          if (!J.$eq$(J.get$length$asx(t3), t2.distance$1(t1)))
            throw H.wrapException(P.ArgumentError$('Text "' + H.S(t3) + '" must be ' + H.S(t2.distance$1(t1)) + " characters long."));
        }
      }, null, null, 12, 0, null, 5, 7, 17]
    }
  }], ["", "package:source_span/src/span_exception.dart",, G, {
    "^": "",
    SourceSpanException: {
      "^": "Object;$ti",
      get$message: [function(_) {
        return this._span_exception$_message;
      }, null, null, 3, 0, null],
      get$span: [function(_) {
        return this._span;
      }, null, null, 3, 0, null],
      toString$1$color: [function(_, color) {
        if (this.get$span(this) == null)
          return this.get$message(this);
        return C.JSString_methods.$add("Error on ", J.message$2$color$x(this.get$span(this), this.get$message(this), color));
      }, function($receiver) {
        return this.toString$1$color($receiver, null);
      }, "toString$0", null, null, "get$toString", 1, 3, null, 0, 75],
      message$2$color: function($receiver, arg0, arg1) {
        return this.get$message(this).call$2$color(arg0, arg1);
      },
      $isException: 1
    },
    SourceSpanFormatException: {
      "^": "SourceSpanException;_span_exception$_source,_span_exception$_message,_span,$ti",
      get$source: [function(_) {
        return this._span_exception$_source;
      }, null, null, 3, 0, null],
      get$offset: [function(_) {
        return this.get$span(this) == null ? null : J.get$offset$z(J.get$start$x(this.get$span(this)));
      }, null, null, 3, 0, null],
      $isFormatException: 1,
      static: {
        SourceSpanFormatException$: [function(message, span, _source) {
          return new G.SourceSpanFormatException(_source, message, span, []);
        }, null, null, 8, 2, null, 0, 21, 132, 146]
      }
    }
  }], ["", "package:source_span/src/span_mixin.dart",, Y, {
    "^": "",
    SourceSpanMixin: {
      "^": "Object;$ti",
      get$sourceUrl: [function() {
        return this.get$start(this).get$sourceUrl();
      }, null, null, 2, 0, null],
      get$length: [function(_) {
        return J.$sub$n(J.get$offset$z(this.get$end()), J.get$offset$z(this.get$start(this)));
      }, null, null, 3, 0, null],
      compareTo$1: ["super$SourceSpanMixin$compareTo", function(_, other) {
        var result;
        H.interceptedTypeCheck(other, "$isSourceSpan");
        result = J.compareTo$1$ns(this.get$start(this), other.get$start(other));
        return result === 0 ? J.compareTo$1$ns(this.get$end(), other.get$end()) : result;
      }, null, "get$compareTo", 5, 0, null, 3],
      message$2$color: [function(_, message, color) {
        var buffer, highlight;
        H.stringTypeCheck(message);
        buffer = P.StringBuffer$("");
        buffer.write$1("line " + H.S(J.$add$ansx(this.get$start(this).get$line(), 1)) + ", column " + H.S(J.$add$ansx(this.get$start(this).get$column(), 1)));
        if (this.get$sourceUrl() != null)
          buffer.write$1(" of " + H.S(D.prettyUri(this.get$sourceUrl())));
        buffer.write$1(": " + H.S(message));
        highlight = this.highlight$1$color(0, color);
        if (!J.get$isEmpty$asx(highlight)) {
          buffer.writeln$0();
          buffer.write$1(highlight);
        }
        return buffer.toString$0(0);
      }, function($receiver, message) {
        return this.message$2$color($receiver, message, null);
      }, "message$1", "call$2$color", "call$1", "get$message", 5, 3, 201, 0, 21, 75],
      highlight$1$color: [function(_, color) {
        if (!this.$isSourceSpanWithContext && J.$eq$(this.get$length(this), 0))
          return "";
        return J.highlight$0$z(U.Highlighter_Highlighter(this, color));
      }, function($receiver) {
        return this.highlight$1$color($receiver, null);
      }, "highlight$0", null, null, "get$highlight", 1, 3, null, 0, 75],
      $eq: ["super$SourceSpanMixin$$eq", function(_, other) {
        if (other == null)
          return false;
        return !!J.getInterceptor$(other).$isSourceSpan && J.$eq$(this.get$start(this), other.get$start(other)) && J.$eq$(this.get$end(), other.get$end());
      }, null, "get$==", 5, 0, null, 3],
      get$hashCode: [function(_) {
        var t1, t2;
        t1 = J.get$hashCode$(this.get$start(this));
        t2 = J.get$hashCode$(this.get$end());
        if (typeof t2 !== "number")
          return H.iae(t2);
        return J.$add$ansx(t1, 31 * t2);
      }, null, null, 3, 0, null],
      toString$0: [function(_) {
        return "<" + H.S(this.get$runtimeType(this)) + ": from " + H.S(this.get$start(this)) + " to " + H.S(this.get$end()) + ' "' + H.S(this.get$text(this)) + '">';
      }, null, "get$toString", 1, 0, null],
      $isComparable: 1,
      $asComparable: function() {
        return [V.SourceSpan];
      },
      $isSourceSpan: 1
    }
  }], ["", "package:source_span/src/span_with_context.dart",, X, {
    "^": "",
    SourceSpanWithContext: {
      "^": "SourceSpanBase;_span_with_context$_context,start,end,text,$ti",
      get$context: [function() {
        return this._span_with_context$_context;
      }, null, null, 2, 0, null],
      SourceSpanWithContext$4: [function(start, end, text, _context) {
        if (!J.contains$1$asx(this.get$context(), text))
          throw H.wrapException(P.ArgumentError$('The context line "' + H.S(this.get$context()) + '" must contain "' + H.S(text) + '".'));
        if (B.findLineStart(this.get$context(), text, start.get$column()) == null)
          throw H.wrapException(P.ArgumentError$('The span text "' + H.S(text) + '" must start at column ' + H.S(J.$add$ansx(start.get$column(), 1)) + ' in a line within "' + H.S(this.get$context()) + '".'));
      }, null, null, 16, 0, null, 5, 7, 17, 547],
      static: {
        SourceSpanWithContext$: [function(start, end, text, _context) {
          var t1 = new X.SourceSpanWithContext(_context, start, end, text, []);
          t1.SourceSpanBase$3(start, end, text);
          t1.SourceSpanWithContext$4(start, end, text, _context);
          return t1;
        }, null, null, 16, 0, null, 5, 7, 17, 547]
      }
    }
  }], ["", "package:source_span/src/utils.dart",, B, {
    "^": "",
    countCodeUnits: [function(string, codeUnit) {
      var t1, count;
      H.stringTypeCheck(string);
      H.intTypeCheck(codeUnit);
      for (t1 = J.get$iterator$ax(J.get$codeUnits$s(string)), count = 0; t1.moveNext$0();)
        if (t1.get$current() == codeUnit)
          ++count;
      return count;
    }, null, null, 8, 0, null, 30, 125],
    findLineStart: [function(context, text, column) {
      var t1, beginningOfLine, index, lineStart;
      H.stringTypeCheck(context);
      H.stringTypeCheck(text);
      H.intTypeCheck(column);
      if (J.get$isEmpty$asx(text))
        for (t1 = J.getInterceptor$asx(context), beginningOfLine = 0; true;) {
          index = t1.indexOf$2(context, "\n", beginningOfLine);
          if (index === -1) {
            t1 = context.length;
            if (typeof column !== "number")
              return H.iae(column);
            return t1 - beginningOfLine >= column ? beginningOfLine : null;
          }
          if (typeof index !== "number")
            return index.$sub();
          if (typeof column !== "number")
            return H.iae(column);
          if (index - beginningOfLine >= column)
            return beginningOfLine;
          beginningOfLine = index + 1;
        }
      index = J.getInterceptor$asx(context).indexOf$1(context, text);
      for (; index !== -1;) {
        if (index === 0)
          lineStart = 0;
        else {
          if (typeof index !== "number")
            return index.$sub();
          lineStart = J.$add$ansx(C.JSString_methods.lastIndexOf$2(context, "\n", index - 1), 1);
        }
        if (typeof index !== "number")
          return index.$sub();
        if (typeof lineStart !== "number")
          return H.iae(lineStart);
        if (column === index - lineStart)
          return lineStart;
        index = C.JSString_methods.indexOf$2(context, text, index + 1);
      }
      return;
    }, null, null, 12, 0, null, 202, 17, 99]
  }], ["", "package:string_scanner/src/eager_span_scanner.dart",, D, {
    "^": "",
    EagerSpanScanner: {
      "^": "SpanScanner;$ti"
    },
    _EagerSpanScannerState: {
      "^": "Object;$ti",
      $isLineScannerState: 1
    }
  }], ["", "package:string_scanner/src/exception.dart",, E, {
    "^": "",
    StringScannerException: {
      "^": "SourceSpanFormatException;_span_exception$_source,_span_exception$_message,_span,$ti",
      get$source: [function(_) {
        return H.stringTypeCheck(G.SourceSpanFormatException.prototype.get$source.call(this, this));
      }, null, null, 3, 0, null],
      get$sourceUrl: [function() {
        return this.get$span(this).get$sourceUrl();
      }, null, null, 2, 0, null],
      static: {
        StringScannerException$: [function(message, span, source) {
          return new E.StringScannerException(source, message, span, []);
        }, null, null, 12, 0, null, 21, 132, 11]
      }
    }
  }], ["", "package:string_scanner/src/line_scanner.dart",, Z, {
    "^": "",
    LineScanner: {
      "^": "StringScanner;$ti"
    },
    LineScannerState: {
      "^": "Object;$ti"
    }
  }], ["", "package:string_scanner/src/relative_span_scanner.dart",, R, {
    "^": "",
    RelativeSpanScanner: {
      "^": "StringScanner;$ti",
      $isLineScanner: 1,
      $isSpanScanner: 1
    },
    _SpanScannerState: {
      "^": "Object;$ti",
      $isLineScannerState: 1
    }
  }], ["", "package:string_scanner/src/span_scanner.dart",, S, {
    "^": "",
    SpanScanner: {
      "^": "StringScanner;$ti",
      $isLineScanner: 1
    },
    _SpanScannerState0: {
      "^": "Object;$ti",
      $isLineScannerState: 1
    }
  }], ["", "package:string_scanner/src/string_scanner.dart",, X, {
    "^": "",
    StringScanner: {
      "^": "Object;sourceUrl<,string,_string_scanner$_position,0_lastMatch,0_lastMatchPosition,$ti",
      get$position: [function(_) {
        return this._string_scanner$_position;
      }, null, null, 3, 0, null],
      set$position: [function(_, position) {
        var t1;
        H.intTypeCheck(position);
        if (typeof position !== "number")
          return position.$lt();
        if (position >= 0) {
          t1 = J.get$length$asx(this.string);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = position > t1;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.ArgumentError$("Invalid position " + position));
        this._string_scanner$_position = position;
        this._lastMatch = null;
      }, null, null, 7, 0, null, 69],
      get$lastMatch: [function() {
        if (!J.$eq$(this._string_scanner$_position, this._lastMatchPosition))
          this._lastMatch = null;
        return this._lastMatch;
      }, null, null, 2, 0, null],
      get$isDone: [function() {
        return J.$eq$(this.get$position(this), J.get$length$asx(this.string));
      }, null, null, 2, 0, null],
      StringScanner$3$position$sourceUrl: [function(string, position, sourceUrl) {
        if (position != null)
          this.set$position(0, position);
      }, null, null, 4, 5, null, 0, 0, 30, 69, 240],
      scan$1: [function(pattern) {
        var success, t1;
        success = this.matches$1(0, H.stringSuperNativeTypeCheck(pattern, "$isPattern"));
        if (success) {
          t1 = H.intTypeCheck(this._lastMatch.get$end());
          this._string_scanner$_position = t1;
          this._lastMatchPosition = t1;
        }
        return success;
      }, null, "get$scan", 4, 0, null, 36],
      expect$2$name: [function(pattern, $name) {
        var t1, source;
        H.stringSuperNativeTypeCheck(pattern, "$isPattern");
        H.stringTypeCheck($name);
        if (this.scan$1(pattern))
          return;
        if ($name == null) {
          t1 = J.getInterceptor$(pattern);
          if (!!t1.$isRegExp) {
            source = pattern.pattern;
            $name = "/" + H.S(!$.$get$_slashAutoEscape() ? J.replaceAll$2$s(source, "/", "\\/") : source) + "/";
          } else
            $name = '"' + H.S(J.replaceAll$2$s(J.replaceAll$2$s(t1.toString$0(pattern), "\\", "\\\\"), '"', '\\"')) + '"';
        }
        this._fail$1($name);
      }, function(pattern) {
        return this.expect$2$name(pattern, null);
      }, "expect$1", null, null, "get$expect", 4, 3, null, 0, 36, 8],
      expectDone$0: [function() {
        if (this.get$isDone())
          return;
        this._fail$1("no more input");
      }, null, "get$expectDone", 0, 0, null],
      matches$1: [function(_, pattern) {
        var t1 = H.interceptedTypeCheck(J.matchAsPrefix$2$s(H.stringSuperNativeTypeCheck(pattern, "$isPattern"), this.string, this.get$position(this)), "$isMatch");
        this._lastMatch = t1;
        this._lastMatchPosition = H.intTypeCheck(this._string_scanner$_position);
        return t1 != null;
      }, "call$1", "get$matches", 5, 0, 202, 36],
      substring$2: [function(_, start, end) {
        H.intTypeCheck(start);
        H.intTypeCheck(end);
        if (end == null)
          end = this.get$position(this);
        return J.substring$2$s(this.string, start, end);
      }, function($receiver, start) {
        return this.substring$2($receiver, start, null);
      }, "substring$1", null, null, "get$substring", 5, 2, null, 0, 5, 7],
      error$4$length$match$position: [function(_, message, $length, match, position) {
        var t1, sourceFile;
        H.stringTypeCheck(message);
        H.interceptedTypeCheck(match, "$isMatch");
        H.intTypeCheck(position);
        H.intTypeCheck($length);
        t1 = this.string;
        B.validateErrorArgs(t1, match, position, $length);
        if (match == null && position == null && $length == null)
          match = this.get$lastMatch();
        if (position == null)
          position = match == null ? this.get$position(this) : match.get$start(match);
        if ($length == null)
          $length = match == null ? 0 : J.$sub$n(match.get$end(), match.get$start(match));
        sourceFile = Y.SourceFile$fromString(t1, this.sourceUrl);
        if (typeof position !== "number")
          return position.$add();
        if (typeof $length !== "number")
          return H.iae($length);
        throw H.wrapException(E.StringScannerException$(message, sourceFile.span$2(0, position, position + $length), t1));
      }, function($receiver, message) {
        return this.error$4$length$match$position($receiver, message, null, null, null);
      }, "error$1", function($receiver, message, position) {
        return this.error$4$length$match$position($receiver, message, null, null, position);
      }, "error$2$position", function($receiver, message, $length, position) {
        return this.error$4$length$match$position($receiver, message, $length, null, position);
      }, "error$3$length$position", "call$4$length$match$position", "call$1", "call$2$position", "call$3$length$position", "get$error", 5, 7, 203, 0, 0, 0, 21, 35, 148, 69],
      _fail$1: [function($name) {
        this.error$3$length$position(0, "expected " + H.S(H.stringTypeCheck($name)) + ".", 0, this.get$position(this));
      }, null, "get$_fail", 4, 0, null, 8],
      static: {
        StringScanner$: [function(string, position, sourceUrl) {
          var t1 = new X.StringScanner(H.interceptedTypeCheck(typeof sourceUrl === "string" ? P.Uri_parse(sourceUrl, 0, null) : sourceUrl, "$isUri"), string, 0, []);
          t1.StringScanner$3$position$sourceUrl(string, position, sourceUrl);
          return t1;
        }, null, null, 4, 5, null, 0, 0, 30, 69, 240]
      }
    }
  }], ["", "package:string_scanner/src/utils.dart",, B, {
    "^": "",
    validateErrorArgs: [function(string, match, position, $length) {
      var t1, t2;
      H.stringTypeCheck(string);
      H.interceptedTypeCheck(match, "$isMatch");
      H.intTypeCheck(position);
      H.intTypeCheck($length);
      if (match != null)
        t1 = position != null || $length != null;
      else
        t1 = false;
      if (t1)
        throw H.wrapException(P.ArgumentError$("Can't pass both match and position/length."));
      t1 = position != null;
      if (t1)
        if (position < 0)
          throw H.wrapException(P.RangeError$("position must be greater than or equal to 0."));
        else if (position > string.length)
          throw H.wrapException(P.RangeError$("position must be less than or equal to the string length."));
      t2 = $length != null;
      if (t2 && $length < 0)
        throw H.wrapException(P.RangeError$("length must be greater than or equal to 0."));
      if (t1 && t2 && position + $length > string.length)
        throw H.wrapException(P.RangeError$("position plus length must not go beyond the end of the string."));
    }, null, null, 16, 0, null, 30, 148, 69, 35]
  }], ["", "package:term_glyph/src/generated/ascii_glyph_set.dart",, A, {
    "^": "",
    AsciiGlyphSet: {
      "^": "Object;$ti",
      $isGlyphSet: 1
    }
  }], ["", "package:term_glyph/src/generated/glyph_set.dart",, E, {
    "^": "",
    GlyphSet: {
      "^": "Object;$ti"
    }
  }], ["", "package:term_glyph/src/generated/top_level.dart",, K, {
    "^": "",
    horizontalLine: [function() {
      return D.glyphs().get$horizontalLine();
    }, null, null, 2, 0, null],
    verticalLine: [function() {
      return D.glyphs().get$verticalLine();
    }, null, null, 2, 0, null],
    topLeftCorner: [function() {
      return D.glyphs().get$topLeftCorner();
    }, null, null, 2, 0, null],
    bottomLeftCorner: [function() {
      return D.glyphs().get$bottomLeftCorner();
    }, null, null, 2, 0, null],
    upEnd: [function() {
      return D.glyphs().get$upEnd();
    }, null, null, 2, 0, null],
    downEnd: [function() {
      return D.glyphs().get$downEnd();
    }, null, null, 2, 0, null]
  }], ["", "package:term_glyph/src/generated/unicode_glyph_set.dart",, K, {
    "^": "",
    UnicodeGlyphSet: {
      "^": "Object;$ti",
      glyphOrAscii$2: [function(glyph, alternative) {
        H.stringTypeCheck(glyph);
        H.stringTypeCheck(alternative);
        return glyph;
      }, null, "get$glyphOrAscii", 8, 0, null, 548, 481],
      get$horizontalLine: [function() {
        return "\u2500";
      }, null, null, 2, 0, null],
      get$verticalLine: [function() {
        return "\u2502";
      }, null, null, 2, 0, null],
      get$topLeftCorner: [function() {
        return "\u250c";
      }, null, null, 2, 0, null],
      get$bottomLeftCorner: [function() {
        return "\u2514";
      }, null, null, 2, 0, null],
      get$upEnd: [function() {
        return "\u2575";
      }, null, null, 2, 0, null],
      get$downEnd: [function() {
        return "\u2577";
      }, null, null, 2, 0, null],
      $isGlyphSet: 1
    }
  }], ["", "package:term_glyph/term_glyph.dart",, D, {
    "^": "",
    glyphs: [function() {
      return $._glyphs;
    }, null, null, 2, 0, null],
    glyphOrAscii: [function(glyph, alternative) {
      H.stringTypeCheck(glyph);
      H.stringTypeCheck(alternative);
      return D.glyphs().glyphOrAscii$2(glyph, alternative);
    }, null, null, 8, 0, null, 548, 481]
  }], ["typed_data.typed_buffers", "package:typed_data/typed_buffers.dart",, N, {
    "^": "",
    _TypedDataBuffer: {
      "^": "ListBase;$ti"
    },
    _IntBuffer: {
      "^": "_TypedDataBuffer;$ti",
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $as_TypedDataBuffer: function() {
        return [P.int];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    _FloatBuffer: {
      "^": "_TypedDataBuffer;$ti",
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asListBase: function() {
        return [P.double];
      },
      $asListMixin: function() {
        return [P.double];
      },
      $asIterable: function() {
        return [P.double];
      },
      $asList: function() {
        return [P.double];
      },
      $as_TypedDataBuffer: function() {
        return [P.double];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.double];
      }
    },
    Uint8Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Int8Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Uint8ClampedBuffer: {
      "^": "_IntBuffer;$ti"
    },
    Uint16Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Int16Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Uint32Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Int32Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Uint64Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Int64Buffer: {
      "^": "_IntBuffer;$ti"
    },
    Float32Buffer: {
      "^": "_FloatBuffer;$ti"
    },
    Float64Buffer: {
      "^": "_FloatBuffer;$ti"
    },
    Int32x4Buffer: {
      "^": "_TypedDataBuffer;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Int32x4];
      },
      $asListBase: function() {
        return [P.Int32x4];
      },
      $asListMixin: function() {
        return [P.Int32x4];
      },
      $asIterable: function() {
        return [P.Int32x4];
      },
      $asList: function() {
        return [P.Int32x4];
      },
      $as_TypedDataBuffer: function() {
        return [P.Int32x4];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Int32x4];
      }
    },
    Float32x4Buffer: {
      "^": "_TypedDataBuffer;$ti",
      $asEfficientLengthIterable: function() {
        return [P.Float32x4];
      },
      $asListBase: function() {
        return [P.Float32x4];
      },
      $asListMixin: function() {
        return [P.Float32x4];
      },
      $asIterable: function() {
        return [P.Float32x4];
      },
      $asList: function() {
        return [P.Float32x4];
      },
      $as_TypedDataBuffer: function() {
        return [P.Float32x4];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.Float32x4];
      }
    }
  }], ["vm_service_lib", "package:vm_service_lib/vm_service_lib.dart",, S, {
    "^": "",
    decodeBase64: [function(str) {
      return P.String_String$fromCharCodes(C.Base64Codec_Base64Encoder_false.decode$1(0, H.stringTypeCheck(str)), 0, null);
    }, null, null, 4, 0, null, 82],
    _createObject: [function(json) {
      var t1, type;
      if (json == null)
        return;
      t1 = J.getInterceptor$(json);
      if (!!t1.$isList)
        return J.toList$0$ax(t1.map$1$1(json, new S._createObject_closure(), P.Object));
      else if (!!t1.$isMap) {
        type = H.stringTypeCheck(json.$index(0, "type"));
        if (J.$index$asx($.$get$_typeFactories(), type) == null)
          return;
        else
          return J.$index$asx($.$get$_typeFactories(), type).call$1(json);
      } else
        return json;
    }, null, null, 4, 0, null, 2],
    _createSpecificObject: [function(json, creator) {
      var t1, map, key;
      H.functionTypeCheck(creator, {func: 1, args: [[P.Map, P.String,,]]});
      if (json == null)
        return;
      t1 = J.getInterceptor$(json);
      if (!!t1.$isList)
        return J.toList$0$ax(t1.map$1$1(json, new S._createSpecificObject_closure(creator), null));
      else if (!!t1.$isMap) {
        map = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
        for (t1 = J.get$iterator$ax(json.get$keys()); t1.moveNext$0();) {
          key = H.stringTypeCast(t1.get$current());
          map.$indexSet(0, key, json.$index(0, key));
        }
        return creator.call$1(map);
      } else
        return json;
    }, null, null, 8, 0, null, 2, 1043],
    _createObject_closure: {
      "^": "Closure:70;$ti",
      call$1: [function(e) {
        return S._createObject(e);
      }, null, null, 4, 0, null, 19, "call"]
    },
    _createSpecificObject_closure: {
      "^": "Closure:3;creator,$ti",
      call$1: [function(e) {
        return this.creator.call$1(H.assertSubtype(e, "$isMap", [P.String, null], "$asMap"));
      }, null, null, 4, 0, null, 19, "call"]
    },
    VmService: {
      "^": "Object;0_streamSub,0_writeMessage,_id,_completers,_methodCalls,_services,0_log,_onSend,_onReceive,_eventControllers,0_disposeHandler,$ti",
      set$_disposeHandler: function(_disposeHandler) {
        this._disposeHandler = H.functionTypeCheck(_disposeHandler, {func: 1, ret: [P.Future,,]});
      },
      _getEventController$1: [function(eventName) {
        var t1, t2, controller;
        H.stringTypeCheck(eventName);
        t1 = this._eventControllers;
        t2 = J.getInterceptor$asx(t1);
        controller = t2.$index(t1, eventName);
        if (controller == null) {
          controller = P.StreamController_StreamController$broadcast(null, null, false, S.Event0);
          t2.$indexSet(t1, eventName, controller);
        }
        return controller;
      }, null, "get$_getEventController", 4, 0, null, 409],
      VmService$4$disposeHandler$log: [function(inStream, writeMessage, disposeHandler, log) {
        this._streamSub = H.interceptedTypeCheck(inStream.listen$1(this.get$_processMessage()), "$isStreamSubscription");
        this._writeMessage = H.interceptedTypeCheck(writeMessage, "$isFunction");
        this._log = log == null ? S._NullLog$() : log;
        this.set$_disposeHandler(disposeHandler);
      }, null, null, 8, 5, null, 0, 0, 229, 228, 227, 182],
      get$onIsolateEvent: [function() {
        return J.get$stream$z(this._getEventController$1("Isolate"));
      }, null, null, 2, 0, null],
      get$onDebugEvent: [function() {
        return J.get$stream$z(this._getEventController$1("Debug"));
      }, null, null, 2, 0, null],
      get$onGCEvent: [function() {
        return J.get$stream$z(this._getEventController$1("GC"));
      }, null, null, 2, 0, null],
      get$onStdoutEvent: [function() {
        return J.get$stream$z(this._getEventController$1("Stdout"));
      }, null, null, 2, 0, null],
      get$onStderrEvent: [function() {
        return J.get$stream$z(this._getEventController$1("Stderr"));
      }, null, null, 2, 0, null],
      get$onExtensionEvent: [function() {
        return J.get$stream$z(this._getEventController$1("Extension"));
      }, null, null, 2, 0, null],
      get$onServiceEvent: [function() {
        return J.get$stream$z(this._getEventController$1("_Service"));
      }, null, null, 2, 0, null],
      onEvent$1: [function(streamName) {
        return J.get$stream$z(this._getEventController$1(H.stringTypeCheck(streamName)));
      }, null, "get$onEvent", 4, 0, null, 517],
      addBreakpoint$4$column: [function(isolateId, scriptId, line, column) {
        var m;
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(scriptId);
        H.intTypeCheck(line);
        H.intTypeCheck(column);
        m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "scriptId", scriptId, "line", line]);
        if (column != null)
          m.$indexSet(0, "column", column);
        return this._call$1$2("addBreakpoint", m, S.Breakpoint);
      }, function(isolateId, scriptId, line) {
        return this.addBreakpoint$4$column(isolateId, scriptId, line, null);
      }, "addBreakpoint$3", null, null, "get$addBreakpoint", 12, 3, null, 0, 28, 288, 49, 99],
      invoke$4: [function(isolateId, targetId, selector, argumentIds) {
        return this._call$1$2("invoke", P.LinkedHashMap__makeLiteral(["isolateId", H.stringTypeCheck(isolateId), "targetId", H.stringTypeCheck(targetId), "selector", H.stringTypeCheck(selector), "argumentIds", H.assertSubtype(argumentIds, "$isList", [P.String], "$asList")]), null);
      }, null, "get$invoke", 16, 0, null, 28, 226, 515, 516],
      evaluate$4$scope: [function(isolateId, targetId, expression, scope) {
        var t1, m;
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(targetId);
        H.stringTypeCheck(expression);
        t1 = P.String;
        H.assertSubtype(scope, "$isMap", [t1, t1], "$asMap");
        m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "targetId", targetId, "expression", expression]);
        if (scope != null)
          m.$indexSet(0, "scope", scope);
        return this._call$1$2("evaluate", m, null);
      }, null, "get$evaluate", 12, 3, null, 0, 28, 226, 147, 184],
      getIsolate$1: [function(isolateId) {
        return this._call$1$2("getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", H.stringTypeCheck(isolateId)]), null);
      }, null, "get$getIsolate", 4, 0, null, 28],
      getScripts$1: [function(isolateId) {
        return this._call$1$2("getScripts", P.LinkedHashMap__makeLiteral(["isolateId", H.stringTypeCheck(isolateId)]), S.ScriptList);
      }, null, "get$getScripts", 4, 0, null, 28],
      getObject$4$count$offset: [function(isolateId, objectId, count, offset) {
        var m;
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(objectId);
        H.intTypeCheck(offset);
        H.intTypeCheck(count);
        m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "objectId", objectId]);
        if (offset != null)
          m.$indexSet(0, "offset", offset);
        if (count != null)
          m.$indexSet(0, "count", count);
        return this._call$1$2("getObject", m, null);
      }, function(isolateId, objectId) {
        return this.getObject$4$count$offset(isolateId, objectId, null, null);
      }, "getObject$2", null, null, "get$getObject", 8, 5, null, 0, 0, 28, 514, 42, 52],
      getStack$1: [function(isolateId) {
        return this._call$1$2("getStack", P.LinkedHashMap__makeLiteral(["isolateId", H.stringTypeCheck(isolateId)]), S.Stack);
      }, null, "get$getStack", 4, 0, null, 28],
      getVM$0: [function() {
        return this._call$1$1("getVM", S.VM);
      }, null, "get$getVM", 0, 0, null],
      pause$1: [function(_, isolateId) {
        return this._call$1$2("pause", P.LinkedHashMap__makeLiteral(["isolateId", H.stringTypeCheck(isolateId)]), S.Success);
      }, null, "get$pause", 5, 0, null, 28],
      removeBreakpoint$2: [function(isolateId, breakpointId) {
        return this._call$1$2("removeBreakpoint", P.LinkedHashMap__makeLiteral(["isolateId", H.stringTypeCheck(isolateId), "breakpointId", H.stringTypeCheck(breakpointId)]), S.Success);
      }, null, "get$removeBreakpoint", 8, 0, null, 28, 518],
      resume$3$frameIndex$step: [function(isolateId, frameIndex, step) {
        var m;
        H.stringTypeCheck(isolateId);
        H.stringTypeCheck(step);
        H.intTypeCheck(frameIndex);
        m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId]);
        if (step != null)
          m.$indexSet(0, "step", step);
        if (frameIndex != null)
          m.$indexSet(0, "frameIndex", frameIndex);
        return this._call$1$2("resume", m, S.Success);
      }, function(isolateId) {
        return this.resume$3$frameIndex$step(isolateId, null, null);
      }, "resume$1", function(isolateId, step) {
        return this.resume$3$frameIndex$step(isolateId, null, step);
      }, "resume$2$step", "call$3$frameIndex$step", "call$1", "call$2$step", "get$resume", 4, 5, 60, 0, 0, 28, 519, 520],
      setExceptionPauseMode$2: [function(isolateId, mode) {
        return this._call$1$2("setExceptionPauseMode", P.LinkedHashMap__makeLiteral(["isolateId", H.stringTypeCheck(isolateId), "mode", H.stringTypeCheck(mode)]), S.Success);
      }, null, "get$setExceptionPauseMode", 8, 0, null, 28, 177],
      streamListen$1: [function(streamId) {
        return this._call$1$2("streamListen", P.LinkedHashMap__makeLiteral(["streamId", H.stringTypeCheck(streamId)]), S.Success);
      }, null, "get$streamListen", 4, 0, null, 522],
      clearVMTimeline$0: [function() {
        return this._call$1$1("_clearVMTimeline", S.Success);
      }, null, "get$clearVMTimeline", 0, 0, null],
      setVMTimelineFlags$1: [function(recordedStreams) {
        return this._call$1$2("_setVMTimelineFlags", P.LinkedHashMap__makeLiteral(["recordedStreams", H.assertSubtype(recordedStreams, "$isList", [P.String], "$asList")]), S.Success);
      }, null, "get$setVMTimelineFlags", 4, 0, null, 521],
      getVMTimeline$0: [function() {
        return this._call$1$1("_getVMTimeline", S.Response);
      }, null, "get$getVMTimeline", 0, 0, null],
      callMethod$3$args$isolateId: [function(method, args, isolateId) {
        H.stringTypeCheck(method);
        H.stringTypeCheck(isolateId);
        return this.callServiceExtension$3$args$isolateId(method, H.interceptedTypeCheck(args, "$isMap"), isolateId);
      }, function(method) {
        return this.callMethod$3$args$isolateId(method, null, null);
      }, "callMethod$1", null, null, "get$callMethod", 4, 5, null, 0, 0, 61, 71, 28],
      callServiceExtension$3$args$isolateId: [function(method, args, isolateId) {
        var t1, t2;
        H.stringTypeCheck(method);
        H.stringTypeCheck(isolateId);
        H.interceptedTypeCheck(args, "$isMap");
        t1 = args == null;
        if (t1 && isolateId == null)
          return this._call$1$1(method, S.Response);
        else {
          t2 = S.Response;
          if (t1)
            return this._call$1$2(method, P.LinkedHashMap__makeLiteral(["isolateId", isolateId]), t2);
          else {
            args = P.LinkedHashMap_LinkedHashMap$from(args, null, null);
            args.$indexSet(0, "isolateId", isolateId);
            return this._call$1$2(method, args, t2);
          }
        }
      }, function(method, isolateId) {
        return this.callServiceExtension$3$args$isolateId(method, null, isolateId);
      }, "callServiceExtension$2$isolateId", null, null, "get$callServiceExtension", 4, 5, null, 0, 0, 61, 71, 28],
      dispose$0: [function() {
        this._streamSub.cancel$0();
        J.forEach$1$ax(J.get$values$z(this._completers), new S.VmService_dispose_closure());
        var t1 = this._disposeHandler;
        if (t1 != null)
          t1.call$0();
      }, null, "get$dispose", 0, 0, null],
      _call$1$2: [1, function(method, args, $T) {
        var t1, id, completer, m, message;
        H.stringTypeCheck(method);
        H.interceptedTypeCheck(args, "$isMap");
        t1 = H.intTypeCheck(J.$add$ansx(this._id, 1));
        this._id = t1;
        id = H.S(t1);
        completer = P.Completer_Completer($T);
        J.$indexSet$ax(this._completers, id, completer);
        J.$indexSet$ax(this._methodCalls, id, method);
        m = P.LinkedHashMap__makeLiteral(["id", id, "method", method]);
        if (args != null)
          m.$indexSet(0, "params", args);
        message = P.jsonEncode(m, null);
        J.add$1$ax(this._onSend, message);
        this._writeMessage.call$1(message);
        return completer.get$future();
      }, function(method, args) {
        return this._call$1$2(method, args, null);
      }, "_call$2", function(method, $T) {
        return this._call$1$2(method, null, $T);
      }, "_call$1$1", null, "call$2", null, "get$_call", 4, 2, null, 0, 61, 71],
      _processMessage$1: [function(message) {
        var t1;
        if (typeof message === "string")
          this._processMessageStr$1(message);
        else if (H.checkSubtype(message, "$isList", [P.int], "$asList"))
          this._processMessageByteData$1(P.ByteData_ByteData$view(H.NativeUint8List_NativeUint8List$fromList(message).buffer, 0, null));
        else {
          t1 = J.getInterceptor$(message);
          if (!!t1.$isByteData)
            this._processMessageByteData$1(message);
          else
            this._log.warning$1("unknown message type: " + H.S(t1.get$runtimeType(message)));
        }
      }, "call$1", "get$_processMessage", 4, 0, 6, 21],
      _processMessageByteData$1: [function(bytes) {
        var metaSize, t1, t2, meta, offset, t3, data, map, streamId, $event;
        H.interceptedTypeCheck(bytes, "$isByteData");
        metaSize = (bytes && C.NativeByteData_methods).getUint32$2(bytes, 4, C.Endian_false);
        t1 = bytes.buffer;
        t2 = bytes.byteOffset;
        if (typeof t2 !== "number")
          return t2.$add();
        meta = C.Utf8Codec_false.decode$1(0, P.Uint8List_Uint8List$view(t1, t2 + 8, metaSize));
        if (typeof metaSize !== "number")
          return H.iae(metaSize);
        offset = 8 + metaSize;
        t2 = bytes.buffer;
        t1 = bytes.byteOffset;
        if (typeof t1 !== "number")
          return t1.$add();
        t3 = bytes.byteLength;
        if (typeof t3 !== "number")
          return t3.$sub();
        data = P.ByteData_ByteData$view(t2, t1 + offset, t3 - offset);
        map = P.jsonDecode(meta, null);
        if (map != null && J.$eq$(J.$index$asx(map, "method"), "streamNotify")) {
          t1 = J.getInterceptor$asx(map);
          streamId = H.stringTypeCheck(J.$index$asx(t1.$index(map, "params"), "streamId"));
          $event = H.interceptedTypeCheck(J.$index$asx(t1.$index(map, "params"), "event"), "$isMap");
          $event.$indexSet(0, "_data", data);
          J.add$1$ax(this._getEventController$1(streamId), H.interceptedTypeCheck(S._createObject($event), "$isEvent0"));
        }
      }, null, "get$_processMessageByteData", 4, 0, null, 103],
      _processMessageStr$1: [function(message) {
        var json, e, s, exception, t1;
        H.stringTypeCheck(message);
        json = null;
        try {
          J.add$1$ax(this._onReceive, message);
          json = P.jsonDecode(message, null);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          this._log.severe$1("unable to decode message: " + H.S(message) + ", " + H.S(e) + "\n" + H.S(s));
          return;
        }
        if (H.boolTypeCheck(json.containsKey$1("method"))) {
          t1 = [P.String, null];
          if (H.boolTypeCheck(json.containsKey$1("id")))
            this._processRequest$1(H.assertSubtype(json, "$isMap", t1, "$asMap"));
          else
            this._processNotification$1(H.assertSubtype(json, "$isMap", t1, "$asMap"));
        } else {
          if (H.boolTypeCheck(json.containsKey$1("id")))
            t1 = H.boolTypeCheck(json.containsKey$1("result")) || H.boolTypeCheck(json.containsKey$1("error"));
          else
            t1 = false;
          if (t1)
            this._processResponse$1(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
          else
            this._log.severe$1("unknown message type: " + H.S(message));
        }
      }, null, "get$_processMessageStr", 4, 0, null, 21],
      _processResponse$1: [function(json) {
        var t1, completer, methodName, result, type;
        t1 = [P.String, null];
        H.assertSubtype(json, "$isMap", t1, "$asMap");
        completer = J.remove$1$ax(this._completers, json.$index(0, "id"));
        methodName = J.remove$1$ax(this._methodCalls, json.$index(0, "id"));
        if (completer == null)
          this._log.severe$1("unmatched request response: " + H.S(P.jsonEncode(json, null)));
        else if (json.$index(0, "error") != null)
          completer.completeError$1(S.RPCError_parse(methodName, json.$index(0, "error")));
        else {
          result = H.subtypeCast(json.$index(0, "result"), "$isMap", t1, "$asMap");
          type = H.stringTypeCheck(result.$index(0, "type"));
          if (J.$index$asx($.$get$_typeFactories(), type) == null)
            completer.complete$1(0, S.Response_parse(result));
          else
            completer.complete$1(0, S._createObject(result));
        }
      }, null, "get$_processResponse", 4, 0, null, 2],
      _processRequest$1: [function(json) {
        return this._processRequest$body$VmService(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
      }, null, "get$_processRequest", 4, 0, null, 2],
      _processRequest$body$VmService: [function(json) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, m, message;
        var $async$_processRequest$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait($async$self._routeRequest$2(H.stringTypeCheck(json.$index(0, "method")), H.interceptedTypeCheck(json.$index(0, "params"), "$isMap")), $async$_processRequest$1);
              case 2:
                // returning from await.
                m = $async$result;
                m.$indexSet(0, "id", json.$index(0, "id"));
                m.$indexSet(0, "jsonrpc", "2.0");
                message = P.jsonEncode(m, null);
                J.add$1$ax($async$self._onSend, message);
                $async$self._writeMessage.call$1(message);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_processRequest$1, $async$completer);
      }, null, null, 4, 0, null, 2],
      _processNotification$1: [function(json) {
        return this._processNotification$body$VmService(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
      }, null, "get$_processNotification", 4, 0, null, 2],
      _processNotification$body$VmService: [function(json) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter(null),
          $async$self = this, method, params;
        var $async$_processNotification$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                method = H.stringTypeCheck(json.$index(0, "method"));
                params = H.interceptedTypeCheck(json.$index(0, "params"), "$isMap");
                $async$goto = method === "streamNotify" ? 2 : 4;
                break;
              case 2:
                // then
                J.add$1$ax($async$self._getEventController$1(H.stringTypeCheck(params.$index(0, "streamId"))), H.interceptedTypeCheck(S._createObject(params.$index(0, "event")), "$isEvent0"));
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $async$goto = 5;
                return P._asyncAwait($async$self._routeRequest$2(method, params), $async$_processNotification$1);
              case 5:
                // returning from await.
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_processNotification$1, $async$completer);
      }, null, null, 4, 0, null, 2],
      _routeRequest$2: [function(method, params) {
        H.stringTypeCheck(method);
        H.interceptedTypeCheck(params, "$isMap");
        return this._routeRequest$body$VmService(method, params);
      }, null, "get$_routeRequest", 8, 0, null, 61, 160],
      _routeRequest$body$VmService: [function(method, params) {
        var $async$goto = 0,
          $async$completer = P._makeAsyncAwaitCompleter([P.Map,,,]),
          $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, s, t1, exception, $async$exception;
        var $async$_routeRequest$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$handler = 4;
                t1 = $async$self._services;
                $async$goto = t1.containsKey$1(method) ? 7 : 8;
                break;
              case 7:
                // then
                $async$goto = 9;
                return P._asyncAwait(J.$index$asx(t1, method).call$1(H.assertSubtype(params, "$isMap", [P.String, null], "$asMap")), $async$_routeRequest$2);
              case 9:
                // returning from await.
                t1 = $async$result;
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              case 8:
                // join
                t1 = P.LinkedHashMap__makeLiteral(["error", P.LinkedHashMap_LinkedHashMap$_literal(["code", -32601, "message", "Method not found '" + H.S(method) + "'"], P.String, P.Object)]);
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                e = H.unwrapException($async$exception);
                s = H.getTraceFromException($async$exception);
                t1 = P.LinkedHashMap_LinkedHashMap$_literal(["code", -32000, "message", "Unexpected Server Error " + H.S(e) + "\n" + H.S(s)], P.String, null);
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_routeRequest$2, $async$completer);
      }, null, null, 8, 0, null, 61, 160],
      static: {
        VmService$: [function(inStream, writeMessage, disposeHandler, log) {
          var t1 = P.String;
          t1 = new S.VmService(0, P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.Completer,,]), P.LinkedHashMap_LinkedHashMap$_empty(t1, t1), P.LinkedHashMap_LinkedHashMap$_empty(t1, {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String,,]]}), P.StreamController_StreamController$broadcast(null, null, true, t1), P.StreamController_StreamController$broadcast(null, null, true, t1), P.LinkedHashMap_LinkedHashMap$_empty(t1, [P.StreamController, S.Event0]), []);
          t1.VmService$4$disposeHandler$log(inStream, writeMessage, disposeHandler, log);
          return t1;
        }, null, null, 8, 5, null, 0, 0, 229, 228, 227, 182]
      }
    },
    VmService_dispose_closure: {
      "^": "Closure:205;$ti",
      call$1: [function(c) {
        return H.interceptedTypeCheck(c, "$isCompleter").completeError$1("disposed");
      }, null, null, 4, 0, null, 70, "call"]
    },
    RPCError: {
      "^": "Object;callingMethod,code>,message>,data>,$ti",
      get$details: [function() {
        var t1 = this.data;
        return H.stringTypeCheck(t1 == null ? null : J.$index$asx(t1, "details"));
      }, null, null, 2, 0, null],
      toString$0: [function(_) {
        var t1, t2, t3;
        t1 = this.message;
        t2 = this.code;
        t3 = this.callingMethod;
        if (this.get$details() == null)
          return H.S(t1) + " (" + H.S(t2) + ") from " + H.S(t3) + "()";
        else
          return H.S(t1) + " (" + H.S(t2) + ") from " + H.S(t3) + "():\n" + H.S(this.get$details());
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        RPCError_parse: [function(callingMethod, json) {
          var t1 = J.getInterceptor$asx(json);
          return S.RPCError$(H.stringTypeCheck(callingMethod), H.intTypeCheck(t1.$index(json, "code")), H.stringTypeCheck(t1.$index(json, "message")), H.interceptedTypeCheck(t1.$index(json, "data"), "$isMap"));
        }, null, null, 8, 0, null, 413, 2],
        RPCError$: [function(callingMethod, code, message, data) {
          return new S.RPCError(callingMethod, code, message, data, []);
        }, null, null, 12, 2, null, 0, 413, 811, 21, 34]
      }
    },
    ExtensionData: {
      "^": "Object;data>,$ti",
      toString$0: [function(_) {
        return "[ExtensionData " + H.S(this.data) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ExtensionData_parse: [function(json) {
          H.interceptedTypeCheck(json, "$isMap");
          return json == null ? null : S.ExtensionData$_fromJson(json);
        }, "call$1", "vm_service_lib_ExtensionData_parse$closure", 4, 0, 217, 2],
        ExtensionData$_fromJson: [function(data) {
          return new S.ExtensionData(data, []);
        }, null, null, 4, 0, null, 34]
      }
    },
    Log: {
      "^": "Object;$ti"
    },
    _NullLog: {
      "^": "Object;$ti",
      warning$1: [function(message) {
        H.stringTypeCheck(message);
      }, null, "get$warning", 4, 0, null, 21],
      severe$1: [function(message) {
        H.stringTypeCheck(message);
      }, null, "get$severe", 4, 0, null, 21],
      $isLog: 1,
      static: {
        _NullLog$: [function() {
          return new S._NullLog([]);
        }, null, null, 0, 0, null]
      }
    },
    CodeKind: {
      "^": "Object;$ti"
    },
    ErrorKind: {
      "^": "Object;$ti"
    },
    EventKind: {
      "^": "Object;$ti"
    },
    InstanceKind: {
      "^": "Object;$ti"
    },
    SentinelKind: {
      "^": "Object;$ti"
    },
    FrameKind: {
      "^": "Object;$ti"
    },
    SourceReportKind: {
      "^": "Object;$ti"
    },
    ExceptionPauseMode: {
      "^": "Object;$ti"
    },
    StepOption: {
      "^": "Object;$ti"
    },
    BoundField: {
      "^": "Object;0decl,0value*,$ti",
      BoundField$_fromJson$1: [function(json) {
        this.decl = H.interceptedTypeCheck(S._createObject(json.$index(0, "decl")), "$isFieldRef");
        this.value = S._createObject(json.$index(0, "value"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[BoundField decl: " + H.S(this.decl) + ", value: " + H.S(this.value) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        BoundField_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.BoundField$_fromJson(json);
        }, "call$1", "vm_service_lib_BoundField_parse$closure", 4, 0, 218, 2],
        BoundField$_fromJson: [function(json) {
          var t1 = new S.BoundField([]);
          t1.BoundField$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    BoundVariable: {
      "^": "Object;0name>,0value*,0declarationTokenPos,0scopeStartTokenPos,0scopeEndTokenPos,$ti",
      BoundVariable$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.value = S._createObject(json.$index(0, "value"));
        this.declarationTokenPos = H.intTypeCheck(json.$index(0, "declarationTokenPos"));
        this.scopeStartTokenPos = H.intTypeCheck(json.$index(0, "scopeStartTokenPos"));
        this.scopeEndTokenPos = H.intTypeCheck(json.$index(0, "scopeEndTokenPos"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[BoundVariable name: " + H.S(this.name) + ", value: " + H.S(this.value) + ", declarationTokenPos: " + H.S(this.declarationTokenPos) + ", scopeStartTokenPos: " + H.S(this.scopeStartTokenPos) + ", scopeEndTokenPos: " + H.S(this.scopeEndTokenPos) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        BoundVariable_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.BoundVariable$_fromJson(json);
        }, "call$1", "vm_service_lib_BoundVariable_parse$closure", 4, 0, 219, 2],
        BoundVariable$: [function() {
          return new S.BoundVariable([]);
        }, null, null, 0, 0, null],
        BoundVariable$_fromJson: [function(json) {
          var t1 = new S.BoundVariable([]);
          t1.BoundVariable$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Breakpoint: {
      "^": "Obj;0breakpointNumber,0resolved,0isSyntheticAsyncContinuation,0location>,0id,0classRef,0size,json,0type,$ti",
      Breakpoint$_fromJson$1: [function(json) {
        this.breakpointNumber = H.intTypeCheck(json.$index(0, "breakpointNumber"));
        this.resolved = H.boolTypeCheck(json.$index(0, "resolved"));
        this.isSyntheticAsyncContinuation = H.boolTypeCheck(json.$index(0, "isSyntheticAsyncContinuation"));
        this.location = S._createObject(json.$index(0, "location"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Breakpoint && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Breakpoint type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", breakpointNumber: " + H.S(this.breakpointNumber) + ", resolved: " + H.S(this.resolved) + ", location: " + H.S(this.location) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Breakpoint_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Breakpoint$_fromJson(json);
        }, "call$1", "vm_service_lib_Breakpoint_parse$closure", 4, 0, 220, 2],
        Breakpoint$_fromJson: [function(json) {
          var t1 = new S.Breakpoint(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Breakpoint$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ClassRef: {
      "^": "ObjRef;0name>,0id,json,0type,$ti",
      ClassRef$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.ClassRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[ClassRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ClassRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ClassRef$_fromJson(json);
        }, "call$1", "vm_service_lib_ClassRef_parse$closure", 4, 0, 221, 2],
        ClassRef$_fromJson: [function(json) {
          var t1 = new S.ClassRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.ClassRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Class: {
      "^": "Obj;0name>,0error>,0isAbstract,0isConst,0library,0location>,0superClass,0superType,0interfaces,0mixin,0fields,0functions,0subclasses,0id,0classRef,0size,json,0type,$ti",
      set$interfaces: function(interfaces) {
        this.interfaces = H.assertSubtype(interfaces, "$isList", [S.InstanceRef], "$asList");
      },
      set$fields: function(fields) {
        this.fields = H.assertSubtype(fields, "$isList", [S.FieldRef], "$asList");
      },
      set$functions: function(functions) {
        this.functions = H.assertSubtype(functions, "$isList", [S.FuncRef], "$asList");
      },
      set$subclasses: function(subclasses) {
        this.subclasses = H.assertSubtype(subclasses, "$isList", [S.ClassRef], "$asList");
      },
      Class$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.error = H.interceptedTypeCheck(S._createObject(json.$index(0, "error")), "$isErrorRef");
        this.isAbstract = H.boolTypeCheck(json.$index(0, "abstract"));
        this.isConst = H.boolTypeCheck(json.$index(0, "const"));
        this.library = H.interceptedTypeCheck(S._createObject(json.$index(0, "library")), "$isObjRef");
        this.location = H.interceptedTypeCheck(S._createObject(json.$index(0, "location")), "$isSourceLocation");
        this.superClass = H.interceptedTypeCheck(S._createObject(json.$index(0, "super")), "$isClassRef");
        this.superType = H.interceptedTypeCheck(S._createObject(json.$index(0, "superType")), "$isInstanceRef");
        this.set$interfaces(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "interfaces")), "$isIterable"), true, S.InstanceRef));
        this.mixin = H.interceptedTypeCheck(S._createObject(json.$index(0, "mixin")), "$isInstanceRef");
        this.set$fields(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "fields")), "$isIterable"), true, S.FieldRef));
        this.set$functions(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "functions")), "$isIterable"), true, S.FuncRef));
        this.set$subclasses(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "subclasses")), "$isIterable"), true, S.ClassRef));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Class && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Class]";
      }, null, "get$toString", 1, 0, null],
      error$1: function($receiver, arg0) {
        return this.error.call$1(arg0);
      },
      static: {
        Class_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Class$_fromJson(json);
        }, "call$1", "vm_service_lib_Class_parse$closure", 4, 0, 222, 2],
        Class$_fromJson: [function(json) {
          var t1 = new S.Class(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Class$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ClassList: {
      "^": "Response;0classes>,json,0type,$ti",
      set$classes: function(_, classes) {
        this.classes = H.assertSubtype(classes, "$isList", [S.ClassRef], "$asList");
      },
      ClassList$_fromJson$1: [function(json) {
        this.set$classes(0, P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "classes")), "$isIterable"), true, S.ClassRef));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[ClassList type: " + H.S(this.type) + ", classes: " + H.S(this.classes) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ClassList_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ClassList$_fromJson(json);
        }, "call$1", "vm_service_lib_ClassList_parse$closure", 4, 0, 223, 2],
        ClassList$_fromJson: [function(json) {
          var t1 = new S.ClassList(json, []);
          t1.Response$_fromJson$1(json);
          t1.ClassList$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    CodeRef: {
      "^": "ObjRef;0name>,0kind>,0id,json,0type,$ti",
      CodeRef$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.CodeRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[CodeRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + ", kind: " + H.S(this.kind) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        CodeRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.CodeRef$_fromJson(json);
        }, "call$1", "vm_service_lib_CodeRef_parse$closure", 4, 0, 224, 2],
        CodeRef$: [function() {
          return new S.CodeRef(null, []);
        }, null, null, 0, 0, null],
        CodeRef$_fromJson: [function(json) {
          var t1 = new S.CodeRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.CodeRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Code: {
      "^": "ObjRef;0name>,0kind>,0id,json,0type,$ti",
      Code$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Code && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Code type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + ", kind: " + H.S(this.kind) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Code_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Code$_fromJson(json);
        }, "call$1", "vm_service_lib_Code_parse$closure", 4, 0, 225, 2],
        Code$_fromJson: [function(json) {
          var t1 = new S.Code(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.Code$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ContextRef: {
      "^": "ObjRef;0length>,0id,json,0type,$ti",
      set$length: function(_, $length) {
        this.length = H.intTypeCheck($length);
      },
      ContextRef$_fromJson$1: [function(json) {
        this.length = H.intTypeCheck(json.$index(0, "length"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.ContextRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[ContextRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", length: " + H.S(this.length) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ContextRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ContextRef$_fromJson(json);
        }, "call$1", "vm_service_lib_ContextRef_parse$closure", 4, 0, 226, 2],
        ContextRef$_fromJson: [function(json) {
          var t1 = new S.ContextRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.ContextRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Context: {
      "^": "Obj;0length>,0parent>,0variables,0id,0classRef,0size,json,0type,$ti",
      set$length: function(_, $length) {
        this.length = H.intTypeCheck($length);
      },
      set$variables: function(variables) {
        this.variables = H.assertSubtype(variables, "$isList", [S.ContextElement], "$asList");
      },
      Context$_fromJson$1: [function(json) {
        this.length = H.intTypeCheck(json.$index(0, "length"));
        this.parent = H.interceptedTypeCheck(S._createObject(json.$index(0, "parent")), "$isContext");
        this.set$variables(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "variables")), "$isIterable"), true, S.ContextElement));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Context && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Context type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", length: " + H.S(this.length) + ", variables: " + H.S(this.variables) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Context_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Context$_fromJson(json);
        }, "call$1", "vm_service_lib_Context_parse$closure", 4, 0, 227, 2],
        Context$_fromJson: [function(json) {
          var t1 = new S.Context(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Context$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ContextElement: {
      "^": "Object;0value*,$ti",
      ContextElement$_fromJson$1: [function(json) {
        this.value = S._createObject(json.$index(0, "value"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[ContextElement value: " + H.S(this.value) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ContextElement_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ContextElement$_fromJson(json);
        }, "call$1", "vm_service_lib_ContextElement_parse$closure", 4, 0, 228, 2],
        ContextElement$_fromJson: [function(json) {
          var t1 = new S.ContextElement([]);
          t1.ContextElement$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ErrorRef: {
      "^": "ObjRef;0kind>,0message>,0id,json,0type,$ti",
      ErrorRef$_fromJson$1: [function(json) {
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.message = H.stringTypeCheck(json.$index(0, "message"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.ErrorRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[ErrorRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + ", message: " + H.S(this.message) + "]";
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        ErrorRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ErrorRef$_fromJson(json);
        }, "call$1", "vm_service_lib_ErrorRef_parse$closure", 4, 0, 229, 2],
        ErrorRef$_fromJson: [function(json) {
          var t1 = new S.ErrorRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.ErrorRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Error0: {
      "^": "Obj;0kind>,0message>,0exception,0stacktrace,0id,0classRef,0size,json,0type,$ti",
      Error$_fromJson$1: [function(json) {
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.message = H.stringTypeCheck(json.$index(0, "message"));
        this.exception = H.interceptedTypeCheck(S._createObject(json.$index(0, "exception")), "$isInstanceRef");
        this.stacktrace = H.interceptedTypeCheck(S._createObject(json.$index(0, "stacktrace")), "$isInstanceRef");
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Error0 && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Error type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + ", message: " + H.S(this.message) + "]";
      }, null, "get$toString", 1, 0, null],
      message$2$color: function($receiver, arg0, arg1) {
        return this.message.call$2$color(arg0, arg1);
      },
      static: {
        Error_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Error$_fromJson(json);
        }, "call$1", "vm_service_lib_Error_parse$closure", 4, 0, 230, 2],
        Error$_fromJson: [function(json) {
          var t1 = new S.Error0(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Error$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Event0: {
      "^": "Response;0kind>,0isolate<,0vm,0timestamp<,0breakpoint,0pauseBreakpoints,0topFrame<,0exception,0bytes,0inspectee,0extensionRPC,0extensionKind,0extensionData,0timelineEvents,0atAsyncSuspension<,0status>,0service<,0method,0alias,json,0type,$ti",
      set$pauseBreakpoints: function(pauseBreakpoints) {
        this.pauseBreakpoints = H.assertSubtype(pauseBreakpoints, "$isList", [S.Breakpoint], "$asList");
      },
      set$timelineEvents: function(timelineEvents) {
        this.timelineEvents = H.assertSubtype(timelineEvents, "$isList", [S.TimelineEvent], "$asList");
      },
      Event$_fromJson$1: [function(json) {
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.isolate = H.interceptedTypeCheck(S._createObject(json.$index(0, "isolate")), "$isIsolateRef");
        this.vm = H.interceptedTypeCheck(S._createObject(json.$index(0, "vm")), "$isVMRef");
        this.timestamp = H.intTypeCheck(json.$index(0, "timestamp"));
        this.breakpoint = H.interceptedTypeCheck(S._createObject(json.$index(0, "breakpoint")), "$isBreakpoint");
        this.set$pauseBreakpoints(json.$index(0, "pauseBreakpoints") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "pauseBreakpoints")), "$isIterable"), true, S.Breakpoint));
        this.topFrame = H.interceptedTypeCheck(S._createObject(json.$index(0, "topFrame")), "$isFrame");
        this.exception = H.interceptedTypeCheck(S._createObject(json.$index(0, "exception")), "$isInstanceRef");
        this.bytes = H.stringTypeCheck(json.$index(0, "bytes"));
        this.inspectee = H.interceptedTypeCheck(S._createObject(json.$index(0, "inspectee")), "$isInstanceRef");
        this.extensionRPC = H.stringTypeCheck(json.$index(0, "extensionRPC"));
        this.extensionKind = H.stringTypeCheck(json.$index(0, "extensionKind"));
        this.extensionData = H.interceptedTypeCheck(S.ExtensionData_parse(H.interceptedTypeCheck(json.$index(0, "extensionData"), "$isMap")), "$isExtensionData");
        this.set$timelineEvents(json.$index(0, "timelineEvents") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "timelineEvents")), "$isIterable"), true, S.TimelineEvent));
        this.atAsyncSuspension = H.boolTypeCheck(json.$index(0, "atAsyncSuspension"));
        this.status = H.stringTypeCheck(json.$index(0, "status"));
        this.service = H.stringTypeCheck(json.$index(0, "service"));
        this.method = H.stringTypeCheck(json.$index(0, "method"));
        this.alias = H.stringTypeCheck(json.$index(0, "alias"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Event type: " + H.S(this.type) + ", kind: " + H.S(this.kind) + ", timestamp: " + H.S(this.timestamp) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Event_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Event$_fromJson(json);
        }, "call$1", "vm_service_lib_Event_parse$closure", 4, 0, 231, 2],
        Event$_fromJson: [function(json) {
          var t1 = new S.Event0(json, []);
          t1.Response$_fromJson$1(json);
          t1.Event$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    FieldRef: {
      "^": "ObjRef;0name>,0owner,0declaredType,0isConst,0isFinal,0isStatic,0id,json,0type,$ti",
      FieldRef$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.owner = H.interceptedTypeCheck(S._createObject(json.$index(0, "owner")), "$isObjRef");
        this.declaredType = H.interceptedTypeCheck(S._createObject(json.$index(0, "declaredType")), "$isInstanceRef");
        this.isConst = H.boolTypeCheck(json.$index(0, "const"));
        this.isFinal = H.boolTypeCheck(json.$index(0, "final"));
        this.isStatic = H.boolTypeCheck(json.$index(0, "static"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.FieldRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[FieldRef]";
      }, null, "get$toString", 1, 0, null],
      static: {
        FieldRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.FieldRef$_fromJson(json);
        }, "call$1", "vm_service_lib_FieldRef_parse$closure", 4, 0, 232, 2],
        FieldRef$_fromJson: [function(json) {
          var t1 = new S.FieldRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.FieldRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Field: {
      "^": "Obj;0name>,0owner,0declaredType,0isConst,0isFinal,0isStatic,0staticValue,0location>,0id,0classRef,0size,json,0type,$ti",
      Field$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.owner = H.interceptedTypeCheck(S._createObject(json.$index(0, "owner")), "$isObjRef");
        this.declaredType = H.interceptedTypeCheck(S._createObject(json.$index(0, "declaredType")), "$isInstanceRef");
        this.isConst = H.boolTypeCheck(json.$index(0, "const"));
        this.isFinal = H.boolTypeCheck(json.$index(0, "final"));
        this.isStatic = H.boolTypeCheck(json.$index(0, "static"));
        this.staticValue = H.interceptedTypeCheck(S._createObject(json.$index(0, "staticValue")), "$isInstanceRef");
        this.location = H.interceptedTypeCheck(S._createObject(json.$index(0, "location")), "$isSourceLocation");
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Field && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Field]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Field_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Field$_fromJson(json);
        }, "call$1", "vm_service_lib_Field_parse$closure", 4, 0, 233, 2],
        Field$_fromJson: [function(json) {
          var t1 = new S.Field(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Field$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Flag: {
      "^": "Object;0name>,0comment,0modified,0valueAsString<,$ti",
      Flag$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.comment = H.stringTypeCheck(json.$index(0, "comment"));
        this.modified = H.boolTypeCheck(json.$index(0, "modified"));
        this.valueAsString = H.stringTypeCheck(json.$index(0, "valueAsString"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Flag name: " + H.S(this.name) + ", comment: " + H.S(this.comment) + ", modified: " + H.S(this.modified) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Flag_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Flag$_fromJson(json);
        }, "call$1", "vm_service_lib_Flag_parse$closure", 4, 0, 234, 2],
        Flag$_fromJson: [function(json) {
          var t1 = new S.Flag([]);
          t1.Flag$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    FlagList: {
      "^": "Response;0flags,json,0type,$ti",
      set$flags: function(flags) {
        this.flags = H.assertSubtype(flags, "$isList", [S.Flag], "$asList");
      },
      FlagList$_fromJson$1: [function(json) {
        this.set$flags(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "flags")), "$isIterable"), true, S.Flag));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[FlagList type: " + H.S(this.type) + ", flags: " + H.S(this.flags) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        FlagList_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.FlagList$_fromJson(json);
        }, "call$1", "vm_service_lib_FlagList_parse$closure", 4, 0, 235, 2],
        FlagList$_fromJson: [function(json) {
          var t1 = new S.FlagList(json, []);
          t1.Response$_fromJson$1(json);
          t1.FlagList$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Frame: {
      "^": "Response;0index>,0$function,0code>,0location>,0vars,0kind>,json,0type,$ti",
      set$vars: function(vars) {
        this.vars = H.assertSubtype(vars, "$isList", [S.BoundVariable], "$asList");
      },
      Frame$_fromJson$1: [function(json) {
        this.index = H.intTypeCheck(json.$index(0, "index"));
        this.$function = H.interceptedTypeCheck(S._createObject(json.$index(0, "function")), "$isFuncRef");
        this.code = H.interceptedTypeCheck(S._createObject(json.$index(0, "code")), "$isCodeRef");
        this.location = H.interceptedTypeCheck(S._createObject(json.$index(0, "location")), "$isSourceLocation");
        this.set$vars(json.$index(0, "vars") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "vars")), "$isIterable"), true, S.BoundVariable));
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Frame type: " + H.S(this.type) + ", index: " + H.S(this.index) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Frame_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Frame$_fromJson(json);
        }, "call$1", "vm_service_lib_Frame_parse$closure", 4, 0, 236, 2],
        Frame$: [function() {
          return new S.Frame(null, []);
        }, null, null, 0, 0, null],
        Frame$_fromJson: [function(json) {
          var t1 = new S.Frame(json, []);
          t1.Response$_fromJson$1(json);
          t1.Frame$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    FuncRef: {
      "^": "ObjRef;0name>,0owner,0isStatic,0isConst,0id,json,0type,$ti",
      FuncRef$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.owner = S._createObject(json.$index(0, "owner"));
        this.isStatic = H.boolTypeCheck(json.$index(0, "static"));
        this.isConst = H.boolTypeCheck(json.$index(0, "const"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.FuncRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[FuncRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + ", owner: " + H.S(this.owner) + ", isStatic: " + H.S(this.isStatic) + ", isConst: " + H.S(this.isConst) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        FuncRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.FuncRef$_fromJson(json);
        }, "call$1", "vm_service_lib_FuncRef_parse$closure", 4, 0, 237, 2],
        FuncRef$_fromJson: [function(json) {
          var t1 = new S.FuncRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.FuncRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Func: {
      "^": "Obj;0name>,0owner,0location>,0code>,0id,0classRef,0size,json,0type,$ti",
      Func$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.owner = S._createObject(json.$index(0, "owner"));
        this.location = H.interceptedTypeCheck(S._createObject(json.$index(0, "location")), "$isSourceLocation");
        this.code = H.interceptedTypeCheck(S._createObject(json.$index(0, "code")), "$isCodeRef");
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Func && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Func type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + ", owner: " + H.S(this.owner) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Func_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Func$_fromJson(json);
        }, "call$1", "vm_service_lib_Func_parse$closure", 4, 0, 238, 2],
        Func$_fromJson: [function(json) {
          var t1 = new S.Func(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Func$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    InstanceRef: {
      "^": "ObjRef;0kind>,0classRef,0valueAsString<,0valueAsStringIsTruncated,0length>,0name>,0typeClass,0parameterizedClass,0pattern>,0id,json,0type,$ti",
      set$length: function(_, $length) {
        this.length = H.intTypeCheck($length);
      },
      InstanceRef$_fromJson$1: [function(json) {
        var t1;
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.classRef = H.interceptedTypeCheck(S._createObject(json.$index(0, "class")), "$isClassRef");
        this.valueAsString = H.stringTypeCheck(json.$index(0, "valueAsString"));
        t1 = json.$index(0, "valueAsStringIsTruncated");
        this.valueAsStringIsTruncated = H.boolTypeCheck(t1 == null ? false : t1);
        this.length = H.intTypeCheck(json.$index(0, "length"));
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.typeClass = H.interceptedTypeCheck(S._createObject(json.$index(0, "typeClass")), "$isClassRef");
        this.parameterizedClass = H.interceptedTypeCheck(S._createObject(json.$index(0, "parameterizedClass")), "$isClassRef");
        this.pattern = H.interceptedTypeCheck(S._createObject(json.$index(0, "pattern")), "$isInstanceRef");
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.InstanceRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[InstanceRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + ", classRef: " + H.S(this.classRef) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        InstanceRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.InstanceRef$_fromJson(json);
        }, "call$1", "vm_service_lib_InstanceRef_parse$closure", 4, 0, 239, 2],
        InstanceRef$_fromJson: [function(json) {
          var t1 = new S.InstanceRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.InstanceRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Instance: {
      "^": "Obj;0kind>,0valueAsString<,0valueAsStringIsTruncated,0length>,0offset>,0count,0name>,0typeClass,0parameterizedClass,0fields,0elements,0associations,0bytes,0closureFunction,0mirrorReferent,0pattern>,0isCaseSensitive,0isMultiLine,0propertyKey,0propertyValue,0typeArguments,0parameterIndex,0targetType,0bound,0id,0classRef,0size,json,0type,$ti",
      set$length: function(_, $length) {
        this.length = H.intTypeCheck($length);
      },
      set$fields: function(fields) {
        this.fields = H.assertSubtype(fields, "$isList", [S.BoundField], "$asList");
      },
      set$associations: function(associations) {
        this.associations = H.assertSubtype(associations, "$isList", [S.MapAssociation], "$asList");
      },
      Instance$_fromJson$1: [function(json) {
        var t1;
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.valueAsString = H.stringTypeCheck(json.$index(0, "valueAsString"));
        t1 = json.$index(0, "valueAsStringIsTruncated");
        this.valueAsStringIsTruncated = H.boolTypeCheck(t1 == null ? false : t1);
        this.length = H.intTypeCheck(json.$index(0, "length"));
        this.offset = H.intTypeCheck(json.$index(0, "offset"));
        this.count = H.intTypeCheck(json.$index(0, "count"));
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.typeClass = H.interceptedTypeCheck(S._createObject(json.$index(0, "typeClass")), "$isClassRef");
        this.parameterizedClass = H.interceptedTypeCheck(S._createObject(json.$index(0, "parameterizedClass")), "$isClassRef");
        this.set$fields(json.$index(0, "fields") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "fields")), "$isIterable"), true, S.BoundField));
        this.elements = H.listTypeCheck(json.$index(0, "elements") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "elements")), "$isIterable"), true, null));
        this.set$associations(json.$index(0, "associations") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(json.$index(0, "associations"), S.vm_service_lib_MapAssociation_parse$closure()), "$isIterable"), true, S.MapAssociation));
        this.bytes = H.stringTypeCheck(json.$index(0, "bytes"));
        this.closureFunction = H.interceptedTypeCheck(S._createObject(json.$index(0, "closureFunction")), "$isFuncRef");
        this.mirrorReferent = H.interceptedTypeCheck(S._createObject(json.$index(0, "mirrorReferent")), "$isInstanceRef");
        this.pattern = H.stringTypeCheck(json.$index(0, "pattern"));
        this.isCaseSensitive = H.boolTypeCheck(json.$index(0, "isCaseSensitive"));
        this.isMultiLine = H.boolTypeCheck(json.$index(0, "isMultiLine"));
        this.propertyKey = H.interceptedTypeCheck(S._createObject(json.$index(0, "propertyKey")), "$isInstanceRef");
        this.propertyValue = H.interceptedTypeCheck(S._createObject(json.$index(0, "propertyValue")), "$isInstanceRef");
        this.typeArguments = H.interceptedTypeCheck(S._createObject(json.$index(0, "typeArguments")), "$isTypeArgumentsRef");
        this.parameterIndex = H.intTypeCheck(json.$index(0, "parameterIndex"));
        this.targetType = H.interceptedTypeCheck(S._createObject(json.$index(0, "targetType")), "$isInstanceRef");
        this.bound = H.interceptedTypeCheck(S._createObject(json.$index(0, "bound")), "$isInstanceRef");
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Instance && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Instance type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Instance_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Instance$_fromJson(json);
        }, "call$1", "vm_service_lib_Instance_parse$closure", 4, 0, 240, 2],
        Instance$_fromJson: [function(json) {
          var t1 = new S.Instance(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Instance$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    IsolateRef: {
      "^": "Response;0id>,0number,0name>,json,0type,$ti",
      IsolateRef$_fromJson$1: [function(json) {
        this.id = H.stringTypeCheck(json.$index(0, "id"));
        this.number = H.stringTypeCheck(json.$index(0, "number"));
        this.name = H.stringTypeCheck(json.$index(0, "name"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.IsolateRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[IsolateRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", number: " + H.S(this.number) + ", name: " + H.S(this.name) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        IsolateRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.IsolateRef$_fromJson(json);
        }, "call$1", "vm_service_lib_IsolateRef_parse$closure", 4, 0, 241, 2],
        IsolateRef$_fromJson: [function(json) {
          var t1 = new S.IsolateRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.IsolateRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Isolate: {
      "^": "Response;0id>,0number,0name>,0startTime<,0runnable,0livePorts,0pauseOnExit,0pauseEvent,0rootLib<,0libraries<,0breakpoints<,0error>,0exceptionPauseMode<,0extensionRPCs,json,0type,$ti",
      set$libraries: function(libraries) {
        this.libraries = H.assertSubtype(libraries, "$isList", [S.LibraryRef], "$asList");
      },
      set$breakpoints: function(breakpoints) {
        this.breakpoints = H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList");
      },
      set$exceptionPauseMode: function(exceptionPauseMode) {
        this.exceptionPauseMode = H.stringTypeCheck(exceptionPauseMode);
      },
      set$extensionRPCs: function(extensionRPCs) {
        this.extensionRPCs = H.assertSubtype(extensionRPCs, "$isList", [P.String], "$asList");
      },
      Isolate$_fromJson$1: [function(json) {
        this.id = H.stringTypeCheck(json.$index(0, "id"));
        this.number = H.stringTypeCheck(json.$index(0, "number"));
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.startTime = H.intTypeCheck(json.$index(0, "startTime"));
        this.runnable = H.boolTypeCheck(json.$index(0, "runnable"));
        this.livePorts = H.intTypeCheck(json.$index(0, "livePorts"));
        this.pauseOnExit = H.boolTypeCheck(json.$index(0, "pauseOnExit"));
        this.pauseEvent = H.interceptedTypeCheck(S._createObject(json.$index(0, "pauseEvent")), "$isEvent0");
        this.rootLib = H.interceptedTypeCheck(S._createObject(json.$index(0, "rootLib")), "$isLibraryRef");
        this.set$libraries(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "libraries")), "$isIterable"), true, S.LibraryRef));
        this.set$breakpoints(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "breakpoints")), "$isIterable"), true, S.Breakpoint));
        this.error = H.interceptedTypeCheck(S._createObject(json.$index(0, "error")), "$isError0");
        this.exceptionPauseMode = H.stringTypeCheck(json.$index(0, "exceptionPauseMode"));
        this.set$extensionRPCs(json.$index(0, "extensionRPCs") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "extensionRPCs"), "$isIterable"), true, P.String));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Isolate && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Isolate]";
      }, null, "get$toString", 1, 0, null],
      error$1: function($receiver, arg0) {
        return this.error.call$1(arg0);
      },
      static: {
        Isolate_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Isolate$_fromJson(json);
        }, "call$1", "vm_service_lib_Isolate_parse$closure", 4, 0, 242, 2],
        Isolate$_fromJson: [function(json) {
          var t1 = new S.Isolate(json, []);
          t1.Response$_fromJson$1(json);
          t1.Isolate$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    LibraryRef: {
      "^": "ObjRef;0name>,0uri<,0id,json,0type,$ti",
      LibraryRef$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.uri = H.stringTypeCheck(json.$index(0, "uri"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.LibraryRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[LibraryRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + ", uri: " + H.S(this.uri) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        LibraryRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.LibraryRef$_fromJson(json);
        }, "call$1", "vm_service_lib_LibraryRef_parse$closure", 4, 0, 243, 2],
        LibraryRef$_fromJson: [function(json) {
          var t1 = new S.LibraryRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.LibraryRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Library: {
      "^": "Obj;0name>,0uri<,0debuggable,0dependencies,0scripts,0variables,0functions,0classes>,0id,0classRef,0size,json,0type,$ti",
      set$dependencies: function(dependencies) {
        this.dependencies = H.assertSubtype(dependencies, "$isList", [S.LibraryDependency], "$asList");
      },
      set$scripts: function(scripts) {
        this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
      },
      set$variables: function(variables) {
        this.variables = H.assertSubtype(variables, "$isList", [S.FieldRef], "$asList");
      },
      set$functions: function(functions) {
        this.functions = H.assertSubtype(functions, "$isList", [S.FuncRef], "$asList");
      },
      set$classes: function(_, classes) {
        this.classes = H.assertSubtype(classes, "$isList", [S.ClassRef], "$asList");
      },
      Library$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.uri = H.stringTypeCheck(json.$index(0, "uri"));
        this.debuggable = H.boolTypeCheck(json.$index(0, "debuggable"));
        this.set$dependencies(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "dependencies")), "$isIterable"), true, S.LibraryDependency));
        this.set$scripts(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "scripts")), "$isIterable"), true, S.ScriptRef));
        this.set$variables(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "variables")), "$isIterable"), true, S.FieldRef));
        this.set$functions(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "functions")), "$isIterable"), true, S.FuncRef));
        this.set$classes(0, P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "classes")), "$isIterable"), true, S.ClassRef));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Library && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Library]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Library_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Library$_fromJson(json);
        }, "call$1", "vm_service_lib_Library_parse$closure", 4, 0, 244, 2],
        Library$_fromJson: [function(json) {
          var t1 = new S.Library(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Library$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    LibraryDependency: {
      "^": "Object;0isImport,0isDeferred,0prefix,0target,$ti",
      LibraryDependency$_fromJson$1: [function(json) {
        this.isImport = H.boolTypeCheck(json.$index(0, "isImport"));
        this.isDeferred = H.boolTypeCheck(json.$index(0, "isDeferred"));
        this.prefix = H.stringTypeCheck(json.$index(0, "prefix"));
        this.target = H.interceptedTypeCheck(S._createObject(json.$index(0, "target")), "$isLibraryRef");
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[LibraryDependency isImport: " + H.S(this.isImport) + ", isDeferred: " + H.S(this.isDeferred) + ", prefix: " + H.S(this.prefix) + ", target: " + H.S(this.target) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        LibraryDependency_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.LibraryDependency$_fromJson(json);
        }, "call$1", "vm_service_lib_LibraryDependency_parse$closure", 4, 0, 245, 2],
        LibraryDependency$_fromJson: [function(json) {
          var t1 = new S.LibraryDependency([]);
          t1.LibraryDependency$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    MapAssociation: {
      "^": "Object;0key,0value*,$ti",
      MapAssociation$_fromJson$1: [function(json) {
        this.key = S._createObject(json.$index(0, "key"));
        this.value = S._createObject(json.$index(0, "value"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[MapAssociation key: " + H.S(this.key) + ", value: " + H.S(this.value) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        MapAssociation_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.MapAssociation$_fromJson(json);
        }, "call$1", "vm_service_lib_MapAssociation_parse$closure", 4, 0, 246, 2],
        MapAssociation$_fromJson: [function(json) {
          var t1 = new S.MapAssociation([]);
          t1.MapAssociation$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Message: {
      "^": "Response;0index>,0name>,0messageObjectId,0size,0handler,0location>,json,0type,$ti",
      Message$_fromJson$1: [function(json) {
        this.index = H.intTypeCheck(json.$index(0, "index"));
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.messageObjectId = H.stringTypeCheck(json.$index(0, "messageObjectId"));
        this.size = H.intTypeCheck(json.$index(0, "size"));
        this.handler = H.interceptedTypeCheck(S._createObject(json.$index(0, "handler")), "$isFuncRef");
        this.location = H.interceptedTypeCheck(S._createObject(json.$index(0, "location")), "$isSourceLocation");
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Message type: " + H.S(this.type) + ", index: " + H.S(this.index) + ", name: " + H.S(this.name) + ", messageObjectId: " + H.S(this.messageObjectId) + ", size: " + H.S(this.size) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Message_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Message$_fromJson(json);
        }, "call$1", "vm_service_lib_Message_parse$closure", 4, 0, 247, 2],
        Message$_fromJson: [function(json) {
          var t1 = new S.Message(json, []);
          t1.Response$_fromJson$1(json);
          t1.Message$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    NullValRef: {
      "^": "InstanceRef;0kind,0classRef,0valueAsString,0valueAsStringIsTruncated,0length,0name,0typeClass,0parameterizedClass,0pattern,0id,json,0type,$ti",
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.NullValRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[NullValRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + ", classRef: " + H.S(this.classRef) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        NullValRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.NullValRef$_fromJson(json);
        }, "call$1", "vm_service_lib_NullValRef_parse$closure", 4, 0, 248, 2],
        NullValRef$_fromJson: [function(json) {
          var t1 = new S.NullValRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.InstanceRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    NullVal: {
      "^": "Instance;0kind,0valueAsString,0valueAsStringIsTruncated,0length,0offset,0count,0name,0typeClass,0parameterizedClass,0fields,0elements,0associations,0bytes,0closureFunction,0mirrorReferent,0pattern,0isCaseSensitive,0isMultiLine,0propertyKey,0propertyValue,0typeArguments,0parameterIndex,0targetType,0bound,0id,0classRef,0size,json,0type,$ti",
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.NullVal && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[NullVal type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        NullVal_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.NullVal$_fromJson(json);
        }, "call$1", "vm_service_lib_NullVal_parse$closure", 4, 0, 249, 2],
        NullVal$_fromJson: [function(json) {
          var t1 = new S.NullVal(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Instance$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ObjRef: {
      "^": "Response;0id>,json,0type,$ti",
      ObjRef$_fromJson$1: [function(json) {
        this.id = H.stringTypeCheck(json.$index(0, "id"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.ObjRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[ObjRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ObjRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ObjRef$_fromJson(json);
        }, "call$1", "vm_service_lib_ObjRef_parse$closure", 4, 0, 250, 2],
        ObjRef$_fromJson: [function(json) {
          var t1 = new S.ObjRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Obj: {
      "^": "Response;0id>,0classRef,0size,json,0type,$ti",
      Obj$_fromJson$1: [function(json) {
        this.id = H.stringTypeCheck(json.$index(0, "id"));
        this.classRef = H.interceptedTypeCheck(S._createObject(json.$index(0, "class")), "$isClassRef");
        this.size = H.intTypeCheck(json.$index(0, "size"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Obj && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Obj type: " + H.S(this.type) + ", id: " + H.S(this.id) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Obj_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Obj$_fromJson(json);
        }, "call$1", "vm_service_lib_Obj_parse$closure", 4, 0, 251, 2],
        Obj$_fromJson: [function(json) {
          var t1 = new S.Obj(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ReloadReport: {
      "^": "Response;0success,json,0type,$ti",
      ReloadReport$_fromJson$1: [function(json) {
        this.success = H.boolTypeCheck(json.$index(0, "success"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[ReloadReport type: " + H.S(this.type) + ", success: " + H.S(this.success) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ReloadReport_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ReloadReport$_fromJson(json);
        }, "call$1", "vm_service_lib_ReloadReport_parse$closure", 4, 0, 252, 2],
        ReloadReport$_fromJson: [function(json) {
          var t1 = new S.ReloadReport(json, []);
          t1.Response$_fromJson$1(json);
          t1.ReloadReport$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Response: {
      "^": "Object;json,0type,$ti",
      Response$_fromJson$1: [function(json) {
        this.type = H.stringTypeCheck(J.$index$asx(this.json, "type"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Response type: " + H.S(this.type) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Response_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Response$_fromJson(json);
        }, "call$1", "vm_service_lib_Response_parse$closure", 4, 0, 253, 2],
        Response$_fromJson: [function(json) {
          var t1 = new S.Response(json, []);
          t1.Response$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Sentinel: {
      "^": "Response;0kind>,0valueAsString<,json,0type,$ti",
      Sentinel$_fromJson$1: [function(json) {
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.valueAsString = H.stringTypeCheck(json.$index(0, "valueAsString"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Sentinel type: " + H.S(this.type) + ", kind: " + H.S(this.kind) + ", valueAsString: " + H.S(this.valueAsString) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Sentinel_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Sentinel$_fromJson(json);
        }, "call$1", "vm_service_lib_Sentinel_parse$closure", 4, 0, 254, 2],
        Sentinel$_fromJson: [function(json) {
          var t1 = new S.Sentinel(json, []);
          t1.Response$_fromJson$1(json);
          t1.Sentinel$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ScriptRef: {
      "^": "ObjRef;0uri<,0id,json,0type,$ti",
      ScriptRef$_fromJson$1: [function(json) {
        this.uri = H.stringTypeCheck(json.$index(0, "uri"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.ScriptRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[ScriptRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", uri: " + H.S(this.uri) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ScriptRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ScriptRef$_fromJson(json);
        }, "call$1", "vm_service_lib_ScriptRef_parse$closure", 4, 0, 255, 2],
        ScriptRef$_fromJson: [function(json) {
          var t1 = new S.ScriptRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.ScriptRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Script: {
      "^": "Obj;0uri<,0library,0source>,0tokenPosTable,0id,0classRef,0size,json,0type,$ti",
      set$tokenPosTable: function(tokenPosTable) {
        this.tokenPosTable = H.assertSubtype(tokenPosTable, "$isList", [[P.List, P.int]], "$asList");
      },
      Script$_fromJson$1: [function(json) {
        this.uri = H.stringTypeCheck(json.$index(0, "uri"));
        this.library = H.interceptedTypeCheck(S._createObject(json.$index(0, "library")), "$isLibraryRef");
        this.source = H.stringTypeCheck(json.$index(0, "source"));
        this.set$tokenPosTable(P.List_List$from(H.listSuperNativeTypeCheck(J.map$1$ax(json.$index(0, "tokenPosTable"), new S.Script$_fromJson_closure()), "$isIterable"), true, [P.List, P.int]));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.Script && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[Script type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", uri: " + H.S(this.uri) + ", library: " + H.S(this.library) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Script_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Script$_fromJson(json);
        }, "call$1", "vm_service_lib_Script_parse$closure", 4, 0, 256, 2],
        Script$_fromJson: [function(json) {
          var t1 = new S.Script(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.Script$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Script$_fromJson_closure: {
      "^": "Closure:206;$ti",
      call$1: [function(list) {
        return P.List_List$from(H.listSuperNativeTypeCheck(list, "$isIterable"), true, P.int);
      }, null, null, 4, 0, null, 68, "call"]
    },
    ScriptList: {
      "^": "Response;0scripts,json,0type,$ti",
      set$scripts: function(scripts) {
        this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
      },
      ScriptList$_fromJson$1: [function(json) {
        this.set$scripts(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "scripts")), "$isIterable"), true, S.ScriptRef));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[ScriptList type: " + H.S(this.type) + ", scripts: " + H.S(this.scripts) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ScriptList_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ScriptList$_fromJson(json);
        }, "call$1", "vm_service_lib_ScriptList_parse$closure", 4, 0, 257, 2],
        ScriptList$_fromJson: [function(json) {
          var t1 = new S.ScriptList(json, []);
          t1.Response$_fromJson$1(json);
          t1.ScriptList$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    SourceLocation: {
      "^": "Response;0script<,0tokenPos<,0endTokenPos,json,0type,$ti",
      SourceLocation$_fromJson$1: [function(json) {
        this.script = H.interceptedTypeCheck(S._createObject(json.$index(0, "script")), "$isScriptRef");
        this.tokenPos = H.intTypeCheck(json.$index(0, "tokenPos"));
        this.endTokenPos = H.intTypeCheck(json.$index(0, "endTokenPos"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[SourceLocation type: " + H.S(this.type) + ", script: " + H.S(this.script) + ", tokenPos: " + H.S(this.tokenPos) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        SourceLocation_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.SourceLocation$_fromJson(json);
        }, "call$1", "vm_service_lib_SourceLocation_parse$closure", 4, 0, 258, 2],
        SourceLocation$_fromJson: [function(json) {
          var t1 = new S.SourceLocation(json, []);
          t1.Response$_fromJson$1(json);
          t1.SourceLocation$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    SourceReport: {
      "^": "Response;0ranges,0scripts,json,0type,$ti",
      set$ranges: function(ranges) {
        this.ranges = H.assertSubtype(ranges, "$isList", [S.SourceReportRange], "$asList");
      },
      set$scripts: function(scripts) {
        this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
      },
      SourceReport$_fromJson$1: [function(json) {
        this.set$ranges(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "ranges")), "$isIterable"), true, S.SourceReportRange));
        this.set$scripts(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "scripts")), "$isIterable"), true, S.ScriptRef));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[SourceReport type: " + H.S(this.type) + ", ranges: " + H.S(this.ranges) + ", scripts: " + H.S(this.scripts) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        SourceReport_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.SourceReport$_fromJson(json);
        }, "call$1", "vm_service_lib_SourceReport_parse$closure", 4, 0, 259, 2],
        SourceReport$_fromJson: [function(json) {
          var t1 = new S.SourceReport(json, []);
          t1.Response$_fromJson$1(json);
          t1.SourceReport$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    SourceReportCoverage: {
      "^": "Object;0hits,0misses,$ti",
      set$hits: function(hits) {
        this.hits = H.assertSubtype(hits, "$isList", [P.int], "$asList");
      },
      set$misses: function(misses) {
        this.misses = H.assertSubtype(misses, "$isList", [P.int], "$asList");
      },
      SourceReportCoverage$_fromJson$1: [function(json) {
        var t1 = P.int;
        this.set$hits(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "hits"), "$isIterable"), true, t1));
        this.set$misses(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "misses"), "$isIterable"), true, t1));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[SourceReportCoverage hits: " + H.S(this.hits) + ", misses: " + H.S(this.misses) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        SourceReportCoverage_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.SourceReportCoverage$_fromJson(json);
        }, "call$1", "vm_service_lib_SourceReportCoverage_parse$closure", 4, 0, 260, 2],
        SourceReportCoverage$_fromJson: [function(json) {
          var t1 = new S.SourceReportCoverage([]);
          t1.SourceReportCoverage$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    SourceReportRange: {
      "^": "Object;0scriptIndex,0startPos,0endPos,0compiled,0error>,0coverage,0possibleBreakpoints,$ti",
      set$possibleBreakpoints: function(possibleBreakpoints) {
        this.possibleBreakpoints = H.assertSubtype(possibleBreakpoints, "$isList", [P.int], "$asList");
      },
      SourceReportRange$_fromJson$1: [function(json) {
        this.scriptIndex = H.intTypeCheck(json.$index(0, "scriptIndex"));
        this.startPos = H.intTypeCheck(json.$index(0, "startPos"));
        this.endPos = H.intTypeCheck(json.$index(0, "endPos"));
        this.compiled = H.boolTypeCheck(json.$index(0, "compiled"));
        this.error = H.interceptedTypeCheck(S._createObject(json.$index(0, "error")), "$isErrorRef");
        this.coverage = H.interceptedTypeCheck(S._createObject(json.$index(0, "coverage")), "$isSourceReportCoverage");
        this.set$possibleBreakpoints(json.$index(0, "possibleBreakpoints") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "possibleBreakpoints"), "$isIterable"), true, P.int));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[SourceReportRange scriptIndex: " + H.S(this.scriptIndex) + ", startPos: " + H.S(this.startPos) + ", endPos: " + H.S(this.endPos) + ", compiled: " + H.S(this.compiled) + "]";
      }, null, "get$toString", 1, 0, null],
      error$1: function($receiver, arg0) {
        return this.error.call$1(arg0);
      },
      static: {
        SourceReportRange_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.SourceReportRange$_fromJson(json);
        }, "call$1", "vm_service_lib_SourceReportRange_parse$closure", 4, 0, 261, 2],
        SourceReportRange$_fromJson: [function(json) {
          var t1 = new S.SourceReportRange([]);
          t1.SourceReportRange$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Stack: {
      "^": "Response;0frames,0asyncCausalFrames,0awaiterFrames,0messages,json,0type,$ti",
      set$frames: function($frames) {
        this.frames = H.assertSubtype($frames, "$isList", [S.Frame], "$asList");
      },
      set$asyncCausalFrames: function(asyncCausalFrames) {
        this.asyncCausalFrames = H.assertSubtype(asyncCausalFrames, "$isList", [S.Frame], "$asList");
      },
      set$awaiterFrames: function(awaiterFrames) {
        this.awaiterFrames = H.assertSubtype(awaiterFrames, "$isList", [S.Frame], "$asList");
      },
      set$messages: function(messages) {
        this.messages = H.assertSubtype(messages, "$isList", [S.Message], "$asList");
      },
      Stack$_fromJson$1: [function(json) {
        var t1 = S.Frame;
        this.set$frames(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "frames")), "$isIterable"), true, t1));
        this.set$asyncCausalFrames(json.$index(0, "asyncCausalFrames") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "asyncCausalFrames")), "$isIterable"), true, t1));
        this.set$awaiterFrames(json.$index(0, "awaiterFrames") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "awaiterFrames")), "$isIterable"), true, t1));
        this.set$messages(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "messages")), "$isIterable"), true, S.Message));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Stack type: " + H.S(this.type) + ", frames: " + H.S(this.frames) + ", messages: " + H.S(this.messages) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Stack_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Stack$_fromJson(json);
        }, "call$1", "vm_service_lib_Stack_parse$closure", 4, 0, 262, 2],
        Stack$_fromJson: [function(json) {
          var t1 = new S.Stack(json, []);
          t1.Response$_fromJson$1(json);
          t1.Stack$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Success: {
      "^": "Response;json,0type,$ti",
      toString$0: [function(_) {
        return "[Success type: " + H.S(this.type) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Success_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Success$_fromJson(json);
        }, "call$1", "vm_service_lib_Success_parse$closure", 4, 0, 263, 2],
        Success$_fromJson: [function(json) {
          var t1 = new S.Success(json, []);
          t1.Response$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    TimelineEvent: {
      "^": "Object;$ti",
      toString$0: [function(_) {
        return "[TimelineEvent ]";
      }, null, "get$toString", 1, 0, null],
      static: {
        TimelineEvent_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.TimelineEvent$_fromJson(json);
        }, "call$1", "vm_service_lib_TimelineEvent_parse$closure", 4, 0, 264, 2],
        TimelineEvent$_fromJson: [function(json) {
          return new S.TimelineEvent([]);
        }, null, null, 4, 0, null, 2]
      }
    },
    TypeArgumentsRef: {
      "^": "ObjRef;0name>,0id,json,0type,$ti",
      TypeArgumentsRef$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.TypeArgumentsRef && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[TypeArgumentsRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        TypeArgumentsRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.TypeArgumentsRef$_fromJson(json);
        }, "call$1", "vm_service_lib_TypeArgumentsRef_parse$closure", 4, 0, 265, 2],
        TypeArgumentsRef$_fromJson: [function(json) {
          var t1 = new S.TypeArgumentsRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.ObjRef$_fromJson$1(json);
          t1.TypeArgumentsRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    TypeArguments: {
      "^": "Obj;0name>,0types,0id,0classRef,0size,json,0type,$ti",
      set$types: function(types) {
        this.types = H.assertSubtype(types, "$isList", [S.InstanceRef], "$asList");
      },
      TypeArguments$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.set$types(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "types")), "$isIterable"), true, S.InstanceRef));
      }, null, null, 4, 0, null, 2],
      get$hashCode: [function(_) {
        return J.get$hashCode$(this.id);
      }, null, null, 3, 0, null],
      $eq: [function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.TypeArguments && J.$eq$(this.id, other.id);
      }, null, "get$==", 5, 0, null, 3],
      toString$0: [function(_) {
        return "[TypeArguments type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + ", types: " + H.S(this.types) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        TypeArguments_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.TypeArguments$_fromJson(json);
        }, "call$1", "vm_service_lib_TypeArguments_parse$closure", 4, 0, 266, 2],
        TypeArguments$_fromJson: [function(json) {
          var t1 = new S.TypeArguments(json, []);
          t1.Response$_fromJson$1(json);
          t1.Obj$_fromJson$1(json);
          t1.TypeArguments$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    UnresolvedSourceLocation: {
      "^": "Response;0script<,0scriptUri,0tokenPos<,0line<,0column<,json,0type,$ti",
      UnresolvedSourceLocation$_fromJson$1: [function(json) {
        this.script = H.interceptedTypeCheck(S._createObject(json.$index(0, "script")), "$isScriptRef");
        this.scriptUri = H.stringTypeCheck(json.$index(0, "scriptUri"));
        this.tokenPos = H.intTypeCheck(json.$index(0, "tokenPos"));
        this.line = H.intTypeCheck(json.$index(0, "line"));
        this.column = H.intTypeCheck(json.$index(0, "column"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[UnresolvedSourceLocation type: " + H.S(this.type) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        UnresolvedSourceLocation_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.UnresolvedSourceLocation$_fromJson(json);
        }, "call$1", "vm_service_lib_UnresolvedSourceLocation_parse$closure", 4, 0, 267, 2],
        UnresolvedSourceLocation$_fromJson: [function(json) {
          var t1 = new S.UnresolvedSourceLocation(json, []);
          t1.Response$_fromJson$1(json);
          t1.UnresolvedSourceLocation$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    Version: {
      "^": "Response;0major,0minor,json,0type,$ti",
      Version$_fromJson$1: [function(json) {
        this.major = H.intTypeCheck(json.$index(0, "major"));
        this.minor = H.intTypeCheck(json.$index(0, "minor"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[Version type: " + H.S(this.type) + ", major: " + H.S(this.major) + ", minor: " + H.S(this.minor) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        Version_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.Version$_fromJson(json);
        }, "call$1", "vm_service_lib_Version_parse$closure", 4, 0, 268, 2],
        Version$_fromJson: [function(json) {
          var t1 = new S.Version(json, []);
          t1.Response$_fromJson$1(json);
          t1.Version$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    VMRef: {
      "^": "Response;0name>,json,0type,$ti",
      VMRef$_fromJson$1: [function(json) {
        this.name = H.stringTypeCheck(json.$index(0, "name"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[VMRef type: " + H.S(this.type) + ", name: " + H.S(this.name) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        VMRef_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.VMRef$_fromJson(json);
        }, "call$1", "vm_service_lib_VMRef_parse$closure", 4, 0, 269, 2],
        VMRef$_fromJson: [function(json) {
          var t1 = new S.VMRef(json, []);
          t1.Response$_fromJson$1(json);
          t1.VMRef$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    VM: {
      "^": "Response;0architectureBits,0targetCPU,0hostCPU,0version,0pid,0startTime<,0isolates<,json,0type,$ti",
      set$isolates: function(isolates) {
        this.isolates = H.assertSubtype(isolates, "$isList", [S.IsolateRef], "$asList");
      },
      VM$_fromJson$1: [function(json) {
        this.architectureBits = H.intTypeCheck(json.$index(0, "architectureBits"));
        this.targetCPU = H.stringTypeCheck(json.$index(0, "targetCPU"));
        this.hostCPU = H.stringTypeCheck(json.$index(0, "hostCPU"));
        this.version = H.stringTypeCheck(json.$index(0, "version"));
        this.pid = H.intTypeCheck(json.$index(0, "pid"));
        this.startTime = H.intTypeCheck(json.$index(0, "startTime"));
        this.set$isolates(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "isolates")), "$isIterable"), true, S.IsolateRef));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[VM]";
      }, null, "get$toString", 1, 0, null],
      static: {
        VM_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.VM$_fromJson(json);
        }, "call$1", "vm_service_lib_VM_parse$closure", 4, 0, 270, 2],
        VM$_fromJson: [function(json) {
          var t1 = new S.VM(json, []);
          t1.Response$_fromJson$1(json);
          t1.VM$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    CpuProfile: {
      "^": "Response;0sampleCount,0samplePeriod,0stackDepth,0timeSpan,0timeOriginMicros,0timeExtentMicros,0codes,0functions,0exclusiveCodeTrie,0inclusiveCodeTrie,0exclusiveFunctionTrie,0inclusiveFunctionTrie,json,0type,$ti",
      set$codes: function(codes) {
        this.codes = H.assertSubtype(codes, "$isList", [S.CodeRegion], "$asList");
      },
      set$functions: function(functions) {
        this.functions = H.assertSubtype(functions, "$isList", [S.ProfileFunction], "$asList");
      },
      set$exclusiveCodeTrie: function(exclusiveCodeTrie) {
        this.exclusiveCodeTrie = H.assertSubtype(exclusiveCodeTrie, "$isList", [P.int], "$asList");
      },
      set$inclusiveCodeTrie: function(inclusiveCodeTrie) {
        this.inclusiveCodeTrie = H.assertSubtype(inclusiveCodeTrie, "$isList", [P.int], "$asList");
      },
      set$exclusiveFunctionTrie: function(exclusiveFunctionTrie) {
        this.exclusiveFunctionTrie = H.assertSubtype(exclusiveFunctionTrie, "$isList", [P.int], "$asList");
      },
      set$inclusiveFunctionTrie: function(inclusiveFunctionTrie) {
        this.inclusiveFunctionTrie = H.assertSubtype(inclusiveFunctionTrie, "$isList", [P.int], "$asList");
      },
      CpuProfile$_fromJson$1: [function(json) {
        var t1;
        this.sampleCount = H.intTypeCheck(json.$index(0, "sampleCount"));
        this.samplePeriod = H.intTypeCheck(json.$index(0, "samplePeriod"));
        this.stackDepth = H.intTypeCheck(json.$index(0, "stackDepth"));
        this.timeSpan = H.doubleTypeCheck(json.$index(0, "timeSpan"));
        this.timeOriginMicros = H.intTypeCheck(json.$index(0, "timeOriginMicros"));
        this.timeExtentMicros = H.intTypeCheck(json.$index(0, "timeExtentMicros"));
        this.set$codes(P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(json.$index(0, "codes"), S.vm_service_lib_CodeRegion_parse$closure()), "$isIterable"), true, S.CodeRegion));
        this.set$functions(P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(json.$index(0, "functions"), S.vm_service_lib_ProfileFunction_parse$closure()), "$isIterable"), true, S.ProfileFunction));
        t1 = P.int;
        this.set$exclusiveCodeTrie(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "exclusiveCodeTrie"), "$isIterable"), true, t1));
        this.set$inclusiveCodeTrie(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "inclusiveCodeTrie"), "$isIterable"), true, t1));
        this.set$exclusiveFunctionTrie(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "exclusiveFunctionTrie"), "$isIterable"), true, t1));
        this.set$inclusiveFunctionTrie(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "inclusiveFunctionTrie"), "$isIterable"), true, t1));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[_CpuProfile]";
      }, null, "get$toString", 1, 0, null],
      static: {
        CpuProfile_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.CpuProfile$_fromJson(json);
        }, "call$1", "vm_service_lib_CpuProfile_parse$closure", 4, 0, 271, 2],
        CpuProfile$_fromJson: [function(json) {
          var t1 = new S.CpuProfile(json, []);
          t1.Response$_fromJson$1(json);
          t1.CpuProfile$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    CodeRegion: {
      "^": "Object;0kind>,0inclusiveTicks,0exclusiveTicks,0code>,$ti",
      CodeRegion$_fromJson$1: [function(json) {
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.inclusiveTicks = H.intTypeCheck(json.$index(0, "inclusiveTicks"));
        this.exclusiveTicks = H.intTypeCheck(json.$index(0, "exclusiveTicks"));
        this.code = H.interceptedTypeCheck(S._createObject(json.$index(0, "code")), "$isCodeRef");
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[CodeRegion kind: " + H.S(this.kind) + ", inclusiveTicks: " + H.S(this.inclusiveTicks) + ", exclusiveTicks: " + H.S(this.exclusiveTicks) + ", code: " + H.S(this.code) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        CodeRegion_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.CodeRegion$_fromJson(json);
        }, "call$1", "vm_service_lib_CodeRegion_parse$closure", 4, 0, 272, 2],
        CodeRegion$_fromJson: [function(json) {
          var t1 = new S.CodeRegion([]);
          t1.CodeRegion$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ProfileFunction: {
      "^": "Object;0kind>,0inclusiveTicks,0exclusiveTicks,0$function,0codes,$ti",
      set$codes: function(codes) {
        this.codes = H.assertSubtype(codes, "$isList", [P.int], "$asList");
      },
      ProfileFunction$_fromJson$1: [function(json) {
        this.kind = H.stringTypeCheck(json.$index(0, "kind"));
        this.inclusiveTicks = H.intTypeCheck(json.$index(0, "inclusiveTicks"));
        this.exclusiveTicks = H.intTypeCheck(json.$index(0, "exclusiveTicks"));
        this.$function = H.interceptedTypeCheck(S._createObject(json.$index(0, "function")), "$isFuncRef");
        this.set$codes(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "codes"), "$isIterable"), true, P.int));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[ProfileFunction kind: " + H.S(this.kind) + ", inclusiveTicks: " + H.S(this.inclusiveTicks) + ", exclusiveTicks: " + H.S(this.exclusiveTicks) + ", function: " + H.S(this.$function) + ", codes: " + H.S(this.codes) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ProfileFunction_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ProfileFunction$_fromJson(json);
        }, "call$1", "vm_service_lib_ProfileFunction_parse$closure", 4, 0, 273, 2],
        ProfileFunction$_fromJson: [function(json) {
          var t1 = new S.ProfileFunction([]);
          t1.ProfileFunction$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    AllocationProfile: {
      "^": "Response;0dateLastServiceGC,0members,json,0type,$ti",
      set$members: function(members) {
        this.members = H.assertSubtype(members, "$isList", [S.ClassHeapStats], "$asList");
      },
      AllocationProfile$_fromJson$1: [function(json) {
        this.dateLastServiceGC = H.stringTypeCheck(json.$index(0, "dateLastServiceGC"));
        this.set$members(P.List_List$from(H.listSuperNativeTypeCheck(S._createObject(json.$index(0, "members")), "$isIterable"), true, S.ClassHeapStats));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[AllocationProfile type: " + H.S(this.type) + ", dateLastServiceGC: " + H.S(this.dateLastServiceGC) + ", members: " + H.S(this.members) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        AllocationProfile_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.AllocationProfile$_fromJson(json);
        }, "call$1", "vm_service_lib_AllocationProfile_parse$closure", 4, 0, 274, 2],
        AllocationProfile$_fromJson: [function(json) {
          var t1 = new S.AllocationProfile(json, []);
          t1.Response$_fromJson$1(json);
          t1.AllocationProfile$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    ClassHeapStats: {
      "^": "Response;0classRef,0new_,0old,0promotedBytes,0promotedInstances,json,0type,$ti",
      set$new_: function(new_) {
        this.new_ = H.assertSubtype(new_, "$isList", [P.int], "$asList");
      },
      set$old: function(old) {
        this.old = H.assertSubtype(old, "$isList", [P.int], "$asList");
      },
      ClassHeapStats$_fromJson$1: [function(json) {
        var t1;
        this.classRef = H.interceptedTypeCheck(S._createObject(json.$index(0, "class")), "$isClassRef");
        t1 = P.int;
        this.set$new_(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "new"), "$isIterable"), true, t1));
        this.set$old(P.List_List$from(H.listSuperNativeTypeCheck(json.$index(0, "old"), "$isIterable"), true, t1));
        this.promotedBytes = H.intTypeCheck(json.$index(0, "promotedBytes"));
        this.promotedInstances = H.intTypeCheck(json.$index(0, "promotedInstances"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[ClassHeapStats type: " + H.S(this.type) + ", classRef: " + H.S(this.classRef) + ", new_: " + H.S(this.new_) + ", old: " + H.S(this.old) + ", promotedBytes: " + H.S(this.promotedBytes) + ", promotedInstances: " + H.S(this.promotedInstances) + "]";
      }, null, "get$toString", 1, 0, null],
      static: {
        ClassHeapStats_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.ClassHeapStats$_fromJson(json);
        }, "call$1", "vm_service_lib_ClassHeapStats_parse$closure", 4, 0, 275, 2],
        ClassHeapStats$_fromJson: [function(json) {
          var t1 = new S.ClassHeapStats(json, []);
          t1.Response$_fromJson$1(json);
          t1.ClassHeapStats$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    },
    HeapSpace: {
      "^": "Response;0avgCollectionPeriodMillis,0capacity,0collections,0external,0name>,0time,0used,json,0type,$ti",
      HeapSpace$_fromJson$1: [function(json) {
        this.avgCollectionPeriodMillis = H.doubleTypeCheck(json.$index(0, "avgCollectionPeriodMillis"));
        this.capacity = H.intTypeCheck(json.$index(0, "capacity"));
        this.collections = H.intTypeCheck(json.$index(0, "collections"));
        this.external = H.intTypeCheck(json.$index(0, "external"));
        this.name = H.stringTypeCheck(json.$index(0, "name"));
        this.time = H.doubleTypeCheck(json.$index(0, "time"));
        this.used = H.intTypeCheck(json.$index(0, "used"));
      }, null, null, 4, 0, null, 2],
      toString$0: [function(_) {
        return "[HeapSpace]";
      }, null, "get$toString", 1, 0, null],
      static: {
        HeapSpace_parse: [function(json) {
          H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
          return json == null ? null : S.HeapSpace$_fromJson(json);
        }, "call$1", "vm_service_lib_HeapSpace_parse$closure", 4, 0, 184, 2],
        HeapSpace$_fromJson: [function(json) {
          var t1 = new S.HeapSpace(json, []);
          t1.Response$_fromJson$1(json);
          t1.HeapSpace$_fromJson$1(json);
          return t1;
        }, null, null, 4, 0, null, 2]
      }
    }
  }], ["", "main.dart",, F, {
    "^": "",
    main: [function() {
      E.FrameworkCore_init();
      var framework = F.PerfToolFramework$();
      E.FrameworkCore_initVmService(new F.main_closure(framework));
      framework.loadScreenFromLocation$0();
    }, null, null, 0, 0, null],
    main_closure: {
      "^": "Closure:22;framework,$ti",
      call$2: [function(title, error) {
        this.framework.showError$2(H.stringTypeCheck(title), error);
      }, null, null, 8, 0, null, 86, 14, "call"]
    }
  }, 1]];
  setupProgram(dart, 0, 0);
  // getInterceptor methods
  J.getInterceptor$ = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSDouble.prototype;
    }
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return J.JSNull.prototype;
    if (typeof receiver == "boolean")
      return J.JSBool.prototype;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$ansx = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$asx = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$ax = function(receiver) {
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$bn = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (receiver == null)
      return receiver;
    if (typeof receiver == "boolean")
      return J.JSBool.prototype;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$i = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSNumber.prototype;
    }
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$in = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSNumber.prototype;
    }
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$n = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$ns = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$s = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$x = function(receiver) {
    if (receiver == null)
      return receiver;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$z = function(receiver) {
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.set$backgroundImage$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$backgroundImage(receiver, value);
  };
  J.set$checked$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$checked(receiver, value);
  };
  J.set$className$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$className(receiver, value);
  };
  J.set$disabled$z = function(receiver, value) {
    return J.getInterceptor$z(receiver).set$disabled(receiver, value);
  };
  J.set$display$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$display(receiver, value);
  };
  J.set$font$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$font(receiver, value);
  };
  J.set$height$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$height(receiver, value);
  };
  J.set$left$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$left(receiver, value);
  };
  J.set$length$asx = function(receiver, value) {
    return J.getInterceptor$asx(receiver).set$length(receiver, value);
  };
  J.set$overflow$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$overflow(receiver, value);
  };
  J.set$overflowX$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$overflowX(receiver, value);
  };
  J.set$paddingLeft$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$paddingLeft(receiver, value);
  };
  J.set$position$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$position(receiver, value);
  };
  J.set$responseType$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$responseType(receiver, value);
  };
  J.set$root$z = function(receiver, value) {
    return J.getInterceptor$z(receiver).set$root(receiver, value);
  };
  J.set$scrollTop$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$scrollTop(receiver, value);
  };
  J.set$selectedIndex$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$selectedIndex(receiver, value);
  };
  J.set$text$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$text(receiver, value);
  };
  J.set$title$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$title(receiver, value);
  };
  J.set$top$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$top(receiver, value);
  };
  J.set$transform$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$transform(receiver, value);
  };
  J.set$value$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$value(receiver, value);
  };
  J.set$width$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$width(receiver, value);
  };
  J.set$withCredentials$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$withCredentials(receiver, value);
  };
  J.get$_attributes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$_attributes(receiver);
  };
  J.get$_firstElementChild$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$_firstElementChild(receiver);
  };
  J.get$_lastElementChild$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$_lastElementChild(receiver);
  };
  J.get$add$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$add(receiver);
  };
  J.get$animationFrame$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$animationFrame(receiver);
  };
  J.get$attributes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$attributes(receiver);
  };
  J.get$baseUri$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$baseUri(receiver);
  };
  J.get$body$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$body(receiver);
  };
  J.get$bottom$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$bottom(receiver);
  };
  J.get$bottomRight$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$bottomRight(receiver);
  };
  J.get$buffer$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$buffer(receiver);
  };
  J.get$button$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$button(receiver);
  };
  J.get$canvas$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$canvas(receiver);
  };
  J.get$checked$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$checked(receiver);
  };
  J.get$childNodes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$childNodes(receiver);
  };
  J.get$children$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$children(receiver);
  };
  J.get$className$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$className(receiver);
  };
  J.get$classes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$classes(receiver);
  };
  J.get$client$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$client(receiver);
  };
  J.get$close$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$close(receiver);
  };
  J.get$codeUnits$s = function(receiver) {
    return J.getInterceptor$s(receiver).get$codeUnits(receiver);
  };
  J.get$color$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$color(receiver);
  };
  J.get$complete$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$complete(receiver);
  };
  J.get$console$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$console(receiver);
  };
  J.get$context2D$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$context2D(receiver);
  };
  J.get$currentScript$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$currentScript(receiver);
  };
  J.get$data$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$data(receiver);
  };
  J.get$devicePixelRatio$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$devicePixelRatio(receiver);
  };
  J.get$disabled$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$disabled(receiver);
  };
  J.get$duration$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$duration(receiver);
  };
  J.get$dx$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$dx(receiver);
  };
  J.get$entries$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$entries(receiver);
  };
  J.get$error$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$error(receiver);
  };
  J.get$first$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$first(receiver);
  };
  J.get$fontSize$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$fontSize(receiver);
  };
  J.get$fonts$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$fonts(receiver);
  };
  J.get$hash$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$hash(receiver);
  };
  J.get$hashCode$ = function(receiver) {
    return J.getInterceptor$(receiver).get$hashCode(receiver);
  };
  J.get$head$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$head(receiver);
  };
  J.get$height$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$height(receiver);
  };
  J.get$history$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$history(receiver);
  };
  J.get$id$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$id(receiver);
  };
  J.get$implementation$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$implementation(receiver);
  };
  J.get$index$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$index(receiver);
  };
  J.get$isEmpty$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
  };
  J.get$isNegative$n = function(receiver) {
    return J.getInterceptor$n(receiver).get$isNegative(receiver);
  };
  J.get$isNotEmpty$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
  };
  J.get$iterator$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$iterator(receiver);
  };
  J.get$kind$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$kind(receiver);
  };
  J.get$last$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$last(receiver);
  };
  J.get$lastChild$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$lastChild(receiver);
  };
  J.get$left$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$left(receiver);
  };
  J.get$length$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$length(receiver);
  };
  J.get$location$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$location(receiver);
  };
  J.get$matches$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$matches(receiver);
  };
  J.get$message$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$message(receiver);
  };
  J.get$name$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$name(receiver);
  };
  J.get$navigator$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$navigator(receiver);
  };
  J.get$nodes$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$nodes(receiver);
  };
  J.get$offset$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$offset(receiver);
  };
  J.get$offsetHeight$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$offsetHeight(receiver);
  };
  J.get$onChange$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onChange(receiver);
  };
  J.get$onClick$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onClick(receiver);
  };
  J.get$onDoubleClick$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onDoubleClick(receiver);
  };
  J.get$onError$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onError(receiver);
  };
  J.get$onKeyDown$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onKeyDown(receiver);
  };
  J.get$onLoad$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onLoad(receiver);
  };
  J.get$onMouseLeave$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onMouseLeave(receiver);
  };
  J.get$onMouseMove$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onMouseMove(receiver);
  };
  J.get$onMouseOver$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onMouseOver(receiver);
  };
  J.get$onPopState$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onPopState(receiver);
  };
  J.get$onResize$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onResize(receiver);
  };
  J.get$onScroll$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$onScroll(receiver);
  };
  J.get$onSelect$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$onSelect(receiver);
  };
  J.get$parent$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$parent(receiver);
  };
  J.get$path$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$path(receiver);
  };
  J.get$pathname$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$pathname(receiver);
  };
  J.get$pattern$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$pattern(receiver);
  };
  J.get$paused$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$paused(receiver);
  };
  J.get$position$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$position(receiver);
  };
  J.get$previousNode$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$previousNode(receiver);
  };
  J.get$rect$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$rect(receiver);
  };
  J.get$result$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$result(receiver);
  };
  J.get$reversed$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$reversed(receiver);
  };
  J.get$right$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$right(receiver);
  };
  J.get$runtimeType$ = function(receiver) {
    return J.getInterceptor$(receiver).get$runtimeType(receiver);
  };
  J.get$scrollHeight$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$scrollHeight(receiver);
  };
  J.get$scrollTop$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$scrollTop(receiver);
  };
  J.get$search$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$search(receiver);
  };
  J.get$setRequestHeader$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$setRequestHeader(receiver);
  };
  J.get$single$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$single(receiver);
  };
  J.get$source$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$source(receiver);
  };
  J.get$span$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$span(receiver);
  };
  J.get$start$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$start(receiver);
  };
  J.get$stream$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$stream(receiver);
  };
  J.get$style$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$style(receiver);
  };
  J.get$target$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$target(receiver);
  };
  J.get$text$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$text(receiver);
  };
  J.get$top$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$top(receiver);
  };
  J.get$topLeft$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$topLeft(receiver);
  };
  J.get$url$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$url(receiver);
  };
  J.get$userAgent$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$userAgent(receiver);
  };
  J.get$value$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$value(receiver);
  };
  J.get$values$z = function(receiver) {
    return J.getInterceptor$z(receiver).get$values(receiver);
  };
  J.get$width$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$width(receiver);
  };
  J.get$x$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$x(receiver);
  };
  J.get$y$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$y(receiver);
  };
  J.$add$ansx = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver + a0;
    return J.getInterceptor$ansx(receiver).$add(receiver, a0);
  };
  J.$and$bn = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver & a0) >>> 0;
    return J.getInterceptor$bn(receiver).$and(receiver, a0);
  };
  J.$div$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver / a0;
    return J.getInterceptor$n(receiver).$div(receiver, a0);
  };
  J.$eq$ = function(receiver, a0) {
    if (receiver == null)
      return a0 == null;
    if (typeof receiver != "object")
      return a0 != null && receiver === a0;
    return J.getInterceptor$(receiver).$eq(receiver, a0);
  };
  J.$ge$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver >= a0;
    return J.getInterceptor$n(receiver).$ge(receiver, a0);
  };
  J.$gt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver > a0;
    return J.getInterceptor$n(receiver).$gt(receiver, a0);
  };
  J.$index$asx = function(receiver, a0) {
    if (typeof a0 === "number")
      if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
        if (a0 >>> 0 === a0 && a0 < receiver.length)
          return receiver[a0];
    return J.getInterceptor$asx(receiver).$index(receiver, a0);
  };
  J.$indexSet$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
  };
  J.$le$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver <= a0;
    return J.getInterceptor$n(receiver).$le(receiver, a0);
  };
  J.$lt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver < a0;
    return J.getInterceptor$n(receiver).$lt(receiver, a0);
  };
  J.$mod$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$mod(receiver, a0);
  };
  J.$mul$ns = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver * a0;
    return J.getInterceptor$ns(receiver).$mul(receiver, a0);
  };
  J.$negate$in = function(receiver) {
    if (typeof receiver == "number")
      return -receiver;
    return J.getInterceptor$in(receiver).$negate(receiver);
  };
  J.$or$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver | a0) >>> 0;
    return J.getInterceptor$n(receiver).$or(receiver, a0);
  };
  J.$shl$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$shl(receiver, a0);
  };
  J.$sub$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver - a0;
    return J.getInterceptor$n(receiver).$sub(receiver, a0);
  };
  J.$tdiv$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
  };
  J.$xor$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver ^ a0) >>> 0;
    return J.getInterceptor$n(receiver).$xor(receiver, a0);
  };
  J._clearChildren$0$x = function(receiver) {
    return J.getInterceptor$x(receiver)._clearChildren$0(receiver);
  };
  J._codeUnitAt$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver)._codeUnitAt$1(receiver, a0);
  };
  J._hasAttribute$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver)._hasAttribute$1(receiver, a0);
  };
  J._removeChild$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver)._removeChild$1(receiver, a0);
  };
  J._replaceChild$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver)._replaceChild$2(receiver, a0, a1);
  };
  J.abs$0$in = function(receiver) {
    if (typeof receiver === "number")
      return Math.abs(receiver);
    return J.getInterceptor$in(receiver).abs$0(receiver);
  };
  J.add$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).add$1(receiver, a0);
  };
  J.addAll$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
  };
  J.addEventListener$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
  };
  J.adoptNode$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).adoptNode$1(receiver, a0);
  };
  J.allMatches$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).allMatches$1(receiver, a0);
  };
  J.any$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).any$1(receiver, a0);
  };
  J.append$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).append$1(receiver, a0);
  };
  J.appendText$1$z = function(receiver, a0) {
    return J.getInterceptor$z(receiver).appendText$1(receiver, a0);
  };
  J.cast$1$0$ax = function(receiver, $T1) {
    return J.getInterceptor$ax(receiver).cast$1$0(receiver, $T1);
  };
  J.cast$2$0$ax = function(receiver, $T1, $T2) {
    return J.getInterceptor$ax(receiver).cast$2$0(receiver, $T1, $T2);
  };
  J.ceil$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).ceil$0(receiver);
  };
  J.clamp$2$n = function(receiver, a0, a1) {
    return J.getInterceptor$n(receiver).clamp$2(receiver, a0, a1);
  };
  J.clear$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).clear$0(receiver);
  };
  J.clear$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).clear$1(receiver, a0);
  };
  J.clearRect$4$x = function(receiver, a0, a1, a2, a3) {
    return J.getInterceptor$x(receiver).clearRect$4(receiver, a0, a1, a2, a3);
  };
  J.click$1$z = function(receiver, a0) {
    return J.getInterceptor$z(receiver).click$1(receiver, a0);
  };
  J.close$0$z = function(receiver) {
    return J.getInterceptor$z(receiver).close$0(receiver);
  };
  J.close$2$z = function(receiver, a0, a1) {
    return J.getInterceptor$z(receiver).close$2(receiver, a0, a1);
  };
  J.codeUnitAt$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
  };
  J.compareTo$1$ns = function(receiver, a0) {
    return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
  };
  J.complete$0$z = function(receiver) {
    return J.getInterceptor$z(receiver).complete$0(receiver);
  };
  J.complete$1$z = function(receiver, a0) {
    return J.getInterceptor$z(receiver).complete$1(receiver, a0);
  };
  J.contains$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
  };
  J.contains$2$asx = function(receiver, a0, a1) {
    return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
  };
  J.createContextualFragment$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).createContextualFragment$1(receiver, a0);
  };
  J.createDocumentFragment$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).createDocumentFragment$0(receiver);
  };
  J.createElement$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).createElement$0(receiver);
  };
  J.createElement$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).createElement$1(receiver, a0);
  };
  J.createFragment$2$treeSanitizer$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).createFragment$2$treeSanitizer(receiver, a0, a1);
  };
  J.createFragment$3$treeSanitizer$validator$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).createFragment$3$treeSanitizer$validator(receiver, a0, a1, a2);
  };
  J.createHtmlDocument$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).createHtmlDocument$1(receiver, a0);
  };
  J.decode$1$z = function(receiver, a0) {
    return J.getInterceptor$z(receiver).decode$1(receiver, a0);
  };
  J.decode$3$z = function(receiver, a0, a1, a2) {
    return J.getInterceptor$z(receiver).decode$3(receiver, a0, a1, a2);
  };
  J.destroy$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).destroy$2(receiver, a0, a1);
  };
  J.disconnect$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).disconnect$0(receiver);
  };
  J.elementAt$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
  };
  J.endsWith$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
  };
  J.fillRange$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).fillRange$3(receiver, a0, a1, a2);
  };
  J.firstWhere$2$orElse$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).firstWhere$2$orElse(receiver, a0, a1);
  };
  J.flex$0$z = function(receiver) {
    return J.getInterceptor$z(receiver).flex$0(receiver);
  };
  J.floor$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).floor$0(receiver);
  };
  J.forEach$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
  };
  J.getAttribute$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).getAttribute$1(receiver, a0);
  };
  J.getBoundingClientRect$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).getBoundingClientRect$0(receiver);
  };
  J.getSelection$3$z = function(receiver, a0, a1, a2) {
    return J.getInterceptor$z(receiver).getSelection$3(receiver, a0, a1, a2);
  };
  J.hidden$1$z = function(receiver, a0) {
    return J.getInterceptor$z(receiver).hidden$1(receiver, a0);
  };
  J.highlight$0$z = function(receiver) {
    return J.getInterceptor$z(receiver).highlight$0(receiver);
  };
  J.indexOf$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
  };
  J.insert$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).insert$2(receiver, a0, a1);
  };
  J.insertAll$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).insertAll$2(receiver, a0, a1);
  };
  J.insertAllBefore$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).insertAllBefore$2(receiver, a0, a1);
  };
  J.insertBefore$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).insertBefore$2(receiver, a0, a1);
  };
  J.join$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).join$1(receiver, a0);
  };
  J.lastWhere$2$orElse$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).lastWhere$2$orElse(receiver, a0, a1);
  };
  J.load$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).load$0(receiver);
  };
  J.load$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).load$1(receiver, a0);
  };
  J.map$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).map$1(receiver, a0);
  };
  J.map$1$1$ax = function(receiver, a0, $T1) {
    return J.getInterceptor$ax(receiver).map$1$1(receiver, a0, $T1);
  };
  J.map$2$1$ax = function(receiver, a0, $T1, $T2) {
    return J.getInterceptor$ax(receiver).map$2$1(receiver, a0, $T1, $T2);
  };
  J.matchAsPrefix$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).matchAsPrefix$1(receiver, a0);
  };
  J.matchAsPrefix$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
  };
  J.matchMedia$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).matchMedia$1(receiver, a0);
  };
  J.matches$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).matches$1(receiver, a0);
  };
  J.measureText$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).measureText$1(receiver, a0);
  };
  J.message$2$color$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).message$2$color(receiver, a0, a1);
  };
  J.noSuchMethod$1$ = function(receiver, a0) {
    return J.getInterceptor$(receiver).noSuchMethod$1(receiver, a0);
  };
  J.observe$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).observe$1(receiver, a0);
  };
  J.padLeft$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).padLeft$1(receiver, a0);
  };
  J.padLeft$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).padLeft$2(receiver, a0, a1);
  };
  J.padRight$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).padRight$1(receiver, a0);
  };
  J.pause$0$z = function(receiver) {
    return J.getInterceptor$z(receiver).pause$0(receiver);
  };
  J.pause$1$z = function(receiver, a0) {
    return J.getInterceptor$z(receiver).pause$1(receiver, a0);
  };
  J.pushState$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).pushState$3(receiver, a0, a1, a2);
  };
  J.querySelector$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).querySelector$1(receiver, a0);
  };
  J.querySelectorAll$1$1$x = function(receiver, a0, $T1) {
    return J.getInterceptor$x(receiver).querySelectorAll$1$1(receiver, a0, $T1);
  };
  J.remainder$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).remainder$1(receiver, a0);
  };
  J.remove$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).remove$0(receiver);
  };
  J.remove$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
  };
  J.removeAt$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).removeAt$1(receiver, a0);
  };
  J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
  };
  J.removeLast$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).removeLast$0(receiver);
  };
  J.replaceAll$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
  };
  J.replaceAllMapped$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).replaceAllMapped$2(receiver, a0, a1);
  };
  J.replaceFirst$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).replaceFirst$2(receiver, a0, a1);
  };
  J.replaceRange$2$asx = function(receiver, a0, a1) {
    return J.getInterceptor$asx(receiver).replaceRange$2(receiver, a0, a1);
  };
  J.replaceRange$3$asx = function(receiver, a0, a1, a2) {
    return J.getInterceptor$asx(receiver).replaceRange$3(receiver, a0, a1, a2);
  };
  J.replaceWith$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).replaceWith$1(receiver, a0);
  };
  J.requestAnimationFrame$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).requestAnimationFrame$1(receiver, a0);
  };
  J.round$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).round$0(receiver);
  };
  J.scrollIntoView$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).scrollIntoView$0(receiver);
  };
  J.scrollIntoView$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).scrollIntoView$2(receiver, a0, a1);
  };
  J.scrollIntoView$3$margin$x = function(receiver, a0, a1, a2) {
    return J.getInterceptor$x(receiver).scrollIntoView$3$margin(receiver, a0, a1, a2);
  };
  J.scrollTo$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).scrollTo$1(receiver, a0);
  };
  J.scrollTo$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).scrollTo$2(receiver, a0, a1);
  };
  J.scrollTo$2$scrollBehavior$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).scrollTo$2$scrollBehavior(receiver, a0, a1);
  };
  J.selectNodeContents$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).selectNodeContents$1(receiver, a0);
  };
  J.send$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).send$1(receiver, a0);
  };
  J.setAll$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).setAll$2(receiver, a0, a1);
  };
  J.setAttribute$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).setAttribute$2(receiver, a0, a1);
  };
  J.setInnerHtml$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).setInnerHtml$1(receiver, a0);
  };
  J.setInnerHtml$2$treeSanitizer$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).setInnerHtml$2$treeSanitizer(receiver, a0, a1);
  };
  J.setRange$3$ax = function(receiver, a0, a1, a2) {
    return J.getInterceptor$ax(receiver).setRange$3(receiver, a0, a1, a2);
  };
  J.setRange$4$ax = function(receiver, a0, a1, a2, a3) {
    return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
  };
  J.skip$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
  };
  J.sort$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
  };
  J.split$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).split$1(receiver, a0);
  };
  J.startsWith$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
  };
  J.startsWith$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).startsWith$2(receiver, a0, a1);
  };
  J.stop$0$z = function(receiver) {
    return J.getInterceptor$z(receiver).stop$0(receiver);
  };
  J.stroke$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).stroke$0(receiver);
  };
  J.sublist$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).sublist$1(receiver, a0);
  };
  J.sublist$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
  };
  J.substring$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).substring$1(receiver, a0);
  };
  J.substring$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
  };
  J.take$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).take$1(receiver, a0);
  };
  J.timeout$0$z = function(receiver) {
    return J.getInterceptor$z(receiver).timeout$0(receiver);
  };
  J.toDouble$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).toDouble$0(receiver);
  };
  J.toInt$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).toInt$0(receiver);
  };
  J.toList$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).toList$0(receiver);
  };
  J.toList$1$growable$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).toList$1$growable(receiver, a0);
  };
  J.toLowerCase$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
  };
  J.toRadixString$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
  };
  J.toString$0$ = function(receiver) {
    return J.getInterceptor$(receiver).toString$0(receiver);
  };
  J.toString$1$minLevel$ = function(receiver, a0) {
    return J.getInterceptor$(receiver).toString$1$minLevel(receiver, a0);
  };
  J.toStringAsFixed$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).toStringAsFixed$1(receiver, a0);
  };
  J.toUnsigned$1$i = function(receiver, a0) {
    return J.getInterceptor$i(receiver).toUnsigned$1(receiver, a0);
  };
  J.toUpperCase$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).toUpperCase$0(receiver);
  };
  J.toggle$2$z = function(receiver, a0, a1) {
    return J.getInterceptor$z(receiver).toggle$2(receiver, a0, a1);
  };
  J.trim$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).trim$0(receiver);
  };
  J.trimLeft$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).trimLeft$0(receiver);
  };
  J.trimRight$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).trimRight$0(receiver);
  };
  J.truncate$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).truncate$0(receiver);
  };
  J.where$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).where$1(receiver, a0);
  };
  Isolate.makeConstantList = function(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  };
  var $ = Isolate.$isolateProperties;
  C.CanvasElement_methods = W.CanvasElement.prototype;
  C.CanvasRenderingContext2D_methods = W.CanvasRenderingContext2D.prototype;
  C.CssStyleDeclaration_methods = W.CssStyleDeclaration.prototype;
  C.FileReader_methods = W.FileReader.prototype;
  C.HttpRequest_methods = W.HttpRequest.prototype;
  C.ImageElement_methods = W.ImageElement.prototype;
  C.InputElement_methods = W.InputElement.prototype;
  C.Interceptor_methods = J.Interceptor.prototype;
  C.IntersectionObserver_methods = W.IntersectionObserver.prototype;
  C.JSArray_methods = J.JSArray.prototype;
  C.JSDouble_methods = J.JSDouble.prototype;
  C.JSInt_methods = J.JSInt.prototype;
  C.JSNull_methods = J.JSNull.prototype;
  C.JSNumber_methods = J.JSNumber.prototype;
  C.JSString_methods = J.JSString.prototype;
  C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
  C.MediaQueryList_methods = W.MediaQueryList.prototype;
  C.MessageEvent_methods = W.MessageEvent.prototype;
  C.NativeByteBuffer_methods = H.NativeByteBuffer.prototype;
  C.NativeByteData_methods = H.NativeByteData.prototype;
  C.NativeUint8List_methods = H.NativeUint8List.prototype;
  C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
  C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
  C.WebSocket_methods = W.WebSocket0.prototype;
  C._DomRect_methods = W._DomRect.prototype;
  C.AsciiCodec_false = new P.AsciiCodec(false, []);
  C.AsciiDecoder_false_127 = new P.AsciiDecoder(false, 127, []);
  C.AsciiDecoder_true_127 = new P.AsciiDecoder(true, 127, []);
  C.AsciiEncoder_127 = new P.AsciiEncoder(127, []);
  C.Base64Encoder_false = new P.Base64Encoder(false, []);
  C.Base64Codec_Base64Encoder_false = new P.Base64Codec(C.Base64Encoder_false, []);
  C.C_Base64Decoder = new P.Base64Decoder([]);
  C.C_Console = new W.Console([]);
  C.C_EmptyIterator = new H.EmptyIterator([P.Null]);
  C.C_OutOfMemoryError = new P.OutOfMemoryError([]);
  C.C_TrustedHtmlTreeSanitizer = new A.TrustedHtmlTreeSanitizer([]);
  C.C_UnicodeGlyphSet = new K.UnicodeGlyphSet([]);
  C.C_Utf8Encoder = new P.Utf8Encoder([]);
  C.C__DelayedDone = new P._DelayedDone([]);
  C.C__HashEnd = new S._HashEnd([]);
  C.C__NoDefaultValue = new U._NoDefaultValue([]);
  C.C__RootZone = new P._RootZone([]);
  C.Color_4278190080 = new S.Color(4278190080, []);
  C.Color_4282415296 = new S.Color(4282415296, []);
  C.Color_4291477317 = new S.Color(4291477317, []);
  C.Color_4294540412 = new S.Color(4294540412, []);
  C.DiagnosticLevel_0 = new U.DiagnosticLevel(0, "DiagnosticLevel.hidden", []);
  C.DiagnosticLevel_1 = new U.DiagnosticLevel(1, "DiagnosticLevel.fine", []);
  C.DiagnosticLevel_2 = new U.DiagnosticLevel(2, "DiagnosticLevel.debug", []);
  C.DiagnosticLevel_3 = new U.DiagnosticLevel(3, "DiagnosticLevel.info", []);
  C.DiagnosticLevel_4 = new U.DiagnosticLevel(4, "DiagnosticLevel.warning", []);
  C.DiagnosticLevel_9 = new U.DiagnosticLevel(9, "DiagnosticLevel.error", []);
  C.DiagnosticsTreeStyle_0 = new U.DiagnosticsTreeStyle(0, "DiagnosticsTreeStyle.sparse", []);
  C.DiagnosticsTreeStyle_1 = new U.DiagnosticsTreeStyle(1, "DiagnosticsTreeStyle.offstage", []);
  C.DiagnosticsTreeStyle_10 = new U.DiagnosticsTreeStyle(10, "DiagnosticsTreeStyle.shallow", []);
  C.DiagnosticsTreeStyle_11 = new U.DiagnosticsTreeStyle(11, "DiagnosticsTreeStyle.truncateChildren", []);
  C.DiagnosticsTreeStyle_2 = new U.DiagnosticsTreeStyle(2, "DiagnosticsTreeStyle.dense", []);
  C.DiagnosticsTreeStyle_3 = new U.DiagnosticsTreeStyle(3, "DiagnosticsTreeStyle.transition", []);
  C.DiagnosticsTreeStyle_4 = new U.DiagnosticsTreeStyle(4, "DiagnosticsTreeStyle.error", []);
  C.DiagnosticsTreeStyle_5 = new U.DiagnosticsTreeStyle(5, "DiagnosticsTreeStyle.whitespace", []);
  C.DiagnosticsTreeStyle_6 = new U.DiagnosticsTreeStyle(6, "DiagnosticsTreeStyle.flat", []);
  C.DiagnosticsTreeStyle_7 = new U.DiagnosticsTreeStyle(7, "DiagnosticsTreeStyle.singleLine", []);
  C.DiagnosticsTreeStyle_8 = new U.DiagnosticsTreeStyle(8, "DiagnosticsTreeStyle.headerLine", []);
  C.DiagnosticsTreeStyle_9 = new U.DiagnosticsTreeStyle(9, "DiagnosticsTreeStyle.indentedSingleLine", []);
  C.Duration_0 = new P.Duration(0, []);
  C.Duration_1000 = new P.Duration(1000, []);
  C.Duration_100000 = new P.Duration(100000, []);
  C.Duration_1000000 = new P.Duration(1000000, []);
  C.Duration_3000000 = new P.Duration(3000000, []);
  C.Duration_4000000 = new P.Duration(4000000, []);
  C.Duration_500000 = new P.Duration(500000, []);
  C.Endian_false = new P.Endian(false, []);
  C.Endian_true = new P.Endian(true, []);
  C.EventStreamProvider_change = new W.EventStreamProvider("change", [W.Event]);
  C.EventStreamProvider_click = new W.EventStreamProvider("click", [W.MouseEvent]);
  C.EventStreamProvider_close = new W.EventStreamProvider("close", [W.CloseEvent]);
  C.EventStreamProvider_dblclick = new W.EventStreamProvider("dblclick", [W.Event]);
  C.EventStreamProvider_error = new W.EventStreamProvider("error", [W.Event]);
  C.EventStreamProvider_error0 = new W.EventStreamProvider("error", [W.ProgressEvent]);
  C.EventStreamProvider_keydown = new W.EventStreamProvider("keydown", [W.KeyboardEvent]);
  C.EventStreamProvider_load = new W.EventStreamProvider("load", [W.Event]);
  C.EventStreamProvider_load0 = new W.EventStreamProvider("load", [W.ProgressEvent]);
  C.EventStreamProvider_loadend = new W.EventStreamProvider("loadend", [W.ProgressEvent]);
  C.EventStreamProvider_message = new W.EventStreamProvider("message", [W.MessageEvent]);
  C.EventStreamProvider_mouseleave = new W.EventStreamProvider("mouseleave", [W.MouseEvent]);
  C.EventStreamProvider_mousemove = new W.EventStreamProvider("mousemove", [W.MouseEvent]);
  C.EventStreamProvider_mouseover = new W.EventStreamProvider("mouseover", [W.MouseEvent]);
  C.EventStreamProvider_open = new W.EventStreamProvider("open", [W.Event]);
  C.EventStreamProvider_popstate = new W.EventStreamProvider("popstate", [W.PopStateEvent]);
  C.EventStreamProvider_resize = new W.EventStreamProvider("resize", [W.Event]);
  C.EventStreamProvider_scroll = new W.EventStreamProvider("scroll", [W.Event]);
  C.FlutterTreeType_0 = new E.FlutterTreeType(0, "FlutterTreeType.widget", []);
  C.FlutterTreeType_1 = new E.FlutterTreeType(1, "FlutterTreeType.renderObject", []);
  C.FontStyle_1 = new S.FontStyle(1, "FontStyle.italic", []);
  C.HtmlEscapeMode_p2v = new P.HtmlEscapeMode("unknown", true, true, true, true, []);
  C.HtmlEscape_gsm = new P.HtmlEscape(C.HtmlEscapeMode_p2v, []);
  C.UrlIcon_Mqz = new S.UrlIcon("/icons/custom/info.png", []);
  C.IconKind_Kv2 = new S.IconKind("info", C.UrlIcon_Mqz, C.UrlIcon_Mqz, []);
  C.UrlIcon_q8Y = new S.UrlIcon("/icons/custom/method.png", []);
  C.UrlIcon_f9t = new S.UrlIcon("/icons/custom/method_abstract.png", []);
  C.IconKind_hSO = new S.IconKind("method", C.UrlIcon_q8Y, C.UrlIcon_f9t, []);
  C.UrlIcon_BmO = new S.UrlIcon("/icons/custom/class.png", []);
  C.UrlIcon_ub9 = new S.UrlIcon("/icons/custom/class_abstract.png", []);
  C.IconKind_int = new S.IconKind("class", C.UrlIcon_BmO, C.UrlIcon_ub9, []);
  C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
  C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
  C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
  C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
  C.JS_CONST_bDt = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
  C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
  C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
  C.JS_CONST_u2C = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
  C.JsonCodec_null_null = new P.JsonCodec(null, null, []);
  C.JsonDecoder_null = new P.JsonDecoder(null, []);
  C.JsonEncoder_null_null = new P.JsonEncoder(null, null, []);
  C.JsonEncoder_yLX = new P.JsonEncoder("  ", null, []);
  C.Latin1Codec_false = new P.Latin1Codec(false, []);
  C.Latin1Decoder_false_255 = new P.Latin1Decoder(false, 255, []);
  C.Latin1Decoder_true_255 = new P.Latin1Decoder(true, 255, []);
  C.Latin1Encoder_255 = new P.Latin1Encoder(255, []);
  C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.int]);
  C.List_239_191_189 = H.setRuntimeTypeInfo(Isolate.makeConstantList([239, 191, 189]), [P.int]);
  C.List_2Vk = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]), [P.int]);
  C.List_2Zi = H.setRuntimeTypeInfo(Isolate.makeConstantList(["*::class", "*::dir", "*::draggable", "*::hidden", "*::id", "*::inert", "*::itemprop", "*::itemref", "*::itemscope", "*::lang", "*::spellcheck", "*::title", "*::translate", "A::accesskey", "A::coords", "A::hreflang", "A::name", "A::shape", "A::tabindex", "A::target", "A::type", "AREA::accesskey", "AREA::alt", "AREA::coords", "AREA::nohref", "AREA::shape", "AREA::tabindex", "AREA::target", "AUDIO::controls", "AUDIO::loop", "AUDIO::mediagroup", "AUDIO::muted", "AUDIO::preload", "BDO::dir", "BODY::alink", "BODY::bgcolor", "BODY::link", "BODY::text", "BODY::vlink", "BR::clear", "BUTTON::accesskey", "BUTTON::disabled", "BUTTON::name", "BUTTON::tabindex", "BUTTON::type", "BUTTON::value", "CANVAS::height", "CANVAS::width", "CAPTION::align", "COL::align", "COL::char", "COL::charoff", "COL::span", "COL::valign", "COL::width", "COLGROUP::align", "COLGROUP::char", "COLGROUP::charoff", "COLGROUP::span", "COLGROUP::valign", "COLGROUP::width", "COMMAND::checked", "COMMAND::command", "COMMAND::disabled", "COMMAND::label", "COMMAND::radiogroup", "COMMAND::type", "DATA::value", "DEL::datetime", "DETAILS::open", "DIR::compact", "DIV::align", "DL::compact", "FIELDSET::disabled", "FONT::color", "FONT::face", "FONT::size", "FORM::accept", "FORM::autocomplete", "FORM::enctype", "FORM::method", "FORM::name", "FORM::novalidate", "FORM::target", "FRAME::name", "H1::align", "H2::align", "H3::align", "H4::align", "H5::align", "H6::align", "HR::align", "HR::noshade", "HR::size", "HR::width", "HTML::version", "IFRAME::align", "IFRAME::frameborder", "IFRAME::height", "IFRAME::marginheight", "IFRAME::marginwidth", "IFRAME::width", "IMG::align", "IMG::alt", "IMG::border", "IMG::height", "IMG::hspace", "IMG::ismap", "IMG::name", "IMG::usemap", "IMG::vspace", "IMG::width", "INPUT::accept", "INPUT::accesskey", "INPUT::align", "INPUT::alt", "INPUT::autocomplete", "INPUT::autofocus", "INPUT::checked", "INPUT::disabled", "INPUT::inputmode", "INPUT::ismap", "INPUT::list", "INPUT::max", "INPUT::maxlength", "INPUT::min", "INPUT::multiple", "INPUT::name", "INPUT::placeholder", "INPUT::readonly", "INPUT::required", "INPUT::size", "INPUT::step", "INPUT::tabindex", "INPUT::type", "INPUT::usemap", "INPUT::value", "INS::datetime", "KEYGEN::disabled", "KEYGEN::keytype", "KEYGEN::name", "LABEL::accesskey", "LABEL::for", "LEGEND::accesskey", "LEGEND::align", "LI::type", "LI::value", "LINK::sizes", "MAP::name", "MENU::compact", "MENU::label", "MENU::type", "METER::high", "METER::low", "METER::max", "METER::min", "METER::value", "OBJECT::typemustmatch", "OL::compact", "OL::reversed", "OL::start", "OL::type", "OPTGROUP::disabled", "OPTGROUP::label", "OPTION::disabled", "OPTION::label", "OPTION::selected", "OPTION::value", "OUTPUT::for", "OUTPUT::name", "P::align", "PRE::width", "PROGRESS::max", "PROGRESS::min", "PROGRESS::value", "SELECT::autocomplete", "SELECT::disabled", "SELECT::multiple", "SELECT::name", "SELECT::required", "SELECT::size", "SELECT::tabindex", "SOURCE::type", "TABLE::align", "TABLE::bgcolor", "TABLE::border", "TABLE::cellpadding", "TABLE::cellspacing", "TABLE::frame", "TABLE::rules", "TABLE::summary", "TABLE::width", "TBODY::align", "TBODY::char", "TBODY::charoff", "TBODY::valign", "TD::abbr", "TD::align", "TD::axis", "TD::bgcolor", "TD::char", "TD::charoff", "TD::colspan", "TD::headers", "TD::height", "TD::nowrap", "TD::rowspan", "TD::scope", "TD::valign", "TD::width", "TEXTAREA::accesskey", "TEXTAREA::autocomplete", "TEXTAREA::cols", "TEXTAREA::disabled", "TEXTAREA::inputmode", "TEXTAREA::name", "TEXTAREA::placeholder", "TEXTAREA::readonly", "TEXTAREA::required", "TEXTAREA::rows", "TEXTAREA::tabindex", "TEXTAREA::wrap", "TFOOT::align", "TFOOT::char", "TFOOT::charoff", "TFOOT::valign", "TH::abbr", "TH::align", "TH::axis", "TH::bgcolor", "TH::char", "TH::charoff", "TH::colspan", "TH::headers", "TH::height", "TH::nowrap", "TH::rowspan", "TH::scope", "TH::valign", "TH::width", "THEAD::align", "THEAD::char", "THEAD::charoff", "THEAD::valign", "TR::align", "TR::bgcolor", "TR::char", "TR::charoff", "TR::valign", "TRACK::default", "TRACK::kind", "TRACK::label", "TRACK::srclang", "UL::compact", "UL::type", "VIDEO::controls", "VIDEO::height", "VIDEO::loop", "VIDEO::mediagroup", "VIDEO::muted", "VIDEO::preload", "VIDEO::width"]), [P.String]);
  C.List_3US = H.setRuntimeTypeInfo(Isolate.makeConstantList(["S", "M", "T", "W", "T", "F", "S"]), [P.String]);
  C.List_5_6 = H.setRuntimeTypeInfo(Isolate.makeConstantList([5, 6]), [P.int]);
  C.List_65533 = H.setRuntimeTypeInfo(Isolate.makeConstantList([65533]), [P.int]);
  C.List_6xs = H.setRuntimeTypeInfo(Isolate.makeConstantList(["Before Christ", "Anno Domini"]), [P.String]);
  C.List_AM_PM = H.setRuntimeTypeInfo(Isolate.makeConstantList(["AM", "PM"]), [P.String]);
  C.List_BC_AD = H.setRuntimeTypeInfo(Isolate.makeConstantList(["BC", "AD"]), [P.String]);
  C.List_CVk = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]), [P.int]);
  C.List_JYB = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]), [P.int]);
  C.List_Q1_Q2_Q3_Q4 = H.setRuntimeTypeInfo(Isolate.makeConstantList(["Q1", "Q2", "Q3", "Q4"]), [P.String]);
  C.List_WnV = H.setRuntimeTypeInfo(Isolate.makeConstantList(["/", "\\"]), [P.String]);
  C.UrlIcon_nrL = new S.UrlIcon("/icons/inspector/balloonInformation.png", []);
  C.Category_s2C = new S.Category("Accessibility", C.UrlIcon_nrL, []);
  C.UrlIcon_Auo = new S.UrlIcon("/icons/inspector/resume.png", []);
  C.Category_yHZ = new S.Category("Animation and Motion", C.UrlIcon_Auo, []);
  C.UrlIcon_ybB = new S.UrlIcon("/icons/inspector/any_type.png", []);
  C.Category_0 = new S.Category("Assets, Images, and Icons", C.UrlIcon_ybB, []);
  C.UrlIcon_IVQ = new S.UrlIcon("/icons/inspector/threads.png", []);
  C.Category_je4 = new S.Category("Async", C.UrlIcon_IVQ, []);
  C.Category_Basics_null = new S.Category("Basics", null, []);
  C.Category_smQ = new S.Category("Cupertino (iOS-style widgets)", null, []);
  C.UrlIcon_qBS = new S.UrlIcon("/icons/inspector/renderer.png", []);
  C.Category_us1 = new S.Category("Input", C.UrlIcon_qBS, []);
  C.UrlIcon_BCk = new S.UrlIcon("/icons/inspector/colors.png", []);
  C.Category_mPa = new S.Category("Painting and effects", C.UrlIcon_BCk, []);
  C.UrlIcon_3r9 = new S.UrlIcon("/icons/inspector/scrollbar.png", []);
  C.Category_g78 = new S.Category("Scrolling", C.UrlIcon_3r9, []);
  C.UrlIcon_23h = new S.UrlIcon("/icons/inspector/value.png", []);
  C.Category_OyB = new S.Category("Stack", C.UrlIcon_23h, []);
  C.UrlIcon_WVA = new S.UrlIcon("/icons/inspector/atrule.png", []);
  C.Category_Otz = new S.Category("Styling", C.UrlIcon_WVA, []);
  C.UrlIcon_qBS0 = new S.UrlIcon("/icons/inspector/textArea.png", []);
  C.Category_ASA = new S.Category("Text", C.UrlIcon_qBS0, []);
  C.List_ZZ9 = H.setRuntimeTypeInfo(Isolate.makeConstantList([C.Category_s2C, C.Category_yHZ, C.Category_0, C.Category_je4, C.Category_Basics_null, C.Category_smQ, C.Category_us1, C.Category_mPa, C.Category_g78, C.Category_OyB, C.Category_Otz, C.Category_ASA]), [S.Category]);
  C.List_bJM = H.setRuntimeTypeInfo(Isolate.makeConstantList(["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]), [P.String]);
  C.List_cIc = H.setRuntimeTypeInfo(Isolate.makeConstantList(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]), [P.String]);
  C.List_cSk = H.setRuntimeTypeInfo(Isolate.makeConstantList(["/"]), [P.String]);
  C.List_cno = H.setRuntimeTypeInfo(Isolate.makeConstantList(["EEEE, MMMM d, y", "MMMM d, y", "MMM d, y", "M/d/yy"]), [P.String]);
  C.List_ego = H.setRuntimeTypeInfo(Isolate.makeConstantList(["HEAD", "AREA", "BASE", "BASEFONT", "BR", "COL", "COLGROUP", "EMBED", "FRAME", "FRAMESET", "HR", "IMAGE", "IMG", "INPUT", "ISINDEX", "LINK", "META", "PARAM", "SOURCE", "STYLE", "TITLE", "WBR"]), [P.String]);
  C.List_empty = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [U.DiagnosticsNode]);
  C.List_empty2 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.Null]);
  C.List_empty3 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [M.RemoteDiagnosticsNode]);
  C.List_empty1 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.String]);
  C.List_empty0 = Isolate.makeConstantList([]);
  C.List_gRj = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]), [P.int]);
  C.List_gc6 = H.setRuntimeTypeInfo(Isolate.makeConstantList(["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]), [P.String]);
  C.List_h8w = H.setRuntimeTypeInfo(Isolate.makeConstantList(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]), [P.String]);
  C.List_iDZ = H.setRuntimeTypeInfo(Isolate.makeConstantList(["{1} 'at' {0}", "{1} 'at' {0}", "{1}, {0}", "{1}, {0}"]), [P.String]);
  C.List_kWG = H.setRuntimeTypeInfo(Isolate.makeConstantList(["h:mm:ss a zzzz", "h:mm:ss a z", "h:mm:ss a", "h:mm a"]), [P.String]);
  C.UrlIcon_woc = new S.UrlIcon("/icons/debug_paint.png", []);
  C.ToggleableServiceExtensionDescription_kyk = new E.ToggleableServiceExtensionDescription("ext.flutter.debugPaint", "Debug Paint", C.UrlIcon_woc, true, false, "Hide Debug Paint", "Show Debug Paint", [P.bool]);
  C.ToggleableServiceExtensionDescription_RH1 = new E.ToggleableServiceExtensionDescription("ext.flutter.debugPaintBaselinesEnabled", "Paint Baselines", C.UrlIcon_BCk, true, false, "Hide Paint Baselines", "Show Paint Baselines", [P.bool]);
  C.UrlIcon_l5n = new S.UrlIcon("/icons/repaint_rainbow.png", []);
  C.ToggleableServiceExtensionDescription_GFE = new E.ToggleableServiceExtensionDescription("ext.flutter.repaintRainbow", "Repaint Rainbow", C.UrlIcon_l5n, true, false, "Hide Repaint Rainbow", "Show Repaint Rainbow", [P.bool]);
  C.UrlIcon_x0l = new S.UrlIcon("/icons/general/performance_overlay.svg", []);
  C.ToggleableServiceExtensionDescription_Zyt = new E.ToggleableServiceExtensionDescription("ext.flutter.showPerformanceOverlay", "Performance Overlay", C.UrlIcon_x0l, true, false, "Hide Performance Overlay", "Show Performance Overlay", [P.bool]);
  C.UrlIcon_EGJ = new S.UrlIcon("/icons/debug_banner.png", []);
  C.ToggleableServiceExtensionDescription_Kp8 = new E.ToggleableServiceExtensionDescription("ext.flutter.debugAllowBanner", "Debug Banner", C.UrlIcon_EGJ, true, false, "Hide Debug Banner", "Show Debug Banner", [P.bool]);
  C.UrlIcon_G7M = new S.UrlIcon("/icons/perf/GreyProgr.png", []);
  C.ToggleableServiceExtensionDescription_WRK = new E.ToggleableServiceExtensionDescription("ext.flutter.profileWidgetBuilds", "Track Widget Rebuilds", C.UrlIcon_G7M, true, false, "Do Not Track Widget Rebuilds", "Track Widget Rebuilds", [P.bool]);
  C.UrlIcon_1zl = new S.UrlIcon("/icons/general/locate.png", []);
  C.ToggleableServiceExtensionDescription_woc = new E.ToggleableServiceExtensionDescription("ext.flutter.inspector.show", "Select Widget Mode", C.UrlIcon_1zl, true, false, "Disable Select Widget Mode", "Enable Select Widget Mode", [P.bool]);
  C.UrlIcon_Ucj = new S.UrlIcon("/icons/phone.png", []);
  C.ToggleableServiceExtensionDescription_M2D = new E.ToggleableServiceExtensionDescription("ext.flutter.platformOverride", "iOS", C.UrlIcon_Ucj, "iOS", "android", "Toggle iOS Platform", "Toggle iOS Platform", [P.String]);
  C.UrlIcon_gQW = new S.UrlIcon("/icons/history.svg", []);
  C.ToggleableServiceExtensionDescription_0 = new E.ToggleableServiceExtensionDescription("ext.flutter.timeDilation", "Slow Animations", C.UrlIcon_gQW, 5, 1, "Disable Slow Animations", "Enable Slow Animations", [P.num]);
  C.List_nqK = H.setRuntimeTypeInfo(Isolate.makeConstantList([C.ToggleableServiceExtensionDescription_kyk, C.ToggleableServiceExtensionDescription_RH1, C.ToggleableServiceExtensionDescription_GFE, C.ToggleableServiceExtensionDescription_Zyt, C.ToggleableServiceExtensionDescription_Kp8, C.ToggleableServiceExtensionDescription_WRK, C.ToggleableServiceExtensionDescription_woc, C.ToggleableServiceExtensionDescription_M2D, C.ToggleableServiceExtensionDescription_0]), [[E.ToggleableServiceExtensionDescription,,]]);
  C.List_nxB = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]), [P.int]);
  C.List_qNA = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]), [P.int]);
  C.List_qg40 = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]), [P.int]);
  C.List_qg4 = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]), [P.int]);
  C.List_qpm = H.setRuntimeTypeInfo(Isolate.makeConstantList(["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]), [P.String]);
  C.List_wMy = H.setRuntimeTypeInfo(Isolate.makeConstantList(["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]), [P.String]);
  C.List_wSV = H.setRuntimeTypeInfo(Isolate.makeConstantList(["bind", "if", "ref", "repeat", "syntax"]), [P.String]);
  C.List_yrN = H.setRuntimeTypeInfo(Isolate.makeConstantList(["A::href", "AREA::href", "BLOCKQUOTE::cite", "BODY::background", "COMMAND::icon", "DEL::cite", "FORM::action", "IMG::src", "INPUT::src", "INS::cite", "Q::cite", "VIDEO::poster"]), [P.String]);
  C.List_EQM = H.setRuntimeTypeInfo(Isolate.makeConstantList(["d", "E", "EEEE", "LLL", "LLLL", "M", "Md", "MEd", "MMM", "MMMd", "MMMEd", "MMMM", "MMMMd", "MMMMEEEEd", "QQQ", "QQQQ", "y", "yM", "yMd", "yMEd", "yMMM", "yMMMd", "yMMMEd", "yMMMM", "yMMMMd", "yMMMMEEEEd", "yQQQ", "yQQQQ", "H", "Hm", "Hms", "j", "jm", "jms", "jmv", "jmz", "jz", "m", "ms", "s", "v", "z", "zzzz", "ZZZZ"]), [P.String]);
  C.Map_EQGBe = new H.ConstantStringMap(44, {d: "d", E: "EEE", EEEE: "EEEE", LLL: "LLL", LLLL: "LLLL", M: "L", Md: "M/d", MEd: "EEE, M/d", MMM: "LLL", MMMd: "MMM d", MMMEd: "EEE, MMM d", MMMM: "LLLL", MMMMd: "MMMM d", MMMMEEEEd: "EEEE, MMMM d", QQQ: "QQQ", QQQQ: "QQQQ", y: "y", yM: "M/y", yMd: "M/d/y", yMEd: "EEE, M/d/y", yMMM: "MMM y", yMMMd: "MMM d, y", yMMMEd: "EEE, MMM d, y", yMMMM: "MMMM y", yMMMMd: "MMMM d, y", yMMMMEEEEd: "EEEE, MMMM d, y", yQQQ: "QQQ y", yQQQQ: "QQQQ y", H: "HH", Hm: "HH:mm", Hms: "HH:mm:ss", j: "h a", jm: "h:mm a", jms: "h:mm:ss a", jmv: "h:mm a v", jmz: "h:mm a z", jz: "h a z", m: "m", ms: "mm:ss", s: "s", v: "v", z: "z", zzzz: "zzzz", ZZZZ: "ZZZZ"}, C.List_EQM, [P.String, P.String]);
  C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty1, [P.String, P.String]);
  C.List_empty4 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.Symbol0]);
  C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty4, [P.Symbol0, null]);
  C.List_kTd = H.setRuntimeTypeInfo(Isolate.makeConstantList(["sparse", "offstage", "dense", "transition", "whitespace", "error", "flat", "singleLine", "headerLine", "indentedSingleLine", "shallow", "truncateChildren"]), [P.String]);
  C.Map_kTHDR = new H.ConstantStringMap(12, {sparse: C.DiagnosticsTreeStyle_0, offstage: C.DiagnosticsTreeStyle_1, dense: C.DiagnosticsTreeStyle_2, transition: C.DiagnosticsTreeStyle_3, whitespace: C.DiagnosticsTreeStyle_5, error: C.DiagnosticsTreeStyle_4, flat: C.DiagnosticsTreeStyle_6, singleLine: C.DiagnosticsTreeStyle_7, headerLine: C.DiagnosticsTreeStyle_8, indentedSingleLine: C.DiagnosticsTreeStyle_9, shallow: C.DiagnosticsTreeStyle_10, truncateChildren: C.DiagnosticsTreeStyle_11}, C.List_kTd, [P.String, U.DiagnosticsTreeStyle]);
  C.List_omH = H.setRuntimeTypeInfo(Isolate.makeConstantList(["hidden", "fine", "debug", "info", "warning", "hint", "fix", "contract", "violation", "error", "off"]), [P.String]);
  C.DiagnosticLevel_5 = new U.DiagnosticLevel(5, "DiagnosticLevel.hint", []);
  C.DiagnosticLevel_6 = new U.DiagnosticLevel(6, "DiagnosticLevel.fix", []);
  C.DiagnosticLevel_7 = new U.DiagnosticLevel(7, "DiagnosticLevel.contract", []);
  C.DiagnosticLevel_8 = new U.DiagnosticLevel(8, "DiagnosticLevel.violation", []);
  C.DiagnosticLevel_10 = new U.DiagnosticLevel(10, "DiagnosticLevel.off", []);
  C.Map_omyhD = new H.ConstantStringMap(11, {hidden: C.DiagnosticLevel_0, fine: C.DiagnosticLevel_1, debug: C.DiagnosticLevel_2, info: C.DiagnosticLevel_3, warning: C.DiagnosticLevel_4, hint: C.DiagnosticLevel_5, fix: C.DiagnosticLevel_6, contract: C.DiagnosticLevel_7, violation: C.DiagnosticLevel_8, error: C.DiagnosticLevel_9, off: C.DiagnosticLevel_10}, C.List_omH, [P.String, U.DiagnosticLevel]);
  C.Map_yXAeS = new H.GeneralConstantMap([0, "FontWeight.w100", 1, "FontWeight.w200", 2, "FontWeight.w300", 3, "FontWeight.w400", 4, "FontWeight.w500", 5, "FontWeight.w600", 6, "FontWeight.w700", 7, "FontWeight.w800", 8, "FontWeight.w900"], [P.int, P.String]);
  C.Color_4294967181 = new S.Color(4294967181, []);
  C.Color_4294967040 = new S.Color(4294967040, []);
  C.Color_4294961664 = new S.Color(4294961664, []);
  C.Color_4294956544 = new S.Color(4294956544, []);
  C.Map_iTwHq = new H.GeneralConstantMap([100, C.Color_4294967181, 200, C.Color_4294967040, 400, C.Color_4294961664, 700, C.Color_4294956544], [P.int, S.Color]);
  C.MaterialAccentColor_Map_iTwHq_4294967040 = new S.MaterialAccentColor(C.Map_iTwHq, 4294967040, []);
  C.Color_4294638330 = new S.Color(4294638330, []);
  C.Color_4294309365 = new S.Color(4294309365, []);
  C.Color_4293848814 = new S.Color(4293848814, []);
  C.Color_4292927712 = new S.Color(4292927712, []);
  C.Color_4292269782 = new S.Color(4292269782, []);
  C.Color_4290624957 = new S.Color(4290624957, []);
  C.Color_4288585374 = new S.Color(4288585374, []);
  C.Color_4285887861 = new S.Color(4285887861, []);
  C.Color_4284572001 = new S.Color(4284572001, []);
  C.Color_4282532418 = new S.Color(4282532418, []);
  C.Color_4281348144 = new S.Color(4281348144, []);
  C.Color_4280361249 = new S.Color(4280361249, []);
  C.Map_HFpTk = new H.GeneralConstantMap([50, C.Color_4294638330, 100, C.Color_4294309365, 200, C.Color_4293848814, 300, C.Color_4292927712, 350, C.Color_4292269782, 400, C.Color_4290624957, 500, C.Color_4288585374, 600, C.Color_4285887861, 700, C.Color_4284572001, 800, C.Color_4282532418, 850, C.Color_4281348144, 900, C.Color_4280361249], [P.int, S.Color]);
  C.MaterialColor_Map_HFpTk_4288585374 = new S.MaterialColor(C.Map_HFpTk, 4288585374, []);
  C.Color_4294964192 = new S.Color(4294964192, []);
  C.Color_4294959282 = new S.Color(4294959282, []);
  C.Color_4294954112 = new S.Color(4294954112, []);
  C.Color_4294948685 = new S.Color(4294948685, []);
  C.Color_4294944550 = new S.Color(4294944550, []);
  C.Color_4294940672 = new S.Color(4294940672, []);
  C.Color_4294675456 = new S.Color(4294675456, []);
  C.Color_4294278144 = new S.Color(4294278144, []);
  C.Color_4293880832 = new S.Color(4293880832, []);
  C.Color_4293284096 = new S.Color(4293284096, []);
  C.Map_JNZaB = new H.GeneralConstantMap([50, C.Color_4294964192, 100, C.Color_4294959282, 200, C.Color_4294954112, 300, C.Color_4294948685, 400, C.Color_4294944550, 500, C.Color_4294940672, 600, C.Color_4294675456, 700, C.Color_4294278144, 800, C.Color_4293880832, 900, C.Color_4293284096], [P.int, S.Color]);
  C.MaterialColor_Map_JNZaB_4294940672 = new S.MaterialColor(C.Map_JNZaB, 4294940672, []);
  C.Color_4294962158 = new S.Color(4294962158, []);
  C.Color_4294954450 = new S.Color(4294954450, []);
  C.Color_4293892762 = new S.Color(4293892762, []);
  C.Color_4293227379 = new S.Color(4293227379, []);
  C.Color_4293874512 = new S.Color(4293874512, []);
  C.Color_4294198070 = new S.Color(4294198070, []);
  C.Color_4293212469 = new S.Color(4293212469, []);
  C.Color_4292030255 = new S.Color(4292030255, []);
  C.Color_4291176488 = new S.Color(4291176488, []);
  C.Color_4290190364 = new S.Color(4290190364, []);
  C.Map_JNc9P = new H.GeneralConstantMap([50, C.Color_4294962158, 100, C.Color_4294954450, 200, C.Color_4293892762, 300, C.Color_4293227379, 400, C.Color_4293874512, 500, C.Color_4294198070, 600, C.Color_4293212469, 700, C.Color_4292030255, 800, C.Color_4291176488, 900, C.Color_4290190364], [P.int, S.Color]);
  C.MaterialColor_Map_JNc9P_4294198070 = new S.MaterialColor(C.Map_JNc9P, 4294198070, []);
  C.ScrollAlignment_BOTTOM = new W.ScrollAlignment("BOTTOM", []);
  C.ScrollAlignment_CENTER = new W.ScrollAlignment("CENTER", []);
  C.ScrollAlignment_TOP = new W.ScrollAlignment("TOP", []);
  C.Size_0_0 = new S.Size(0, 0, []);
  C.SortOrder_0 = new Q.SortOrder(0, "SortOrder.ascending", []);
  C.SortOrder_1 = new Q.SortOrder(1, "SortOrder.descending", []);
  C.Symbol_89P = new H.Symbol("Intl.locale", []);
  C.Symbol_call = new H.Symbol("call", []);
  C.TextStyle_QWq = new U.TextStyle(true, C.Color_4278190080, null, null, null, C.FontStyle_1, null, null, null, null, null, null, null, null, []);
  C.TextStyle_mOc = new U.TextStyle(true, C.Color_4278190080, null, null, null, null, null, null, null, null, null, null, null, null, []);
  C.FontWeight_6 = new S.FontWeight(6, []);
  C.TextStyle_yVv = new U.TextStyle(true, C.Color_4278190080, null, null, C.FontWeight_6, null, null, null, null, null, null, null, null, null, []);
  C.TimelineEventType_0 = new O.TimelineEventType(0, "TimelineEventType.cpu", []);
  C.TimelineEventType_1 = new O.TimelineEventType(1, "TimelineEventType.gpu", []);
  C.TimelineEventType_2 = new O.TimelineEventType(2, "TimelineEventType.unknown", []);
  C.Type_ByteBuffer_RkP = H.createRuntimeType(P.ByteBuffer);
  C.Type_ByteData_zNC = H.createRuntimeType(P.ByteData);
  C.Type_Error_A6W = H.createRuntimeType(S.Error0);
  C.Type_Float32List_LB7 = H.createRuntimeType(P.Float32List);
  C.Type_Float64List_LB7 = H.createRuntimeType(P.Float64List);
  C.Type_Int16List_uXf = H.createRuntimeType(P.Int16List);
  C.Type_Int32List_O50 = H.createRuntimeType(P.Int32List);
  C.Type_Int8List_ekJ = H.createRuntimeType(P.Int8List);
  C.Type_JSObject_8k0 = H.createRuntimeType(J.JSObject);
  C.Type_MessageBus_MAi = H.createRuntimeType(A.MessageBus);
  C.Type_Null_Yyn = H.createRuntimeType(P.Null);
  C.Type_RPCError_SOa = H.createRuntimeType(S.RPCError);
  C.Type_ServiceConnectionManager_qdG = H.createRuntimeType(R.ServiceConnectionManager);
  C.Type_String_k8F = H.createRuntimeType(P.String);
  C.Type_Uint16List_2bx = H.createRuntimeType(P.Uint16List);
  C.Type_Uint32List_2bx = H.createRuntimeType(P.Uint32List);
  C.Type_Uint8ClampedList_Jik = H.createRuntimeType(P.Uint8ClampedList);
  C.Type_Uint8List_WLA = H.createRuntimeType(P.Uint8List);
  C.Type_bool_lhE = H.createRuntimeType(P.bool);
  C.Type_double_K1J = H.createRuntimeType(P.double);
  C.Type_int_tHn = H.createRuntimeType(P.int);
  C.Type_num_cv7 = H.createRuntimeType(P.num);
  C.UrlIcon_bhs = new S.UrlIcon("/icons/general/pause_black@2x.png", []);
  C.UrlIcon_k2W = new S.UrlIcon("/icons/general/pause_white@2x.png", []);
  C.UrlIcon_mZF = new S.UrlIcon("/icons/actions/forceRefresh.svg", []);
  C.UrlIcon_nbd = new S.UrlIcon("/icons/general/resume_black_disabled@2x.png", []);
  C.UrlIcon_ww8 = new S.UrlIcon("/icons/general/resume_white_disabled@2x.png", []);
  C.Utf8Codec_false = new P.Utf8Codec(false, []);
  C._IterationMarker_null_2 = new P._IterationMarker(null, 2, []);
  C._WordWrapParseMode_0 = new U._WordWrapParseMode(0, "_WordWrapParseMode.inSpace", []);
  C._WordWrapParseMode_1 = new U._WordWrapParseMode(1, "_WordWrapParseMode.inWord", []);
  C._WordWrapParseMode_2 = new U._WordWrapParseMode(2, "_WordWrapParseMode.atBreak", []);
  C._ZoneFunction__RootZone__rootScheduleMicrotask = new P._ZoneFunction(C.C__RootZone, P.async___rootScheduleMicrotask$closure(), [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: -1}]}]);
  $.printToZone = null;
  $.Primitives_timerFrequency = null;
  $.Primitives_timerTicks = null;
  $.Closure_functionCounter = 0;
  $.BoundClosure_selfFieldNameCache = null;
  $.BoundClosure_receiverFieldNameCache = null;
  $._inTypeAssertion = false;
  $.getTagFunction = null;
  $.alternateTagFunction = null;
  $.prototypeForTagFunction = null;
  $.dispatchRecordsForInstanceTags = null;
  $.interceptorsForUncacheableTags = null;
  $.initNativeDispatchFlag = null;
  $._nextCallback = null;
  $._lastCallback = null;
  $._lastPriorityCallback = null;
  $._isInCallbackLoop = false;
  $.Zone__current = C.C__RootZone;
  $.Expando__keyCount = 0;
  $.Stopwatch__frequency = null;
  $.Element__parseDocument = null;
  $.Element__parseRange = null;
  $.Element__defaultValidator = null;
  $.Element__defaultSanitizer = null;
  $.Device__isOpera = null;
  $.Device__isIE = null;
  $.Device__isFirefox = null;
  $.Device__isWebKit = null;
  $.Device__cachedCssPrefix = null;
  $.Category__categories = null;
  $.Catalog__cachedCatalog = null;
  $.Catalog__instance = null;
  $._useHtmlInspectorTreeRenderer = false;
  $._inspectorDependenciesLoaded = false;
  $.InspectorService_nextGroupId = 0;
  $._verboseDebugging = false;
  $._debugEventTrace = false;
  $._MaterialIconRenderer__iconsFont = null;
  $._MaterialIconRenderer__iconsFontFuture = null;
  $._MaterialIconRenderer__fontLoaded = false;
  $.en_USPatterns = C.Map_EQGBe;
  $.Intl__defaultLocale = null;
  $.Intl_systemLocale = "en_US";
  $.cachedDateSymbols = null;
  $.lastDateSymbolLocale = null;
  $._currentUriBase = null;
  $._current = null;
  $._glyphs = C.C_UnicodeGlyphSet;
  $ = null;
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers$[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    var hunk = $dart_deferred_initializers$[hunkHash];
    if (hunk == null)
      throw "DeferredLoading state error: code with hash '" + hunkHash + "' was not loaded";
    hunk($globals$, $);
    init.deferredInitialized[hunkHash] = true;
  };
  init.deferredLibraryParts = {};
  init.deferredPartUris = [];
  init.deferredPartHashes = [];
  // Empty type-to-interceptor map.
  (function(lazies) {
    for (var i = 0; i < lazies.length;) {
      var fieldName = lazies[i++];
      var getterName = lazies[i++];
      var lazyValue = lazies[i++];
      var staticName = lazies[i++];
      Isolate.$lazy(fieldName, getterName, lazyValue, staticName);
    }
  })(["DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
    return H.getIsolateAffinityTag("_$dart_dartClosure");
  }, "DART_CLOSURE_PROPERTY_NAME", "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
    return H.getIsolateAffinityTag("_$dart_js");
  }, "JS_INTEROP_INTERCEPTOR_TAG", "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(H.TypeErrorDecoder_buildJavaScriptObject())), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_noSuchMethodPattern", "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(H.TypeErrorDecoder_buildJavaScriptObjectWithNonClosure())), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_notClosurePattern", "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null)), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_nullCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOnNull()), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_nullLiteralCallPattern", "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0)), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_undefinedCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOnUndefined()), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_undefinedLiteralCallPattern", "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null)), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_nullPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOnNull()), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_nullLiteralPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0)), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_undefinedPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
    return H.interceptedTypeCheck(H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOnUndefined()), "$isTypeErrorDecoder");
  }, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
    return P._AsyncRun__initializeScheduleImmediate();
  }, "_AsyncRun__scheduleImmediateClosure", "Future__nullFuture", "$get$Future__nullFuture", function() {
    return P._Future$zoneValue(null, C.C__RootZone, P.Null);
  }, "Future__nullFuture", "Future__falseFuture", "$get$Future__falseFuture", function() {
    return P._Future$zoneValue(false, C.C__RootZone, P.bool);
  }, "Future__falseFuture", "_toStringVisiting", "$get$_toStringVisiting", function() {
    return [];
  }, "_toStringVisiting", "Utf8Decoder__decoder", "$get$Utf8Decoder__decoder", function() {
    return P.Utf8Decoder__makeDecoder();
  }, "Utf8Decoder__decoder", "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
    return H.NativeInt8List_NativeInt8List$fromList(H.setRuntimeTypeInfo([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2], [P.int]));
  }, "_Base64Decoder__inverseAlphabet", "Encoding__nameToEncoding", "$get$Encoding__nameToEncoding", function() {
    return P.LinkedHashMap_LinkedHashMap$_literal(["iso_8859-1:1987", C.Latin1Codec_false, "iso-ir-100", C.Latin1Codec_false, "iso_8859-1", C.Latin1Codec_false, "iso-8859-1", C.Latin1Codec_false, "latin1", C.Latin1Codec_false, "l1", C.Latin1Codec_false, "ibm819", C.Latin1Codec_false, "cp819", C.Latin1Codec_false, "csisolatin1", C.Latin1Codec_false, "iso-ir-6", C.AsciiCodec_false, "ansi_x3.4-1968", C.AsciiCodec_false, "ansi_x3.4-1986", C.AsciiCodec_false, "iso_646.irv:1991", C.AsciiCodec_false, "iso646-us", C.AsciiCodec_false, "us-ascii", C.AsciiCodec_false, "us", C.AsciiCodec_false, "ibm367", C.AsciiCodec_false, "cp367", C.AsciiCodec_false, "csascii", C.AsciiCodec_false, "ascii", C.AsciiCodec_false, "csutf8", C.Utf8Codec_false, "utf-8", C.Utf8Codec_false], P.String, P.Encoding);
  }, "Encoding__nameToEncoding", "_Uri__isWindowsCached", "$get$_Uri__isWindowsCached", function() {
    return typeof process != "undefined" && Object.prototype.toString.call(process) == "[object process]" && process.platform == "win32";
  }, "_Uri__isWindowsCached", "_Uri__needsNoEncoding", "$get$_Uri__needsNoEncoding", function() {
    return P.RegExp_RegExp("^[\\-\\.0-9A-Z_a-z~]*$", true, false);
  }, "_Uri__needsNoEncoding", "_hasErrorStackProperty", "$get$_hasErrorStackProperty", function() {
    return new Error().stack != void 0;
  }, "_hasErrorStackProperty", "_scannerTables", "$get$_scannerTables", function() {
    return P._createTables();
  }, "_scannerTables", "CssStyleDeclaration__propertyCache", "$get$CssStyleDeclaration__propertyCache", function() {
    return {};
  }, "CssStyleDeclaration__propertyCache", "_Html5NodeValidator__allowedElements", "$get$_Html5NodeValidator__allowedElements", function() {
    return P.LinkedHashSet_LinkedHashSet$from(["A", "ABBR", "ACRONYM", "ADDRESS", "AREA", "ARTICLE", "ASIDE", "AUDIO", "B", "BDI", "BDO", "BIG", "BLOCKQUOTE", "BR", "BUTTON", "CANVAS", "CAPTION", "CENTER", "CITE", "CODE", "COL", "COLGROUP", "COMMAND", "DATA", "DATALIST", "DD", "DEL", "DETAILS", "DFN", "DIR", "DIV", "DL", "DT", "EM", "FIELDSET", "FIGCAPTION", "FIGURE", "FONT", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "I", "IFRAME", "IMG", "INPUT", "INS", "KBD", "LABEL", "LEGEND", "LI", "MAP", "MARK", "MENU", "METER", "NAV", "NOBR", "OL", "OPTGROUP", "OPTION", "OUTPUT", "P", "PRE", "PROGRESS", "Q", "S", "SAMP", "SECTION", "SELECT", "SMALL", "SOURCE", "SPAN", "STRIKE", "STRONG", "SUB", "SUMMARY", "SUP", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TIME", "TR", "TRACK", "TT", "U", "UL", "VAR", "VIDEO", "WBR"], P.String);
  }, "_Html5NodeValidator__allowedElements", "_Html5NodeValidator__attributeValidators", "$get$_Html5NodeValidator__attributeValidators", function() {
    return P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.Function);
  }, "_Html5NodeValidator__attributeValidators", "CssClassSetImpl__validTokenRE", "$get$CssClassSetImpl__validTokenRE", function() {
    return P.RegExp_RegExp("^\\S+$", true, false);
  }, "CssClassSetImpl__validTokenRE", "context", "$get$context", function() {
    return H.interceptedTypeCheck(P._wrapToDart(self), "$isJsObject");
  }, "context", "_DART_OBJECT_PROPERTY_NAME", "$get$_DART_OBJECT_PROPERTY_NAME", function() {
    return H.getIsolateAffinityTag("_$dart_dartObject");
  }, "_DART_OBJECT_PROPERTY_NAME", "_dartProxyCtor", "$get$_dartProxyCtor", function() {
    return function DartObject(o) {
      this.o = o;
    };
  }, "_dartProxyCtor", "CodeMirror__instances", "$get$CodeMirror__instances", function() {
    return P.LinkedHashMap_LinkedHashMap$_empty(P.JsObject, X.CodeMirror);
  }, "CodeMirror__instances", "_toStringVisiting0", "$get$_toStringVisiting0", function() {
    return [];
  }, "_toStringVisiting0", "globals", "$get$globals", function() {
    return P.LinkedHashMap_LinkedHashMap$_empty(P.Type, null);
  }, "globals", "diagnosticLevelToName", "$get$diagnosticLevelToName", function() {
    return M._invertMap(C.Map_omyhD, U.DiagnosticLevel, P.String);
  }, "diagnosticLevelToName", "treeStyleToName", "$get$treeStyleToName", function() {
    return M._invertMap(C.Map_kTHDR, U.DiagnosticsTreeStyle, P.String);
  }, "treeStyleToName", "RemoteDiagnosticsNode_iconMaker", "$get$RemoteDiagnosticsNode_iconMaker", function() {
    return S.CustomIconMaker$();
  }, "RemoteDiagnosticsNode_iconMaker", "grayed", "$get$grayed", function() {
    return U.TextStyle$(C.MaterialColor_Map_HFpTk_4288585374.get$shade500(), null, null, null, null, null, null, null, null, null, true, null, null, null, null);
  }, "grayed", "warning", "$get$warning", function() {
    return U.TextStyle$(C.MaterialColor_Map_JNZaB_4294940672.get$shade500(), null, null, null, null, null, null, null, null, null, true, null, null, null, null);
  }, "warning", "error", "$get$error", function() {
    return U.TextStyle$(C.MaterialColor_Map_JNc9P_4294198070.get$shade500(), null, null, null, null, null, null, null, null, null, true, null, null, null, null);
  }, "error", "_primaryDescriptionPattern", "$get$_primaryDescriptionPattern", function() {
    return P.RegExp_RegExp("([\\w ]+)[-#]?(.*)", true, false);
  }, "_primaryDescriptionPattern", "_colorIconMaker", "$get$_colorIconMaker", function() {
    return S.ColorIconMaker$();
  }, "_colorIconMaker", "_customIconMaker", "$get$_customIconMaker", function() {
    return S.CustomIconMaker$();
  }, "_customIconMaker", "defaultIcon", "$get$defaultIcon", function() {
    return $.$get$_customIconMaker().fromInfo$1("Default");
  }, "defaultIcon", "collapseArrow", "$get$collapseArrow", function() {
    return K.MaterialIcon$("arrow_drop_down", C.MaterialColor_Map_HFpTk_4288585374, 0, 32, C.JSInt_methods.toInt$0(13));
  }, "collapseArrow", "expandArrow", "$get$expandArrow", function() {
    return K.MaterialIcon$("arrow_drop_down", C.MaterialColor_Map_HFpTk_4288585374, -1.5707963267948966, 32, C.JSInt_methods.toInt$0(13));
  }, "expandArrow", "InspectorTreeNodeRenderCanvasBuilder__measurementCanvas", "$get$InspectorTreeNodeRenderCanvasBuilder__measurementCanvas", function() {
    return J.get$context2D$x(W.CanvasElement_CanvasElement(1, 1));
  }, "InspectorTreeNodeRenderCanvasBuilder__measurementCanvas", "timeFormat", "$get$timeFormat", function() {
    return T.DateFormat$("HH:mm:ss.SSS", null);
  }, "timeFormat", "toggleableExtensionsWhitelist", "$get$toggleableExtensionsWhitelist", function() {
    return P.LinkedHashMap_LinkedHashMap$fromIterable(C.List_nqK, new E.closure(), new E.closure0(), P.String, [E.ToggleableServiceExtensionDescription,,]);
  }, "toggleableExtensionsWhitelist", "Rect_zero", "$get$Rect_zero", function() {
    return S.Rect$_();
  }, "Rect_zero", "sparseTextConfiguration", "$get$sparseTextConfiguration", function() {
    return U.TextTreeConfiguration$(true, "", "", ":", "", "", "", "", "", true, false, "\n", true, "\u2502", "", "\u2514\u2500", "\u251c\u2500", " ", " ", "\u2502 ", "  ", "", true, "");
  }, "sparseTextConfiguration", "dashedTextConfiguration", "$get$dashedTextConfiguration", function() {
    return U.TextTreeConfiguration$(true, "", "", ":", "", "", "", "", "", true, false, "\n", true, "\u254e", "", "\u2514\u254c", "\u254e\u254c", " ", " ", "\u2502 ", "  ", "", true, "");
  }, "dashedTextConfiguration", "denseTextConfiguration", "$get$denseTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", "", ":", ")", "", "(", "", "", false, false, "\n", false, "\u2502", "", "\u2514", "\u251c", "", "", "\u2502", " ", ", ", true, "");
  }, "denseTextConfiguration", "transitionTextConfiguration", "$get$transitionTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", ":", " \u2550\u2550\u2550", "", "", "", "  ", " \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550", false, true, "\n", true, "\u2502", "", "\u2558\u2550\u2566\u2550\u2550 ", "\u255e\u2550\u2566\u2550\u2550 ", " \u2551 ", "", "", "", "", true, "");
  }, "transitionTextConfiguration", "errorTextConfiguration", "$get$errorTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", "", ":", "", "\u2550\u2550\u2561 ", "", "", " \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550", false, false, "\n", true, "\u2502", "\u2550\u2550\u2550\u2550\u2550", "\u2558\u2550\u2566", "\u255e\u2550\u2566", " \u2551 ", "", "", "", "", true, " \u255e\u2550\u2550");
  }, "errorTextConfiguration", "whitespaceTextConfiguration", "$get$whitespaceTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", ":", ":", "", "", "", "", "", false, false, "\n", true, " ", "", "", "", " ", "  ", "", "", "", true, "");
  }, "whitespaceTextConfiguration", "flatTextConfiguration", "$get$flatTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", ":", ":", "", "", "", "", "", false, false, "\n", true, "", "", "", "", "", "", "", "", "", true, "");
  }, "flatTextConfiguration", "singleLineTextConfiguration", "$get$singleLineTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", "", ":", ")", "", "(", "", "", true, false, "", false, "", "", "", "", "", "", "", "", ", ", false, "");
  }, "singleLineTextConfiguration", "headerLineTextConfiguration", "$get$headerLineTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", "", ":", ")", "", "(", "", "", true, false, "", false, "", "", "", "", "", "", "", "", ", ", false, "");
  }, "headerLineTextConfiguration", "singleLineTextConfigurationIndented", "$get$singleLineTextConfigurationIndented", function() {
    return U.TextTreeConfiguration$(false, "", "", "\n  ", ")", "", "(", "", "", true, false, "", false, "", "", "", "", "", "", "", "", ", ", false, "");
  }, "singleLineTextConfigurationIndented", "shallowTextConfiguration", "$get$shallowTextConfiguration", function() {
    return U.TextTreeConfiguration$(false, "", ":", ":", "", "", "", "", "", false, false, "\n", true, " ", "", "", "", " ", "  ", "", "", "", false, "");
  }, "shallowTextConfiguration", "_indentPattern", "$get$_indentPattern", function() {
    return P.RegExp_RegExp("^ *(?:[-+*] |[0-9]+[.):] )?", true, false);
  }, "_indentPattern", "rendererExpando", "$get$rendererExpando", function() {
    return P.Expando$("IconRenderer", [Y.HtmlIconRenderer, S.Icon]);
  }, "rendererExpando", "FlutterMaterialIcons__iconCache", "$get$FlutterMaterialIcons__iconCache", function() {
    return P.LinkedHashMap_LinkedHashMap$_empty(P.String, K.MaterialIcon);
  }, "FlutterMaterialIcons__iconCache", "_devicePixelRatio", "$get$_devicePixelRatio", function() {
    return J.get$devicePixelRatio$x(W.window());
  }, "_devicePixelRatio", "nf", "$get$nf", function() {
    return T.NumberFormat$decimalPattern(null);
  }, "nf", "_escapedChar", "$get$_escapedChar", function() {
    return P.RegExp_RegExp('["\\x00-\\x1F\\x7F]', true, false);
  }, "_escapedChar", "token", "$get$token", function() {
    return P.RegExp_RegExp('[^()<>@,;:"\\\\/[\\]?={} \\t\\x00-\\x1F\\x7F]+', true, false);
  }, "token", "_lws", "$get$_lws", function() {
    return P.RegExp_RegExp("(?:\\r\\n)?[ \\t]+", true, false);
  }, "_lws", "_quotedString", "$get$_quotedString", function() {
    return P.RegExp_RegExp('"(?:[^"\\x00-\\x1F\\x7F]|\\\\.)*"', true, false);
  }, "_quotedString", "_quotedPair", "$get$_quotedPair", function() {
    return P.RegExp_RegExp("\\\\(.)", true, false);
  }, "_quotedPair", "nonToken", "$get$nonToken", function() {
    return P.RegExp_RegExp('[()<>@,;:"\\\\/\\[\\]?={} \\t\\x00-\\x1F\\x7F]', true, false);
  }, "nonToken", "whitespace", "$get$whitespace", function() {
    return P.RegExp_RegExp("(?:" + H.S(J.get$pattern$z($.$get$_lws())) + ")*", true, false);
  }, "whitespace", "en_USSymbols", "$get$en_USSymbols", function() {
    return B.DateSymbols$(C.List_AM_PM, null, C.List_cno, C.List_iDZ, C.List_6xs, C.List_BC_AD, 6, 5, C.List_cIc, "en_US", C.List_qpm, C.List_3US, C.List_bJM, C.List_h8w, C.List_Q1_Q2_Q3_Q4, C.List_gc6, C.List_cIc, C.List_qpm, C.List_3US, C.List_h8w, C.List_gc6, C.List_wMy, C.List_kWG, C.List_wMy, C.List_5_6, null);
  }, "en_USSymbols", "DateFormat__matchers", "$get$DateFormat__matchers", function() {
    return H.setRuntimeTypeInfo([P.RegExp_RegExp("^'(?:[^']|'')*'", true, false), P.RegExp_RegExp("^(?:G+|y+|M+|k+|S+|E+|a+|h+|K+|H+|c+|L+|Q+|d+|D+|m+|s+|v+|z+|Z+)", true, false), P.RegExp_RegExp("^[^'GyMkSEahKHcLQdDmsvzZ]+", true, false)], [P.RegExp]);
  }, "DateFormat__matchers", "DateFormat__useNativeDigitsByDefault", "$get$DateFormat__useNativeDigitsByDefault", function() {
    return P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.bool);
  }, "DateFormat__useNativeDigitsByDefault", "DateFormat__asciiZeroCodeUnit", "$get$DateFormat__asciiZeroCodeUnit", function() {
    return 48;
  }, "DateFormat__asciiZeroCodeUnit", "_DateFormatQuotedField__twoEscapedQuotes", "$get$_DateFormatQuotedField__twoEscapedQuotes", function() {
    return P.RegExp_RegExp("''", true, false);
  }, "_DateFormatQuotedField__twoEscapedQuotes", "NumberFormat__ln10", "$get$NumberFormat__ln10", function() {
    return P.log(10);
  }, "NumberFormat__ln10", "NumberFormat__maxInt", "$get$NumberFormat__maxInt", function() {
    return typeof 1 === "number" ? P.pow(2, 52) : C.JSInt_methods.floor$0(1e300);
  }, "NumberFormat__maxInt", "NumberFormat__maxDigits", "$get$NumberFormat__maxDigits", function() {
    return J.ceil$0$n(J.$div$n(P.log($.$get$NumberFormat__maxInt()), P.log(10)));
  }, "NumberFormat__maxDigits", "numberFormatSymbols", "$get$numberFormatSymbols", function() {
    return P.LinkedHashMap_LinkedHashMap$_literal(["af", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ",", "ZAR", "E", "\xa0", "\u221e", "-", "af", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "am", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "ETB", "E", ",", "\u221e", "-", "am", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ar", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ".", "EGP", "E", ",", "\u221e", "\u200e-", "ar", "\u0644\u064a\u0633\xa0\u0631\u0642\u0645\u064b\u0627", "\u200e%\u200e", "#,##0%", "\u2030", "\u200e+", "#E0", "0"), "ar_DZ", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "DZD", "E", ".", "\u221e", "\u200e-", "ar_DZ", "\u0644\u064a\u0633\xa0\u0631\u0642\u0645\u064b\u0627", "\u200e%\u200e", "#,##0%", "\u2030", "\u200e+", "#E0", "0"), "ar_EG", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", "\u066b", "EGP", "\u0627\u0633", "\u066c", "\u221e", "\u061c-", "ar_EG", "\u0644\u064a\u0633\xa0\u0631\u0642\u0645", "\u066a\u061c", "#,##0%", "\u0609", "\u061c+", "#E0", "\u0660"), "az", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "AZN", "E", ".", "\u221e", "-", "az", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "be", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "BYN", "E", "\xa0", "\u221e", "-", "be", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "bg", B.NumberSymbols$("0.00\xa0\xa4", "#,##0.###", ",", "BGN", "E", "\xa0", "\u221e", "-", "bg", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "bn", B.NumberSymbols$("#,##,##0.00\xa4", "#,##,##0.###", ".", "BDT", "E", ",", "\u221e", "-", "bn", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "\u09e6"), "br", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", "\xa0", "\u221e", "-", "br", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "bs", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "BAM", "E", ".", "\u221e", "-", "bs", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "ca", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "-", "ca", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "chr", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "USD", "E", ",", "\u221e", "-", "chr", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "cs", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "CZK", "E", "\xa0", "\u221e", "-", "cs", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "cy", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "GBP", "E", ",", "\u221e", "-", "cy", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "da", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "DKK", "E", ".", "\u221e", "-", "da", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "de", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "-", "de", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "de_AT", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "EUR", "E", "\xa0", "\u221e", "-", "de_AT", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "de_CH", B.NumberSymbols$("\xa4\xa0#,##0.00;\xa4-#,##0.00", "#,##0.###", ".", "CHF", "E", "\u2019", "\u221e", "-", "de_CH", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "el", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "e", ".", "\u221e", "-", "el", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "USD", "E", ",", "\u221e", "-", "en", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_AU", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "AUD", "e", ",", "\u221e", "-", "en_AU", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_CA", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "CAD", "e", ",", "\u221e", "-", "en_CA", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_GB", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "GBP", "E", ",", "\u221e", "-", "en_GB", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_IE", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "EUR", "E", ",", "\u221e", "-", "en_IE", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_IN", B.NumberSymbols$("\xa4\xa0#,##,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "en_IN", "NaN", "%", "#,##,##0%", "\u2030", "+", "#E0", "0"), "en_MY", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "MYR", "E", ",", "\u221e", "-", "en_MY", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_SG", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "SGD", "E", ",", "\u221e", "-", "en_SG", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_US", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "USD", "E", ",", "\u221e", "-", "en_US", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "en_ZA", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ",", "ZAR", "E", "\xa0", "\u221e", "-", "en_ZA", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "es", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "-", "es", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "es_419", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "MXN", "E", ",", "\u221e", "-", "es_419", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "es_ES", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "-", "es_ES", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "es_MX", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "MXN", "E", ",", "\u221e", "-", "es_MX", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "es_US", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "USD", "E", ",", "\u221e", "-", "es_US", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "et", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "\xd710^", "\xa0", "\u221e", "\u2212", "et", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "eu", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "\u2212", "eu", "NaN", "%", "%\xa0#,##0", "\u2030", "+", "#E0", "0"), "fa", B.NumberSymbols$("\u200e\xa4#,##0.00", "#,##0.###", "\u066b", "IRR", "\xd7\u06f1\u06f0^", "\u066c", "\u221e", "\u200e\u2212", "fa", "\u0646\u0627\u0639\u062f\u062f", "\u066a", "#,##0%", "\u0609", "\u200e+", "#E0", "\u06f0"), "fi", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", "\xa0", "\u221e", "\u2212", "fi", "ep\xe4luku", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "fil", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "PHP", "E", ",", "\u221e", "-", "fil", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "fr", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", "\xa0", "\u221e", "-", "fr", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "fr_CA", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "CAD", "E", "\xa0", "\u221e", "-", "fr_CA", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "fr_CH", B.NumberSymbols$("#,##0.00\xa0\xa4;-#,##0.00\xa0\xa4", "#,##0.###", ",", "CHF", "E", "\xa0", "\u221e", "-", "fr_CH", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ga", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "EUR", "E", ",", "\u221e", "-", "ga", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "gl", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "-", "gl", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "gsw", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ".", "CHF", "E", "\u2019", "\u221e", "\u2212", "gsw", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "gu", B.NumberSymbols$("\xa4#,##,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "gu", "NaN", "%", "#,##,##0%", "\u2030", "+", "[#E0]", "0"), "haw", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "USD", "E", ",", "\u221e", "-", "haw", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "he", B.NumberSymbols$("\u200f#,##0.00\xa0\xa4;\u200f-#,##0.00\xa0\xa4", "#,##0.###", ".", "ILS", "E", ",", "\u221e", "\u200e-", "he", "NaN", "%", "#,##0%", "\u2030", "\u200e+", "#E0", "0"), "hi", B.NumberSymbols$("\xa4#,##,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "hi", "NaN", "%", "#,##,##0%", "\u2030", "+", "[#E0]", "0"), "hr", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "HRK", "E", ".", "\u221e", "-", "hr", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "hu", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "HUF", "E", "\xa0", "\u221e", "-", "hu", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "hy", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "AMD", "E", "\xa0", "\u221e", "-", "hy", "\u0548\u0579\u0539", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "id", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ",", "IDR", "E", ".", "\u221e", "-", "id", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "in", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ",", "IDR", "E", ".", "\u221e", "-", "in", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "is", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "ISK", "E", ".", "\u221e", "-", "is", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "it", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "-", "it", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "it_CH", B.NumberSymbols$("\xa4\xa0#,##0.00;\xa4-#,##0.00", "#,##0.###", ".", "CHF", "E", "\u2019", "\u221e", "-", "it_CH", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "iw", B.NumberSymbols$("\u200f#,##0.00\xa0\xa4;\u200f-#,##0.00\xa0\xa4", "#,##0.###", ".", "ILS", "E", ",", "\u221e", "\u200e-", "iw", "NaN", "%", "#,##0%", "\u2030", "\u200e+", "#E0", "0"), "ja", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "JPY", "E", ",", "\u221e", "-", "ja", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ka", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "GEL", "E", "\xa0", "\u221e", "-", "ka", "\u10d0\u10e0\xa0\u10d0\u10e0\u10d8\u10e1\xa0\u10e0\u10d8\u10ea\u10ee\u10d5\u10d8", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "kk", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "KZT", "E", "\xa0", "\u221e", "-", "kk", "\u0441\u0430\u043d\xa0\u0435\u043c\u0435\u0441", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "km", B.NumberSymbols$("#,##0.00\xa4", "#,##0.###", ",", "KHR", "E", ".", "\u221e", "-", "km", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "kn", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "INR", "E", ",", "\u221e", "-", "kn", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ko", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "KRW", "E", ",", "\u221e", "-", "ko", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ky", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "KGS", "E", "\xa0", "\u221e", "-", "ky", "\u0441\u0430\u043d\xa0\u044d\u043c\u0435\u0441", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ln", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "CDF", "E", ".", "\u221e", "-", "ln", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "lo", B.NumberSymbols$("\xa4#,##0.00;\xa4-#,##0.00", "#,##0.###", ",", "LAK", "E", ".", "\u221e", "-", "lo", "\u0e9a\u0ecd\u0ec8\u200b\u0ec1\u0ea1\u0ec8\u0e99\u200b\u0ec2\u0e95\u200b\u0ec0\u0ea5\u0e81", "%", "#,##0%", "\u2030", "+", "#", "0"), "lt", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "\xd710^", "\xa0", "\u221e", "\u2212", "lt", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "lv", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", "\xa0", "\u221e", "-", "lv", "NS", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "mk", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "MKD", "E", ".", "\u221e", "-", "mk", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ml", B.NumberSymbols$("\xa4#,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "ml", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "mn", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ".", "MNT", "E", ",", "\u221e", "-", "mn", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "mr", B.NumberSymbols$("\xa4#,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "mr", "NaN", "%", "#,##0%", "\u2030", "+", "[#E0]", "\u0966"), "ms", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "MYR", "E", ",", "\u221e", "-", "ms", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "mt", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "EUR", "E", ",", "\u221e", "-", "mt", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "my", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ".", "MMK", "E", ",", "\u221e", "-", "my", "\u1002\u100f\u1014\u103a\u1038\u1019\u101f\u102f\u1010\u103a\u101e\u1031\u102c", "%", "#,##0%", "\u2030", "+", "#E0", "\u1040"), "nb", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "NOK", "E", "\xa0", "\u221e", "\u2212", "nb", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "ne", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ".", "NPR", "E", ",", "\u221e", "-", "ne", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "\u0966"), "nl", B.NumberSymbols$("\xa4\xa0#,##0.00;\xa4\xa0-#,##0.00", "#,##0.###", ",", "EUR", "E", ".", "\u221e", "-", "nl", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "no", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "NOK", "E", "\xa0", "\u221e", "\u2212", "no", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "no_NO", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "NOK", "E", "\xa0", "\u221e", "\u2212", "no_NO", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "or", B.NumberSymbols$("\xa4\xa0#,##,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "or", "NaN", "%", "#,##,##0%", "\u2030", "+", "#E0", "0"), "pa", B.NumberSymbols$("\xa4\xa0#,##,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "pa", "NaN", "%", "#,##,##0%", "\u2030", "+", "[#E0]", "0"), "pl", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "PLN", "E", "\xa0", "\u221e", "-", "pl", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ps", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", "\u066b", "AFN", "\xd7\u06f1\u06f0^", "\u066c", "\u221e", "\u200e-\u200e", "ps", "NaN", "\u066a", "#,##0%", "\u0609", "\u200e+\u200e", "#E0", "\u06f0"), "pt", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "BRL", "E", ".", "\u221e", "-", "pt", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "pt_BR", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ",", "BRL", "E", ".", "\u221e", "-", "pt_BR", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "pt_PT", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "E", "\xa0", "\u221e", "-", "pt_PT", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ro", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "RON", "E", ".", "\u221e", "-", "ro", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "ru", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "RUB", "E", "\xa0", "\u221e", "-", "ru", "\u043d\u0435\xa0\u0447\u0438\u0441\u043b\u043e", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "si", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "LKR", "E", ",", "\u221e", "-", "si", "NaN", "%", "#,##0%", "\u2030", "+", "#", "0"), "sk", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "e", "\xa0", "\u221e", "-", "sk", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "sl", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "EUR", "e", ".", "\u221e", "\u2212", "sl", "NaN", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "sq", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "ALL", "E", "\xa0", "\u221e", "-", "sq", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "sr", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "RSD", "E", ".", "\u221e", "-", "sr", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "sr_Latn", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "RSD", "E", ".", "\u221e", "-", "sr_Latn", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "sv", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "SEK", "\xd710^", "\xa0", "\u221e", "\u2212", "sv", "\xa4\xa4\xa4", "%", "#,##0\xa0%", "\u2030", "+", "#E0", "0"), "sw", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "TZS", "E", ",", "\u221e", "-", "sw", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ta", B.NumberSymbols$("\xa4\xa0#,##,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "ta", "NaN", "%", "#,##,##0%", "\u2030", "+", "#E0", "0"), "te", B.NumberSymbols$("\xa4#,##,##0.00", "#,##,##0.###", ".", "INR", "E", ",", "\u221e", "-", "te", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "th", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "THB", "E", ",", "\u221e", "-", "th", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "tl", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "PHP", "E", ",", "\u221e", "-", "tl", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "tr", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ",", "TRY", "E", ".", "\u221e", "-", "tr", "NaN", "%", "%#,##0", "\u2030", "+", "#E0", "0"), "uk", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "UAH", "\u0415", "\xa0", "\u221e", "-", "uk", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "ur", B.NumberSymbols$("\xa4\xa0#,##0.00", "#,##0.###", ".", "PKR", "E", ",", "\u221e", "\u200e-", "ur", "NaN", "%", "#,##0%", "\u2030", "\u200e+", "#E0", "0"), "uz", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "UZS", "E", "\xa0", "\u221e", "-", "uz", "son\xa0emas", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "vi", B.NumberSymbols$("#,##0.00\xa0\xa4", "#,##0.###", ",", "VND", "E", ".", "\u221e", "-", "vi", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "zh", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "CNY", "E", ",", "\u221e", "-", "zh", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "zh_CN", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "CNY", "E", ",", "\u221e", "-", "zh_CN", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "zh_HK", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "HKD", "E", ",", "\u221e", "-", "zh_HK", "\u975e\u6578\u503c", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "zh_TW", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "TWD", "E", ",", "\u221e", "-", "zh_TW", "\u975e\u6578\u503c", "%", "#,##0%", "\u2030", "+", "#E0", "0"), "zu", B.NumberSymbols$("\xa4#,##0.00", "#,##0.###", ".", "ZAR", "E", ",", "\u221e", "-", "zu", "NaN", "%", "#,##0%", "\u2030", "+", "#E0", "0")], P.String, B.NumberSymbols);
  }, "numberFormatSymbols", "currencyFractionDigits", "$get$currencyFractionDigits", function() {
    return P.LinkedHashMap_LinkedHashMap$_literal(["ADP", 0, "AFN", 0, "ALL", 0, "AMD", 0, "BHD", 3, "BIF", 0, "BYN", 2, "BYR", 0, "CAD", 2, "CHF", 2, "CLF", 4, "CLP", 0, "COP", 0, "CRC", 2, "CZK", 2, "DEFAULT", 2, "DJF", 0, "DKK", 2, "ESP", 0, "GNF", 0, "GYD", 0, "HUF", 2, "IDR", 0, "IQD", 0, "IRR", 0, "ISK", 0, "ITL", 0, "JOD", 3, "JPY", 0, "KMF", 0, "KPW", 0, "KRW", 0, "KWD", 3, "LAK", 0, "LBP", 0, "LUF", 0, "LYD", 3, "MGA", 0, "MGF", 0, "MMK", 0, "MNT", 0, "MRO", 0, "MUR", 0, "NOK", 2, "OMR", 3, "PKR", 0, "PYG", 0, "RSD", 0, "RWF", 0, "SEK", 2, "SLL", 0, "SOS", 0, "STD", 0, "SYP", 0, "TMM", 0, "TND", 3, "TRL", 0, "TWD", 2, "TZS", 0, "UGX", 0, "UYI", 0, "UZS", 0, "VND", 0, "VUV", 0, "XAF", 0, "XOF", 0, "XPF", 0, "YER", 0, "ZMK", 0, "ZWD", 0], P.String, P.int);
  }, "currencyFractionDigits", "_dateTimeSymbols", "$get$_dateTimeSymbols", function() {
    return X.UninitializedLocaleData$("initializeDateFormatting(<locale>)", $.$get$en_USSymbols(), B.DateSymbols);
  }, "_dateTimeSymbols", "dateTimePatterns", "$get$dateTimePatterns", function() {
    return X.UninitializedLocaleData$("initializeDateFormatting(<locale>)", $.en_USPatterns, [P.Map, P.String, P.String]);
  }, "dateTimePatterns", "context0", "$get$context0", function() {
    return M.createInternal();
  }, "context0", "Style_posix", "$get$Style_posix", function() {
    return E.PosixStyle$();
  }, "Style_posix", "Style_windows", "$get$Style_windows", function() {
    return L.WindowsStyle$();
  }, "Style_windows", "Style_url", "$get$Style_url", function() {
    return F.UrlStyle$();
  }, "Style_url", "Style_platform", "$get$Style_platform", function() {
    return O.Style__getPlatformStyle();
  }, "Style_platform", "_slashAutoEscape", "$get$_slashAutoEscape", function() {
    return J.$eq$(J.get$pattern$z(P.RegExp_RegExp("/", true, false)), "\\/");
  }, "_slashAutoEscape", "_typeFactories", "$get$_typeFactories", function() {
    return P.LinkedHashMap_LinkedHashMap$_literal(["BoundField", S.vm_service_lib_BoundField_parse$closure(), "BoundVariable", S.vm_service_lib_BoundVariable_parse$closure(), "Breakpoint", S.vm_service_lib_Breakpoint_parse$closure(), "@Class", S.vm_service_lib_ClassRef_parse$closure(), "Class", S.vm_service_lib_Class_parse$closure(), "ClassList", S.vm_service_lib_ClassList_parse$closure(), "@Code", S.vm_service_lib_CodeRef_parse$closure(), "Code", S.vm_service_lib_Code_parse$closure(), "@Context", S.vm_service_lib_ContextRef_parse$closure(), "Context", S.vm_service_lib_Context_parse$closure(), "ContextElement", S.vm_service_lib_ContextElement_parse$closure(), "@Error", S.vm_service_lib_ErrorRef_parse$closure(), "Error", S.vm_service_lib_Error_parse$closure(), "Event", S.vm_service_lib_Event_parse$closure(), "ExtensionData", S.vm_service_lib_ExtensionData_parse$closure(), "@Field", S.vm_service_lib_FieldRef_parse$closure(), "Field", S.vm_service_lib_Field_parse$closure(), "Flag", S.vm_service_lib_Flag_parse$closure(), "FlagList", S.vm_service_lib_FlagList_parse$closure(), "Frame", S.vm_service_lib_Frame_parse$closure(), "@Function", S.vm_service_lib_FuncRef_parse$closure(), "Function", S.vm_service_lib_Func_parse$closure(), "@Instance", S.vm_service_lib_InstanceRef_parse$closure(), "Instance", S.vm_service_lib_Instance_parse$closure(), "@Isolate", S.vm_service_lib_IsolateRef_parse$closure(), "Isolate", S.vm_service_lib_Isolate_parse$closure(), "@Library", S.vm_service_lib_LibraryRef_parse$closure(), "Library", S.vm_service_lib_Library_parse$closure(), "LibraryDependency", S.vm_service_lib_LibraryDependency_parse$closure(), "MapAssociation", S.vm_service_lib_MapAssociation_parse$closure(), "Message", S.vm_service_lib_Message_parse$closure(), "@Null", S.vm_service_lib_NullValRef_parse$closure(), "Null", S.vm_service_lib_NullVal_parse$closure(), "@Object", S.vm_service_lib_ObjRef_parse$closure(), "Object", S.vm_service_lib_Obj_parse$closure(), "ReloadReport", S.vm_service_lib_ReloadReport_parse$closure(), "Response", S.vm_service_lib_Response_parse$closure(), "Sentinel", S.vm_service_lib_Sentinel_parse$closure(), "@Script", S.vm_service_lib_ScriptRef_parse$closure(), "Script", S.vm_service_lib_Script_parse$closure(), "ScriptList", S.vm_service_lib_ScriptList_parse$closure(), "SourceLocation", S.vm_service_lib_SourceLocation_parse$closure(), "SourceReport", S.vm_service_lib_SourceReport_parse$closure(), "SourceReportCoverage", S.vm_service_lib_SourceReportCoverage_parse$closure(), "SourceReportRange", S.vm_service_lib_SourceReportRange_parse$closure(), "Stack", S.vm_service_lib_Stack_parse$closure(), "Success", S.vm_service_lib_Success_parse$closure(), "TimelineEvent", S.vm_service_lib_TimelineEvent_parse$closure(), "@TypeArguments", S.vm_service_lib_TypeArgumentsRef_parse$closure(), "TypeArguments", S.vm_service_lib_TypeArguments_parse$closure(), "UnresolvedSourceLocation", S.vm_service_lib_UnresolvedSourceLocation_parse$closure(), "Version", S.vm_service_lib_Version_parse$closure(), "@VM", S.vm_service_lib_VMRef_parse$closure(), "VM", S.vm_service_lib_VM_parse$closure(), "_CpuProfile", S.vm_service_lib_CpuProfile_parse$closure(), "CodeRegion", S.vm_service_lib_CodeRegion_parse$closure(), "ProfileFunction", S.vm_service_lib_ProfileFunction_parse$closure(), "AllocationProfile", S.vm_service_lib_AllocationProfile_parse$closure(), "ClassHeapStats", S.vm_service_lib_ClassHeapStats_parse$closure(), "HeapSpace", S.vm_service_lib_HeapSpace_parse$closure()], P.String, P.Function);
  }, "_typeFactories"]);
  Isolate = Isolate.$finishIsolateConstructor(Isolate);
  $ = new Isolate();
  init.metadata = [null, "value", "json", "other", "key", "start", "index", "end", "name", "object", "element", "source", "_", "iterable", "error", "f", 0, "text", false, "e", "stackTrace", "message", "event", "node", "parent", "o", "path", true, "isolateId", "type", "string", "onError", "onData", "a", "data", "length", "pattern", "x", "receiver", "", "date", "test", "count", "callback", "arg", "cancelOnError", "methodName", "onDone", "sink", "line", "s", "table", "offset", "isLast", "b", "input", "width", "stream", C.C__HashEnd, "result", "_sink", "method", "url", "action", "function", "uri", "item", "property", "list", "position", "c", "args", "n", "frame", "service", "color", "startIndex", "y", "state", "compare", "elements", "ref", "str", "rti", "number", "obj", "title", "skipCount", "subscription", "target", "separator", "arg1", "_element", "charCode", "arguments", "growable", "height", "validator", "orElse", "column", "icon", "ifAbsent", "t", "bytes", "id", "propertyName", "treeType", "scheme", "headers", "tag", "uiAlreadyUpdated", "map", "v", "codeUnits", "toEncodable", "replacement", "chunk", "treeSanitizer", "options", "left", "allowMalformed", "from", "zone", "request", "isAlive", "codeUnit", "arg2", "framework", "script", "operand", "child", "encoding", "span", "listener", "selection", "bucket", "offsetInBytes", "parameters", "onListen", "onCancel", "style", "_map", "memberName", "useCapture", "attributeName", "selectors", "_source", "expression", "match", "html", "record", "debuggerState", "row", "positionalArguments", "parts", "hash", "summaryTree", "namedArguments", "_iterator", "vmService", "params", "depth", "newLength", "inspectorService", "char", "instanceRefFuture", "interceptor", "_iterable", "self", "minLevel", "host", "parentConfiguration", "instanceRef", "breakpoint", "dispatch", "resumeSignal", "breakpoints", "mode", "paused", "isolateRef", "locale", "location", "log", "reviver", "scope", "_start", "top", "charCodes", "convert", "items", "classes", "pair", "prefixLineOne", "closure", "part", "indent", "_f", "onHover", "i", "sEnv", "onNodeAdded", "body", "context", "prefixOtherLines", "transform", 1, "entries", "onSelectionChange", "duration", "parameter", "query", "enabled", "tEnv", "newSelection", "right", "scriptRef", "buffer", "detailsSelection", "level", "reference", "onExpand", "canvas", "to", "urlSafe", "port", "ex", "targetId", "disposeHandler", "writeMessage", "inStream", "genericContext", "shouldAdd", "isField", C.DiagnosticLevel_2, "checks", "uriPolicy", "milliseconds", "day", "month", "size", "sourceUrl", "jsObject", "bufferSize", "handle", "_modifications", "isolates", "output", " ", "textStyle", "endIndex", "uriDescriber", "regexp", "array", "k", "extension", "isolate", "stringRef", "owner", "setSelectionResult", "debugName", "setSubtreeRoot", "variable", "ch", "file", "radix", "controller", "_target", "kind", "defaultValue", "onNonMatch", "onMatch", "instance", "gutterSize", "_stream", "multiLine", "sync", "onResume", "onPause", "isIntercepted", "listeners", "base", "at", "arity", "handleData", "completer", "bodyFunction", "asField", "visible", "scriptId", "symbol", "each", "arg3", "cell", "_name", "handleDone", "client", "screen", "isValidKey", "types", "caseSensitive", "bits", "treeNode", "pos", "allocation", "_string", "mouseEvent", "invocation", "fn", "_toEncodable", "smooth", "scrollBehavior", "keyValuePairs", "tooltip", "_indent", "addChunk", "subtype", "_message", "isUtc", "future", "_eventType", "_pattern", "fontSize", "handleError", C.Utf8Codec_false, "component", "fragment", "family", "substitutionName", C.Map_empty, "statusCode", "isRedirect", "persistentConnection", "reasonPhrase", "localeName", "newPattern", "constructor", "currencySymbol", "decimalDigits", "argumentError", "withDrive", "streams", "startValue", "_useCapture", "_skipCount", "expandProperties", "codeMirror", "alphabet", "values", "outputIndex", "allowInvalid", "encoded", "bufferLength", "microsecond", "endOrNull", "objects", "invalidValue", "minValue", "maxValue", "hours", "minutes", "encodedComponent", "seconds", "_match", "pathSegments", "queryParameters", "userInfo", "segments", "hasAuthority", "charTable", "escapeDelimiters", "fractionDigits", "streamTransformer", "_value", "factor", "msg", "_input", "windows", "transition", "_index", "time", "bag", "_nodeList", "_endOrLength", "collection", "typeExtension", "descriptors", "src", "protocols", "argument", "indexable", "reason", "g", "_receiver", "angle", "priority", "tagName", "byteOffset", "password", "user", "takeCount", "mustCopy", "captureThis", "_jsObject", "createProxy", "exponent", "jsProxy", "gutterID", "where", "cssClass", "eventName", "argCount", "canonicalize", "_remaining", "callingMethod", "_breakpointsCountDiv", "variableDescriber", "padding", "proto", "disabled", "computation", "onValue", "errorCallback", "rootLib", "_zone", "field", "libraryName", "isIsolateNull", "functions", "applyTrampolineIndex", "reflectionInfo", "_controller", "errorReporter", "_onDone", "properties", "isStatic", "isSuperCall", "mapper", "_onListen", "inspectorTreeFactory", "isSummaryTree", "isolateStopped", "_arguments", "diagnosticsNode", "inspectorLibrary", "supportedServiceMethods", "groupName", "objectGroup", "jsonFuture", "previousSelection", "localOnly", "asyncError", "expandChildren", "targets", "iconRenderer", "font", "treeStyle", "jsFunction", "modifyState", "allowWrap", "functionTypeRti", "isError", "statusLine", "initialMessage", "onClosed", "callExtension", 29, "rowHeight", "inputEvent", "rowIndex", "observer", "timelineController", "framesUI", "startTime", "empty", "iconPath", "equals", "renderer", "clear", "hashCode", "attributes", "bottom", "alternative", C.DiagnosticLevel_3, "wrapIndent", "debugLabel", "decoration", "decorationColor", "decorationStyle", "fontFamily", "_set", "fontStyle", "fontWeight", "letterSpacing", "textBaseline", "wordSpacing", "isAbstract", 18, "tabs", "supportsSelection", 5, "(", "minSize", "dimension", "extensionDescription", "addBuffer", "onMouseLeave", "onMouseMove", "onTap", "paintCallback", "p", "force", ")", "leftDelimiter", "rightDelimiter", "objectId", "selector", "argumentIds", "streamName", "breakpointId", "frameIndex", "step", "recordedStreams", "streamId", "substitution", "contentLength", "fill", "charset", "NAME", "newLocale", "aLocale", "format", "inputPattern", "numberOfDigits", "basic", "part1", "part2", "part3", "part4", "part5", "part6", "part7", "path1", "path2", "reusable", "decoder", "_end", "lines", "_context", "glyph", "validKey", "_proxy", "isAttr", "dict", "postCreate", "interceptorClass", "year", "promise", "slot", "needle", "el", "hour", "minute", "second", "isCheckProperty", "millisecond", "svg", "proxy", "days", "option", "noCursor", "microseconds", "scrollIntoView", "_duration", "paddingCount", "margin", "origin", "_takeCount", "expectedPadding", "outIndex", "sourceIndex", "cvtEvent", "startName", "endName", "first", "last", "rawClassName", "_body", "modifiedObject", "dartException", "variableName", "_outerHelper", "generator", "transformer", "exception", "_exception", "internalName", "hooks", "numberOfArguments", "converter", "isPaused", "growableList", "_escape", "futures", "cleanUp", "eagerError", "argumentNames", "unsupportedObject", "cause", "onComplete", "tokenPos", "upperLimit", "newScript", "scrollTo", "scripts", "commonPrefix", "selectRootScript", "ref1", "ref2", "frames", "selectTop", "desc", "global", "assoc", "_userInfo", "fixedLengthList", "_host", "errorHandler", "_port", "arg4", "mapSink", "_memberName", "partialResult", "_query", "_fragment", "notificationHandler", "warning", "schemeEnd", "rebuild", "hostStart", "inverted", "_pending", "isProperty", "entry", "portStart", "nodes", "pathStart", "queryStart", "_internalName", "label", "widgets", "_kind", "fragmentStart", "stubName", "_re", "_sinkMapper", "combine", "_regExp", "signature", "previous", "string1", "_bufferSize", "_self", "st", "errorCode", "subtreeRoot", "subtreeSelection", "eventId", "valueRef", "maybeRerootDetailsTree", "diagnostic", "_nextIndex", "flutterIsolate", "sub", "firstSegment", "strictIPv6", "contextName", "theError", "theStackTrace", "rootDirectories", "lowerCase", "keepGoing", "jsonElement", "jsonObject", "genericFunctionRti", "string2", "regExp", "sourceResult", "selectionChanged", "highlightDepth", "isSelected", "lineToParent", "ticks", "allowScheme", "chan", "_namedArgumentNames", "_portStart", "_callback", "clazz", "fieldName", "children", "plusToSpace", "_text", "pendingEvents", "_separatorIndices", "_uriCache", "_typeArgumentCount", "sourceUri", "rect", "indices", "targetRect", C.MaterialColor_Map_HFpTk_4288585374, "_uri", "cssClasses", "container", "_schemeEnd", "loggingScreen", "_hostStart", "serviceRef", "_details", "timestamp", "detailsComputer", "summary", "summaryHtml", "indexability", "_chunkedSink", "_pathStart", "reloadServiceAvailable", "newText", "pageId", "idMethod", "wasInputPaused", "finishedCompleter", "streamControllers", "onFirstListenerSubscribed", "_queryStart", "isolateRefId", "staticName", "extensionName", "valueFromJson", "_fragmentStart", "_schemeCache", "_data", "stringSink", "otherZone", "currentRowIndex", "firstRenderedRowInclusive", "lastRenderedRowExclusive", "newIndex", "keepVisible", "v1", "quotient", "dataObject", "_keys", "elapsedMs", "startTimeMs", "previousFrame", "lead", "tail", "frameUI", "selected", "cpuThreadId", "gpuThreadId", "_stringSink", "category", "phase", "processId", "threadId", "timestampMicros", "durationMicros", "buf", "ss", "segment", "defaultTransition", "chars", "_allowMalformed", "childProvider", "open", "results", "range", "infix", "_class", "removeOthers", "flexAmount", "shiftHandle", "r", "dx", "dy", "replacer", "_rti", "arg01", "arg02", "arg03", "arg04", "arg05", "arg06", "arg07", "arg08", "arg09", "arg10", "arg11", "arg12", "arg13", "arg14", "arg15", "arg16", "arg17", "arg18", "arg19", "arg20", "_equals", "delta", "code", "\n", "addBlankLineIfNoChildren", "afterDescription", "afterDescriptionIfBody", "afterName", "afterProperties", "beforeName", "beforeProperties", "bodyIndent", "footer", "isBlankLineBetweenPropertiesAndChildren", "isNameOnOwnLine", "lineBreak", "lineBreakProperties", "linkCharacter", "manditoryFooter", "prefixLastChildLineOne", "_hashCode", "sequenceNumber", "prefixOtherLinesRootNode", "propertyPrefixIfChildren", "propertyPrefixNoChildren", "propertySeparator", "showChildren", "suffixLineOne", "_equality", "_hasher", "isAccessor", "wrapWidth", "wrapWidthProperties", C.C__NoDefaultValue, "suffix", C.DiagnosticsTreeStyle_7, "description", "expandableValue", "ifEmpty", "ifNull", "linePrefix", "missingIfNull", "showName", "showSeparator", "showSeperatorAfter", "jsPromise", "href", "blobParts", "endings", "sourceEnd", "val", "hyphenated", "hashMapCellKey", "hashMapCellValue", "inherit", "years", "package", "unsortedIndex", "typeExtention", "lineLength", "byte", "fromText", "times", "iconWidth", "leadingSurrogate", "nextCodeUnit", "tab", "_genericClosure", "_this", "horizontal", "cache", "sizes", "horizontalSizes", "verticalSizes", "userAgent", "units", "available", "millisecondsSinceEpoch", "d", "initialValue", "codePoints", "group_", "eventType", "victim", "minDelay", "maxDelay", "requestsPerSecond", "newValue", "_argumentsExpr", "_expr", "win", "requiredParameterCount", "_window", "w", "_method", "promiseValue", "promiseError", "content", "firstPadding", "destX", "destY", "m", "key1", "key2", "optionalParameterCount", "futureOrRti", "destHeight", "areOptionalParametersNamed", "functionType", "maxWidth", "asynch", "fields", "bodyBytes", "response", C.Latin1Codec_false, "v2", "fallback", "mediaType", "clearParameters", "mimeType", "attribute", "scanner", "AMPMS", "AVAILABLEFORMATS", "DATEFORMATS", "DATETIMEFORMATS", "ERANAMES", "ERAS", "FIRSTDAYOFWEEK", "FIRSTWEEKCUTOFFDAY", "MONTHS", C.Endian_false, "NARROWMONTHS", "NARROWWEEKDAYS", "QUARTERS", "SHORTMONTHS", "SHORTQUARTERS", "SHORTWEEKDAYS", "STANDALONEMONTHS", "STANDALONENARROWMONTHS", "STANDALONENARROWWEEKDAYS", "STANDALONESHORTMONTHS", "STANDALONESHORTWEEKDAYS", "STANDALONEWEEKDAYS", "TIMEFORMATS", "WEEKDAYS", "WEEKENDRANGE", "ZERODIGIT", "localName_OR_tagName", T.intl_Intl__throwLocaleError$closure(), "localeExists", "onFailure", "newContents", "options_OR_typeExtension", "newEntries", "className", "leapYear", "existingArgumentNames", "typeArguments", "_original", "canonicalTable", "numberString", "toBePrinted", "getPattern", "computeCurrencySymbol", "isForCurrency", "remainingSignificantDigits", "integerPart", "extraIntegerDigits", "integer", "fractionPart", "fractionPresent", "digits", "alignment", "centerIfNeeded", "totalLength", "affix", "trunk", "CURRENCY_PATTERN", "DECIMAL_PATTERN", "DECIMAL_SEP", "DEF_CURRENCY_CODE", "EXP_SYMBOL", "GROUP_SEP", "INFINITY", "MINUS_SIGN", "NAN", "PERCENT", "PERCENT_PATTERN", "PERMILL", "PLUS_SIGN", "SCIENTIFIC_PATTERN", "ZERO_DIGIT", "fallbackData", "options_OR_x", "blob", "endian", "async", "lowerLimit", "spaceToPlus", "body_OR_data", "part8", "_parent", "otherNode", "newNodes", "root", "isRootRelative", "separators", "_reviver", "codeUnit1", "codeUnit2", "wrapped", "supertype", "streamFactory", "refChild", "prefix", "_streamFactory", "observable", "_wrapper", "seedValue", "latestValue", "onListenHandler", "onCancelHandler", "littleEndian", "allowedAttributes", "decodedChars", "_subsetMask", "_span", "_color", "allowedElements", "_utf8Sink", "allowedUriAttributes", "attr", "corrupted", "creator", "attrs", ":", "destWidth"];
  init.types = [{func: 1, ret: -1}, {func: 1, ret: P.Null}, {func: 1, ret: -1, args: [P.Object]}, {func: 1, args: [,]}, {func: 1, ret: P.Null, args: [,]}, {func: 1, ret: -1, args: [P.Object], opt: [P.StackTrace]}, {func: 1, ret: -1, args: [,]}, {func: 1, ret: P.String, args: [P.String]}, {func: 1, ret: [P.Future,,]}, {func: 1, ret: P.Null, args: [,,]}, {func: 1, ret: P.Null, args: [W.Event]}, {func: 1, ret: -1, args: [S.Event0]}, {func: 1, ret: [P.Future, -1], opt: [,]}, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}, {func: 1, ret: P.bool, args: [P.String]}, {func: 1, ret: P.Null, args: [P.String]}, {func: 1, ret: P.Null, args: [P.bool]}, {func: 1, ret: P.bool, args: [,]}, {func: 1, ret: P.bool, args: [P.Object]}, {func: 1, ret: P.Null, args: [W.MouseEvent]}, {func: 1, ret: P.Null, args: [P.String, P.String]}, {func: 1, ret: P.Null, args: [A.BusEvent]}, {func: 1, ret: P.Null, args: [P.String,,]}, {func: 1, ret: P.Null, args: [S.Event0]}, {func: 1, ret: [P.Future, S.Success]}, {func: 1, ret: P.bool, args: [W.Node]}, {func: 1, ret: [P.Future, P.String], opt: [,]}, {func: 1, ret: P.Null, args: [P.Null]}, {func: 1, ret: P.Null, args: [W.ProgressEvent]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, ret: P.Null, args: [S.IsolateRef]}, {func: 1, ret: [P.Future, [P.List, P.String]], opt: [,]}, {func: 1, ret: [P.Future, P.Null]}, {func: 1, ret: -1, args: [P.Function]}, {func: 1, ret: -1, args: [[P.Set, P.String]]}, {func: 1, ret: -1, args: [W.MouseEvent]}, {func: 1, ret: -1, opt: [P.Object]}, {func: 1, ret: P.Null, args: [O.TimelineFrame]}, {func: 1, ret: P.String, args: [P.Match]}, {func: 1, ret: P.Null, args: [W.CanvasImageSource]}, {func: 1, ret: -1, args: [{func: 1, ret: -1}]}, {func: 1, ret: -1, args: [P.String, P.String]}, {func: 1, ret: P.bool, args: [S.ScriptRef]}, {func: 1, ret: [P.List, S.Breakpoint]}, {func: 1, ret: -1, args: [P.Uint8List, P.String, P.int]}, {func: 1, ret: P.bool, args: [W.Element, P.String, P.String, W._Html5NodeValidator]}, {func: 1, ret: -1, args: [S.VmService]}, {func: 1, ret: P.int, args: [,]}, {func: 1, ret: P.Null, args: [P.num]}, {func: 1, ret: -1, args: [S.Offset]}, {func: 1, ret: P.Null, args: [-1]}, {func: 1, ret: -1, args: [P.num]}, {func: 1, ret: P.Null, args: [P.Symbol0,,]}, {func: 1, ret: -1, args: [U.VmServiceWrapper]}, {func: 1, ret: P.Null, args: [P.Object]}, {func: 1, ret: -1, args: [P.String, P.int]}, {func: 1, ret: P.int, args: [P.int, S.HeapSpace]}, {func: 1, ret: [P.Future, -1], args: [,]}, {func: 1, ret: -1, args: [W.Event]}, {func: 1, ret: P.Null, args: [, P.StackTrace]}, {func: 1, ret: [P.Future, S.Success], args: [P.String], named: {frameIndex: P.int, step: P.String}}, {func: 1, ret: P.bool, args: [S.IsolateRef]}, {func: 1, ret: -1, args: [[P.List,,], W.IntersectionObserver]}, {func: 1, ret: [P.Future, P.Null], args: [P.bool]}, {func: 1, ret: -1, args: [U.DiagnosticsNode]}, {func: 1, ret: P.bool}, {func: 1, ret: P.Null, args: [W.FontFace]}, {func: 1, args: [,,]}, {func: 1, ret: -1, named: {disabled: P.bool}}, {func: 1, ret: -1, opt: [[P.Future,,]]}, {func: 1, ret: P.Object, args: [,]}, {func: 1, ret: P.int, args: [,,]}, {func: 1, ret: P.bool, args: [W.NodeValidator]}, {func: 1, ret: A.CoreElement, args: [S.Frame]}, {func: 1, ret: -1, args: [P.String], opt: [,]}, {func: 1, ret: [P.Future, P.Null], args: [S.Frame]}, {func: 1, ret: P.int, args: [P.int, P.int]}, {func: 1, ret: [P.Future, P.String], args: [S.BoundVariable]}, {func: 1, ret: [P.Future, P.Null], args: [S.Breakpoint]}, {func: 1, ret: [P.Future, P.Null], args: [S.ScriptRef]}, {func: 1, ret: P.Null, args: [,], opt: [,]}, {func: 1, ret: P.Null, args: [[P.List, S.Breakpoint]]}, {func: 1, ret: [P._Future,,], args: [,]}, {func: 1, ret: P.Uint8List, args: [P.int]}, {func: 1, ret: [P.Future, -1], args: [S.Breakpoint]}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, ret: P.Null, args: [P.int]}, {func: 1, ret: P.Null, args: [P.int,,]}, {func: 1, ret: A.CoreElement, args: [S.Breakpoint]}, {func: 1, ret: P.Null, args: [S.Script]}, {func: 1, ret: A.CoreElement, args: [S.ScriptRef]}, {func: 1, ret: P.int, args: [S.ScriptRef, S.ScriptRef]}, {func: 1, ret: -1, args: [P.num, P.num, P.num, P.num]}, {func: 1, ret: A.CoreElement, args: [S.BoundVariable]}, {func: 1, ret: W.Element, args: [P.Object]}, {func: 1, ret: S.BoundVariable, args: [S.MapAssociation]}, {func: 1, ret: S.BoundVariable, args: [S.BoundField]}, {func: 1, ret: -1, args: [[P._DelayedEvent,,]]}, {func: 1, ret: P.bool, args: [S.Script]}, {func: 1, ret: S.ScriptRef, args: [,]}, {func: 1, ret: -1, args: [, P.StackTrace]}, {func: 1, ret: W.FontFaceSet, args: [W.FontFace]}, {func: 1, ret: [P.Future, S.InstanceRef]}, {func: 1, ret: -1, args: [W.PopStateEvent]}, {func: 1, ret: P.bool, args: [N.Screen]}, {func: 1, ret: -1, args: [N.StatusItem]}, {func: 1, args: [P.num]}, {func: 1, ret: M.InspectorTreeWeb, named: {onExpand: {func: 1, ret: -1, args: [K.InspectorTreeNode]}, onHover: {func: 1, ret: -1, args: [K.InspectorTreeNode]}, onNodeAdded: {func: 1, ret: -1, args: [K.InspectorTreeNode, M.RemoteDiagnosticsNode]}, onSelectionChange: {func: 1, ret: -1}, summaryTree: P.bool, treeType: E.FlutterTreeType}}, {func: 1, ret: P.bool, args: [K.InspectorTreeNode]}, {func: 1, ret: [P.Future, -1]}, {func: 1, ret: -1, args: [E.InspectorInstanceRef]}, {func: 1, ret: -1, args: [K.InspectorTreeNode]}, {func: 1, ret: -1, args: [K.InspectorTreeNode, M.RemoteDiagnosticsNode]}, {func: 1, ret: [P.Future, [P.Set, P.String]]}, {func: 1, ret: -1, args: [,], opt: [,]}, {func: 1, args: [P.String]}, {func: 1, ret: -1, args: [W.CanvasRenderingContext2D, S.Rect]}, {func: 1, args: [W.Event]}, {func: 1, ret: P.bool, args: [P.double]}, {func: 1, ret: -1, opt: [S.Color]}, {func: 1, ret: -1, args: [W.NodeValidator]}, {func: 1, ret: P.int}, {func: 1, ret: P.Null, args: [Y.LogData]}, {func: 1, ret: P.Null, args: [{func: 1, ret: -1}]}, {func: 1, ret: [P.Future, P.String]}, {func: 1, ret: -1, opt: [S.IsolateRef]}, {func: 1, ret: V.ClassHeapStats0, args: [[P.Map, P.String,,]]}, {func: 1, ret: P.bool, args: [V.ClassHeapStats0]}, {func: 1, ret: -1, args: [W.Node, W.Node]}, {func: 1, ret: P.String, args: [V.HeapSample]}, {func: 1, ret: P.int, args: [P.int, V.HeapSample]}, {func: 1, ret: [P.Future, S.Isolate], args: [S.IsolateRef]}, {func: 1, ret: [P._ConverterStreamEventSink,,,], args: [[P.EventSink,,]]}, {func: 1, ret: P.bool, args: [V.HeapSample]}, {func: 1, ret: S.HeapSpace, args: [,]}, {func: 1, ret: P.bool, args: [[P.Set, P.String]]}, {func: 1, ret: -1, args: [P.Uint8List, P.int, P.int]}, {func: 1, ret: W.Element, args: [W.Node]}, {func: 1, ret: [P.Future, P.int], opt: [,]}, {func: 1, ret: P.JsFunction, args: [,]}, {func: 1, ret: P.Null, args: [P.String, P.int,,]}, {func: 1, ret: P.String, args: [S.Breakpoint]}, {func: 1, ret: P.String, args: [S.ScriptRef]}, {func: 1, ret: P.String, args: [S.Frame]}, {func: 1, ret: P.String, args: [S.BoundVariable]}, {func: 1, ret: [P.Future, P.Null], args: [S.CpuProfile]}, {func: 1, ret: P.Null, args: [S.Success]}, {func: 1, ret: P.Null, args: [V.PerfData]}, {func: 1, ret: P.bool, args: [S.ProfileFunction]}, {func: 1, ret: V.PerfData, args: [S.ProfileFunction]}, {func: 1, args: [W.MessageEvent]}, {func: 1, ret: P.ByteData, args: [W.ProgressEvent]}, {func: 1, ret: -1, args: [P.String]}, {func: 1, ret: P.Null, args: [W.CloseEvent]}, {func: 1, ret: P.String, args: [,]}, {func: 1, ret: [E.ToggleableServiceExtensionDescription,,], args: [,]}, {func: 1, ret: [P.Future, S.Response], args: [P.String]}, {func: 1, ret: -1, args: [-1]}, {func: 1, ret: [P.Future, S.Success], args: [P.String]}, {func: 1, ret: [P.JsArray,,], args: [,]}, {func: 1, ret: [P.Future, -1], args: [S.Event0]}, {func: 1, ret: P.Null, args: [P.String, [P.StreamController, P.bool]]}, {func: 1, ret: P.JsObject, args: [,]}, {func: 1, ret: P.Null, args: [W.KeyboardEvent]}, {func: 1, ret: -1, args: [W.Element, P.int]}, {func: 1, ret: -1, args: [O.TimelineEvent0, P.int]}, {func: 1, args: [,,,]}, {func: 1, ret: O.TraceEvent, args: [[P.Map, P.String,,]]}, {func: 1, ret: P.bool, args: [O.TraceEvent]}, {func: 1, ret: -1, args: [P.String], opt: [P.bool]}, {func: 1, ret: -1, args: [P.String], named: {removeOthers: P.bool}}, {func: 1, ret: P.bool, args: [W.MouseEvent]}, {func: 1, ret: P.Null, args: [,,,,]}, {func: 1, ret: P.bool, args: [U.DiagnosticsNode]}, {func: 1, ret: P.Null, args: [,,,]}, {func: 1, ret: P.int, args: [[P.List, P.int], P.int]}, {func: 1, ret: S.CustomIcon}, {func: 1, ret: S.ColorIcon}, {func: 1, ret: K.MaterialIcon}, {func: 1, ret: P.bool, args: [W.Event]}, {func: 1, args: [P.Object, P.Object, P.num, P.int]}, {func: 1, args: [P.Object, P.num, P.int]}, {func: 1, ret: P.bool, args: [P.bool]}, {func: 1, ret: P.Null, args: [R.ServiceExtensionState]}, {func: 1, ret: S.HeapSpace, args: [[P.Map, P.String,,]]}, {func: 1, ret: [P.Future, U.Response0], args: [U.Client]}, {func: 1, ret: P.bool, args: [P.String, P.String]}, {func: 1, ret: P.int, args: [P.String]}, {func: 1, ret: P.bool, args: [A.BusEvent]}, {func: 1, ret: -1, args: [[P.List, P.int]]}, {func: 1, ret: U.Response0, args: [P.Uint8List]}, {func: 1, ret: P.String, args: [[P.List, P.String]]}, {func: 1, ret: R.MediaType}, {func: 1, ret: -1, args: [P.int, P.int]}, {func: 1, ret: -1, args: [T._DateFormatField]}, {func: 1, ret: T._DateFormatQuotedField, args: [,,]}, {func: 1, ret: T._DateFormatPatternField, args: [,,]}, {func: 1, ret: T._DateFormatLiteralField, args: [,,]}, {func: 1, ret: P.String, args: [B.NumberSymbols]}, {func: 1, ret: -1, args: [S.IsolateRef]}, {func: 1, ret: Y.FileSpan, args: [P.int], opt: [P.int]}, {func: 1, ret: P.String, args: [P.String], named: {color: null}}, {func: 1, ret: P.bool, args: [P.Pattern]}, {func: 1, ret: -1, args: [P.String], named: {length: P.int, match: P.Match, position: P.int}}, {func: 1, ret: {futureOr: 1, type: P.bool}}, {func: 1, ret: -1, args: [[P.Completer,,]]}, {func: 1, ret: [P.List, P.int], args: [,]}, {func: 1, args: [, P.String]}, {func: 1, ret: P.num}, {func: 1, ret: [P.Map, P.String, P.String], args: [[P.Map, P.String, P.String], P.String]}, {func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: -1}]}, {func: 1, ret: P.bool, args: [,,]}, {func: 1, ret: P.int, args: [P.Object]}, {func: 1, ret: P.bool, args: [P.Object, P.Object]}, {func: 1, ret: [P.Future, P.Null], args: [[P.List, S.Breakpoint]]}, {func: 1, ret: P.int, args: [S.Breakpoint, S.Breakpoint]}, {func: 1, bounds: [P.Object], ret: A.CoreElement, args: [0]}, {func: 1, ret: S.ExtensionData, args: [[P.Map,,,]]}, {func: 1, ret: S.BoundField, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.BoundVariable, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Breakpoint, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ClassRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Class, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ClassList, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.CodeRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Code, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ContextRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Context, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ContextElement, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ErrorRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Error0, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Event0, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.FieldRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Field, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Flag, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.FlagList, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Frame, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.FuncRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Func, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.InstanceRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Instance, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.IsolateRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Isolate, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.LibraryRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Library, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.LibraryDependency, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.MapAssociation, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Message, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.NullValRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.NullVal, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ObjRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Obj, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ReloadReport, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Response, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Sentinel, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ScriptRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Script, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ScriptList, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceLocation, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceReport, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceReportCoverage, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceReportRange, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Stack, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Success, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.TimelineEvent, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.TypeArgumentsRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.TypeArguments, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.UnresolvedSourceLocation, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Version, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.VMRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.VM, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.CpuProfile, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.CodeRegion, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ProfileFunction, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.AllocationProfile, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ClassHeapStats, args: [[P.Map, P.String,,]]}, {func: 1, ret: P.bool, args: [W.Element]}];
  function convertToFastObject(properties) {
    function MyClass() {
    }
    MyClass.prototype = properties;
    new MyClass();
    return properties;
  }
  function convertToSlowObject(properties) {
    properties.__MAGIC_SLOW_PROPERTY = 1;
    delete properties.__MAGIC_SLOW_PROPERTY;
    return properties;
  }
  A = convertToFastObject(A);
  B = convertToFastObject(B);
  C = convertToFastObject(C);
  D = convertToFastObject(D);
  E = convertToFastObject(E);
  F = convertToFastObject(F);
  G = convertToFastObject(G);
  H = convertToFastObject(H);
  J = convertToFastObject(J);
  K = convertToFastObject(K);
  L = convertToFastObject(L);
  M = convertToFastObject(M);
  N = convertToFastObject(N);
  O = convertToFastObject(O);
  P = convertToFastObject(P);
  Q = convertToFastObject(Q);
  R = convertToFastObject(R);
  S = convertToFastObject(S);
  T = convertToFastObject(T);
  U = convertToFastObject(U);
  V = convertToFastObject(V);
  W = convertToFastObject(W);
  X = convertToFastObject(X);
  Y = convertToFastObject(Y);
  Z = convertToFastObject(Z);
  function init() {
    Isolate.$isolateProperties = Object.create(null);
    init.allClasses = map();
    init.getTypeFromName = function(name) {
      return init.allClasses[name];
    };
    init.interceptorsByTag = map();
    init.leafTags = map();
    init.finishedClasses = map();
    Isolate.$lazy = function(fieldName, getterName, lazyValue, staticName, prototype) {
      if (!init.lazies)
        init.lazies = Object.create(null);
      init.lazies[fieldName] = getterName;
      prototype = prototype || Isolate.$isolateProperties;
      var sentinelUndefined = {};
      var sentinelInProgress = {};
      prototype[fieldName] = sentinelUndefined;
      prototype[getterName] = function() {
        var result = this[fieldName];
        if (result == sentinelInProgress)
          H.throwCyclicInit(staticName || fieldName);
        try {
          if (result === sentinelUndefined) {
            this[fieldName] = sentinelInProgress;
            try {
              result = this[fieldName] = lazyValue();
            } finally {
              if (result === sentinelUndefined)
                this[fieldName] = null;
            }
          }
          return result;
        } finally {
          this[getterName] = function() {
            return this[fieldName];
          };
        }
      };
    };
    Isolate.$finishIsolateConstructor = function(oldIsolate) {
      var isolateProperties = oldIsolate.$isolateProperties;
      function Isolate() {
        var staticNames = Object.keys(isolateProperties);
        for (var i = 0; i < staticNames.length; i++) {
          var staticName = staticNames[i];
          this[staticName] = isolateProperties[staticName];
        }
        var lazies = init.lazies;
        var lazyInitializers = lazies ? Object.keys(lazies) : [];
        for (var i = 0; i < lazyInitializers.length; i++)
          this[lazies[lazyInitializers[i]]] = null;
        function ForceEfficientMap() {
        }
        ForceEfficientMap.prototype = this;
        new ForceEfficientMap();
        for (var i = 0; i < lazyInitializers.length; i++) {
          var lazyInitName = lazies[lazyInitializers[i]];
          this[lazyInitName] = isolateProperties[lazyInitName];
        }
      }
      Isolate.prototype = oldIsolate.prototype;
      Isolate.prototype.constructor = Isolate;
      Isolate.$isolateProperties = isolateProperties;
      Isolate.makeConstantList = oldIsolate.makeConstantList;
      Isolate.functionThatReturnsNull = oldIsolate.functionThatReturnsNull;
      return Isolate;
    };
  }
  !function() {
    var intern = function(s) {
      var o = {};
      o[s] = 1;
      return Object.keys(convertToFastObject(o))[0];
    };
    init.getIsolateTag = function(name) {
      return intern("___dart_" + name + init.isolateTag);
    };
    var tableProperty = "___dart_isolate_tags_";
    var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
    var rootProperty = "_ZxYxX";
    for (var i = 0;; i++) {
      var property = intern(rootProperty + "_" + i + "_");
      if (!(property in usedProperties)) {
        usedProperties[property] = 1;
        init.isolateTag = property;
        break;
      }
    }
    init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
  }();
  // BEGIN invoke [main].
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(F.main, []);
    else
      F.main([]);
  });
  // END invoke [main].
})();

//# sourceMappingURL=main.dart.js.map
